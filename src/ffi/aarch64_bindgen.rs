// Generated at 2025-01-11 08:14:17.747949300 +00:00
#[cfg(not(target_arch = "aarch64"))]
compile_error!("These bindings can only be used on `aarch64` architectures. To generate bindings for your target architecture, consider using the `regenerate` feature.");

pub use nt_string::unicode_string::NtUnicodeString as _UNICODE_STRING;
pub use windows_sys::Win32::Foundation::NTSTATUS as NTSTATUS;
pub use nt_string::unicode_string::NtUnicodeString as UNICODE_STRING;
pub use windows_sys::Win32::Foundation::BOOL as BOOL;
pub use windows_sys::Win32::Foundation::BOOLEAN as BOOLEAN;

pub const PHNT_VERSION: u32 = self::PHNT_WIN11_24H2;
pub const PHNT_MODE: u32 = self::PHNT_MODE_USER;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
   storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
   #[inline]
   pub const fn new(storage: Storage) -> Self {
      Self { storage }
   }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
   Storage: AsRef<[u8]> + AsMut<[u8]>,
{
   #[inline]
   fn extract_bit(byte: u8, index: usize) -> bool {
      let bit_index = if cfg!(target_endian = "big") {
         7 - (index % 8)
      } else {
         index % 8
      };
      let mask = 1 << bit_index;
      byte & mask == mask
   }
   #[inline]
   pub fn get_bit(&self, index: usize) -> bool {
      debug_assert!(index / 8 < self.storage.as_ref().len());
      let byte_index = index / 8;
      let byte = self.storage.as_ref()[byte_index];
      Self::extract_bit(byte, index)
   }
   #[inline]
   pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
      debug_assert!(index / 8 < core::mem::size_of::<Storage>());
      let byte_index = index / 8;
      let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
      Self::extract_bit(byte, index)
   }
   #[inline]
   fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
      let bit_index = if cfg!(target_endian = "big") {
         7 - (index % 8)
      } else {
         index % 8
      };
      let mask = 1 << bit_index;
      if val {
         byte | mask
      } else {
         byte & !mask
      }
   }
   #[inline]
   pub fn set_bit(&mut self, index: usize, val: bool) {
      debug_assert!(index / 8 < self.storage.as_ref().len());
      let byte_index = index / 8;
      let byte = &mut self.storage.as_mut()[byte_index];
      *byte = Self::change_bit(*byte, index, val);
   }
   #[inline]
   pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
      debug_assert!(index / 8 < core::mem::size_of::<Storage>());
      let byte_index = index / 8;
      let byte = (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
      *byte = Self::change_bit(*byte, index, val);
   }
   #[inline]
   pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
      debug_assert!(bit_width <= 64);
      debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
      debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
      let mut val = 0;
      for i in 0..(bit_width as usize) {
         if self.get_bit(i + bit_offset) {
            let index = if cfg!(target_endian = "big") {
               bit_width as usize - 1 - i
            } else {
               i
            };
            val |= 1 << index;
         }
      }
      val
   }
   #[inline]
   pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
      debug_assert!(bit_width <= 64);
      debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
      debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
      let mut val = 0;
      for i in 0..(bit_width as usize) {
         if Self::raw_get_bit(this, i + bit_offset) {
            let index = if cfg!(target_endian = "big") {
               bit_width as usize - 1 - i
            } else {
               i
            };
            val |= 1 << index;
         }
      }
      val
   }
   #[inline]
   pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
      debug_assert!(bit_width <= 64);
      debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
      debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
      for i in 0..(bit_width as usize) {
         let mask = 1 << i;
         let val_bit_is_set = val & mask == mask;
         let index = if cfg!(target_endian = "big") {
            bit_width as usize - 1 - i
         } else {
            i
         };
         self.set_bit(index + bit_offset, val_bit_is_set);
      }
   }
   #[inline]
   pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
      debug_assert!(bit_width <= 64);
      debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
      debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
      for i in 0..(bit_width as usize) {
         let mask = 1 << i;
         let val_bit_is_set = val & mask == mask;
         let index = if cfg!(target_endian = "big") {
            bit_width as usize - 1 - i
         } else {
            i
         };
         Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
      }
   }
}
pub const INT_ERROR: i32 = -1;
pub const MAXLONGLONG: u64 = 9223372036854775807;
pub const MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS: u32 = 0;
pub const DESKTOP_ALL_ACCESS: u32 = 983551;
pub const DESKTOP_GENERIC_READ: u32 = 131137;
pub const DESKTOP_GENERIC_WRITE: u32 = 131262;
pub const DESKTOP_GENERIC_EXECUTE: u32 = 131328;
pub const WINSTA_GENERIC_READ: u32 = 131843;
pub const WINSTA_GENERIC_WRITE: u32 = 131100;
pub const WINSTA_GENERIC_EXECUTE: u32 = 131168;
pub const WMIGUID_GENERIC_READ: u32 = 131085;
pub const WMIGUID_GENERIC_WRITE: u32 = 131170;
pub const WMIGUID_GENERIC_EXECUTE: u32 = 134800;
pub const PHNT_MODE_KERNEL: u32 = 0;
pub const PHNT_MODE_USER: u32 = 1;
pub const PHNT_WIN2K: u32 = 50;
pub const PHNT_WINXP: u32 = 51;
pub const PHNT_WS03: u32 = 52;
pub const PHNT_VISTA: u32 = 60;
pub const PHNT_WIN7: u32 = 61;
pub const PHNT_WIN8: u32 = 62;
pub const PHNT_WINBLUE: u32 = 63;
pub const PHNT_THRESHOLD: u32 = 100;
pub const PHNT_THRESHOLD2: u32 = 101;
pub const PHNT_REDSTONE: u32 = 102;
pub const PHNT_REDSTONE2: u32 = 103;
pub const PHNT_REDSTONE3: u32 = 104;
pub const PHNT_REDSTONE4: u32 = 105;
pub const PHNT_REDSTONE5: u32 = 106;
pub const PHNT_19H1: u32 = 107;
pub const PHNT_19H2: u32 = 108;
pub const PHNT_20H1: u32 = 109;
pub const PHNT_20H2: u32 = 110;
pub const PHNT_21H1: u32 = 111;
pub const PHNT_WIN10_21H2: u32 = 112;
pub const PHNT_WIN10_22H2: u32 = 113;
pub const PHNT_WIN11: u32 = 114;
pub const PHNT_WIN11_22H2: u32 = 115;
pub const PHNT_WIN11_23H2: u32 = 116;
pub const PHNT_WIN11_24H2: u32 = 117;
pub const MAXUCHAR: u32 = 255;
pub const MAXUSHORT: u32 = 65535;
pub const MAXULONG: u32 = 4294967295;
pub const NT_CUSTOMER_SHIFT: u32 = 29;
pub const NT_FACILITY_MASK: u32 = 4095;
pub const NT_FACILITY_SHIFT: u32 = 16;
pub const RTL_BALANCED_NODE_RESERVED_PARENT_MASK: u32 = 3;
pub const OBJ_PROTECT_CLOSE: u32 = 1;
pub const OBJ_INHERIT: u32 = 2;
pub const OBJ_AUDIT_OBJECT_CLOSE: u32 = 4;
pub const OBJ_NO_RIGHTS_UPGRADE: u32 = 8;
pub const OBJ_PERMANENT: u32 = 16;
pub const OBJ_EXCLUSIVE: u32 = 32;
pub const OBJ_CASE_INSENSITIVE: u32 = 64;
pub const OBJ_OPENIF: u32 = 128;
pub const OBJ_OPENLINK: u32 = 256;
pub const OBJ_KERNEL_HANDLE: u32 = 512;
pub const OBJ_FORCE_ACCESS_CHECK: u32 = 1024;
pub const OBJ_IGNORE_IMPERSONATED_DEVICEMAP: u32 = 2048;
pub const OBJ_DONT_REPARSE: u32 = 4096;
pub const OBJ_VALID_ATTRIBUTES: u32 = 8178;
pub const MAXIMUM_LEADBYTES: u32 = 12;
pub const LOW_PRIORITY: u32 = 0;
pub const LOW_REALTIME_PRIORITY: u32 = 16;
pub const HIGH_PRIORITY: u32 = 31;
pub const MAXIMUM_PRIORITY: u32 = 32;
pub const LDRP_PACKAGED_BINARY: u32 = 1;
pub const LDRP_MARKED_FOR_REMOVAL: u32 = 2;
pub const LDRP_IMAGE_DLL: u32 = 4;
pub const LDRP_LOAD_NOTIFICATIONS_SENT: u32 = 8;
pub const LDRP_TELEMETRY_ENTRY_PROCESSED: u32 = 16;
pub const LDRP_PROCESS_STATIC_IMPORT: u32 = 32;
pub const LDRP_IN_LEGACY_LISTS: u32 = 64;
pub const LDRP_IN_INDEXES: u32 = 128;
pub const LDRP_SHIM_DLL: u32 = 256;
pub const LDRP_IN_EXCEPTION_TABLE: u32 = 512;
pub const LDRP_LOAD_IN_PROGRESS: u32 = 4096;
pub const LDRP_LOAD_CONFIG_PROCESSED: u32 = 8192;
pub const LDRP_ENTRY_PROCESSED: u32 = 16384;
pub const LDRP_PROTECT_DELAY_LOAD: u32 = 32768;
pub const LDRP_DONT_CALL_FOR_THREADS: u32 = 262144;
pub const LDRP_PROCESS_ATTACH_CALLED: u32 = 524288;
pub const LDRP_PROCESS_ATTACH_FAILED: u32 = 1048576;
pub const LDRP_COR_DEFERRED_VALIDATE: u32 = 2097152;
pub const LDRP_COR_IMAGE: u32 = 4194304;
pub const LDRP_DONT_RELOCATE: u32 = 8388608;
pub const LDRP_COR_IL_ONLY: u32 = 16777216;
pub const LDRP_CHPE_IMAGE: u32 = 33554432;
pub const LDRP_CHPE_EMULATOR_IMAGE: u32 = 67108864;
pub const LDRP_REDIRECTED: u32 = 268435456;
pub const LDRP_COMPAT_DATABASE_PROCESSED: u32 = 2147483648;
pub const LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT: u32 = 1;
pub const LDR_GET_DLL_HANDLE_EX_PIN: u32 = 2;
pub const LDR_ADDREF_DLL_PIN: u32 = 1;
pub const LDR_GET_PROCEDURE_ADDRESS_DONT_RECORD_FORWARDER: u32 = 1;
pub const LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS: u32 = 1;
pub const LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY: u32 = 2;
pub const LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID: u32 = 0;
pub const LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED: u32 = 1;
pub const LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED: u32 = 2;
pub const LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS: u32 = 1;
pub const LDR_DLL_NOTIFICATION_REASON_LOADED: u32 = 1;
pub const LDR_DLL_NOTIFICATION_REASON_UNLOADED: u32 = 2;
pub const RESOURCE_TYPE_LEVEL: u32 = 0;
pub const RESOURCE_NAME_LEVEL: u32 = 1;
pub const RESOURCE_LANGUAGE_LEVEL: u32 = 2;
pub const RESOURCE_DATA_LEVEL: u32 = 3;
pub const ENCLAVE_STATE_CREATED: u32 = 0;
pub const ENCLAVE_STATE_INITIALIZED: u32 = 1;
pub const ENCLAVE_STATE_INITIALIZED_VBS: u32 = 2;
pub const EFI_VARIABLE_NON_VOLATILE: u32 = 1;
pub const EFI_VARIABLE_BOOTSERVICE_ACCESS: u32 = 2;
pub const EFI_VARIABLE_RUNTIME_ACCESS: u32 = 4;
pub const EFI_VARIABLE_HARDWARE_ERROR_RECORD: u32 = 8;
pub const EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS: u32 = 16;
pub const EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS: u32 = 32;
pub const EFI_VARIABLE_APPEND_WRITE: u32 = 64;
pub const EFI_VARIABLE_ENHANCED_AUTHENTICATED_ACCESS: u32 = 128;
pub const EVENT_QUERY_STATE: u32 = 1;
pub const EVENT_PAIR_ALL_ACCESS: u32 = 2031616;
pub const SEMAPHORE_QUERY_STATE: u32 = 1;
pub const PROFILE_CONTROL: u32 = 1;
pub const PROFILE_ALL_ACCESS: u32 = 983041;
pub const KEYEDEVENT_WAIT: u32 = 1;
pub const KEYEDEVENT_WAKE: u32 = 2;
pub const KEYEDEVENT_ALL_ACCESS: u32 = 983043;
pub const WORKER_FACTORY_RELEASE_WORKER: u32 = 1;
pub const WORKER_FACTORY_WAIT: u32 = 2;
pub const WORKER_FACTORY_SET_INFORMATION: u32 = 4;
pub const WORKER_FACTORY_QUERY_INFORMATION: u32 = 8;
pub const WORKER_FACTORY_READY_WORKER: u32 = 16;
pub const WORKER_FACTORY_SHUTDOWN: u32 = 32;
pub const WORKER_FACTORY_ALL_ACCESS: u32 = 983103;
pub const KF_V86_VIS: u32 = 1;
pub const KF_RDTSC: u32 = 2;
pub const KF_CR4: u32 = 4;
pub const KF_CMOV: u32 = 8;
pub const KF_GLOBAL_PAGE: u32 = 16;
pub const KF_LARGE_PAGE: u32 = 32;
pub const KF_MTRR: u32 = 64;
pub const KF_CMPXCHG8B: u32 = 128;
pub const KF_MMX: u32 = 256;
pub const KF_WORKING_PTE: u32 = 512;
pub const KF_PAT: u32 = 1024;
pub const KF_FXSR: u32 = 2048;
pub const KF_FAST_SYSCALL: u32 = 4096;
pub const KF_XMMI: u32 = 8192;
pub const KF_3DNOW: u32 = 16384;
pub const KF_AMDK6MTRR: u32 = 32768;
pub const KF_XMMI64: u32 = 65536;
pub const KF_DTS: u32 = 131072;
pub const KF_NOEXECUTE: u32 = 536870912;
pub const KF_GLOBAL_32BIT_EXECUTE: u32 = 1073741824;
pub const KF_GLOBAL_32BIT_NOEXECUTE: u32 = 2147483648;
pub const MM_WORKING_SET_MAX_HARD_ENABLE: u32 = 1;
pub const MM_WORKING_SET_MAX_HARD_DISABLE: u32 = 2;
pub const MM_WORKING_SET_MIN_HARD_ENABLE: u32 = 4;
pub const MM_WORKING_SET_MIN_HARD_DISABLE: u32 = 8;
pub const ETW_MAX_PROFILING_SOURCES: u32 = 4;
pub const ETW_MAX_PMC_EVENTS: u32 = 4;
pub const ETW_MAX_PMC_COUNTERS: u32 = 4;
pub const MAXIMUM_NODE_COUNT: u32 = 64;
pub const CODEINTEGRITY_OPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITY_OPTION_TESTSIGN: u32 = 2;
pub const CODEINTEGRITY_OPTION_UMCI_ENABLED: u32 = 4;
pub const CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED: u32 = 8;
pub const CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED: u32 = 16;
pub const CODEINTEGRITY_OPTION_TEST_BUILD: u32 = 32;
pub const CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD: u32 = 64;
pub const CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED: u32 = 128;
pub const CODEINTEGRITY_OPTION_FLIGHT_BUILD: u32 = 256;
pub const CODEINTEGRITY_OPTION_FLIGHTING_ENABLED: u32 = 512;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED: u32 = 1024;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED: u32 = 2048;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED: u32 = 4096;
pub const CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED: u32 = 8192;
pub const CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED: u32 = 16384;
pub const CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED: u32 = 32768;
pub const SYSTEM_STORE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_STATS_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_STORE_CREATE_INFORMATION_VERSION: u32 = 6;
pub const SYSTEM_STORE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_LIST_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_LIST_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_CREATE_INFORMATION_VERSION: u32 = 3;
pub const SYSTEM_CACHE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_CACHE_STORE_CREATE_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_STORE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_CACHE_STATS_INFORMATION_VERSION: u32 = 3;
pub const SYSTEM_STORE_REGISTRATION_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_STORE_RESIZE_INFORMATION_VERSION: u32 = 6;
pub const SYSTEM_CACHE_STORE_RESIZE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_CONFIG_INFORMATION_VERSION: u32 = 4;
pub const SYSTEM_STORE_HIGH_MEM_PRIORITY_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_TRIM_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_COMPRESSION_INFORMATION_VERSION: u32 = 3;
pub const MEMORY_COMBINE_FLAGS_COMMON_PAGES_ONLY: u32 = 4;
pub const KF_BRANCH: u32 = 131072;
pub const KF_XSTATE: u32 = 8388608;
pub const KF_RDTSCP: u64 = 17179869184;
pub const KF_CET_SS: u64 = 70368744177664;
pub const KF_XFD: u64 = 36028797018963968;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITYPOLICY_OPTION_AUDIT: u32 = 2;
pub const CODEINTEGRITYPOLICY_OPTION_REQUIRE_WHQL: u32 = 4;
pub const CODEINTEGRITYPOLICY_OPTION_DISABLED_FLIGHTSIGNING: u32 = 8;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UMCI: u32 = 16;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UPDATE_POLICY_NOREBOOT: u32 = 32;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_SECURE_SETTING_POLICY: u32 = 64;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UNSIGNED_SYSTEMINTEGRITY_POLICY: u32 = 128;
pub const CODEINTEGRITYPOLICY_OPTION_DYNAMIC_CODE_POLICY_ENABLED: u32 = 256;
pub const CODEINTEGRITYPOLICY_OPTION_RELOAD_POLICY_NO_REBOOT: u32 = 268435456;
pub const CODEINTEGRITYPOLICY_OPTION_CONDITIONAL_LOCKDOWN: u32 = 536870912;
pub const CODEINTEGRITYPOLICY_OPTION_NOLOCKDOWN: u32 = 1073741824;
pub const CODEINTEGRITYPOLICY_OPTION_LOCKDOWN: u32 = 2147483648;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_STRICT: u32 = 2;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_DEBUG: u32 = 4;
pub const SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_VERSION: u32 = 1;
pub const SYSDBG_LIVEDUMP_CONTROL_VERSION_1: u32 = 1;
pub const SYSDBG_LIVEDUMP_CONTROL_VERSION_2: u32 = 2;
pub const SYSDBG_LIVEDUMP_CONTROL_VERSION: u32 = 2;
pub const HARDERROR_OVERRIDE_ERRORMODE: u32 = 268435456;
pub const PROCESSOR_FEATURE_MAX: u32 = 64;
pub const MAX_WOW64_SHARED_ENTRIES: u32 = 16;
pub const NX_SUPPORT_POLICY_ALWAYSOFF: u32 = 0;
pub const NX_SUPPORT_POLICY_ALWAYSON: u32 = 1;
pub const NX_SUPPORT_POLICY_OPTIN: u32 = 2;
pub const NX_SUPPORT_POLICY_OPTOUT: u32 = 3;
pub const SEH_VALIDATION_POLICY_ON: u32 = 0;
pub const SEH_VALIDATION_POLICY_OFF: u32 = 1;
pub const SEH_VALIDATION_POLICY_TELEMETRY: u32 = 2;
pub const SEH_VALIDATION_POLICY_DEFER: u32 = 3;
pub const SHARED_GLOBAL_FLAGS_ERROR_PORT_V: u32 = 0;
pub const SHARED_GLOBAL_FLAGS_ERROR_PORT: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED_V: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_ELEVATION_ENABLED: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED_V: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_VIRT_ENABLED: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED_V: u32 = 3;
pub const SHARED_GLOBAL_FLAGS_INSTALLER_DETECT_ENABLED: u32 = 8;
pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED_V: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_LKG_ENABLED: u32 = 16;
pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED_V: u32 = 5;
pub const SHARED_GLOBAL_FLAGS_DYNAMIC_PROC_ENABLED: u32 = 32;
pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED_V: u32 = 6;
pub const SHARED_GLOBAL_FLAGS_CONSOLE_BROKER_ENABLED: u32 = 64;
pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED_V: u32 = 7;
pub const SHARED_GLOBAL_FLAGS_SECURE_BOOT_ENABLED: u32 = 128;
pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU_V: u32 = 8;
pub const SHARED_GLOBAL_FLAGS_MULTI_SESSION_SKU: u32 = 256;
pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU_V: u32 = 9;
pub const SHARED_GLOBAL_FLAGS_MULTIUSERS_IN_SESSION_SKU: u32 = 512;
pub const SHARED_GLOBAL_FLAGS_STATE_SEPARATION_ENABLED_V: u32 = 10;
pub const SHARED_GLOBAL_FLAGS_STATE_SEPARATION_ENABLED: u32 = 1024;
pub const SHARED_GLOBAL_FLAGS_SET_GLOBAL_DATA_FLAG: u32 = 1073741824;
pub const SHARED_GLOBAL_FLAGS_CLEAR_GLOBAL_DATA_FLAG: u32 = 2147483648;
pub const SYSTEM_CALL_SYSCALL: u32 = 0;
pub const SYSTEM_CALL_INT_2E: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_ENABLED: u32 = 1;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_HV_PAGE: u32 = 2;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_DISABLE_32BIT: u32 = 4;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_MFENCE: u32 = 16;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_LFENCE: u32 = 32;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_A73_ERRATA: u32 = 64;
pub const SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_RDTSCP: u32 = 128;
pub const FLG_STOP_ON_EXCEPTION: u32 = 1;
pub const FLG_SHOW_LDR_SNAPS: u32 = 2;
pub const FLG_DEBUG_INITIAL_COMMAND: u32 = 4;
pub const FLG_STOP_ON_HUNG_GUI: u32 = 8;
pub const FLG_HEAP_ENABLE_TAIL_CHECK: u32 = 16;
pub const FLG_HEAP_ENABLE_FREE_CHECK: u32 = 32;
pub const FLG_HEAP_VALIDATE_PARAMETERS: u32 = 64;
pub const FLG_HEAP_VALIDATE_ALL: u32 = 128;
pub const FLG_APPLICATION_VERIFIER: u32 = 256;
pub const FLG_MONITOR_SILENT_PROCESS_EXIT: u32 = 512;
pub const FLG_POOL_ENABLE_TAGGING: u32 = 1024;
pub const FLG_HEAP_ENABLE_TAGGING: u32 = 2048;
pub const FLG_USER_STACK_TRACE_DB: u32 = 4096;
pub const FLG_KERNEL_STACK_TRACE_DB: u32 = 8192;
pub const FLG_MAINTAIN_OBJECT_TYPELIST: u32 = 16384;
pub const FLG_HEAP_ENABLE_TAG_BY_DLL: u32 = 32768;
pub const FLG_DISABLE_STACK_EXTENSION: u32 = 65536;
pub const FLG_ENABLE_CSRDEBUG: u32 = 131072;
pub const FLG_ENABLE_KDEBUG_SYMBOL_LOAD: u32 = 262144;
pub const FLG_DISABLE_PAGE_KERNEL_STACKS: u32 = 524288;
pub const FLG_ENABLE_SYSTEM_CRIT_BREAKS: u32 = 1048576;
pub const FLG_HEAP_DISABLE_COALESCING: u32 = 2097152;
pub const FLG_ENABLE_CLOSE_EXCEPTIONS: u32 = 4194304;
pub const FLG_ENABLE_EXCEPTION_LOGGING: u32 = 8388608;
pub const FLG_ENABLE_HANDLE_TYPE_TAGGING: u32 = 16777216;
pub const FLG_HEAP_PAGE_ALLOCS: u32 = 33554432;
pub const FLG_DEBUG_INITIAL_COMMAND_EX: u32 = 67108864;
pub const FLG_DISABLE_DBGPRINT: u32 = 134217728;
pub const FLG_CRITSEC_EVENT_CREATION: u32 = 268435456;
pub const FLG_LDR_TOP_DOWN: u32 = 536870912;
pub const FLG_ENABLE_HANDLE_EXCEPTIONS: u32 = 1073741824;
pub const FLG_DISABLE_PROTDLLS: u32 = 2147483648;
pub const FLG_VALID_BITS: u32 = 4294966783;
pub const FLG_USERMODE_VALID_BITS: u32 = 2989595123;
pub const FLG_BOOTONLY_VALID_BITS: u32 = 67788804;
pub const FLG_KERNELMODE_VALID_BITS: u32 = 1237582859;
pub const BCD_OBJECT_DESCRIPTION_VERSION: u32 = 1;
pub const BCD_ELEMENT_DESCRIPTION_VERSION: u32 = 1;
pub const PAGE_ENCLAVE_NO_CHANGE: u32 = 536870912;
pub const MEM_DOS_LIM: u32 = 1073741824;
pub const SEC_DRIVER_IMAGE: u32 = 1048576;
pub const SEC_BASED: u32 = 2097152;
pub const SEC_NO_CHANGE: u32 = 4194304;
pub const SEC_GLOBAL: u32 = 536870912;
pub const MEMORY_BLOCK_NOT_ACCESSED: u32 = 0;
pub const MEMORY_BLOCK_READONLY: u32 = 1;
pub const MEMORY_BLOCK_EXECUTABLE: u32 = 2;
pub const MEMORY_BLOCK_EXECUTABLE_READONLY: u32 = 3;
pub const MEMORY_BLOCK_READWRITE: u32 = 4;
pub const MEMORY_BLOCK_COPYONWRITE: u32 = 5;
pub const MEMORY_BLOCK_EXECUTABLE_READWRITE: u32 = 6;
pub const MEMORY_BLOCK_EXECUTABLE_COPYONWRITE: u32 = 7;
pub const MEMORY_BLOCK_NOT_ACCESSED_2: u32 = 8;
pub const MEMORY_BLOCK_NON_CACHEABLE_READONLY: u32 = 9;
pub const MEMORY_BLOCK_NON_CACHEABLE_EXECUTABLE: u32 = 10;
pub const MEMORY_BLOCK_NON_CACHEABLE_EXECUTABLE_READONLY: u32 = 11;
pub const MEMORY_BLOCK_NON_CACHEABLE_READWRITE: u32 = 12;
pub const MEMORY_BLOCK_NON_CACHEABLE_COPYONWRITE: u32 = 13;
pub const MEMORY_BLOCK_NON_CACHEABLE_EXECUTABLE_READWRITE: u32 = 14;
pub const MEMORY_BLOCK_NON_CACHEABLE_EXECUTABLE_COPYONWRITE: u32 = 15;
pub const MEMORY_BLOCK_NOT_ACCESSED_3: u32 = 16;
pub const MEMORY_BLOCK_GUARD_READONLY: u32 = 17;
pub const MEMORY_BLOCK_GUARD_EXECUTABLE: u32 = 18;
pub const MEMORY_BLOCK_GUARD_EXECUTABLE_READONLY: u32 = 19;
pub const MEMORY_BLOCK_GUARD_READWRITE: u32 = 20;
pub const MEMORY_BLOCK_GUARD_COPYONWRITE: u32 = 21;
pub const MEMORY_BLOCK_GUARD_EXECUTABLE_READWRITE: u32 = 22;
pub const MEMORY_BLOCK_GUARD_EXECUTABLE_COPYONWRITE: u32 = 23;
pub const MEMORY_BLOCK_NOT_ACCESSED_4: u32 = 24;
pub const MEMORY_BLOCK_NON_CACHEABLE_GUARD_READONLY: u32 = 25;
pub const MEMORY_BLOCK_NON_CACHEABLE_GUARD_EXECUTABLE: u32 = 26;
pub const MEMORY_BLOCK_NON_CACHEABLE_GUARD_EXECUTABLE_READONLY: u32 = 27;
pub const MEMORY_BLOCK_NON_CACHEABLE_GUARD_READWRITE: u32 = 28;
pub const MEMORY_BLOCK_NON_CACHEABLE_GUARD_COPYONWRITE: u32 = 29;
pub const MEMORY_BLOCK_NON_CACHEABLE_GUARD_EXECUTABLE_READWRITE: u32 = 30;
pub const MEMORY_BLOCK_NON_CACHEABLE_GUARD_EXECUTABLE_COPYONWRITE: u32 = 31;
pub const MMPFNLIST_ZERO: u32 = 0;
pub const MMPFNLIST_FREE: u32 = 1;
pub const MMPFNLIST_STANDBY: u32 = 2;
pub const MMPFNLIST_MODIFIED: u32 = 3;
pub const MMPFNLIST_MODIFIEDNOWRITE: u32 = 4;
pub const MMPFNLIST_BAD: u32 = 5;
pub const MMPFNLIST_ACTIVE: u32 = 6;
pub const MMPFNLIST_TRANSITION: u32 = 7;
pub const MMPFNUSE_PROCESSPRIVATE: u32 = 0;
pub const MMPFNUSE_FILE: u32 = 1;
pub const MMPFNUSE_PAGEFILEMAPPED: u32 = 2;
pub const MMPFNUSE_PAGETABLE: u32 = 3;
pub const MMPFNUSE_PAGEDPOOL: u32 = 4;
pub const MMPFNUSE_NONPAGEDPOOL: u32 = 5;
pub const MMPFNUSE_SYSTEMPTE: u32 = 6;
pub const MMPFNUSE_SESSIONPRIVATE: u32 = 7;
pub const MMPFNUSE_METAFILE: u32 = 8;
pub const MMPFNUSE_AWEPAGE: u32 = 9;
pub const MMPFNUSE_DRIVERLOCKPAGE: u32 = 10;
pub const MMPFNUSE_KERNELSTACK: u32 = 11;
pub const MEM_EXECUTE_OPTION_ENABLE: u32 = 1;
pub const MEM_EXECUTE_OPTION_DISABLE: u32 = 2;
pub const MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION: u32 = 4;
pub const MEM_EXECUTE_OPTION_PERMANENT: u32 = 8;
pub const MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE: u32 = 16;
pub const MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE: u32 = 32;
pub const MEM_EXECUTE_OPTION_DISABLE_EXCEPTION_CHAIN_VALIDATION: u32 = 64;
pub const MEM_EXECUTE_OPTION_VALID_FLAGS: u32 = 127;
pub const VM_PREFETCH_TO_WORKING_SET: u32 = 1;
pub const MAP_PROCESS: u32 = 1;
pub const MAP_SYSTEM: u32 = 2;
pub const TERMINATE_ENCLAVE_VALID_FLAGS: u32 = 5;
pub const TERMINATE_ENCLAVE_FLAG_NO_WAIT: u32 = 1;
pub const TERMINATE_ENCLAVE_FLAG_WAIT_ERROR: u32 = 4;
pub const ENCLAVE_CALL_VALID_FLAGS: u32 = 1;
pub const ENCLAVE_CALL_FLAG_NO_WAIT: u32 = 1;
pub const OBJECT_TYPE_CREATE: u32 = 1;
pub const OBJECT_TYPE_ALL_ACCESS: u32 = 983041;
pub const DIRECTORY_QUERY: u32 = 1;
pub const DIRECTORY_TRAVERSE: u32 = 2;
pub const DIRECTORY_CREATE_OBJECT: u32 = 4;
pub const DIRECTORY_CREATE_SUBDIRECTORY: u32 = 8;
pub const DIRECTORY_ALL_ACCESS: u32 = 983055;
pub const SYMBOLIC_LINK_QUERY: u32 = 1;
pub const SYMBOLIC_LINK_SET: u32 = 2;
pub const SYMBOLIC_LINK_ALL_ACCESS: u32 = 983041;
pub const SYMBOLIC_LINK_ALL_ACCESS_EX: u32 = 1048575;
pub const DUPLICATE_SAME_ATTRIBUTES: u32 = 4;
pub const OBJECT_BOUNDARY_DESCRIPTOR_VERSION: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_FLAG_NO_INHERIT: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT: u32 = 2;
pub const ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN: u32 = 0;
pub const ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE: u32 = 1;
pub const ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE: u32 = 2;
pub const ACTIVATION_CONTEXT_STRING_SECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE: u32 = 1;
pub const ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER: u32 = 2;
pub const ACTIVATION_CONTEXT_GUID_SECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED: u32 = 4;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED: u32 = 8;
pub const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_PRIVATE_ASSEMBLY: u32 = 16;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND: u32 = 4;
pub const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SYSTEM_DEFAULT_REDIRECTED_SYSTEM32_DLL: u32 =
   8;
pub const ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_INVALID: u32 = 0;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE: u32 = 3;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH: u32 = 4;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL: u32 = 5;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_FLAG_OFFSET: u32 = 8;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_DEFAULT: u32 = 256;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_ICON: u32 = 512;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_CONTENT: u32 = 1024;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_THUMBNAIL: u32 = 2048;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_MISCSTATUS_HAS_DOCPRINT: u32 = 4096;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_CLR_CLASS: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID: u32 = 2;
pub const ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_CLR_SURROGATE_FORMAT_WHISTLER: u32 = 1;
pub const ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS_FORMAT_LONGHORN: u32 = 1;
pub const SXS_WINDOWS_SETTINGS_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2005/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2011_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2011/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2013_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2013/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2014_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2014/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2016_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2016/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2017_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2017/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2019_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2019/WindowsSettings\0";
pub const SXS_WINDOWS_SETTINGS_2020_NAMESPACE: &[u8; 54] =
   b"http://schemas.microsoft.com/SMI/2020/WindowsSettings\0";
pub const ASSEMBLY_STORAGE_MAP_ASSEMBLY_ARRAY_IS_HEAP_ALLOCATED: u32 = 1;
pub const ACTIVATION_CONTEXT_NOTIFICATION_DESTROY: u32 = 1;
pub const ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY: u32 = 2;
pub const ACTIVATION_CONTEXT_NOTIFICATION_USED: u32 = 3;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION: u32 = 1;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE: u32 = 2;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST: u32 = 4;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED: u32 = 8;
pub const RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED: u32 = 16;
pub const ACTIVATION_CONTEXT_STACK_FLAG_QUERIES_DISABLED: u32 = 1;
pub const KACF_OLDGETSHORTPATHNAME: u32 = 1;
pub const KACF_VERSIONLIE_NOT_USED: u32 = 2;
pub const KACF_GETTEMPPATH_NOT_USED: u32 = 4;
pub const KACF_GETDISKFREESPACE: u32 = 8;
pub const KACF_FTMFROMCURRENTAPT: u32 = 32;
pub const KACF_DISALLOWORBINDINGCHANGES: u32 = 64;
pub const KACF_OLE32VALIDATEPTRS: u32 = 128;
pub const KACF_DISABLECICERO: u32 = 256;
pub const KACF_OLE32ENABLEASYNCDOCFILE: u32 = 512;
pub const KACF_OLE32ENABLELEGACYEXCEPTIONHANDLING: u32 = 1024;
pub const KACF_RPCDISABLENDRCLIENTHARDENING: u32 = 2048;
pub const KACF_RPCDISABLENDRMAYBENULL_SIZEIS: u32 = 4096;
pub const KACF_DISABLEALLDDEHACK_NOT_USED: u32 = 8192;
pub const KACF_RPCDISABLENDR61_RANGE: u32 = 16384;
pub const KACF_RPC32ENABLELEGACYEXCEPTIONHANDLING: u32 = 32768;
pub const KACF_OLE32DOCFILEUSELEGACYNTFSFLAGS: u32 = 65536;
pub const KACF_RPCDISABLENDRCONSTIIDCHECK: u32 = 131072;
pub const KACF_USERDISABLEFORWARDERPATCH: u32 = 262144;
pub const KACF_OLE32DISABLENEW_WMPAINT_DISPATCH: u32 = 1048576;
pub const KACF_ADDRESTRICTEDSIDINCOINITIALIZESECURITY: u32 = 2097152;
pub const KACF_ALLOCDEBUGINFOFORCRITSECTIONS: u32 = 4194304;
pub const KACF_OLEAUT32ENABLEUNSAFELOADTYPELIBRELATIVE: u32 = 8388608;
pub const KACF_ALLOWMAXIMIZEDWINDOWGAMMA: u32 = 16777216;
pub const KACF_DONOTADDTOCACHE: u32 = 2147483648;
pub const GDI_HANDLE_BUFFER_SIZE32: u32 = 34;
pub const GDI_HANDLE_BUFFER_SIZE64: u32 = 60;
pub const GDI_HANDLE_BUFFER_SIZE: u32 = 60;
pub const TLS_EXPANSION_SLOTS: u32 = 1024;
pub const GDI_BATCH_BUFFER_SIZE: u32 = 310;
pub const TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED: u32 = 1;
pub const TEB_ACTIVE_FRAME_FLAG_EXTENDED: u32 = 1;
pub const STATIC_UNICODE_BUFFER_LENGTH: u32 = 261;
pub const WIN32_CLIENT_INFO_LENGTH: u32 = 62;
pub const PROCESS_SET_PORT: u32 = 2048;
pub const THREAD_ALERT: u32 = 4;
pub const PROCESS_EXCEPTION_PORT_ALL_STATE_BITS: u32 = 3;
pub const PROCESS_PRIORITY_CLASS_UNKNOWN: u32 = 0;
pub const PROCESS_PRIORITY_CLASS_IDLE: u32 = 1;
pub const PROCESS_PRIORITY_CLASS_NORMAL: u32 = 2;
pub const PROCESS_PRIORITY_CLASS_HIGH: u32 = 3;
pub const PROCESS_PRIORITY_CLASS_REALTIME: u32 = 4;
pub const PROCESS_PRIORITY_CLASS_BELOW_NORMAL: u32 = 5;
pub const PROCESS_PRIORITY_CLASS_ABOVE_NORMAL: u32 = 6;
pub const PROCESS_LUID_DOSDEVICES_ONLY: u32 = 1;
pub const PROCESS_HANDLE_EXCEPTIONS_ENABLED: u32 = 1;
pub const PROCESS_HANDLE_RAISE_EXCEPTION_ON_INVALID_HANDLE_CLOSE_DISABLED: u32 = 0;
pub const PROCESS_HANDLE_RAISE_EXCEPTION_ON_INVALID_HANDLE_CLOSE_ENABLED: u32 = 1;
pub const PROCESS_HANDLE_TRACING_MAX_SLOTS: u32 = 131072;
pub const PROCESS_HANDLE_TRACING_MAX_STACKS: u32 = 16;
pub const PROCESS_HANDLE_TRACE_TYPE_OPEN: u32 = 1;
pub const PROCESS_HANDLE_TRACE_TYPE_CLOSE: u32 = 2;
pub const PROCESS_HANDLE_TRACE_TYPE_BADREF: u32 = 3;
pub const PROCESS_WORKING_SET_CONTROL_VERSION: u32 = 3;
pub const PS_PROTECTED_SIGNER_MASK: u32 = 255;
pub const PS_PROTECTED_AUDIT_MASK: u32 = 8;
pub const PS_PROTECTED_TYPE_MASK: u32 = 7;
pub const POWER_THROTTLING_PROCESS_CURRENT_VERSION: u32 = 1;
pub const POWER_THROTTLING_PROCESS_EXECUTION_SPEED: u32 = 1;
pub const POWER_THROTTLING_PROCESS_DELAYTIMERS: u32 = 2;
pub const POWER_THROTTLING_PROCESS_IGNORE_TIMER_RESOLUTION: u32 = 4;
pub const POWER_THROTTLING_PROCESS_VALID_FLAGS: u32 = 7;
pub const WIN32K_SYSCALL_FILTER_STATE_ENABLE: u32 = 1;
pub const WIN32K_SYSCALL_FILTER_STATE_AUDIT: u32 = 2;
pub const POWER_THROTTLING_THREAD_CURRENT_VERSION: u32 = 1;
pub const POWER_THROTTLING_THREAD_EXECUTION_SPEED: u32 = 1;
pub const POWER_THROTTLING_THREAD_VALID_FLAGS: u32 = 1;
pub const PROCESS_READWRITEVM_LOGGING_ENABLE_READVM: u32 = 1;
pub const PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM: u32 = 2;
pub const PROCESS_READWRITEVM_LOGGING_ENABLE_READVM_V: u32 = 1;
pub const PROCESS_READWRITEVM_LOGGING_ENABLE_WRITEVM_V: u32 = 2;
pub const THREAD_PERFORMANCE_DATA_VERSION: u32 = 1;
pub const THREAD_PROFILING_FLAG_HARDWARE_COUNTERS: u32 = 2;
pub const CONTEXT_ARM: u32 = 2097152;
pub const CONTEXT_ARM_CONTROL: u32 = 2097153;
pub const CONTEXT_ARM_INTEGER: u32 = 2097154;
pub const CONTEXT_ARM_FLOATING_POINT: u32 = 2097156;
pub const CONTEXT_ARM_DEBUG_REGISTERS: u32 = 2097160;
pub const CONTEXT_ARM_FULL: u32 = 2097159;
pub const CONTEXT_ARM_ALL: u32 = 2097167;
pub const ARM_MAX_BREAKPOINTS: u32 = 8;
pub const ARM_MAX_WATCHPOINTS: u32 = 1;
pub const PROCESS_CREATE_FLAGS_NONE: u32 = 0;
pub const PROCESS_CREATE_FLAGS_BREAKAWAY: u32 = 1;
pub const PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT: u32 = 2;
pub const PROCESS_CREATE_FLAGS_INHERIT_HANDLES: u32 = 4;
pub const PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE: u32 = 8;
pub const PROCESS_CREATE_FLAGS_LARGE_PAGES: u32 = 16;
pub const PROCESS_CREATE_FLAGS_LARGE_PAGE_SYSTEM_DLL: u32 = 32;
pub const PROCESS_CREATE_FLAGS_PROTECTED_PROCESS: u32 = 64;
pub const PROCESS_CREATE_FLAGS_CREATE_SESSION: u32 = 128;
pub const PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT: u32 = 256;
pub const PROCESS_CREATE_FLAGS_CREATE_SUSPENDED: u32 = 512;
pub const PROCESS_CREATE_FLAGS_FORCE_BREAKAWAY: u32 = 1024;
pub const PROCESS_CREATE_FLAGS_MINIMAL_PROCESS: u32 = 2048;
pub const PROCESS_CREATE_FLAGS_RELEASE_SECTION: u32 = 4096;
pub const PROCESS_CREATE_FLAGS_CLONE_MINIMAL: u32 = 8192;
pub const PROCESS_CREATE_FLAGS_CLONE_MINIMAL_REDUCED_COMMIT: u32 = 16384;
pub const PROCESS_CREATE_FLAGS_AUXILIARY_PROCESS: u32 = 32768;
pub const PROCESS_CREATE_FLAGS_CREATE_STORE: u32 = 131072;
pub const PROCESS_CREATE_FLAGS_USE_PROTECTED_ENVIRONMENT: u32 = 262144;
pub const PROCESS_CREATE_FLAGS_IMAGE_EXPANSION_MITIGATION_DISABLE: u32 = 524288;
pub const PROCESS_CREATE_FLAGS_PARTITION_CREATE_SLAB_IDENTITY: u32 = 4194304;
pub const PROCESS_GET_NEXT_FLAGS_PREVIOUS_PROCESS: u32 = 1;
pub const STATECHANGE_SET_ATTRIBUTES: u32 = 1;
pub const QUEUE_USER_APC_FLAGS_NONE: u32 = 0;
pub const QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC: u32 = 1;
pub const QUEUE_USER_APC_FLAGS_CALLBACK_DATA_CONTEXT: u32 = 65536;
pub const ProcThreadAttributeParentProcess: u32 = 0;
pub const ProcThreadAttributeExtendedFlags: u32 = 1;
pub const ProcThreadAttributeHandleList: u32 = 2;
pub const ProcThreadAttributeGroupAffinity: u32 = 3;
pub const ProcThreadAttributePreferredNode: u32 = 4;
pub const ProcThreadAttributeIdealProcessor: u32 = 5;
pub const ProcThreadAttributeUmsThread: u32 = 6;
pub const ProcThreadAttributeMitigationPolicy: u32 = 7;
pub const ProcThreadAttributePackageFullName: u32 = 8;
pub const ProcThreadAttributeSecurityCapabilities: u32 = 9;
pub const ProcThreadAttributeConsoleReference: u32 = 10;
pub const ProcThreadAttributeProtectionLevel: u32 = 11;
pub const ProcThreadAttributeOsMaxVersionTested: u32 = 12;
pub const ProcThreadAttributeJobList: u32 = 13;
pub const ProcThreadAttributeChildProcessPolicy: u32 = 14;
pub const ProcThreadAttributeAllApplicationPackagesPolicy: u32 = 15;
pub const ProcThreadAttributeWin32kFilter: u32 = 16;
pub const ProcThreadAttributeSafeOpenPromptOriginClaim: u32 = 17;
pub const ProcThreadAttributeDesktopAppPolicy: u32 = 18;
pub const ProcThreadAttributeBnoIsolation: u32 = 19;
pub const ProcThreadAttributePseudoConsole: u32 = 22;
pub const ProcThreadAttributeIsolationManifest: u32 = 23;
pub const ProcThreadAttributeMitigationAuditPolicy: u32 = 24;
pub const ProcThreadAttributeMachineType: u32 = 25;
pub const ProcThreadAttributeComponentFilter: u32 = 26;
pub const ProcThreadAttributeEnableOptionalXStateFeatures: u32 = 27;
pub const ProcThreadAttributeCreateStore: u32 = 28;
pub const ProcThreadAttributeTrustedApp: u32 = 29;
pub const ProcThreadAttributeSveVectorLength: u32 = 30;
pub const EXTENDED_PROCESS_CREATION_FLAG_ELEVATION_HANDLED: u32 = 1;
pub const EXTENDED_PROCESS_CREATION_FLAG_FORCELUA: u32 = 2;
pub const EXTENDED_PROCESS_CREATION_FLAG_FORCE_BREAKAWAY: u32 = 4;
pub const PS_ATTRIBUTE_NUMBER_MASK: u32 = 65535;
pub const PS_ATTRIBUTE_THREAD: u32 = 65536;
pub const PS_ATTRIBUTE_INPUT: u32 = 131072;
pub const PS_ATTRIBUTE_ADDITIVE: u32 = 262144;
pub const PS_STD_INPUT_HANDLE: u32 = 1;
pub const PS_STD_OUTPUT_HANDLE: u32 = 2;
pub const PS_STD_ERROR_HANDLE: u32 = 4;
pub const THREAD_CREATE_FLAGS_NONE: u32 = 0;
pub const THREAD_CREATE_FLAGS_CREATE_SUSPENDED: u32 = 1;
pub const THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH: u32 = 2;
pub const THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER: u32 = 4;
pub const THREAD_CREATE_FLAGS_LOADER_WORKER: u32 = 16;
pub const THREAD_CREATE_FLAGS_SKIP_LOADER_INIT: u32 = 32;
pub const THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE: u32 = 64;
pub const JobObjectBasicAccountingInformation: u32 = 1;
pub const JobObjectBasicLimitInformation: u32 = 2;
pub const JobObjectBasicProcessIdList: u32 = 3;
pub const JobObjectBasicUIRestrictions: u32 = 4;
pub const JobObjectSecurityLimitInformation: u32 = 5;
pub const JobObjectEndOfJobTimeInformation: u32 = 6;
pub const JobObjectAssociateCompletionPortInformation: u32 = 7;
pub const JobObjectBasicAndIoAccountingInformation: u32 = 8;
pub const JobObjectExtendedLimitInformation: u32 = 9;
pub const JobObjectJobSetInformation: u32 = 10;
pub const JobObjectGroupInformation: u32 = 11;
pub const JobObjectNotificationLimitInformation: u32 = 12;
pub const JobObjectLimitViolationInformation: u32 = 13;
pub const JobObjectGroupInformationEx: u32 = 14;
pub const JobObjectCpuRateControlInformation: u32 = 15;
pub const JobObjectCompletionFilter: u32 = 16;
pub const JobObjectCompletionCounter: u32 = 17;
pub const JobObjectFreezeInformation: u32 = 18;
pub const JobObjectExtendedAccountingInformation: u32 = 19;
pub const JobObjectWakeInformation: u32 = 20;
pub const JobObjectBackgroundInformation: u32 = 21;
pub const JobObjectSchedulingRankBiasInformation: u32 = 22;
pub const JobObjectTimerVirtualizationInformation: u32 = 23;
pub const JobObjectCycleTimeNotification: u32 = 24;
pub const JobObjectClearEvent: u32 = 25;
pub const JobObjectInterferenceInformation: u32 = 26;
pub const JobObjectClearPeakJobMemoryUsed: u32 = 27;
pub const JobObjectMemoryUsageInformation: u32 = 28;
pub const JobObjectSharedCommit: u32 = 29;
pub const JobObjectContainerId: u32 = 30;
pub const JobObjectIoRateControlInformation: u32 = 31;
pub const JobObjectNetRateControlInformation: u32 = 32;
pub const JobObjectNotificationLimitInformation2: u32 = 33;
pub const JobObjectLimitViolationInformation2: u32 = 34;
pub const JobObjectCreateSilo: u32 = 35;
pub const JobObjectSiloBasicInformation: u32 = 36;
pub const JobObjectSiloRootDirectory: u32 = 37;
pub const JobObjectServerSiloBasicInformation: u32 = 38;
pub const JobObjectServerSiloUserSharedData: u32 = 39;
pub const JobObjectServerSiloInitialize: u32 = 40;
pub const JobObjectServerSiloRunningState: u32 = 41;
pub const JobObjectIoAttribution: u32 = 42;
pub const JobObjectMemoryPartitionInformation: u32 = 43;
pub const JobObjectContainerTelemetryId: u32 = 44;
pub const JobObjectSiloSystemRoot: u32 = 45;
pub const JobObjectEnergyTrackingState: u32 = 46;
pub const JobObjectThreadImpersonationInformation: u32 = 47;
pub const JobObjectIoPriorityLimit: u32 = 48;
pub const JobObjectPagePriorityLimit: u32 = 49;
pub const JobObjectServerSiloDiagnosticInformation: u32 = 50;
pub const JobObjectNetworkAccountingInformation: u32 = 51;
pub const MaxJobObjectInfoClass: u32 = 52;
pub const JOB_OBJECT_LIMIT_SILO_READY: u32 = 4194304;
pub const SILO_OBJECT_ROOT_DIRECTORY_SHADOW_ROOT: u32 = 1;
pub const SILO_OBJECT_ROOT_DIRECTORY_INITIALIZE: u32 = 2;
pub const SILO_OBJECT_ROOT_DIRECTORY_SHADOW_DOS_DEVICES: u32 = 4;
pub const MEMORY_BULK_INFORMATION_FLAG_BASIC: u32 = 1;
pub const DBG_STATUS_CONTROL_C: u32 = 1;
pub const DBG_STATUS_SYSRQ: u32 = 2;
pub const DBG_STATUS_BUGCHECK_FIRST: u32 = 3;
pub const DBG_STATUS_BUGCHECK_SECOND: u32 = 4;
pub const DBG_STATUS_FATAL: u32 = 5;
pub const DBG_STATUS_DEBUG_CONTROL: u32 = 6;
pub const DBG_STATUS_WORKER: u32 = 7;
pub const DEBUG_READ_EVENT: u32 = 1;
pub const DEBUG_PROCESS_ASSIGN: u32 = 2;
pub const DEBUG_SET_INFORMATION: u32 = 4;
pub const DEBUG_QUERY_INFORMATION: u32 = 8;
pub const DEBUG_ALL_ACCESS: u32 = 2031631;
pub const DEBUG_KILL_ON_CLOSE: u32 = 1;
pub const FILE_SHARE_NONE: u32 = 0;
pub const FILE_SUPERSEDE: u32 = 0;
pub const FILE_OPEN: u32 = 1;
pub const FILE_CREATE: u32 = 2;
pub const FILE_OPEN_IF: u32 = 3;
pub const FILE_OVERWRITE: u32 = 4;
pub const FILE_OVERWRITE_IF: u32 = 5;
pub const FILE_MAXIMUM_DISPOSITION: u32 = 5;
pub const FILE_DIRECTORY_FILE: u32 = 1;
pub const FILE_WRITE_THROUGH: u32 = 2;
pub const FILE_SEQUENTIAL_ONLY: u32 = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: u32 = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 32;
pub const FILE_NON_DIRECTORY_FILE: u32 = 64;
pub const FILE_CREATE_TREE_CONNECTION: u32 = 128;
pub const FILE_COMPLETE_IF_OPLOCKED: u32 = 256;
pub const FILE_NO_EA_KNOWLEDGE: u32 = 512;
pub const FILE_OPEN_REMOTE_INSTANCE: u32 = 1024;
pub const FILE_RANDOM_ACCESS: u32 = 2048;
pub const FILE_DELETE_ON_CLOSE: u32 = 4096;
pub const FILE_OPEN_BY_FILE_ID: u32 = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: u32 = 16384;
pub const FILE_NO_COMPRESSION: u32 = 32768;
pub const FILE_OPEN_REQUIRING_OPLOCK: u32 = 65536;
pub const FILE_DISALLOW_EXCLUSIVE: u32 = 131072;
pub const FILE_SESSION_AWARE: u32 = 262144;
pub const FILE_RESERVE_OPFILTER: u32 = 1048576;
pub const FILE_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_OPEN_NO_RECALL: u32 = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: u32 = 8388608;
pub const TREE_CONNECT_WRITE_THROUGH: u32 = 2;
pub const TREE_CONNECT_NO_CLIENT_BUFFERING: u32 = 8;
pub const FILE_CONTAINS_EXTENDED_CREATE_INFORMATION: u32 = 268435456;
pub const FILE_VALID_EXTENDED_OPTION_FLAGS: u32 = 268435456;
pub const EX_CREATE_FLAG_FILE_SOURCE_OPEN_FOR_COPY: u32 = 1;
pub const EX_CREATE_FLAG_FILE_DEST_OPEN_FOR_COPY: u32 = 2;
pub const FILE_VALID_OPTION_FLAGS: u32 = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_SET_FLAGS: u32 = 54;
pub const FILE_COPY_STRUCTURED_STORAGE: u32 = 65;
pub const FILE_STRUCTURED_STORAGE: u32 = 1089;
pub const FILE_SUPERSEDED: u32 = 0;
pub const FILE_OPENED: u32 = 1;
pub const FILE_CREATED: u32 = 2;
pub const FILE_OVERWRITTEN: u32 = 3;
pub const FILE_EXISTS: u32 = 4;
pub const FILE_DOES_NOT_EXIST: u32 = 5;
pub const FILE_WRITE_TO_END_OF_FILE: u32 = 4294967295;
pub const FILE_USE_FILE_POINTER_POSITION: u32 = 4294967294;
pub const FILE_BYTE_ALIGNMENT: u32 = 0;
pub const FILE_WORD_ALIGNMENT: u32 = 1;
pub const FILE_LONG_ALIGNMENT: u32 = 3;
pub const FILE_QUAD_ALIGNMENT: u32 = 7;
pub const FILE_OCTA_ALIGNMENT: u32 = 15;
pub const FILE_32_BYTE_ALIGNMENT: u32 = 31;
pub const FILE_64_BYTE_ALIGNMENT: u32 = 63;
pub const FILE_128_BYTE_ALIGNMENT: u32 = 127;
pub const FILE_256_BYTE_ALIGNMENT: u32 = 255;
pub const FILE_512_BYTE_ALIGNMENT: u32 = 511;
pub const DOS_MAX_COMPONENT_LENGTH: u32 = 255;
pub const DOS_MAX_PATH_LENGTH: u32 = 260;
pub const MAXIMUM_FILENAME_LENGTH: u32 = 256;
pub const FILE_NEED_EA: u32 = 128;
pub const FILE_EA_TYPE_BINARY: u32 = 65534;
pub const FILE_EA_TYPE_ASCII: u32 = 65533;
pub const FILE_EA_TYPE_BITMAP: u32 = 65531;
pub const FILE_EA_TYPE_METAFILE: u32 = 65530;
pub const FILE_EA_TYPE_ICON: u32 = 65529;
pub const FILE_EA_TYPE_EA: u32 = 65518;
pub const FILE_EA_TYPE_MVMT: u32 = 65503;
pub const FILE_EA_TYPE_MVST: u32 = 65502;
pub const FILE_EA_TYPE_ASN1: u32 = 65501;
pub const FILE_EA_TYPE_FAMILY_IDS: u32 = 65281;
pub const FILE_REMOVABLE_MEDIA: u32 = 1;
pub const FILE_READ_ONLY_DEVICE: u32 = 2;
pub const FILE_FLOPPY_DISKETTE: u32 = 4;
pub const FILE_WRITE_ONCE_MEDIA: u32 = 8;
pub const FILE_REMOTE_DEVICE: u32 = 16;
pub const FILE_DEVICE_IS_MOUNTED: u32 = 32;
pub const FILE_VIRTUAL_VOLUME: u32 = 64;
pub const FILE_AUTOGENERATED_DEVICE_NAME: u32 = 128;
pub const FILE_DEVICE_SECURE_OPEN: u32 = 256;
pub const FILE_CHARACTERISTIC_PNP_DEVICE: u32 = 2048;
pub const FILE_CHARACTERISTIC_TS_DEVICE: u32 = 4096;
pub const FILE_CHARACTERISTIC_WEBDAV_DEVICE: u32 = 8192;
pub const FILE_CHARACTERISTIC_CSV: u32 = 65536;
pub const FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL: u32 = 131072;
pub const FILE_PORTABLE_DEVICE: u32 = 262144;
pub const FILE_REMOTE_DEVICE_VSMB: u32 = 524288;
pub const FILE_DEVICE_REQUIRE_SECURITY_CHECK: u32 = 1048576;
pub const FILE_PIPE_BYTE_STREAM_TYPE: u32 = 0;
pub const FILE_PIPE_MESSAGE_TYPE: u32 = 1;
pub const FILE_PIPE_ACCEPT_REMOTE_CLIENTS: u32 = 0;
pub const FILE_PIPE_REJECT_REMOTE_CLIENTS: u32 = 2;
pub const FILE_PIPE_TYPE_VALID_MASK: u32 = 3;
pub const FILE_PIPE_QUEUE_OPERATION: u32 = 0;
pub const FILE_PIPE_COMPLETE_OPERATION: u32 = 1;
pub const FILE_PIPE_BYTE_STREAM_MODE: u32 = 0;
pub const FILE_PIPE_MESSAGE_MODE: u32 = 1;
pub const FILE_PIPE_INBOUND: u32 = 0;
pub const FILE_PIPE_OUTBOUND: u32 = 1;
pub const FILE_PIPE_FULL_DUPLEX: u32 = 2;
pub const FILE_PIPE_DISCONNECTED_STATE: u32 = 1;
pub const FILE_PIPE_LISTENING_STATE: u32 = 2;
pub const FILE_PIPE_CONNECTED_STATE: u32 = 3;
pub const FILE_PIPE_CLOSING_STATE: u32 = 4;
pub const FILE_PIPE_CLIENT_END: u32 = 0;
pub const FILE_PIPE_SERVER_END: u32 = 1;
pub const FILE_PIPE_UNLIMITED_INSTANCES: u32 = 4294967295;
pub const MAILSLOT_SIZE_AUTO: u32 = 0;
pub const FLAGS_END_OF_FILE_INFO_EX_EXTEND_PAGING: u32 = 1;
pub const FLAGS_END_OF_FILE_INFO_EX_NO_EXTRA_PAGING_EXTEND: u32 = 2;
pub const FLAGS_END_OF_FILE_INFO_EX_TIME_CONSTRAINED: u32 = 4;
pub const FLAGS_DELAY_REASONS_LOG_FILE_FULL: u32 = 1;
pub const FLAGS_DELAY_REASONS_BITMAP_SCANNED: u32 = 2;
pub const FILE_LINK_REPLACE_IF_EXISTS: u32 = 1;
pub const FILE_LINK_POSIX_SEMANTICS: u32 = 2;
pub const FILE_LINK_SUPPRESS_STORAGE_RESERVE_INHERITANCE: u32 = 8;
pub const FILE_LINK_NO_INCREASE_AVAILABLE_SPACE: u32 = 16;
pub const FILE_LINK_NO_DECREASE_AVAILABLE_SPACE: u32 = 32;
pub const FILE_LINK_PRESERVE_AVAILABLE_SPACE: u32 = 48;
pub const FILE_LINK_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const FILE_LINK_FORCE_RESIZE_TARGET_SR: u32 = 128;
pub const FILE_LINK_FORCE_RESIZE_SOURCE_SR: u32 = 256;
pub const FILE_LINK_FORCE_RESIZE_SR: u32 = 384;
pub const FILE_RENAME_REPLACE_IF_EXISTS: u32 = 1;
pub const FILE_RENAME_POSIX_SEMANTICS: u32 = 2;
pub const FILE_RENAME_SUPPRESS_PIN_STATE_INHERITANCE: u32 = 4;
pub const FILE_RENAME_SUPPRESS_STORAGE_RESERVE_INHERITANCE: u32 = 8;
pub const FILE_RENAME_NO_INCREASE_AVAILABLE_SPACE: u32 = 16;
pub const FILE_RENAME_NO_DECREASE_AVAILABLE_SPACE: u32 = 32;
pub const FILE_RENAME_PRESERVE_AVAILABLE_SPACE: u32 = 48;
pub const FILE_RENAME_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const FILE_RENAME_FORCE_RESIZE_TARGET_SR: u32 = 128;
pub const FILE_RENAME_FORCE_RESIZE_SOURCE_SR: u32 = 256;
pub const FILE_RENAME_FORCE_RESIZE_SR: u32 = 384;
pub const FILE_SKIP_SET_USER_EVENT_ON_FAST_IO: u32 = 4;
pub const CHECKSUM_ENFORCEMENT_OFF: u32 = 1;
pub const LX_FILE_METADATA_HAS_UID: u32 = 1;
pub const LX_FILE_METADATA_HAS_GID: u32 = 2;
pub const LX_FILE_METADATA_HAS_MODE: u32 = 4;
pub const LX_FILE_METADATA_HAS_DEVICE_ID: u32 = 8;
pub const LX_FILE_CASE_SENSITIVE_DIR: u32 = 16;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED: u32 = 1;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX: u32 = 2;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX: u32 = 4;
pub const FILE_VC_QUOTA_NONE: u32 = 0;
pub const FILE_VC_QUOTA_TRACK: u32 = 1;
pub const FILE_VC_QUOTA_ENFORCE: u32 = 2;
pub const FILE_VC_QUOTA_MASK: u32 = 3;
pub const FILE_VC_CONTENT_INDEX_DISABLED: u32 = 8;
pub const FILE_VC_LOG_QUOTA_THRESHOLD: u32 = 16;
pub const FILE_VC_LOG_QUOTA_LIMIT: u32 = 32;
pub const FILE_VC_LOG_VOLUME_THRESHOLD: u32 = 64;
pub const FILE_VC_LOG_VOLUME_LIMIT: u32 = 128;
pub const FILE_VC_QUOTAS_INCOMPLETE: u32 = 256;
pub const FILE_VC_QUOTAS_REBUILDING: u32 = 512;
pub const FILE_VC_VALID_MASK: u32 = 1023;
pub const SSINFO_FLAGS_ALIGNED_DEVICE: u32 = 1;
pub const SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE: u32 = 2;
pub const SSINFO_FLAGS_NO_SEEK_PENALTY: u32 = 4;
pub const SSINFO_FLAGS_TRIM_ENABLED: u32 = 8;
pub const SSINFO_FLAGS_BYTE_ADDRESSABLE: u32 = 16;
pub const SSINFO_OFFSET_UNKNOWN: u32 = 4294967295;
pub const FLUSH_FLAGS_FLUSH_AND_PURGE: u32 = 8;
pub const FILE_QUERY_RESTART_SCAN: u32 = 1;
pub const FILE_QUERY_RETURN_SINGLE_ENTRY: u32 = 2;
pub const FILE_QUERY_INDEX_SPECIFIED: u32 = 4;
pub const FILE_QUERY_RETURN_ON_DISK_ENTRIES_ONLY: u32 = 8;
pub const FILE_QUERY_NO_CURSOR_UPDATE: u32 = 16;
pub const FILE_NOTIFY_CHANGE_NAME: u32 = 3;
pub const FILE_NOTIFY_CHANGE_EA: u32 = 128;
pub const FILE_NOTIFY_CHANGE_STREAM_NAME: u32 = 512;
pub const FILE_NOTIFY_CHANGE_STREAM_SIZE: u32 = 1024;
pub const FILE_NOTIFY_CHANGE_STREAM_WRITE: u32 = 2048;
pub const FILE_NOTIFY_VALID_MASK: u32 = 4095;
pub const FILE_ACTION_ADDED_STREAM: u32 = 6;
pub const FILE_ACTION_REMOVED_STREAM: u32 = 7;
pub const FILE_ACTION_MODIFIED_STREAM: u32 = 8;
pub const FILE_ACTION_REMOVED_BY_DELETE: u32 = 9;
pub const FILE_ACTION_ID_NOT_TUNNELLED: u32 = 10;
pub const FILE_ACTION_TUNNELLED_ID_COLLISION: u32 = 11;
pub const IO_COMPLETION_QUERY_STATE: u32 = 1;
pub const SYMLINK_FLAG_RELATIVE: u32 = 1;
pub const SYMLINK_DIRECTORY: u32 = 2147483648;
pub const SYMLINK_FILE: u32 = 1073741824;
pub const REPARSE_DATA_EX_FLAG_GIVEN_TAG_OR_NONE: u32 = 1;
pub const DEVICE_NAMED_PIPE: &[u8; 19] = b"\\Device\\NamedPipe\\\0";
pub const FILE_PIPE_READ_DATA: u32 = 0;
pub const FILE_PIPE_WRITE_SPACE: u32 = 1;
pub const FILE_PIPE_COMPUTER_NAME_LENGTH: u32 = 15;
pub const FILE_PIPE_SYMLINK_FLAG_GLOBAL: u32 = 1;
pub const FILE_PIPE_SYMLINK_FLAG_RELATIVE: u32 = 2;
pub const FILE_PIPE_SYMLINK_VALID_FLAGS: u32 = 3;
pub const MAILSLOT_CLASS_FIRSTCLASS: u32 = 1;
pub const MAILSLOT_CLASS_SECONDCLASS: u32 = 2;
pub const MOUNTMGR_DEVICE_NAME: &[u8; 26] = b"\\Device\\MountPointManager\0";
pub const MOUNTMGRCONTROLTYPE: u32 = 109;
pub const MOUNTDEVCONTROLTYPE: u32 = 77;
pub const FLT_SYMLINK_NAME: &[u8; 17] = b"\\Global??\\FltMgr\0";
pub const FLT_MSG_SYMLINK_NAME: &[u8; 20] = b"\\Global??\\FltMgrMsg\0";
pub const FLT_DEVICE_NAME: &[u8; 27] = b"\\FileSystem\\Filters\\FltMgr\0";
pub const FLT_MSG_DEVICE_NAME: &[u8; 30] = b"\\FileSystem\\Filters\\FltMgrMsg\0";
pub const FLT_PORT_EA_NAME: &[u8; 8] = b"FLTPORT\0";
pub const FLT_PORT_CONTEXT_MAX: u32 = 65512;
pub const IRP_MJ_CREATE: u32 = 0;
pub const IRP_MJ_CREATE_NAMED_PIPE: u32 = 1;
pub const IRP_MJ_CLOSE: u32 = 2;
pub const IRP_MJ_READ: u32 = 3;
pub const IRP_MJ_WRITE: u32 = 4;
pub const IRP_MJ_QUERY_INFORMATION: u32 = 5;
pub const IRP_MJ_SET_INFORMATION: u32 = 6;
pub const IRP_MJ_QUERY_EA: u32 = 7;
pub const IRP_MJ_SET_EA: u32 = 8;
pub const IRP_MJ_FLUSH_BUFFERS: u32 = 9;
pub const IRP_MJ_QUERY_VOLUME_INFORMATION: u32 = 10;
pub const IRP_MJ_SET_VOLUME_INFORMATION: u32 = 11;
pub const IRP_MJ_DIRECTORY_CONTROL: u32 = 12;
pub const IRP_MJ_FILE_SYSTEM_CONTROL: u32 = 13;
pub const IRP_MJ_DEVICE_CONTROL: u32 = 14;
pub const IRP_MJ_INTERNAL_DEVICE_CONTROL: u32 = 15;
pub const IRP_MJ_SHUTDOWN: u32 = 16;
pub const IRP_MJ_LOCK_CONTROL: u32 = 17;
pub const IRP_MJ_CLEANUP: u32 = 18;
pub const IRP_MJ_CREATE_MAILSLOT: u32 = 19;
pub const IRP_MJ_QUERY_SECURITY: u32 = 20;
pub const IRP_MJ_SET_SECURITY: u32 = 21;
pub const IRP_MJ_POWER: u32 = 22;
pub const IRP_MJ_SYSTEM_CONTROL: u32 = 23;
pub const IRP_MJ_DEVICE_CHANGE: u32 = 24;
pub const IRP_MJ_QUERY_QUOTA: u32 = 25;
pub const IRP_MJ_SET_QUOTA: u32 = 26;
pub const IRP_MJ_PNP: u32 = 27;
pub const IRP_MJ_PNP_POWER: u32 = 27;
pub const IRP_MJ_MAXIMUM_FUNCTION: u32 = 27;
pub const FLT_INTERNAL_OPERATION_COUNT: u32 = 22;
pub const IRP_MN_SCSI_CLASS: u32 = 1;
pub const IRP_MN_START_DEVICE: u32 = 0;
pub const IRP_MN_QUERY_REMOVE_DEVICE: u32 = 1;
pub const IRP_MN_REMOVE_DEVICE: u32 = 2;
pub const IRP_MN_CANCEL_REMOVE_DEVICE: u32 = 3;
pub const IRP_MN_STOP_DEVICE: u32 = 4;
pub const IRP_MN_QUERY_STOP_DEVICE: u32 = 5;
pub const IRP_MN_CANCEL_STOP_DEVICE: u32 = 6;
pub const IRP_MN_QUERY_DEVICE_RELATIONS: u32 = 7;
pub const IRP_MN_QUERY_INTERFACE: u32 = 8;
pub const IRP_MN_QUERY_CAPABILITIES: u32 = 9;
pub const IRP_MN_QUERY_RESOURCES: u32 = 10;
pub const IRP_MN_QUERY_RESOURCE_REQUIREMENTS: u32 = 11;
pub const IRP_MN_QUERY_DEVICE_TEXT: u32 = 12;
pub const IRP_MN_FILTER_RESOURCE_REQUIREMENTS: u32 = 13;
pub const IRP_MN_READ_CONFIG: u32 = 15;
pub const IRP_MN_WRITE_CONFIG: u32 = 16;
pub const IRP_MN_EJECT: u32 = 17;
pub const IRP_MN_SET_LOCK: u32 = 18;
pub const IRP_MN_QUERY_ID: u32 = 19;
pub const IRP_MN_QUERY_PNP_DEVICE_STATE: u32 = 20;
pub const IRP_MN_QUERY_BUS_INFORMATION: u32 = 21;
pub const IRP_MN_DEVICE_USAGE_NOTIFICATION: u32 = 22;
pub const IRP_MN_SURPRISE_REMOVAL: u32 = 23;
pub const IRP_MN_DEVICE_ENUMERATED: u32 = 25;
pub const IRP_MN_WAIT_WAKE: u32 = 0;
pub const IRP_MN_POWER_SEQUENCE: u32 = 1;
pub const IRP_MN_SET_POWER: u32 = 2;
pub const IRP_MN_QUERY_POWER: u32 = 3;
pub const IRP_MN_QUERY_ALL_DATA: u32 = 0;
pub const IRP_MN_QUERY_SINGLE_INSTANCE: u32 = 1;
pub const IRP_MN_CHANGE_SINGLE_INSTANCE: u32 = 2;
pub const IRP_MN_CHANGE_SINGLE_ITEM: u32 = 3;
pub const IRP_MN_ENABLE_EVENTS: u32 = 4;
pub const IRP_MN_DISABLE_EVENTS: u32 = 5;
pub const IRP_MN_ENABLE_COLLECTION: u32 = 6;
pub const IRP_MN_DISABLE_COLLECTION: u32 = 7;
pub const IRP_MN_REGINFO: u32 = 8;
pub const IRP_MN_EXECUTE_METHOD: u32 = 9;
pub const IRP_MN_REGINFO_EX: u32 = 11;
pub const FLTFL_CALLBACK_DATA_REISSUE_MASK: u32 = 65535;
pub const FLTFL_CALLBACK_DATA_IRP_OPERATION: u32 = 1;
pub const FLTFL_CALLBACK_DATA_FAST_IO_OPERATION: u32 = 2;
pub const FLTFL_CALLBACK_DATA_FS_FILTER_OPERATION: u32 = 4;
pub const FLTFL_CALLBACK_DATA_SYSTEM_BUFFER: u32 = 8;
pub const FLTFL_CALLBACK_DATA_GENERATED_IO: u32 = 65536;
pub const FLTFL_CALLBACK_DATA_REISSUED_IO: u32 = 131072;
pub const FLTFL_CALLBACK_DATA_DRAINING_IO: u32 = 262144;
pub const FLTFL_CALLBACK_DATA_POST_OPERATION: u32 = 524288;
pub const FLTFL_CALLBACK_DATA_NEW_SYSTEM_BUFFER: u32 = 1048576;
pub const FLTFL_CALLBACK_DATA_DIRTY: u32 = 2147483648;
pub const IRP_NOCACHE: u32 = 1;
pub const IRP_PAGING_IO: u32 = 2;
pub const IRP_MOUNT_COMPLETION: u32 = 2;
pub const IRP_SYNCHRONOUS_API: u32 = 4;
pub const IRP_ASSOCIATED_IRP: u32 = 8;
pub const IRP_BUFFERED_IO: u32 = 16;
pub const IRP_DEALLOCATE_BUFFER: u32 = 32;
pub const IRP_INPUT_OPERATION: u32 = 64;
pub const IRP_SYNCHRONOUS_PAGING_IO: u32 = 64;
pub const IRP_CREATE_OPERATION: u32 = 128;
pub const IRP_READ_OPERATION: u32 = 256;
pub const IRP_WRITE_OPERATION: u32 = 512;
pub const IRP_CLOSE_OPERATION: u32 = 1024;
pub const IRP_DEFER_IO_COMPLETION: u32 = 2048;
pub const IRP_OB_QUERY_NAME: u32 = 4096;
pub const IRP_HOLD_DEVICE_QUEUE: u32 = 8192;
pub const IRP_UM_DRIVER_INITIATED_IO: u32 = 4194304;
pub const FO_FILE_OPEN: u32 = 1;
pub const FO_SYNCHRONOUS_IO: u32 = 2;
pub const FO_ALERTABLE_IO: u32 = 4;
pub const FO_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FO_WRITE_THROUGH: u32 = 16;
pub const FO_SEQUENTIAL_ONLY: u32 = 32;
pub const FO_CACHE_SUPPORTED: u32 = 64;
pub const FO_NAMED_PIPE: u32 = 128;
pub const FO_STREAM_FILE: u32 = 256;
pub const FO_MAILSLOT: u32 = 512;
pub const FO_GENERATE_AUDIT_ON_CLOSE: u32 = 1024;
pub const FO_QUEUE_IRP_TO_THREAD: u32 = 1024;
pub const FO_DIRECT_DEVICE_OPEN: u32 = 2048;
pub const FO_FILE_MODIFIED: u32 = 4096;
pub const FO_FILE_SIZE_CHANGED: u32 = 8192;
pub const FO_CLEANUP_COMPLETE: u32 = 16384;
pub const FO_TEMPORARY_FILE: u32 = 32768;
pub const FO_DELETE_ON_CLOSE: u32 = 65536;
pub const FO_OPENED_CASE_SENSITIVE: u32 = 131072;
pub const FO_HANDLE_CREATED: u32 = 262144;
pub const FO_FILE_FAST_IO_READ: u32 = 524288;
pub const FO_RANDOM_ACCESS: u32 = 1048576;
pub const FO_FILE_OPEN_CANCELLED: u32 = 2097152;
pub const FO_VOLUME_OPEN: u32 = 4194304;
pub const FO_BYPASS_IO_ENABLED: u32 = 8388608;
pub const FO_REMOTE_ORIGIN: u32 = 16777216;
pub const FO_DISALLOW_EXCLUSIVE: u32 = 33554432;
pub const FO_SKIP_COMPLETION_PORT: u32 = 33554432;
pub const FO_SKIP_SET_EVENT: u32 = 67108864;
pub const FO_SKIP_SET_FAST_IO: u32 = 134217728;
pub const FO_INDIRECT_WAIT_OBJECT: u32 = 268435456;
pub const FO_SECTION_MINSTORE_TREATMENT: u32 = 536870912;
pub const SL_PENDING_RETURNED: u32 = 1;
pub const SL_ERROR_RETURNED: u32 = 2;
pub const SL_INVOKE_ON_CANCEL: u32 = 32;
pub const SL_INVOKE_ON_SUCCESS: u32 = 64;
pub const SL_INVOKE_ON_ERROR: u32 = 128;
pub const SL_FORCE_ACCESS_CHECK: u32 = 1;
pub const SL_OPEN_PAGING_FILE: u32 = 2;
pub const SL_OPEN_TARGET_DIRECTORY: u32 = 4;
pub const SL_STOP_ON_SYMLINK: u32 = 8;
pub const SL_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const SL_CASE_SENSITIVE: u32 = 128;
pub const SL_KEY_SPECIFIED: u32 = 1;
pub const SL_OVERRIDE_VERIFY_VOLUME: u32 = 2;
pub const SL_WRITE_THROUGH: u32 = 4;
pub const SL_FT_SEQUENTIAL_WRITE: u32 = 8;
pub const SL_FORCE_DIRECT_WRITE: u32 = 16;
pub const SL_REALTIME_STREAM: u32 = 32;
pub const SL_PERSISTENT_MEMORY_FIXED_MAPPING: u32 = 32;
pub const SL_BYPASS_IO: u32 = 64;
pub const SL_FORCE_ASYNCHRONOUS: u32 = 1;
pub const SL_READ_ACCESS_GRANTED: u32 = 1;
pub const SL_WRITE_ACCESS_GRANTED: u32 = 4;
pub const SL_FAIL_IMMEDIATELY: u32 = 1;
pub const SL_EXCLUSIVE_LOCK: u32 = 2;
pub const SL_RESTART_SCAN: u32 = 1;
pub const SL_RETURN_SINGLE_ENTRY: u32 = 2;
pub const SL_INDEX_SPECIFIED: u32 = 4;
pub const SL_RETURN_ON_DISK_ENTRIES_ONLY: u32 = 8;
pub const SL_NO_CURSOR_UPDATE: u32 = 16;
pub const SL_QUERY_DIRECTORY_MASK: u32 = 27;
pub const SL_WATCH_TREE: u32 = 1;
pub const SL_ALLOW_RAW_MOUNT: u32 = 1;
pub const SL_BYPASS_ACCESS_CHECK: u32 = 1;
pub const SL_INFO_FORCE_ACCESS_CHECK: u32 = 1;
pub const SL_INFO_IGNORE_READONLY_ATTRIBUTE: u32 = 64;
pub const DO_VERIFY_VOLUME: u32 = 2;
pub const DO_BUFFERED_IO: u32 = 4;
pub const DO_EXCLUSIVE: u32 = 8;
pub const DO_DIRECT_IO: u32 = 16;
pub const DO_MAP_IO_BUFFER: u32 = 32;
pub const DO_DEVICE_INITIALIZING: u32 = 128;
pub const DO_SHUTDOWN_REGISTERED: u32 = 2048;
pub const DO_BUS_ENUMERATED_DEVICE: u32 = 4096;
pub const DO_POWER_PAGABLE: u32 = 8192;
pub const DO_POWER_INRUSH: u32 = 16384;
pub const DO_DEVICE_TO_BE_RESET: u32 = 67108864;
pub const DO_DAX_VOLUME: u32 = 268435456;
pub const KSEC_DEVICE_NAME: &[u8; 15] = b"\\Device\\KSecDD\0";
pub const OPLOCK_KEY_VERSION_WIN7: u32 = 1;
pub const OPLOCK_KEY_VERSION_WIN8: u32 = 2;
pub const OPLOCK_KEY_FLAG_PARENT_KEY: u32 = 1;
pub const OPLOCK_KEY_FLAG_TARGET_KEY: u32 = 2;
pub const SUPPORTED_FS_FEATURES_OFFLOAD_READ: u32 = 1;
pub const SUPPORTED_FS_FEATURES_OFFLOAD_WRITE: u32 = 2;
pub const SUPPORTED_FS_FEATURES_QUERY_OPEN: u32 = 4;
pub const SUPPORTED_FS_FEATURES_BYPASS_IO: u32 = 8;
pub const SUPPORTED_FS_FEATURES_VALID_MASK_V3: u32 = 15;
pub const SUPPORTED_FS_FEATURES_VALID_MASK_V2: u32 = 7;
pub const SUPPORTED_FS_FEATURES_VALID_MASK_V1: u32 = 3;
pub const SUPPORTED_FS_FEATURES_VALID_MASK: u32 = 15;
pub const PORT_CONNECT: u32 = 1;
pub const PORT_ALL_ACCESS: u32 = 2031617;
pub const LPC_REQUEST: u32 = 1;
pub const LPC_REPLY: u32 = 2;
pub const LPC_DATAGRAM: u32 = 3;
pub const LPC_LOST_REPLY: u32 = 4;
pub const LPC_PORT_CLOSED: u32 = 5;
pub const LPC_CLIENT_DIED: u32 = 6;
pub const LPC_EXCEPTION: u32 = 7;
pub const LPC_DEBUG_EVENT: u32 = 8;
pub const LPC_ERROR_EVENT: u32 = 9;
pub const LPC_CONNECTION_REQUEST: u32 = 10;
pub const LPC_CONTINUATION_REQUIRED: u32 = 8192;
pub const LPC_NO_IMPERSONATE: u32 = 16384;
pub const LPC_KERNELMODE_MESSAGE: u32 = 32768;
pub const PORT_VALID_OBJECT_ATTRIBUTES: u32 = 64;
pub const PORT_MAXIMUM_MESSAGE_LENGTH: u32 = 512;
pub const ALPC_PORFLG_LPC_MODE: u32 = 4096;
pub const ALPC_PORFLG_ALLOW_IMPERSONATION: u32 = 65536;
pub const ALPC_PORFLG_ALLOW_LPC_REQUESTS: u32 = 131072;
pub const ALPC_PORFLG_WAITABLE_PORT: u32 = 262144;
pub const ALPC_PORFLG_ALLOW_DUP_OBJECT: u32 = 524288;
pub const ALPC_PORFLG_SYSTEM_PROCESS: u32 = 1048576;
pub const ALPC_PORFLG_WAKE_POLICY1: u32 = 2097152;
pub const ALPC_PORFLG_WAKE_POLICY2: u32 = 4194304;
pub const ALPC_PORFLG_WAKE_POLICY3: u32 = 8388608;
pub const ALPC_PORFLG_DIRECT_MESSAGE: u32 = 16777216;
pub const ALPC_PORFLG_ALLOW_MULTIHANDLE_ATTRIBUTE: u32 = 33554432;
pub const ALPC_PORFLG_OBJECT_TYPE_FILE: u32 = 1;
pub const ALPC_PORFLG_OBJECT_TYPE_INVALID: u32 = 2;
pub const ALPC_PORFLG_OBJECT_TYPE_THREAD: u32 = 4;
pub const ALPC_PORFLG_OBJECT_TYPE_SEMAPHORE: u32 = 8;
pub const ALPC_PORFLG_OBJECT_TYPE_EVENT: u32 = 16;
pub const ALPC_PORFLG_OBJECT_TYPE_PROCESS: u32 = 32;
pub const ALPC_PORFLG_OBJECT_TYPE_MUTEX: u32 = 64;
pub const ALPC_PORFLG_OBJECT_TYPE_SECTION: u32 = 128;
pub const ALPC_PORFLG_OBJECT_TYPE_REGKEY: u32 = 256;
pub const ALPC_PORFLG_OBJECT_TYPE_TOKEN: u32 = 512;
pub const ALPC_PORFLG_OBJECT_TYPE_COMPOSITION: u32 = 1024;
pub const ALPC_PORFLG_OBJECT_TYPE_JOB: u32 = 2048;
pub const ALPC_PORFLG_OBJECT_TYPE_ALL: u32 = 4093;
pub const ALPC_MESSAGE_HANDLE_ATTRIBUTE: u32 = 268435456;
pub const ALPC_MESSAGE_CONTEXT_ATTRIBUTE: u32 = 536870912;
pub const ALPC_MESSAGE_VIEW_ATTRIBUTE: u32 = 1073741824;
pub const ALPC_MESSAGE_SECURITY_ATTRIBUTE: u32 = 2147483648;
pub const ALPC_COMPLETION_LIST_BUFFER_GRANULARITY_MASK: u32 = 63;
pub const ALPC_HANDLEFLG_DUPLICATE_SAME_ACCESS: u32 = 65536;
pub const ALPC_HANDLEFLG_DUPLICATE_SAME_ATTRIBUTES: u32 = 131072;
pub const ALPC_HANDLEFLG_DUPLICATE_INHERIT: u32 = 524288;
pub const ALPC_SECFLG_CREATE_HANDLE: u32 = 131072;
pub const ALPC_SECFLG_NOSECTIONHANDLE: u32 = 262144;
pub const ALPC_VIEWFLG_UNMAP_EXISTING: u32 = 65536;
pub const ALPC_VIEWFLG_AUTO_RELEASE: u32 = 131072;
pub const ALPC_VIEWFLG_NOT_SECURE: u32 = 262144;
pub const ALPC_CREATEPORTSECTIONFLG_SECURE: u32 = 262144;
pub const ALPC_MSGFLG_REPLY_MESSAGE: u32 = 1;
pub const ALPC_MSGFLG_LPC_MODE: u32 = 2;
pub const ALPC_MSGFLG_RELEASE_MESSAGE: u32 = 65536;
pub const ALPC_MSGFLG_SYNC_REQUEST: u32 = 131072;
pub const ALPC_MSGFLG_TRACK_PORT_REFERENCES: u32 = 262144;
pub const ALPC_MSGFLG_WAIT_USER_MODE: u32 = 1048576;
pub const ALPC_MSGFLG_WAIT_ALERTABLE: u32 = 2097152;
pub const ALPC_MSGFLG_WOW64_CALL: u32 = 2147483648;
pub const ALPC_CANCELFLG_TRY_CANCEL: u32 = 1;
pub const ALPC_CANCELFLG_NO_CONTEXT_CHECK: u32 = 8;
pub const ALPC_CANCELFLGP_FLUSH: u32 = 65536;
pub const ALPC_IMPERSONATEFLG_ANONYMOUS: u32 = 1;
pub const ALPC_IMPERSONATEFLG_REQUIRE_IMPERSONATE: u32 = 2;
pub const ALPC_ATTRFLG_ALLOCATEDATTR: u32 = 536870912;
pub const ALPC_ATTRFLG_VALIDATTR: u32 = 1073741824;
pub const ALPC_ATTRFLG_KEEPRUNNINGATTR: u32 = 1610612736;
pub const PF_BOOT_CONTROL_VERSION: u32 = 1;
pub const PREFETCHER_INFORMATION_VERSION: u32 = 23;
pub const PF_PFN_PRIO_REQUEST_VERSION: u32 = 1;
pub const PF_PFN_PRIO_REQUEST_QUERY_MEMORY_LIST: u32 = 1;
pub const PF_PFN_PRIO_REQUEST_VALID_FLAGS: u32 = 1;
pub const PF_PRIVSOURCE_QUERY_REQUEST_VERSION: u32 = 8;
pub const PF_PRIVSOURCE_QUERY_REQUEST_FLAGS_QUERYWSPAGES: u32 = 1;
pub const PF_PRIVSOURCE_QUERY_REQUEST_FLAGS_QUERYCOMPRESSEDPAGES: u32 = 2;
pub const PF_PRIVSOURCE_QUERY_REQUEST_FLAGS_QUERYSKIPPAGES: u32 = 4;
pub const PF_SCENARIO_PHASE_INFO_VERSION: u32 = 4;
pub const PF_ROBUSTNESS_CONTROL_VERSION: u32 = 1;
pub const PF_MEMORY_LIST_INFO_VERSION: u32 = 1;
pub const PF_PHYSICAL_MEMORY_RANGE_INFO_V1_VERSION: u32 = 1;
pub const PF_PHYSICAL_MEMORY_RANGE_INFO_V2_VERSION: u32 = 2;
pub const PF_REPURPOSED_BY_PREFETCH_INFO_VERSION: u32 = 1;
pub const PF_VIRTUAL_QUERY_VERSION: u32 = 1;
pub const PF_MIN_WS_AGE_RATE_CONTROL_VERSION: u32 = 1;
pub const PF_DEPRIORITIZE_OLD_PAGES_VERSION: u32 = 3;
pub const PF_GPU_UTILIZATION_INFO_VERSION: u32 = 1;
pub const SUPERFETCH_INFORMATION_VERSION: u32 = 45;
pub const SystemPowerPolicyAc: u32 = 0;
pub const SystemPowerPolicyDc: u32 = 1;
pub const VerifySystemPolicyAc: u32 = 2;
pub const VerifySystemPolicyDc: u32 = 3;
pub const SystemPowerCapabilities: u32 = 4;
pub const SystemBatteryState: u32 = 5;
pub const SystemPowerStateHandler: u32 = 6;
pub const ProcessorStateHandler: u32 = 7;
pub const SystemPowerPolicyCurrent: u32 = 8;
pub const AdministratorPowerPolicy: u32 = 9;
pub const SystemReserveHiberFile: u32 = 10;
pub const ProcessorInformation: u32 = 11;
pub const SystemPowerInformation: u32 = 12;
pub const ProcessorStateHandler2: u32 = 13;
pub const LastWakeTime: u32 = 14;
pub const LastSleepTime: u32 = 15;
pub const SystemExecutionState: u32 = 16;
pub const SystemPowerStateNotifyHandler: u32 = 17;
pub const ProcessorPowerPolicyAc: u32 = 18;
pub const ProcessorPowerPolicyDc: u32 = 19;
pub const VerifyProcessorPowerPolicyAc: u32 = 20;
pub const VerifyProcessorPowerPolicyDc: u32 = 21;
pub const ProcessorPowerPolicyCurrent: u32 = 22;
pub const SystemPowerStateLogging: u32 = 23;
pub const SystemPowerLoggingEntry: u32 = 24;
pub const SetPowerSettingValue: u32 = 25;
pub const NotifyUserPowerSetting: u32 = 26;
pub const PowerInformationLevelUnused0: u32 = 27;
pub const SystemMonitorHiberBootPowerOff: u32 = 28;
pub const SystemVideoState: u32 = 29;
pub const TraceApplicationPowerMessage: u32 = 30;
pub const TraceApplicationPowerMessageEnd: u32 = 31;
pub const ProcessorPerfStates: u32 = 32;
pub const ProcessorIdleStates: u32 = 33;
pub const ProcessorCap: u32 = 34;
pub const SystemWakeSource: u32 = 35;
pub const SystemHiberFileInformation: u32 = 36;
pub const TraceServicePowerMessage: u32 = 37;
pub const ProcessorLoad: u32 = 38;
pub const PowerShutdownNotification: u32 = 39;
pub const MonitorCapabilities: u32 = 40;
pub const SessionPowerInit: u32 = 41;
pub const SessionDisplayState: u32 = 42;
pub const PowerRequestCreate: u32 = 43;
pub const PowerRequestAction: u32 = 44;
pub const GetPowerRequestList: u32 = 45;
pub const ProcessorInformationEx: u32 = 46;
pub const NotifyUserModeLegacyPowerEvent: u32 = 47;
pub const GroupPark: u32 = 48;
pub const ProcessorIdleDomains: u32 = 49;
pub const WakeTimerList: u32 = 50;
pub const SystemHiberFileSize: u32 = 51;
pub const ProcessorIdleStatesHv: u32 = 52;
pub const ProcessorPerfStatesHv: u32 = 53;
pub const ProcessorPerfCapHv: u32 = 54;
pub const ProcessorSetIdle: u32 = 55;
pub const LogicalProcessorIdling: u32 = 56;
pub const UserPresence: u32 = 57;
pub const PowerSettingNotificationName: u32 = 58;
pub const GetPowerSettingValue: u32 = 59;
pub const IdleResiliency: u32 = 60;
pub const SessionRITState: u32 = 61;
pub const SessionConnectNotification: u32 = 62;
pub const SessionPowerCleanup: u32 = 63;
pub const SessionLockState: u32 = 64;
pub const SystemHiberbootState: u32 = 65;
pub const PlatformInformation: u32 = 66;
pub const PdcInvocation: u32 = 67;
pub const MonitorInvocation: u32 = 68;
pub const FirmwareTableInformationRegistered: u32 = 69;
pub const SetShutdownSelectedTime: u32 = 70;
pub const SuspendResumeInvocation: u32 = 71;
pub const PlmPowerRequestCreate: u32 = 72;
pub const ScreenOff: u32 = 73;
pub const CsDeviceNotification: u32 = 74;
pub const PlatformRole: u32 = 75;
pub const LastResumePerformance: u32 = 76;
pub const DisplayBurst: u32 = 77;
pub const ExitLatencySamplingPercentage: u32 = 78;
pub const RegisterSpmPowerSettings: u32 = 79;
pub const PlatformIdleStates: u32 = 80;
pub const ProcessorIdleVeto: u32 = 81;
pub const PlatformIdleVeto: u32 = 82;
pub const SystemBatteryStatePrecise: u32 = 83;
pub const ThermalEvent: u32 = 84;
pub const PowerRequestActionInternal: u32 = 85;
pub const BatteryDeviceState: u32 = 86;
pub const PowerInformationInternal: u32 = 87;
pub const ThermalStandby: u32 = 88;
pub const SystemHiberFileType: u32 = 89;
pub const PhysicalPowerButtonPress: u32 = 90;
pub const QueryPotentialDripsConstraint: u32 = 91;
pub const EnergyTrackerCreate: u32 = 92;
pub const EnergyTrackerQuery: u32 = 93;
pub const UpdateBlackBoxRecorder: u32 = 94;
pub const SessionAllowExternalDmaDevices: u32 = 95;
pub const SendSuspendResumeNotification: u32 = 96;
pub const BlackBoxRecorderDirectAccessBuffer: u32 = 97;
pub const PowerInformationLevelMaximum: u32 = 98;
pub const POWER_PERF_SCALE: u32 = 100;
pub const POWER_STATE_DISABLED_TYPE_MAX: u32 = 8;
pub const POWER_REQUEST_CONTEXT_NOT_SPECIFIED: u32 = 2147483648;
pub const PROCESSOR_STATE_TYPE_PERFORMANCE: u32 = 1;
pub const PROCESSOR_STATE_TYPE_THROTTLE: u32 = 2;
pub const IDLE_STATE_FLAGS_C1_HLT: u32 = 1;
pub const IDLE_STATE_FLAGS_C1_IO_HLT: u32 = 2;
pub const IDLE_STATE_FLAGS_IO: u32 = 4;
pub const IDLE_STATE_FLAGS_MWAIT: u32 = 8;
pub const POWER_REQUEST_SUPPORTED_TYPES_V1: u32 = 3;
pub const POWER_REQUEST_SUPPORTED_TYPES_V2: u32 = 9;
pub const POWER_REQUEST_SUPPORTED_TYPES_V3: u32 = 5;
pub const POWER_REQUEST_SUPPORTED_TYPES_V4: u32 = 6;
pub const POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_VERSION: u32 = 1;
pub const REG_INIT_BOOT_SM: u32 = 0;
pub const REG_INIT_BOOT_SETUP: u32 = 1;
pub const REG_INIT_BOOT_ACCEPTED_BASE: u32 = 2;
pub const REG_INIT_BOOT_ACCEPTED_MAX: u32 = 1001;
pub const REG_MAX_KEY_VALUE_NAME_LENGTH: u32 = 32767;
pub const REG_MAX_KEY_NAME_LENGTH: u32 = 512;
pub const REG_FLAG_VOLATILE: u32 = 1;
pub const REG_FLAG_LINK: u32 = 2;
pub const REG_KEY_DONT_VIRTUALIZE: u32 = 2;
pub const REG_KEY_DONT_SILENT_FAIL: u32 = 4;
pub const REG_KEY_RECURSE_FLAG: u32 = 8;
pub const CM_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const VR_DEVICE_NAME: &[u8; 19] = b"\\Device\\VRegDriver\0";
pub const VR_FLAG_INHERIT_TRUST_CLASS: u32 = 1;
pub const VR_FLAG_WRITE_THROUGH_HIVE: u32 = 2;
pub const VR_FLAG_LOCAL_MACHINE_TRUST_CLASS: u32 = 4;
pub const VR_KEY_COMROOT: u32 = 0;
pub const VR_KEY_MACHINE_SOFTWARE: u32 = 1;
pub const VR_KEY_CONTROL_SET: u32 = 2;
pub const RTL_MEG: u32 = 1048576;
pub const RTL_IMAGE_MAX_DOS_HEADER: u32 = 268435456;
pub const RTL_HASH_ALLOCATED_HEADER: u32 = 1;
pub const RTL_HASH_RESERVED_SIGNATURE: u32 = 0;
pub const RTL_BARRIER_FLAGS_SPIN_ONLY: u32 = 1;
pub const RTL_BARRIER_FLAGS_BLOCK_ONLY: u32 = 2;
pub const RTL_BARRIER_FLAGS_NO_DELETE: u32 = 4;
pub const RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE: u32 = 1;
pub const RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING: u32 = 2;
pub const HASH_STRING_ALGORITHM_DEFAULT: u32 = 0;
pub const HASH_STRING_ALGORITHM_X65599: u32 = 1;
pub const HASH_STRING_ALGORITHM_INVALID: u32 = 4294967295;
pub const RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END: u32 = 1;
pub const RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET: u32 = 2;
pub const RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE: u32 = 4;
pub const COMPRESSION_FORMAT_LZ4: u32 = 6;
pub const COMPRESSION_FORMAT_DEFLATE: u32 = 7;
pub const COMPRESSION_FORMAT_ZLIB: u32 = 8;
pub const COMPRESSION_FORMAT_MAX: u32 = 8;
pub const COMPRESSION_ENGINE_MAX: u32 = 512;
pub const COMPRESSION_FORMAT_MASK: u32 = 255;
pub const COMPRESSION_ENGINE_MASK: u32 = 65280;
pub const COMPRESSION_FORMAT_ENGINE_MASK: u32 = 65535;
pub const RTL_USER_PROC_CURDIR_CLOSE: u32 = 2;
pub const RTL_USER_PROC_CURDIR_INHERIT: u32 = 3;
pub const RTL_MAX_DRIVE_LETTERS: u32 = 32;
pub const RTL_USER_PROC_PARAMS_NORMALIZED: u32 = 1;
pub const RTL_USER_PROC_PROFILE_USER: u32 = 2;
pub const RTL_USER_PROC_PROFILE_KERNEL: u32 = 4;
pub const RTL_USER_PROC_PROFILE_SERVER: u32 = 8;
pub const RTL_USER_PROC_RESERVE_1MB: u32 = 32;
pub const RTL_USER_PROC_RESERVE_16MB: u32 = 64;
pub const RTL_USER_PROC_CASE_SENSITIVE: u32 = 128;
pub const RTL_USER_PROC_DISABLE_HEAP_DECOMMIT: u32 = 256;
pub const RTL_USER_PROC_DLL_REDIRECTION_LOCAL: u32 = 4096;
pub const RTL_USER_PROC_APP_MANIFEST_PRESENT: u32 = 8192;
pub const RTL_USER_PROC_IMAGE_KEY_MISSING: u32 = 16384;
pub const RTL_USER_PROC_DEV_OVERRIDE_ENABLED: u32 = 32768;
pub const RTL_USER_PROC_OPTIN_PROCESS: u32 = 131072;
pub const RTL_USER_PROC_SESSION_OWNER: u32 = 262144;
pub const RTL_USER_PROC_HANDLE_USER_CALLBACK_EXCEPTIONS: u32 = 524288;
pub const RTL_USER_PROC_PROTECTED_PROCESS: u32 = 4194304;
pub const RTL_USER_PROC_SECURE_PROCESS: u32 = 2147483648;
pub const RTL_USER_PROCESS_EXTENDED_PARAMETERS_VERSION: u32 = 1;
pub const RTL_CLONE_PROCESS_FLAGS_CREATE_SUSPENDED: u32 = 1;
pub const RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES: u32 = 2;
pub const RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE: u32 = 4;
pub const RTL_PROCESS_REFLECTION_FLAGS_INHERIT_HANDLES: u32 = 2;
pub const RTL_PROCESS_REFLECTION_FLAGS_NO_SUSPEND: u32 = 4;
pub const RTL_PROCESS_REFLECTION_FLAGS_NO_SYNCHRONIZE: u32 = 8;
pub const RTL_PROCESS_REFLECTION_FLAGS_NO_CLOSE_EVENT: u32 = 16;
pub const CONTEXT_ALIGN: u32 = 16;
pub const CONTEXT_FRAME_LENGTH: u32 = 912;
pub const CONTEXT_EX_PADDING: u32 = 16;
pub const RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION: u32 = 1;
pub const RTL_DEACTIVATE_ACTIVATION_CONTEXT_FLAG_FORCE_EARLY_DEACTIVATION: u32 = 1;
pub const FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT: u32 = 1;
pub const FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS: u32 = 2;
pub const FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA: u32 = 4;
pub const RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT: u32 = 1;
pub const RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE: u32 = 2;
pub const RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS: u32 = 4;
pub const RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF: u32 = 2147483648;
pub const RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK: u32 = 1;
pub const GlobalDataIdUnknown: u32 = 0;
pub const GlobalDataIdRngSeedVersion: u32 = 1;
pub const GlobalDataIdInterruptTime: u32 = 2;
pub const GlobalDataIdTimeZoneBias: u32 = 3;
pub const GlobalDataIdImageNumberLow: u32 = 4;
pub const GlobalDataIdImageNumberHigh: u32 = 5;
pub const GlobalDataIdTimeZoneId: u32 = 6;
pub const GlobalDataIdNtMajorVersion: u32 = 7;
pub const GlobalDataIdNtMinorVersion: u32 = 8;
pub const GlobalDataIdSystemExpirationDate: u32 = 9;
pub const GlobalDataIdKdDebuggerEnabled: u32 = 10;
pub const GlobalDataIdCyclesPerYield: u32 = 11;
pub const GlobalDataIdSafeBootMode: u32 = 12;
pub const GlobalDataIdLastSystemRITEventTickCount: u32 = 13;
pub const GlobalDataIdConsoleSharedDataFlags: u32 = 14;
pub const GlobalDataIdNtSystemRootDrive: u32 = 15;
pub const GlobalDataIdQpcBypassEnabled: u32 = 16;
pub const GlobalDataIdQpcData: u32 = 17;
pub const GlobalDataIdQpcBias: u32 = 18;
pub const RTL_CREATE_ENVIRONMENT_TRANSLATE: u32 = 1;
pub const RTL_CREATE_ENVIRONMENT_TRANSLATE_FROM_OEM: u32 = 2;
pub const RTL_CREATE_ENVIRONMENT_EMPTY: u32 = 4;
pub const RtlNtdllName: &[u8; 10] = b"ntdll.dll\0";
pub const RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION: u32 = 1;
pub const RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH: u32 = 2;
pub const RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION : u32 = 4 ;
pub const IMAGE_FILE_NATIVE_MACHINE_I386: u32 = 1;
pub const IMAGE_FILE_NATIVE_MACHINE_AMD64: u32 = 2;
pub const IMAGE_FILE_NATIVE_MACHINE_ARMNT: u32 = 4;
pub const IMAGE_FILE_NATIVE_MACHINE_ARM64: u32 = 8;
pub const RTL_HEAP_SIGNATURE: u32 = 4293853166;
pub const RTL_HEAP_SEGMENT_SIGNATURE: u32 = 3723419118;
pub const SEGMENT_HEAP_PARAMETERS_VERSION: u32 = 3;
pub const SEGMENT_HEAP_FLG_USE_PAGE_HEAP: u32 = 1;
pub const SEGMENT_HEAP_FLG_NO_LFH: u32 = 2;
pub const SEGMENT_HEAP_PARAMS_VALID_FLAGS: u32 = 3;
pub const HEAP_SETTABLE_USER_VALUE: u32 = 256;
pub const HEAP_SETTABLE_USER_FLAG1: u32 = 512;
pub const HEAP_SETTABLE_USER_FLAG2: u32 = 1024;
pub const HEAP_SETTABLE_USER_FLAG3: u32 = 2048;
pub const HEAP_SETTABLE_USER_FLAGS: u32 = 3584;
pub const HEAP_CLASS_0: u32 = 0;
pub const HEAP_CLASS_1: u32 = 4096;
pub const HEAP_CLASS_2: u32 = 8192;
pub const HEAP_CLASS_3: u32 = 12288;
pub const HEAP_CLASS_4: u32 = 16384;
pub const HEAP_CLASS_5: u32 = 20480;
pub const HEAP_CLASS_6: u32 = 24576;
pub const HEAP_CLASS_7: u32 = 28672;
pub const HEAP_CLASS_8: u32 = 32768;
pub const HEAP_CLASS_MASK: u32 = 61440;
pub const HEAP_GLOBAL_TAG: u32 = 2048;
pub const HEAP_TAG_MASK: u32 = 1073479680;
pub const HEAP_USAGE_ALLOCATED_BLOCKS: u32 = 16;
pub const HEAP_USAGE_FREE_BUFFER: u32 = 8;
pub const HeapCompatibilityInformation: u32 = 0;
pub const HeapEnableTerminationOnCorruption: u32 = 1;
pub const HeapExtendedInformation: u32 = 2;
pub const HeapOptimizeResources: u32 = 3;
pub const HeapTaggingInformation: u32 = 4;
pub const HeapStackDatabase: u32 = 5;
pub const HeapMemoryLimit: u32 = 6;
pub const HeapTag: u32 = 7;
pub const HeapDetailedFailureInformation: u32 = 2147483649;
pub const HeapSetDebuggingInformation: u32 = 2147483650;
pub const HeapPerformanceCountersInformationStandardHeapVersion: u32 = 1;
pub const HeapPerformanceCountersInformationSegmentHeapVersion: u32 = 2;
pub const HeapExtendedProcessHeapInformationLevel: u32 = 1;
pub const HeapExtendedHeapInformationLevel: u32 = 2;
pub const HeapExtendedHeapRegionInformationLevel: u32 = 3;
pub const HeapExtendedHeapRangeInformationLevel: u32 = 4;
pub const HeapExtendedHeapBlockInformationLevel: u32 = 5;
pub const HeapExtendedHeapHeapPerfInformationLevel: u32 = 2147483648;
pub const HEAP_STACK_QUERY_VERSION: u32 = 2;
pub const HEAP_STACK_CONTROL_VERSION: u32 = 1;
pub const HEAP_STACK_CONTROL_FLAGS_STACKTRACE_ENABLE: u32 = 1;
pub const HEAP_STACK_CONTROL_FLAGS_STACKTRACE_DISABLE: u32 = 2;
pub const RTL_QUERY_PROCESS_MODULES: u32 = 1;
pub const RTL_QUERY_PROCESS_BACKTRACES: u32 = 2;
pub const RTL_QUERY_PROCESS_HEAP_SUMMARY: u32 = 4;
pub const RTL_QUERY_PROCESS_HEAP_TAGS: u32 = 8;
pub const RTL_QUERY_PROCESS_HEAP_ENTRIES: u32 = 16;
pub const RTL_QUERY_PROCESS_LOCKS: u32 = 32;
pub const RTL_QUERY_PROCESS_MODULES32: u32 = 64;
pub const RTL_QUERY_PROCESS_VERIFIER_OPTIONS: u32 = 128;
pub const RTL_QUERY_PROCESS_MODULESEX: u32 = 256;
pub const RTL_QUERY_PROCESS_HEAP_SEGMENTS: u32 = 512;
pub const RTL_QUERY_PROCESS_CS_OWNER: u32 = 1024;
pub const RTL_QUERY_PROCESS_NONINVASIVE: u32 = 2147483648;
pub const RTL_QUERY_PROCESS_NONINVASIVE_CS_OWNER: u32 = 2147485696;
pub const RTL_ERRORMODE_FAILCRITICALERRORS: u32 = 16;
pub const RTL_ERRORMODE_NOGPFAULTERRORBOX: u32 = 32;
pub const RTL_ERRORMODE_NOOPENFILEERRORBOX: u32 = 64;
pub const RTL_IMPORT_TABLE_HASH_REVISION: u32 = 1;
pub const SecondsToStartOf1980: u64 = 11960006400;
pub const SecondsToStartOf1970: u64 = 11644473600;
pub const RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS: u32 = 37;
pub const RTL_ATOM_MAXIMUM_NAME_LENGTH: u32 = 255;
pub const RTL_ATOM_PINNED: u32 = 1;
pub const MAX_UNICODE_STACK_BUFFER_LENGTH: u32 = 256;
pub const COMPOUND_ACE_IMPERSONATION: u32 = 1;
pub const RTL_ACQUIRE_PRIVILEGE_REVERT: u32 = 1;
pub const RTL_ACQUIRE_PRIVILEGE_PROCESS: u32 = 2;
pub const BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID: u32 = 1;
pub const RTL_REGISTRY_ABSOLUTE: u32 = 0;
pub const RTL_REGISTRY_SERVICES: u32 = 1;
pub const RTL_REGISTRY_CONTROL: u32 = 2;
pub const RTL_REGISTRY_WINDOWS_NT: u32 = 3;
pub const RTL_REGISTRY_DEVICEMAP: u32 = 4;
pub const RTL_REGISTRY_USER: u32 = 5;
pub const RTL_REGISTRY_MAXIMUM: u32 = 6;
pub const RTL_REGISTRY_HANDLE: u32 = 1073741824;
pub const RTL_REGISTRY_OPTIONAL: u32 = 2147483648;
pub const RTL_QUERY_REGISTRY_SUBKEY: u32 = 1;
pub const RTL_QUERY_REGISTRY_TOPKEY: u32 = 2;
pub const RTL_QUERY_REGISTRY_REQUIRED: u32 = 4;
pub const RTL_QUERY_REGISTRY_NOVALUE: u32 = 8;
pub const RTL_QUERY_REGISTRY_NOEXPAND: u32 = 16;
pub const RTL_QUERY_REGISTRY_DIRECT: u32 = 32;
pub const RTL_QUERY_REGISTRY_DELETE: u32 = 64;
pub const RTL_WALK_USER_MODE_STACK: u32 = 1;
pub const RTL_WALK_VALID_FLAGS: u32 = 1;
pub const RTL_STACK_WALKING_MODE_FRAMES_TO_SKIP_SHIFT: u32 = 8;
pub const ELEVATION_FLAG_TOKEN_CHECKS: u32 = 1;
pub const ELEVATION_FLAG_VIRTUALIZATION: u32 = 2;
pub const ELEVATION_FLAG_SHORTCUT_REDIR: u32 = 4;
pub const ELEVATION_FLAG_NO_SIGNATURE_CHECK: u32 = 8;
pub const RTL_UNLOAD_EVENT_TRACE_NUMBER: u32 = 64;
pub const RTL_IMAGE_MITIGATION_OPTION_STATEMASK: u32 = 3;
pub const RTL_IMAGE_MITIGATION_OPTION_FORCEMASK: u32 = 4;
pub const RTL_IMAGE_MITIGATION_OPTION_OPTIONMASK: u32 = 8;
pub const RTL_IMAGE_MITIGATION_FLAG_RESET: u32 = 1;
pub const RTL_IMAGE_MITIGATION_FLAG_REMOVE: u32 = 2;
pub const RTL_IMAGE_MITIGATION_FLAG_OSDEFAULT: u32 = 4;
pub const RTL_IMAGE_MITIGATION_FLAG_AUDIT: u32 = 8;
pub const PSM_ACTIVATION_TOKEN_PACKAGED_APPLICATION: u32 = 1;
pub const PSM_ACTIVATION_TOKEN_SHARED_ENTITY: u32 = 2;
pub const PSM_ACTIVATION_TOKEN_FULL_TRUST: u32 = 4;
pub const PSM_ACTIVATION_TOKEN_NATIVE_SERVICE: u32 = 8;
pub const PSM_ACTIVATION_TOKEN_MULTIPLE_INSTANCES_ALLOWED: u32 = 16;
pub const PSM_ACTIVATION_TOKEN_BREAKAWAY_INHIBITED: u32 = 32;
pub const PSM_ACTIVATION_TOKEN_RUNTIME_BROKER: u32 = 64;
pub const PSM_ACTIVATION_TOKEN_UNIVERSAL_CONSOLE: u32 = 512;
pub const PSM_ACTIVATION_TOKEN_WIN32ALACARTE_PROCESS: u32 = 65536;
pub const PSMP_MINIMUM_SYSAPP_CLAIM_VALUES: u32 = 2;
pub const PSMP_MAXIMUM_SYSAPP_CLAIM_VALUES: u32 = 4;
pub const WNF_STATE_KEY: u64 = 4739561890659434612;
pub const COPY_FILE_CHUNK_DUPLICATE_EXTENTS: u32 = 1;
pub const VALID_COPY_FILE_CHUNK_FLAGS: u32 = 1;
pub const IMAGE_FILE_MACHINE_CHPE_X86: u32 = 14948;
pub const IMAGE_FILE_MACHINE_ARM64EC: u32 = 42561;
pub const IMAGE_FILE_MACHINE_ARM64X: u32 = 42574;
pub const IMAGE_ARM64EC_CODE_MAP_TYPE_ARM64: u32 = 0;
pub const IMAGE_ARM64EC_CODE_MAP_TYPE_ARM64EC: u32 = 1;
pub const IMAGE_ARM64EC_CODE_MAP_TYPE_AMD64: u32 = 2;
pub const IMAGE_DVRT_ARM64X_FIXUP_TYPE_ZEROFILL: u32 = 0;
pub const IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE: u32 = 1;
pub const IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA: u32 = 2;
pub const IMAGE_DVRT_ARM64X_FIXUP_SIZE_2BYTES: u32 = 1;
pub const IMAGE_DVRT_ARM64X_FIXUP_SIZE_4BYTES: u32 = 2;
pub const IMAGE_DVRT_ARM64X_FIXUP_SIZE_8BYTES: u32 = 3;
pub const IMAGE_DYNAMIC_RELOCATION_ARM64X: u32 = 6;
pub const IMAGE_DYNAMIC_RELOCATION_MM_SHARED_USER_DATA_VA: u32 = 2147352576;
pub const IMAGE_DLLCHARACTERISTICS_EX_FORWARD_CFI_COMPAT: u32 = 64;
pub const IMAGE_DLLCHARACTERISTICS_EX_HOTPATCH_COMPATIBLE: u32 = 128;
pub const SE_MIN_WELL_KNOWN_PRIVILEGE: u32 = 2;
pub const SE_CREATE_TOKEN_PRIVILEGE: u32 = 2;
pub const SE_ASSIGNPRIMARYTOKEN_PRIVILEGE: u32 = 3;
pub const SE_LOCK_MEMORY_PRIVILEGE: u32 = 4;
pub const SE_INCREASE_QUOTA_PRIVILEGE: u32 = 5;
pub const SE_MACHINE_ACCOUNT_PRIVILEGE: u32 = 6;
pub const SE_TCB_PRIVILEGE: u32 = 7;
pub const SE_SECURITY_PRIVILEGE: u32 = 8;
pub const SE_TAKE_OWNERSHIP_PRIVILEGE: u32 = 9;
pub const SE_LOAD_DRIVER_PRIVILEGE: u32 = 10;
pub const SE_SYSTEM_PROFILE_PRIVILEGE: u32 = 11;
pub const SE_SYSTEMTIME_PRIVILEGE: u32 = 12;
pub const SE_PROF_SINGLE_PROCESS_PRIVILEGE: u32 = 13;
pub const SE_INC_BASE_PRIORITY_PRIVILEGE: u32 = 14;
pub const SE_CREATE_PAGEFILE_PRIVILEGE: u32 = 15;
pub const SE_CREATE_PERMANENT_PRIVILEGE: u32 = 16;
pub const SE_BACKUP_PRIVILEGE: u32 = 17;
pub const SE_RESTORE_PRIVILEGE: u32 = 18;
pub const SE_SHUTDOWN_PRIVILEGE: u32 = 19;
pub const SE_DEBUG_PRIVILEGE: u32 = 20;
pub const SE_AUDIT_PRIVILEGE: u32 = 21;
pub const SE_SYSTEM_ENVIRONMENT_PRIVILEGE: u32 = 22;
pub const SE_CHANGE_NOTIFY_PRIVILEGE: u32 = 23;
pub const SE_REMOTE_SHUTDOWN_PRIVILEGE: u32 = 24;
pub const SE_UNDOCK_PRIVILEGE: u32 = 25;
pub const SE_SYNC_AGENT_PRIVILEGE: u32 = 26;
pub const SE_ENABLE_DELEGATION_PRIVILEGE: u32 = 27;
pub const SE_MANAGE_VOLUME_PRIVILEGE: u32 = 28;
pub const SE_IMPERSONATE_PRIVILEGE: u32 = 29;
pub const SE_CREATE_GLOBAL_PRIVILEGE: u32 = 30;
pub const SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE: u32 = 31;
pub const SE_RELABEL_PRIVILEGE: u32 = 32;
pub const SE_INC_WORKING_SET_PRIVILEGE: u32 = 33;
pub const SE_TIME_ZONE_PRIVILEGE: u32 = 34;
pub const SE_CREATE_SYMBOLIC_LINK_PRIVILEGE: u32 = 35;
pub const SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE: u32 = 36;
pub const SE_MAX_WELL_KNOWN_PRIVILEGE: u32 = 36;
pub const TokenPrimaryGroup: u32 = 5;
pub const TokenDefaultDacl: u32 = 6;
pub const TokenSource: u32 = 7;
pub const TokenImpersonationLevel: u32 = 9;
pub const TokenStatistics: u32 = 10;
pub const TokenRestrictedSids: u32 = 11;
pub const TokenSessionId: u32 = 12;
pub const TokenGroupsAndPrivileges: u32 = 13;
pub const TokenSessionReference: u32 = 14;
pub const TokenSandBoxInert: u32 = 15;
pub const TokenAuditPolicy: u32 = 16;
pub const TokenOrigin: u32 = 17;
pub const TokenElevationType: u32 = 18;
pub const TokenLinkedToken: u32 = 19;
pub const TokenElevation: u32 = 20;
pub const TokenHasRestrictions: u32 = 21;
pub const TokenAccessInformation: u32 = 22;
pub const TokenVirtualizationAllowed: u32 = 23;
pub const TokenVirtualizationEnabled: u32 = 24;
pub const TokenIntegrityLevel: u32 = 25;
pub const TokenUIAccess: u32 = 26;
pub const TokenMandatoryPolicy: u32 = 27;
pub const TokenLogonSid: u32 = 28;
pub const TokenIsAppContainer: u32 = 29;
pub const TokenCapabilities: u32 = 30;
pub const TokenAppContainerNumber: u32 = 32;
pub const TokenUserClaimAttributes: u32 = 33;
pub const TokenDeviceClaimAttributes: u32 = 34;
pub const TokenRestrictedUserClaimAttributes: u32 = 35;
pub const TokenRestrictedDeviceClaimAttributes: u32 = 36;
pub const TokenDeviceGroups: u32 = 37;
pub const TokenRestrictedDeviceGroups: u32 = 38;
pub const TokenSecurityAttributes: u32 = 39;
pub const TokenIsRestricted: u32 = 40;
pub const TokenProcessTrustLevel: u32 = 41;
pub const TokenPrivateNameSpace: u32 = 42;
pub const TokenSingletonAttributes: u32 = 43;
pub const TokenBnoIsolation: u32 = 44;
pub const TokenChildProcessFlags: u32 = 45;
pub const TokenIsLessPrivilegedAppContainer: u32 = 46;
pub const TokenIsSandboxed: u32 = 47;
pub const TokenIsAppSilo: u32 = 48;
pub const TokenLoggingInformation: u32 = 49;
pub const MaxTokenInfoClass: u32 = 50;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64: u32 = 1;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64: u32 = 2;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING: u32 = 3;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN: u32 = 4;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_SID: u32 = 5;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN: u32 = 6;
pub const TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING: u32 = 16;
pub const TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE: u32 = 1;
pub const TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE: u32 = 2;
pub const TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY: u32 = 4;
pub const TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT: u32 = 8;
pub const TOKEN_SECURITY_ATTRIBUTE_DISABLED: u32 = 16;
pub const TOKEN_SECURITY_ATTRIBUTE_MANDATORY: u32 = 32;
pub const TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE: u32 = 64;
pub const TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS: u32 = 63;
pub const TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760;
pub const TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1;
pub const TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1;
pub const KCONTINUE_FLAG_TEST_ALERT: u32 = 1;
pub const KCONTINUE_FLAG_DELIVER_APC: u32 = 2;
pub const WOW64_SYSTEM_DIRECTORY: &[u8; 9] = b"SysWOW64\0";
pub const WOW64_SYSTEM_DIRECTORY_U: &[u8; 9] = b"SysWOW64\0";
pub const WOW64_X86_TAG: &[u8; 7] = b" (x86)\0";
pub const WOW64_X86_TAG_U: &[u8; 7] = b" (x86)\0";
pub const PAGE_SIZE_X86NT: u32 = 4096;
pub const PAGE_SHIFT_X86NT: u32 = 12;
pub const WOW64_SPLITS_PER_PAGE: u32 = 1;
pub const WOW64_CPUFLAGS_MSFT64: u32 = 1;
pub const WOW64_CPUFLAGS_SOFTWARE: u32 = 2;
pub const WOW64_CPUFLAGS_IA64: u32 = 4;
pub const SAM_MAXIMUM_LOOKUP_COUNT: u32 = 1000;
pub const SAM_MAXIMUM_LOOKUP_LENGTH: u32 = 32000;
pub const SAM_MAX_PASSWORD_LENGTH: u32 = 256;
pub const SAM_PASSWORD_ENCRYPTION_SALT_LEN: u32 = 16;
pub const SAM_SERVER_CONNECT: u32 = 1;
pub const SAM_SERVER_SHUTDOWN: u32 = 2;
pub const SAM_SERVER_INITIALIZE: u32 = 4;
pub const SAM_SERVER_CREATE_DOMAIN: u32 = 8;
pub const SAM_SERVER_ENUMERATE_DOMAINS: u32 = 16;
pub const SAM_SERVER_LOOKUP_DOMAIN: u32 = 32;
pub const SAM_SERVER_ALL_ACCESS: u32 = 983103;
pub const SAM_SERVER_READ: u32 = 131088;
pub const SAM_SERVER_WRITE: u32 = 131086;
pub const SAM_SERVER_EXECUTE: u32 = 131105;
pub const DOMAIN_READ_PASSWORD_PARAMETERS: u32 = 1;
pub const DOMAIN_WRITE_PASSWORD_PARAMS: u32 = 2;
pub const DOMAIN_READ_OTHER_PARAMETERS: u32 = 4;
pub const DOMAIN_WRITE_OTHER_PARAMETERS: u32 = 8;
pub const DOMAIN_CREATE_USER: u32 = 16;
pub const DOMAIN_CREATE_GROUP: u32 = 32;
pub const DOMAIN_CREATE_ALIAS: u32 = 64;
pub const DOMAIN_GET_ALIAS_MEMBERSHIP: u32 = 128;
pub const DOMAIN_LIST_ACCOUNTS: u32 = 256;
pub const DOMAIN_LOOKUP: u32 = 512;
pub const DOMAIN_ADMINISTER_SERVER: u32 = 1024;
pub const DOMAIN_ALL_ACCESS: u32 = 985087;
pub const DOMAIN_READ: u32 = 131204;
pub const DOMAIN_WRITE: u32 = 132218;
pub const DOMAIN_EXECUTE: u32 = 131841;
pub const DOMAIN_PASSWORD_COMPLEX: u32 = 1;
pub const DOMAIN_PASSWORD_NO_ANON_CHANGE: u32 = 2;
pub const DOMAIN_PASSWORD_NO_CLEAR_CHANGE: u32 = 4;
pub const DOMAIN_LOCKOUT_ADMINS: u32 = 8;
pub const DOMAIN_PASSWORD_STORE_CLEARTEXT: u32 = 16;
pub const DOMAIN_REFUSE_PASSWORD_CHANGE: u32 = 32;
pub const DOMAIN_NO_LM_OWF_CHANGE: u32 = 64;
pub const GROUP_READ_INFORMATION: u32 = 1;
pub const GROUP_WRITE_ACCOUNT: u32 = 2;
pub const GROUP_ADD_MEMBER: u32 = 4;
pub const GROUP_REMOVE_MEMBER: u32 = 8;
pub const GROUP_LIST_MEMBERS: u32 = 16;
pub const GROUP_ALL_ACCESS: u32 = 983071;
pub const GROUP_READ: u32 = 131088;
pub const GROUP_WRITE: u32 = 131086;
pub const GROUP_EXECUTE: u32 = 131073;
pub const ALIAS_ADD_MEMBER: u32 = 1;
pub const ALIAS_REMOVE_MEMBER: u32 = 2;
pub const ALIAS_LIST_MEMBERS: u32 = 4;
pub const ALIAS_READ_INFORMATION: u32 = 8;
pub const ALIAS_WRITE_ACCOUNT: u32 = 16;
pub const ALIAS_ALL_ACCESS: u32 = 983071;
pub const ALIAS_READ: u32 = 131076;
pub const ALIAS_WRITE: u32 = 131091;
pub const ALIAS_EXECUTE: u32 = 131080;
pub const ALIAS_ALL_NAME: u32 = 1;
pub const ALIAS_ALL_MEMBER_COUNT: u32 = 2;
pub const ALIAS_ALL_ADMIN_COMMENT: u32 = 4;
pub const ALIAS_ALL_SHELL_ADMIN_OBJECT_PROPERTIES: u32 = 8;
pub const GROUP_TYPE_BUILTIN_LOCAL_GROUP: u32 = 1;
pub const GROUP_TYPE_ACCOUNT_GROUP: u32 = 2;
pub const GROUP_TYPE_RESOURCE_GROUP: u32 = 4;
pub const GROUP_TYPE_UNIVERSAL_GROUP: u32 = 8;
pub const GROUP_TYPE_APP_BASIC_GROUP: u32 = 16;
pub const GROUP_TYPE_APP_QUERY_GROUP: u32 = 32;
pub const GROUP_TYPE_SECURITY_ENABLED: u32 = 2147483648;
pub const GROUP_TYPE_RESOURCE_BEHAVOIR: u32 = 52;
pub const USER_READ_GENERAL: u32 = 1;
pub const USER_READ_PREFERENCES: u32 = 2;
pub const USER_WRITE_PREFERENCES: u32 = 4;
pub const USER_READ_LOGON: u32 = 8;
pub const USER_READ_ACCOUNT: u32 = 16;
pub const USER_WRITE_ACCOUNT: u32 = 32;
pub const USER_CHANGE_PASSWORD: u32 = 64;
pub const USER_FORCE_PASSWORD_CHANGE: u32 = 128;
pub const USER_LIST_GROUPS: u32 = 256;
pub const USER_READ_GROUP_INFORMATION: u32 = 512;
pub const USER_WRITE_GROUP_INFORMATION: u32 = 1024;
pub const USER_ALL_ACCESS: u32 = 985087;
pub const USER_READ: u32 = 131866;
pub const USER_WRITE: u32 = 131140;
pub const USER_EXECUTE: u32 = 131137;
pub const USER_ACCOUNT_DISABLED: u32 = 1;
pub const USER_HOME_DIRECTORY_REQUIRED: u32 = 2;
pub const USER_PASSWORD_NOT_REQUIRED: u32 = 4;
pub const USER_TEMP_DUPLICATE_ACCOUNT: u32 = 8;
pub const USER_NORMAL_ACCOUNT: u32 = 16;
pub const USER_MNS_LOGON_ACCOUNT: u32 = 32;
pub const USER_INTERDOMAIN_TRUST_ACCOUNT: u32 = 64;
pub const USER_WORKSTATION_TRUST_ACCOUNT: u32 = 128;
pub const USER_SERVER_TRUST_ACCOUNT: u32 = 256;
pub const USER_DONT_EXPIRE_PASSWORD: u32 = 512;
pub const USER_ACCOUNT_AUTO_LOCKED: u32 = 1024;
pub const USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED: u32 = 2048;
pub const USER_SMARTCARD_REQUIRED: u32 = 4096;
pub const USER_TRUSTED_FOR_DELEGATION: u32 = 8192;
pub const USER_NOT_DELEGATED: u32 = 16384;
pub const USER_USE_DES_KEY_ONLY: u32 = 32768;
pub const USER_DONT_REQUIRE_PREAUTH: u32 = 65536;
pub const USER_PASSWORD_EXPIRED: u32 = 131072;
pub const USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION: u32 = 262144;
pub const USER_NO_AUTH_DATA_REQUIRED: u32 = 524288;
pub const USER_PARTIAL_SECRETS_ACCOUNT: u32 = 1048576;
pub const USER_USE_AES_KEYS: u32 = 2097152;
pub const NEXT_FREE_ACCOUNT_CONTROL_BIT: u32 = 4194304;
pub const USER_MACHINE_ACCOUNT_MASK: u32 = 448;
pub const USER_ACCOUNT_TYPE_MASK: u32 = 472;
pub const USER_COMPUTED_ACCOUNT_CONTROL_BITS: u32 = 132096;
pub const SAM_DAYS_PER_WEEK: u32 = 7;
pub const SAM_HOURS_PER_WEEK: u32 = 168;
pub const SAM_MINUTES_PER_WEEK: u32 = 10080;
pub const CYPHER_BLOCK_LENGTH: u32 = 8;
pub const USER_ALL_USERNAME: u32 = 1;
pub const USER_ALL_FULLNAME: u32 = 2;
pub const USER_ALL_USERID: u32 = 4;
pub const USER_ALL_PRIMARYGROUPID: u32 = 8;
pub const USER_ALL_ADMINCOMMENT: u32 = 16;
pub const USER_ALL_USERCOMMENT: u32 = 32;
pub const USER_ALL_HOMEDIRECTORY: u32 = 64;
pub const USER_ALL_HOMEDIRECTORYDRIVE: u32 = 128;
pub const USER_ALL_SCRIPTPATH: u32 = 256;
pub const USER_ALL_PROFILEPATH: u32 = 512;
pub const USER_ALL_WORKSTATIONS: u32 = 1024;
pub const USER_ALL_LASTLOGON: u32 = 2048;
pub const USER_ALL_LASTLOGOFF: u32 = 4096;
pub const USER_ALL_LOGONHOURS: u32 = 8192;
pub const USER_ALL_BADPASSWORDCOUNT: u32 = 16384;
pub const USER_ALL_LOGONCOUNT: u32 = 32768;
pub const USER_ALL_PASSWORDCANCHANGE: u32 = 65536;
pub const USER_ALL_PASSWORDMUSTCHANGE: u32 = 131072;
pub const USER_ALL_PASSWORDLASTSET: u32 = 262144;
pub const USER_ALL_ACCOUNTEXPIRES: u32 = 524288;
pub const USER_ALL_USERACCOUNTCONTROL: u32 = 1048576;
pub const USER_ALL_PARAMETERS: u32 = 2097152;
pub const USER_ALL_COUNTRYCODE: u32 = 4194304;
pub const USER_ALL_CODEPAGE: u32 = 8388608;
pub const USER_ALL_NTPASSWORDPRESENT: u32 = 16777216;
pub const USER_ALL_LMPASSWORDPRESENT: u32 = 33554432;
pub const USER_ALL_PRIVATEDATA: u32 = 67108864;
pub const USER_ALL_PASSWORDEXPIRED: u32 = 134217728;
pub const USER_ALL_SECURITYDESCRIPTOR: u32 = 268435456;
pub const USER_ALL_OWFPASSWORD: u32 = 536870912;
pub const USER_ALL_UNDEFINED_MASK: u32 = 3221225472;
pub const USER_ALL_READ_GENERAL_MASK: u32 = 63;
pub const USER_ALL_READ_LOGON_MASK: u32 = 262080;
pub const USER_ALL_READ_ACCOUNT_MASK: u32 = 3932160;
pub const USER_ALL_READ_PREFERENCES_MASK: u32 = 12582912;
pub const USER_ALL_READ_TRUSTED_MASK: u32 = 520093696;
pub const USER_ALL_READ_CANT_MASK: u32 = 3221225472;
pub const USER_ALL_WRITE_ACCOUNT_MASK: u32 = 3680219;
pub const USER_ALL_WRITE_PREFERENCES_MASK: u32 = 12582944;
pub const USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK: u32 = 184549376;
pub const USER_ALL_WRITE_TRUSTED_MASK: u32 = 335861760;
pub const USER_ALL_WRITE_CANT_MASK: u32 = 3221422084;
pub const USER_EXTENDED_FIELD_UPN: u32 = 1;
pub const USER_EXTENDED_FIELD_A2D2: u32 = 2;
pub const USER_EXTENDED_FIELD_USER_TILE: u32 = 4096;
pub const USER_EXTENDED_FIELD_PASSWORD_HINT: u32 = 8192;
pub const USER_EXTENDED_FIELD_DONT_SHOW_IN_LOGON_UI: u32 = 16384;
pub const USER_EXTENDED_FIELD_SHELL_ADMIN_OBJECT_PROPERTIES: u32 = 32768;
pub const SAM_PWD_CHANGE_NO_ERROR: u32 = 0;
pub const SAM_PWD_CHANGE_PASSWORD_TOO_SHORT: u32 = 1;
pub const SAM_PWD_CHANGE_PWD_IN_HISTORY: u32 = 2;
pub const SAM_PWD_CHANGE_USERNAME_IN_PASSWORD: u32 = 3;
pub const SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD: u32 = 4;
pub const SAM_PWD_CHANGE_NOT_COMPLEX: u32 = 5;
pub const SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT: u32 = 6;
pub const SAM_PWD_CHANGE_FAILED_BY_FILTER: u32 = 7;
pub const SAM_PWD_CHANGE_PASSWORD_TOO_LONG: u32 = 8;
pub const SAM_PWD_CHANGE_FAILURE_REASON_MAX: u32 = 8;
pub const SAM_USER_ACCOUNT: u32 = 1;
pub const SAM_GLOBAL_GROUP_ACCOUNT: u32 = 2;
pub const SAM_LOCAL_GROUP_ACCOUNT: u32 = 4;
pub const SAM_DELTA_NOTIFY_ROUTINE: &[u8; 12] = b"DeltaNotify\0";
pub const SAM_SID_COMPATIBILITY_ALL: u32 = 0;
pub const SAM_SID_COMPATIBILITY_LAX: u32 = 1;
pub const SAM_SID_COMPATIBILITY_STRICT: u32 = 2;
pub const SAM_VALIDATE_PASSWORD_LAST_SET: u32 = 1;
pub const SAM_VALIDATE_BAD_PASSWORD_TIME: u32 = 2;
pub const SAM_VALIDATE_LOCKOUT_TIME: u32 = 4;
pub const SAM_VALIDATE_BAD_PASSWORD_COUNT: u32 = 8;
pub const SAM_VALIDATE_PASSWORD_HISTORY_LENGTH: u32 = 16;
pub const SAM_VALIDATE_PASSWORD_HISTORY: u32 = 32;
pub const FLT_PORT_CONNECT: u32 = 1;
pub const FLT_PORT_ALL_ACCESS: u32 = 2031617;
pub const MIN_ETW_BUFFER_SIZE: u32 = 1;
pub const MAX_ETW_BUFFER_SIZE: u32 = 16384;
pub const MAX_ETW_BUFFER_SIZE_WIN7: u32 = 1024;
pub const MAX_ETW_EVENT_SIZE: u32 = 65535;
pub const ETW_KERNEL_RUNDOWN_START: u32 = 1;
pub const ETW_KERNEL_RUNDOWN_STOP: u32 = 2;
pub const ETW_CKCL_RUNDOWN_START: u32 = 4;
pub const ETW_CKCL_RUNDOWN_STOP: u32 = 8;
pub const ETW_FILENAME_RUNDOWN: u32 = 16;
pub const DEFAULT_TRACE_ALIGNMENT: u32 = 8;
pub const EVENT_TRACE_GROUP_HEADER: u32 = 0;
pub const EVENT_TRACE_GROUP_IO: u32 = 256;
pub const EVENT_TRACE_GROUP_MEMORY: u32 = 512;
pub const EVENT_TRACE_GROUP_PROCESS: u32 = 768;
pub const EVENT_TRACE_GROUP_FILE: u32 = 1024;
pub const EVENT_TRACE_GROUP_THREAD: u32 = 1280;
pub const EVENT_TRACE_GROUP_TCPIP: u32 = 1536;
pub const EVENT_TRACE_GROUP_JOB: u32 = 1792;
pub const EVENT_TRACE_GROUP_UDPIP: u32 = 2048;
pub const EVENT_TRACE_GROUP_REGISTRY: u32 = 2304;
pub const EVENT_TRACE_GROUP_DBGPRINT: u32 = 2560;
pub const EVENT_TRACE_GROUP_CONFIG: u32 = 2816;
pub const EVENT_TRACE_GROUP_SPARE1: u32 = 3072;
pub const EVENT_TRACE_GROUP_WNF: u32 = 3328;
pub const EVENT_TRACE_GROUP_POOL: u32 = 3584;
pub const EVENT_TRACE_GROUP_PERFINFO: u32 = 3840;
pub const EVENT_TRACE_GROUP_HEAP: u32 = 4096;
pub const EVENT_TRACE_GROUP_OBJECT: u32 = 4352;
pub const EVENT_TRACE_GROUP_POWER: u32 = 4608;
pub const EVENT_TRACE_GROUP_MODBOUND: u32 = 4864;
pub const EVENT_TRACE_GROUP_IMAGE: u32 = 5120;
pub const EVENT_TRACE_GROUP_DPC: u32 = 5376;
pub const EVENT_TRACE_GROUP_CC: u32 = 5632;
pub const EVENT_TRACE_GROUP_CRITSEC: u32 = 5888;
pub const EVENT_TRACE_GROUP_STACKWALK: u32 = 6144;
pub const EVENT_TRACE_GROUP_UMS: u32 = 6400;
pub const EVENT_TRACE_GROUP_ALPC: u32 = 6656;
pub const EVENT_TRACE_GROUP_SPLITIO: u32 = 6912;
pub const EVENT_TRACE_GROUP_THREAD_POOL: u32 = 7168;
pub const EVENT_TRACE_GROUP_HYPERVISOR: u32 = 7424;
pub const EVENT_TRACE_GROUP_HYPERVISORX: u32 = 7680;
pub const MAX_KERNEL_TRACE_EVENTS: u32 = 31;
pub const TRACE_HEADER_FLAG: u32 = 2147483648;
pub const TRACE_MESSAGE: u32 = 268435456;
pub const TRACE_HEADER_ULONG32_TIME: u32 = 2952790016;
pub const TRACE_HEADER_EVENT_TRACE: u32 = 1073741824;
pub const TRACE_HEADER_ENUM_MASK: u32 = 16711680;
pub const TRACE_HEADER_TYPE_SYSTEM32: u32 = 1;
pub const TRACE_HEADER_TYPE_SYSTEM64: u32 = 2;
pub const TRACE_HEADER_TYPE_COMPACT32: u32 = 3;
pub const TRACE_HEADER_TYPE_COMPACT64: u32 = 4;
pub const TRACE_HEADER_TYPE_FULL_HEADER32: u32 = 10;
pub const TRACE_HEADER_TYPE_INSTANCE32: u32 = 11;
pub const TRACE_HEADER_TYPE_TIMED: u32 = 12;
pub const TRACE_HEADER_TYPE_ERROR: u32 = 13;
pub const TRACE_HEADER_TYPE_WNODE_HEADER: u32 = 14;
pub const TRACE_HEADER_TYPE_MESSAGE: u32 = 15;
pub const TRACE_HEADER_TYPE_PERFINFO32: u32 = 16;
pub const TRACE_HEADER_TYPE_PERFINFO64: u32 = 17;
pub const TRACE_HEADER_TYPE_EVENT_HEADER32: u32 = 18;
pub const TRACE_HEADER_TYPE_EVENT_HEADER64: u32 = 19;
pub const TRACE_HEADER_TYPE_FULL_HEADER64: u32 = 20;
pub const TRACE_HEADER_TYPE_INSTANCE64: u32 = 21;
pub const EVENT_HEADER_SIZE_MASK: u32 = 65535;
pub const SYSTEM_TRACE_VERSION: u32 = 2;
pub const TRACE_VERSION_MAJOR_WIN7: u32 = 1;
pub const TRACE_VERSION_MINOR_WIN7: u32 = 5;
pub const TRACE_VERSION_MAJOR: u32 = 2;
pub const TRACE_VERSION_MINOR: u32 = 0;
pub const SYSTEM_TRACE_MARKER32: u32 = 3221291008;
pub const SYSTEM_TRACE_MARKER64: u32 = 3221356544;
pub const COMPACT_TRACE_MARKER32: u32 = 3221422080;
pub const COMPACT_TRACE_MARKER64: u32 = 3221487616;
pub const PERFINFO_TRACE_MARKER32: u32 = 3222274048;
pub const PERFINFO_TRACE_MARKER64: u32 = 3222339584;
pub const TRACE_HEADER_PEBS_INDEX_FLAG: u32 = 32768;
pub const TRACE_HEADER_SPARE_FLAG1: u32 = 16384;
pub const TRACE_HEADER_SPARE_FLAG2: u32 = 8192;
pub const TRACE_HEADER_SPARE_FLAG3: u32 = 4096;
pub const TRACE_HEADER_SPARE_FLAG4: u32 = 2048;
pub const TRACE_HEADER_PMC_COUNTERS_MASK: u32 = 1792;
pub const TRACE_HEADER_PMC_COUNTERS_SHIFT: u32 = 8;
pub const TRACE_HEADER_EXT_ITEMS_MASK: u32 = 34560;
pub const SYSTEM_TRACE_MARKER: u32 = 3221356544;
pub const COMPACT_TRACE_MARKER: u32 = 3221487616;
pub const PERFINFO_TRACE_MARKER: u32 = 3222339584;
pub const MAXLOGGERS: u32 = 64;
pub const EVENT_TRACE_CLOCK_RAW: u32 = 0;
pub const EVENT_TRACE_CLOCK_PERFCOUNTER: u32 = 1;
pub const EVENT_TRACE_CLOCK_SYSTEMTIME: u32 = 2;
pub const EVENT_TRACE_CLOCK_CPUCYCLE: u32 = 3;
pub const EVENT_TRACE_CLOCK_MAX: u32 = 4;
pub const EVENT_TRACE_KD_FILTER_MODE: u32 = 524288;
pub const EVENT_TRACE_BUFFER_INTERFACE_MODE: u32 = 262144;
pub const EVENT_TRACE_USE_MS_FLUSH_TIMER: u32 = 16;
pub const EVENT_TRACE_BLOCKING_MODE: u32 = 536870912;
pub const EVENT_TRACE_REALTIME_RELOG_MODE: u32 = 1048576;
pub const EVENT_TRACE_LOST_EVENTS_DEBUG_MODE: u32 = 2097152;
pub const TRACE_MESSAGE_USERMODE: u32 = 64;
pub const TRACE_MESSAGE_WOW: u32 = 128;
pub const ETW_BUFFER_TYPE_GENERIC: u32 = 0;
pub const ETW_BUFFER_TYPE_RUNDOWN: u32 = 1;
pub const ETW_BUFFER_TYPE_CTX_SWAP: u32 = 2;
pub const ETW_BUFFER_TYPE_REFTIME: u32 = 3;
pub const ETW_BUFFER_TYPE_HEADER: u32 = 4;
pub const ETW_BUFFER_TYPE_BATCHED: u32 = 5;
pub const ETW_BUFFER_TYPE_EMPTY_MARKER: u32 = 6;
pub const ETW_BUFFER_TYPE_DBG_INFO: u32 = 7;
pub const ETW_BUFFER_TYPE_MAXIMUM: u32 = 8;
pub const ETW_BUFFER_FLAG_NORMAL: u32 = 0;
pub const ETW_BUFFER_FLAG_FLUSH_MARKER: u32 = 1;
pub const ETW_BUFFER_FLAG_EVENTS_LOST: u32 = 2;
pub const ETW_BUFFER_FLAG_BUFFER_LOST: u32 = 4;
pub const ETW_BUFFER_FLAG_RTBACKUP_CORRUPT: u32 = 8;
pub const ETW_BUFFER_FLAG_RTBACKUP: u32 = 16;
pub const ETW_BUFFER_FLAG_PROC_INDEX: u32 = 32;
pub const ETW_BUFFER_FLAG_COMPRESSED: u32 = 64;
pub const ETW_PROCESSOR_INDEX_MASK: u32 = 2047;
pub const ETW_RT_LOSS_EVENT: u32 = 32;
pub const ETW_RT_LOSS_BUFFER: u32 = 33;
pub const ETW_RT_LOSS_BACKUP: u32 = 34;
pub const EVENT_TRACE_FLAG_EXT_ITEMS: u32 = 2164195328;
pub const EVENT_TRACE_FLAG_EXT_LEN_NEW_STRUCT: u32 = 255;
pub const ETW_MINIMUM_CACHED_STACK_LENGTH: u32 = 4;
pub const ETW_SW_ARRAY_SIZE: u32 = 256;
pub const ETW_STACK_SW_ARRAY_SIZE: u32 = 192;
pub const ETW_MAX_STACKWALK_FILTER: u32 = 256;
pub const ETW_MAX_TAG_FILTER: u32 = 4;
pub const ETW_MAX_POOLTAG_FILTER: u32 = 4;
pub const ETW_EXT_ENABLE_FLAGS: u32 = 1;
pub const ETW_EXT_PIDS: u32 = 2;
pub const ETW_EXT_STACKWALK_FILTER: u32 = 3;
pub const ETW_EXT_POOLTAG_FILTER: u32 = 4;
pub const ETW_EXT_STACK_CACHING: u32 = 5;
pub const PERF_MASK_INDEX: u32 = 3758096384;
pub const PERF_MASK_GROUP: i64 = -3758096385;
pub const PERF_NUM_MASKS: u32 = 8;
pub const PERF_REGISTRY: u32 = 131072;
pub const PERF_HARD_FAULTS: u32 = 8192;
pub const PERF_JOB: u32 = 524288;
pub const PERF_PROC_THREAD: u32 = 3;
pub const PERF_PROCESS: u32 = 1;
pub const PERF_THREAD: u32 = 2;
pub const PERF_DISK_IO: u32 = 768;
pub const PERF_DISK_IO_INIT: u32 = 1024;
pub const PERF_LOADER: u32 = 4;
pub const PERF_ALL_FAULTS: u32 = 4096;
pub const PERF_FILENAME: u32 = 512;
pub const PERF_NETWORK: u32 = 65536;
pub const PERF_ALPC: u32 = 1048576;
pub const PERF_SPLIT_IO: u32 = 2097152;
pub const PERF_PERF_COUNTER: u32 = 8;
pub const PERF_FILE_IO: u32 = 33554432;
pub const PERF_FILE_IO_INIT: u32 = 67108864;
pub const PERF_DBGPRINT: u32 = 262144;
pub const PERF_NO_SYSCONFIG: u32 = 268435456;
pub const PERF_VAMAP: u32 = 32768;
pub const PERF_DEBUG_EVENTS: u32 = 4194304;
pub const PERF_MEMORY: u32 = 536870913;
pub const PERF_PROFILE: u32 = 536870914;
pub const PERF_CONTEXT_SWITCH: u32 = 536870916;
pub const PERF_FOOTPRINT: u32 = 536870920;
pub const PERF_DRIVERS: u32 = 536870928;
pub const PERF_REFSET: u32 = 536870944;
pub const PERF_POOL: u32 = 536870976;
pub const PERF_POOLTRACE: u32 = 536870977;
pub const PERF_DPC: u32 = 536871040;
pub const PERF_COMPACT_CSWITCH: u32 = 536871168;
pub const PERF_DISPATCHER: u32 = 536871424;
pub const PERF_PMC_PROFILE: u32 = 536871936;
pub const PERF_PROFILING: u32 = 536871938;
pub const PERF_PROCESS_INSWAP: u32 = 536872960;
pub const PERF_AFFINITY: u32 = 536875008;
pub const PERF_PRIORITY: u32 = 536879104;
pub const PERF_INTERRUPT: u32 = 536887296;
pub const PERF_VIRTUAL_ALLOC: u32 = 536903680;
pub const PERF_SPINLOCK: u32 = 536936448;
pub const PERF_SYNC_OBJECTS: u32 = 537001984;
pub const PERF_DPC_QUEUE: u32 = 537133056;
pub const PERF_MEMINFO: u32 = 537395200;
pub const PERF_CONTMEM_GEN: u32 = 537919488;
pub const PERF_SPINLOCK_CNTRS: u32 = 538968064;
pub const PERF_SPININSTR: u32 = 539033600;
pub const PERF_SESSION: u32 = 541065216;
pub const PERF_PFSECTION: u32 = 541065216;
pub const PERF_MEMINFO_WS: u32 = 545259520;
pub const PERF_KERNEL_QUEUE: u32 = 553648128;
pub const PERF_INTERRUPT_STEER: u32 = 570425344;
pub const PERF_SHOULD_YIELD: u32 = 603979776;
pub const PERF_WS: u32 = 671088640;
pub const PERF_ANTI_STARVATION: u32 = 1073741825;
pub const PERF_PROCESS_FREEZE: u32 = 1073741826;
pub const PERF_PFN_LIST: u32 = 1073741828;
pub const PERF_WS_DETAIL: u32 = 1073741832;
pub const PERF_WS_ENTRY: u32 = 1073741840;
pub const PERF_HEAP: u32 = 1073741856;
pub const PERF_SYSCALL: u32 = 1073741888;
pub const PERF_UMS: u32 = 1073741952;
pub const PERF_BACKTRACE: u32 = 1073742080;
pub const PERF_VULCAN: u32 = 1073742336;
pub const PERF_OBJECTS: u32 = 1073742848;
pub const PERF_EVENTS: u32 = 1073743872;
pub const PERF_FULLTRACE: u32 = 1073745920;
pub const PERF_DFSS: u32 = 1073750016;
pub const PERF_PREFETCH: u32 = 1073758208;
pub const PERF_PROCESSOR_IDLE: u32 = 1073774592;
pub const PERF_CPU_CONFIG: u32 = 1073807360;
pub const PERF_TIMER: u32 = 1073872896;
pub const PERF_CLOCK_INTERRUPT: u32 = 1074003968;
pub const PERF_LOAD_BALANCER: u32 = 1074266112;
pub const PERF_CLOCK_TIMER: u32 = 1074790400;
pub const PERF_IDLE_SELECTION: u32 = 1075838976;
pub const PERF_IPI: u32 = 1077936128;
pub const PERF_IO_TIMER: u32 = 1082130432;
pub const PERF_REG_HIVE: u32 = 1090519040;
pub const PERF_REG_NOTIF: u32 = 1107296256;
pub const PERF_PPM_EXIT_LATENCY: u32 = 1140850688;
pub const PERF_WORKER_THREAD: u32 = 1207959552;
pub const PERF_OPTICAL_IO: u32 = 2147483649;
pub const PERF_OPTICAL_IO_INIT: u32 = 2147483650;
pub const PERF_DLL_INFO: u32 = 2147483656;
pub const PERF_DLL_FLUSH_WS: u32 = 2147483664;
pub const PERF_OB_HANDLE: u32 = 2147483712;
pub const PERF_OB_OBJECT: u32 = 2147483776;
pub const PERF_WAKE_DROP: u32 = 2147484160;
pub const PERF_WAKE_EVENT: u32 = 2147484672;
pub const PERF_DEBUGGER: u32 = 2147485696;
pub const PERF_PROC_ATTACH: u32 = 2147487744;
pub const PERF_WAKE_COUNTER: u32 = 2147491840;
pub const PERF_POWER: u32 = 2147516416;
pub const PERF_SOFT_TRIM: u32 = 2147549184;
pub const PERF_CC: u32 = 2147614720;
pub const PERF_FLT_IO_INIT: u32 = 2148007936;
pub const PERF_FLT_IO: u32 = 2148532224;
pub const PERF_FLT_FASTIO: u32 = 2149580800;
pub const PERF_FLT_IO_FAILURE: u32 = 2151677952;
pub const PERF_HV_PROFILE: u32 = 2155872256;
pub const PERF_WDF_DPC: u32 = 2164260864;
pub const PERF_WDF_INTERRUPT: u32 = 2181038080;
pub const PERF_CACHE_FLUSH: u32 = 2214592512;
pub const PERF_HIBER_RUNDOWN: u32 = 2684354561;
pub const PERF_SYSCFG_SYSTEM: u32 = 3221225473;
pub const PERF_SYSCFG_GRAPHICS: u32 = 3221225474;
pub const PERF_SYSCFG_STORAGE: u32 = 3221225476;
pub const PERF_SYSCFG_NETWORK: u32 = 3221225480;
pub const PERF_SYSCFG_SERVICES: u32 = 3221225488;
pub const PERF_SYSCFG_PNP: u32 = 3221225504;
pub const PERF_SYSCFG_OPTICAL: u32 = 3221225536;
pub const PERF_SYSCFG_ALL: u32 = 3758096383;
pub const PERF_CLUSTER_OFF: u32 = 3758096385;
pub const PERF_MEMORY_CONTROL: u32 = 3758096386;
pub const WMI_LOG_TYPE_HEADER: u32 = 0;
pub const WMI_LOG_TYPE_HEADER_EXTENSION: u32 = 5;
pub const WMI_LOG_TYPE_RUNDOWN_COMPLETE: u32 = 8;
pub const WMI_LOG_TYPE_GROUP_MASKS_END: u32 = 32;
pub const WMI_LOG_TYPE_RUNDOWN_BEGIN: u32 = 48;
pub const WMI_LOG_TYPE_RUNDOWN_END: u32 = 49;
pub const WMI_LOG_TYPE_DBGID_RSDS: u32 = 64;
pub const WMI_LOG_TYPE_DBGID_NB10: u32 = 65;
pub const WMI_LOG_TYPE_BUILD_LAB: u32 = 66;
pub const WMI_LOG_TYPE_BINARY_PATH: u32 = 67;
pub const WMI_LOG_TYPE_CONFIG_CPU: u32 = 2826;
pub const WMI_LOG_TYPE_CONFIG_PHYSICALDISK: u32 = 2827;
pub const WMI_LOG_TYPE_CONFIG_LOGICALDISK: u32 = 2828;
pub const WMI_LOG_TYPE_CONFIG_OPTICALMEDIA: u32 = 2834;
pub const WMI_LOG_TYPE_CONFIG_NIC: u32 = 2829;
pub const WMI_LOG_TYPE_CONFIG_VIDEO: u32 = 2830;
pub const WMI_LOG_TYPE_CONFIG_SERVICES: u32 = 2831;
pub const WMI_LOG_TYPE_CONFIG_POWER: u32 = 2832;
pub const WMI_LOG_TYPE_CONFIG_IRQ: u32 = 2837;
pub const WMI_LOG_TYPE_CONFIG_PNP: u32 = 2838;
pub const WMI_LOG_TYPE_CONFIG_IDECHANNEL: u32 = 2839;
pub const WMI_LOG_TYPE_CONFIG_NUMANODE: u32 = 2840;
pub const WMI_LOG_TYPE_CONFIG_PLATFORM: u32 = 2841;
pub const WMI_LOG_TYPE_CONFIG_PROCESSORGROUP: u32 = 2842;
pub const WMI_LOG_TYPE_CONFIG_PROCESSORNUMBER: u32 = 2843;
pub const WMI_LOG_TYPE_CONFIG_DPI: u32 = 2844;
pub const WMI_LOG_TYPE_CONFIG_CODEINTEGRITY: u32 = 2845;
pub const WMI_LOG_TYPE_CONFIG_MACHINEID: u32 = 2846;
pub const PERFINFO_LOG_TYPE_FILENAME: u32 = 1024;
pub const PERFINFO_LOG_TYPE_FILENAME_CREATE: u32 = 1056;
pub const PERFINFO_LOG_TYPE_FILENAME_SAME: u32 = 1057;
pub const PERFINFO_LOG_TYPE_FILENAME_NULL: u32 = 1058;
pub const PERFINFO_LOG_TYPE_FILENAME_DELETE: u32 = 1059;
pub const PERFINFO_LOG_TYPE_FILENAME_RUNDOWN: u32 = 1060;
pub const PERFINFO_LOG_TYPE_MAPFILE: u32 = 1061;
pub const PERFINFO_LOG_TYPE_UNMAPFILE: u32 = 1062;
pub const PERFINFO_LOG_TYPE_MAPFILE_DC_START: u32 = 1063;
pub const PERFINFO_LOG_TYPE_MAPFILE_DC_END: u32 = 1064;
pub const PERFINFO_LOG_TYPE_FILE_IO_CREATE: u32 = 1088;
pub const PERFINFO_LOG_TYPE_FILE_IO_CLEANUP: u32 = 1089;
pub const PERFINFO_LOG_TYPE_FILE_IO_CLOSE: u32 = 1090;
pub const PERFINFO_LOG_TYPE_FILE_IO_READ: u32 = 1091;
pub const PERFINFO_LOG_TYPE_FILE_IO_WRITE: u32 = 1092;
pub const PERFINFO_LOG_TYPE_FILE_IO_SET_INFORMATION: u32 = 1093;
pub const PERFINFO_LOG_TYPE_FILE_IO_DELETE: u32 = 1094;
pub const PERFINFO_LOG_TYPE_FILE_IO_RENAME: u32 = 1095;
pub const PERFINFO_LOG_TYPE_FILE_IO_DIRENUM: u32 = 1096;
pub const PERFINFO_LOG_TYPE_FILE_IO_FLUSH: u32 = 1097;
pub const PERFINFO_LOG_TYPE_FILE_IO_QUERY_INFORMATION: u32 = 1098;
pub const PERFINFO_LOG_TYPE_FILE_IO_FS_CONTROL: u32 = 1099;
pub const PERFINFO_LOG_TYPE_FILE_IO_OPERATION_END: u32 = 1100;
pub const PERFINFO_LOG_TYPE_FILE_IO_DIRNOTIFY: u32 = 1101;
pub const PERFINFO_LOG_TYPE_FILE_IO_CREATE_NEW: u32 = 1102;
pub const PERFINFO_LOG_TYPE_FILE_IO_DELETE_PATH: u32 = 1103;
pub const PERFINFO_LOG_TYPE_FILE_IO_RENAME_PATH: u32 = 1104;
pub const PERFINFO_LOG_TYPE_FILE_IO_SETLINK_PATH: u32 = 1105;
pub const PERFINFO_LOG_TYPE_FILE_IO_SETLINK: u32 = 1106;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_INIT: u32 = 1120;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_INIT: u32 = 1121;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_COMPLETION: u32 = 1122;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_COMPLETION: u32 = 1123;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_FAILURE: u32 = 1124;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_FAILURE: u32 = 1125;
pub const WMI_LOG_TYPE_JOB_CREATE: u32 = 1824;
pub const WMI_LOG_TYPE_JOB_TERMINATE: u32 = 1825;
pub const WMI_LOG_TYPE_JOB_OPEN: u32 = 1826;
pub const WMI_LOG_TYPE_JOB_ASSIGN_PROCESS: u32 = 1827;
pub const WMI_LOG_TYPE_JOB_REMOVE_PROCESS: u32 = 1828;
pub const WMI_LOG_TYPE_JOB_SET: u32 = 1829;
pub const WMI_LOG_TYPE_JOB_QUERY: u32 = 1830;
pub const WMI_LOG_TYPE_JOB_SET_FAILED: u32 = 1831;
pub const WMI_LOG_TYPE_JOB_QUERY_FAILED: u32 = 1832;
pub const WMI_LOG_TYPE_JOB_SET_NOTIFICATION: u32 = 1833;
pub const WMI_LOG_TYPE_JOB_SEND_NOTIFICATION: u32 = 1834;
pub const WMI_LOG_TYPE_JOB_QUERY_VIOLATION: u32 = 1835;
pub const WMI_LOG_TYPE_JOB_SET_CPU_RATE: u32 = 1836;
pub const WMI_LOG_TYPE_JOB_SET_NET_RATE: u32 = 1837;
pub const WMI_LOG_TYPE_PROCESS_CREATE: u32 = 769;
pub const WMI_LOG_TYPE_PROCESS_DELETE: u32 = 770;
pub const WMI_LOG_TYPE_PROCESS_DC_START: u32 = 771;
pub const WMI_LOG_TYPE_PROCESS_DC_END: u32 = 772;
pub const WMI_LOG_TYPE_PROCESS_LOAD_IMAGE: u32 = 778;
pub const WMI_LOG_TYPE_PROCESS_TERMINATE: u32 = 779;
pub const PERFINFO_LOG_TYPE_PROCESS_PERFCTR_END: u32 = 800;
pub const PERFINFO_LOG_TYPE_PROCESS_PERFCTR_RD: u32 = 801;
pub const PERFINFO_LOG_TYPE_INSWAPPROCESS: u32 = 803;
pub const PERFINFO_LOG_TYPE_PROCESS_FREEZE: u32 = 804;
pub const PERFINFO_LOG_TYPE_PROCESS_THAW: u32 = 805;
pub const PERFINFO_LOG_TYPE_BOOT_PHASE_START: u32 = 806;
pub const PERFINFO_LOG_TYPE_ZOMBIE_PROCESS: u32 = 807;
pub const PERFINFO_LOG_TYPE_PROCESS_SET_AFFINITY: u32 = 808;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_USER: u32 = 816;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_EXECUTION: u32 = 817;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_KERNEL: u32 = 818;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_INSTRUMENTATION: u32 = 819;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_PRESERVE_PROCESS: u32 = 820;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_USER: u32 = 832;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_EXECUTION: u32 = 833;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_KERNEL: u32 = 834;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_INSTRUMENTATION: u32 = 835;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_PRESERVE_PROCESS: u32 = 836;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_USER: u32 = 848;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_EXECUTION: u32 = 849;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_KERNEL: u32 = 850;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_INSTRUMENTATION: u32 = 851;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_PRESERVE_PROCESS: u32 = 852;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_USER: u32 = 864;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_EXECUTION: u32 = 865;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_KERNEL: u32 = 866;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_INSTRUMENTATION: u32 = 867;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_PRESERVE_PROCESS: u32 = 868;
pub const PERFINFO_LOG_TYPE_DEBUG_EVENT: u32 = 880;
pub const WMI_LOG_TYPE_IMAGE_LOAD: u32 = 5121;
pub const WMI_LOG_TYPE_IMAGE_UNLOAD: u32 = 5122;
pub const WMI_LOG_TYPE_IMAGE_DC_START: u32 = 5123;
pub const WMI_LOG_TYPE_IMAGE_DC_END: u32 = 5124;
pub const WMI_LOG_TYPE_IMAGE_RELOCATION: u32 = 5152;
pub const WMI_LOG_TYPE_IMAGE_KERNEL_BASE: u32 = 5153;
pub const WMI_LOG_TYPE_IMAGE_HYPERCALL_PAGE: u32 = 5154;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_ATTEMPT: u32 = 5248;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_SUCCESS: u32 = 5249;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_FAIL: u32 = 5250;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_WAIT: u32 = 5251;
pub const PERFINFO_LOG_TYPE_LDR_PROC_INIT_DONE: u32 = 5252;
pub const PERFINFO_LOG_TYPE_LDR_CREATE_SECTION: u32 = 5253;
pub const PERFINFO_LOG_TYPE_LDR_SECTION_CREATED: u32 = 5254;
pub const PERFINFO_LOG_TYPE_LDR_MAP_VIEW: u32 = 5255;
pub const PERFINFO_LOG_TYPE_LDR_RELOCATE_IMAGE: u32 = 5264;
pub const PERFINFO_LOG_TYPE_LDR_IMAGE_RELOCATED: u32 = 5265;
pub const PERFINFO_LOG_TYPE_LDR_HANDLE_OLD_DESCRIPTORS: u32 = 5266;
pub const PERFINFO_LOG_TYPE_LDR_OLD_DESCRIPTORS_HANDLED: u32 = 5267;
pub const PERFINFO_LOG_TYPE_LDR_HANDLE_NEW_DESCRIPTORS: u32 = 5268;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DESCRIPTORS_HANDLED: u32 = 5269;
pub const PERFINFO_LOG_TYPE_LDR_DLLMAIN_EXIT: u32 = 5270;
pub const PERFINFO_LOG_TYPE_LDR_FIND_DLL: u32 = 5280;
pub const PERFINFO_LOG_TYPE_LDR_VIEW_MAPPED: u32 = 5281;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_RELEASE: u32 = 5282;
pub const PERFINFO_LOG_TYPE_LDR_DLLMAIN_ENTER: u32 = 5283;
pub const PERFINFO_LOG_TYPE_LDR_ERROR: u32 = 5284;
pub const PERFINFO_LOG_TYPE_LDR_VIEW_MAPPING: u32 = 5285;
pub const PERFINFO_LOG_TYPE_LDR_SNAPPING: u32 = 5286;
pub const PERFINFO_LOG_TYPE_LDR_SNAPPED: u32 = 5287;
pub const PERFINFO_LOG_TYPE_LDR_LOADING: u32 = 5288;
pub const PERFINFO_LOG_TYPE_LDR_LOADED: u32 = 5289;
pub const PERFINFO_LOG_TYPE_LDR_FOUND_KNOWN_DLL: u32 = 5290;
pub const PERFINFO_LOG_TYPE_LDR_ABNORMAL: u32 = 5291;
pub const PERFINFO_LOG_TYPE_LDR_PLACEHOLDER: u32 = 5292;
pub const PERFINFO_LOG_TYPE_LDR_RDY_TO_INIT: u32 = 5293;
pub const PERFINFO_LOG_TYPE_LDR_RDY_TO_RUN: u32 = 5294;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DLL_LOAD: u32 = 5296;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DLL_AS_DATA: u32 = 5297;
pub const PERFINFO_LOG_TYPE_LDR_EXTERNAL_PATH: u32 = 5312;
pub const PERFINFO_LOG_TYPE_LDR_GENERATED_PATH: u32 = 5313;
pub const PERFINFO_LOG_TYPE_LDR_APISET_RESOLVING: u32 = 5328;
pub const PERFINFO_LOG_TYPE_LDR_APISET_HOSTED: u32 = 5329;
pub const PERFINFO_LOG_TYPE_LDR_APISET_UNHOSTED: u32 = 5330;
pub const PERFINFO_LOG_TYPE_LDR_APISET_UNRESOLVED: u32 = 5331;
pub const PERFINFO_LOG_TYPE_LDR_SEARCH_SECURITY: u32 = 5332;
pub const PERFINFO_LOG_TYPE_LDR_SEARCH_PATH_SECURITY: u32 = 5333;
pub const WMI_LOG_TYPE_THREAD_CREATE: u32 = 1281;
pub const WMI_LOG_TYPE_THREAD_DELETE: u32 = 1282;
pub const WMI_LOG_TYPE_THREAD_DC_START: u32 = 1283;
pub const WMI_LOG_TYPE_THREAD_DC_END: u32 = 1284;
pub const PERFINFO_LOG_TYPE_CONTEXTSWAP: u32 = 1316;
pub const PERFINFO_LOG_TYPE_CONTEXTSWAP_BATCH: u32 = 1317;
pub const PERFINFO_LOG_TYPE_SPINLOCK: u32 = 1321;
pub const PERFINFO_LOG_TYPE_QUEUE: u32 = 1322;
pub const PERFINFO_LOG_TYPE_RESOURCE: u32 = 1323;
pub const PERFINFO_LOG_TYPE_PUSHLOCK: u32 = 1324;
pub const PERFINFO_LOG_TYPE_WAIT_SINGLE: u32 = 1325;
pub const PERFINFO_LOG_TYPE_WAIT_MULTIPLE: u32 = 1326;
pub const PERFINFO_LOG_TYPE_DELAY_EXECUTION: u32 = 1327;
pub const PERFINFO_LOG_TYPE_THREAD_SET_PRIORITY: u32 = 1328;
pub const PERFINFO_LOT_TYPE_THREAD_SET_BASE_PRIORITY: u32 = 1329;
pub const PERFINFO_LOG_TYPE_THREAD_SET_BASE_PRIORITY: u32 = 1329;
pub const PERFINFO_LOG_TYPE_READY_THREAD: u32 = 1330;
pub const PERFINFO_LOG_TYPE_THREAD_SET_PAGE_PRIORITY: u32 = 1331;
pub const PERFINFO_LOG_TYPE_THREAD_SET_IO_PRIORITY: u32 = 1332;
pub const PERFINFO_LOG_TYPE_THREAD_SET_AFFINITY: u32 = 1333;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM: u32 = 1337;
pub const PERFINFO_LOG_TYPE_DFSS_START_NEW_INTERVAL: u32 = 1338;
pub const PERFINFO_LOG_TYPE_DFSS_PROCESS_IDLE_ONLY_QUEUE: u32 = 1339;
pub const PERFINFO_LOG_TYPE_ANTI_STARVATION_BOOST: u32 = 1340;
pub const PERFINFO_LOG_TYPE_THREAD_MIGRATION: u32 = 1341;
pub const PERFINFO_LOG_TYPE_KQUEUE_ENQUEUE: u32 = 1342;
pub const PERFINFO_LOG_TYPE_KQUEUE_DEQUEUE: u32 = 1343;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_START: u32 = 1344;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_END: u32 = 1345;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_SET_FLOOR: u32 = 1346;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_CLEAR_FLOOR: u32 = 1347;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_NO_ENTRIES: u32 = 1348;
pub const PERFINFO_LOG_TYPE_THREAD_SUBPROCESSTAG_CHANGED: u32 = 1349;
pub const WMI_LOG_TYPE_TCPIP_SEND: u32 = 1546;
pub const WMI_LOG_TYPE_TCPIP_RECEIVE: u32 = 1547;
pub const WMI_LOG_TYPE_TCPIP_CONNECT: u32 = 1548;
pub const WMI_LOG_TYPE_TCPIP_DISCONNECT: u32 = 1549;
pub const WMI_LOG_TYPE_TCPIP_RETRANSMIT: u32 = 1550;
pub const WMI_LOG_TYPE_TCPIP_ACCEPT: u32 = 1551;
pub const WMI_LOG_TYPE_TCPIP_RECONNECT: u32 = 1552;
pub const WMI_LOG_TYPE_TCPIP_FAIL: u32 = 1553;
pub const WMI_LOG_TYPE_TCPIP_TCPCOPY: u32 = 1554;
pub const WMI_LOG_TYPE_TCPIP_ARPCOPY: u32 = 1555;
pub const WMI_LOG_TYPE_TCPIP_FULLACK: u32 = 1556;
pub const WMI_LOG_TYPE_TCPIP_PARTACK: u32 = 1557;
pub const WMI_LOG_TYPE_TCPIP_DUPACK: u32 = 1558;
pub const WMI_LOG_TYPE_UDP_SEND: u32 = 2058;
pub const WMI_LOG_TYPE_UDP_RECEIVE: u32 = 2059;
pub const WMI_LOG_TYPE_UDP_FAIL: u32 = 2065;
pub const WMI_LOG_TYPE_TCPIP_SEND_IPV6: u32 = 1562;
pub const WMI_LOG_TYPE_TCPIP_RECEIVE_IPV6: u32 = 1563;
pub const WMI_LOG_TYPE_TCPIP_CONNECT_IPV6: u32 = 1564;
pub const WMI_LOG_TYPE_TCPIP_DISCONNECT_IPV6: u32 = 1565;
pub const WMI_LOG_TYPE_TCPIP_RETRANSMIT_IPV6: u32 = 1566;
pub const WMI_LOG_TYPE_TCPIP_ACCEPT_IPV6: u32 = 1567;
pub const WMI_LOG_TYPE_TCPIP_RECONNECT_IPV6: u32 = 1568;
pub const WMI_LOG_TYPE_TCPIP_FAIL_IPV6: u32 = 1569;
pub const WMI_LOG_TYPE_TCPIP_TCPCOPY_IPV6: u32 = 1570;
pub const WMI_LOG_TYPE_TCPIP_ARPCOPY_IPV6: u32 = 1571;
pub const WMI_LOG_TYPE_TCPIP_FULLACK_IPV6: u32 = 1572;
pub const WMI_LOG_TYPE_TCPIP_PARTACK_IPV6: u32 = 1573;
pub const WMI_LOG_TYPE_TCPIP_DUPACK_IPV6: u32 = 1574;
pub const WMI_LOG_TYPE_UDP_SEND_IPV6: u32 = 2074;
pub const WMI_LOG_TYPE_UDP_RECEIVE_IPV6: u32 = 2075;
pub const WMI_LOG_TYPE_IO_READ: u32 = 266;
pub const WMI_LOG_TYPE_IO_WRITE: u32 = 267;
pub const WMI_LOG_TYPE_IO_READ_INIT: u32 = 268;
pub const WMI_LOG_TYPE_IO_WRITE_INIT: u32 = 269;
pub const WMI_LOG_TYPE_IO_FLUSH: u32 = 270;
pub const WMI_LOG_TYPE_IO_FLUSH_INIT: u32 = 271;
pub const WMI_LOG_TYPE_IO_REDIRECTED_INIT: u32 = 272;
pub const PERFINFO_LOG_TYPE_DRIVER_INIT: u32 = 288;
pub const PERFINFO_LOG_TYPE_DRIVER_INIT_COMPLETE: u32 = 289;
pub const PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_CALL: u32 = 290;
pub const PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_RETURN: u32 = 291;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_CALL: u32 = 292;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_RETURN: u32 = 293;
pub const PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_CALL: u32 = 294;
pub const PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_RETURN: u32 = 295;
pub const PERFINFO_LOG_TYPE_DRIVER_STARTIO_CALL: u32 = 296;
pub const PERFINFO_LOG_TYPE_DRIVER_STARTIO_RETURN: u32 = 297;
pub const PERFINFO_LOG_TYPE_PREFETCH_ACTION: u32 = 304;
pub const PERFINFO_LOG_TYPE_PREFETCH_REQUEST: u32 = 305;
pub const PERFINFO_LOG_TYPE_PREFETCH_READLIST: u32 = 306;
pub const PERFINFO_LOG_TYPE_PREFETCH_READ: u32 = 307;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST: u32 = 308;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST_RETURN: u32 = 309;
pub const PERFINFO_LOG_TYPE_BOOT_PREFETCH_INFORMATION: u32 = 310;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_READ: u32 = 311;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_WRITE: u32 = 312;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_FLUSH: u32 = 313;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_READ_INIT: u32 = 314;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_WRITE_INIT: u32 = 315;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_FLUSH_INIT: u32 = 316;
pub const WMI_LOG_TYPE_PAGE_FAULT_TRANSITION: u32 = 522;
pub const WMI_LOG_TYPE_PAGE_FAULT_DEMAND_ZERO: u32 = 523;
pub const WMI_LOG_TYPE_PAGE_FAULT_COPY_ON_WRITE: u32 = 524;
pub const WMI_LOG_TYPE_PAGE_FAULT_GUARD_PAGE: u32 = 525;
pub const WMI_LOG_TYPE_PAGE_FAULT_HARD_PAGE_FAULT: u32 = 526;
pub const WMI_LOG_TYPE_PAGE_FAULT_ACCESS_VIOLATION: u32 = 527;
pub const PERFINFO_LOG_TYPE_HARDFAULT: u32 = 544;
pub const PERFINFO_LOG_TYPE_REMOVEPAGEBYCOLOR: u32 = 545;
pub const PERFINFO_LOG_TYPE_REMOVEPAGEFROMLIST: u32 = 546;
pub const PERFINFO_LOG_TYPE_PAGEINMEMORY: u32 = 547;
pub const PERFINFO_LOG_TYPE_INSERTINFREELIST: u32 = 548;
pub const PERFINFO_LOG_TYPE_INSERTINMODIFIEDLIST: u32 = 549;
pub const PERFINFO_LOG_TYPE_INSERTINLIST: u32 = 550;
pub const PERFINFO_LOG_TYPE_INSERTATFRONT: u32 = 552;
pub const PERFINFO_LOG_TYPE_UNLINKFROMSTANDBY: u32 = 553;
pub const PERFINFO_LOG_TYPE_UNLINKFFREEORZERO: u32 = 554;
pub const PERFINFO_LOG_TYPE_WORKINGSETMANAGER: u32 = 555;
pub const PERFINFO_LOG_TYPE_TRIMPROCESS: u32 = 556;
pub const PERFINFO_LOG_TYPE_ZEROSHARECOUNT: u32 = 558;
pub const PERFINFO_LOG_TYPE_WSINFOPROCESS: u32 = 572;
pub const PERFINFO_LOG_TYPE_FAULTADDR_WITH_IP: u32 = 581;
pub const PERFINFO_LOG_TYPE_TRIMSESSION: u32 = 582;
pub const PERFINFO_LOG_TYPE_MEMORYSNAPLITE: u32 = 583;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_RUNDOWN: u32 = 584;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_CREATE: u32 = 585;
pub const PERFINFO_LOG_TYPE_WSINFOSESSION: u32 = 586;
pub const PERFINFO_LOG_TYPE_CREATE_SESSION: u32 = 587;
pub const PERFINFO_LOG_TYPE_SESSION_RUNDOWN_DC_END: u32 = 588;
pub const PERFINFO_LOG_TYPE_SESSION_RUNDOWN_DC_START: u32 = 589;
pub const PERFINFO_LOG_TYPE_SESSION_DELETE: u32 = 590;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_DELETE: u32 = 591;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC: u32 = 610;
pub const PERFINFO_LOG_TYPE_VIRTUAL_FREE: u32 = 611;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RUNDOWN: u32 = 612;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_CREATE: u32 = 613;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RESERVE: u32 = 614;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RELEASE: u32 = 615;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_DESTROY: u32 = 616;
pub const PERFINFO_LOG_TYPE_PAGEFILE_BACK: u32 = 617;
pub const PERFINFO_LOG_TYPE_MEMINFO: u32 = 624;
pub const PERFINFO_LOG_TYPE_CONTMEM_GENERATE: u32 = 625;
pub const PERFINFO_LOG_TYPE_FILE_STORE_FAULT: u32 = 626;
pub const PERFINFO_LOG_TYPE_INMEMORY_STORE_FAULT: u32 = 627;
pub const PERFINFO_LOG_TYPE_COMPRESSED_PAGE: u32 = 628;
pub const PERFINFO_LOG_TYPE_PAGEINMEMORY_ACTIVE: u32 = 629;
pub const PERFINFO_LOG_TYPE_PAGE_ACCESS: u32 = 630;
pub const PERFINFO_LOG_TYPE_PAGE_RELEASE: u32 = 631;
pub const PERFINFO_LOG_TYPE_PAGE_RANGE_ACCESS: u32 = 632;
pub const PERFINFO_LOG_TYPE_PAGE_RANGE_RELEASE: u32 = 633;
pub const PERFINFO_LOG_TYPE_PAGE_COMBINE: u32 = 634;
pub const PERFINFO_LOG_TYPE_KERNEL_MEMUSAGE: u32 = 635;
pub const PERFINFO_LOG_TYPE_MM_STATS: u32 = 636;
pub const PERFINFO_LOG_TYPE_MEMINFOEX_WS: u32 = 637;
pub const PERFINFO_LOG_TYPE_MEMINFOEX_SESSIONWS: u32 = 638;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ROTATE: u32 = 639;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC_DC_START: u32 = 640;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC_DC_END: u32 = 641;
pub const PERFINFO_LOG_TYPE_PAGE_ACCESS_EX: u32 = 642;
pub const PERFINFO_LOG_TYPE_REMOVEFROMWS: u32 = 643;
pub const PERFINFO_LOG_TYPE_WSSHAREABLE_RUNDOWN: u32 = 644;
pub const PERFINFO_LOG_TYPE_INMEMORYACTIVE_RUNDOWN: u32 = 645;
pub const PERFINFO_LOG_TYPE_MEM_RESET_INFO: u32 = 646;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_OBJECT_CREATE: u32 = 647;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_OBJECT_DELETE: u32 = 648;
pub const WMI_LOG_TYPE_REG_RUNDOWNBEGIN: u32 = 2328;
pub const WMI_LOG_TYPE_REG_RUNDOWNEND: u32 = 2329;
pub const PERFINFO_LOG_TYPE_CMCELLREFERRED: u32 = 2336;
pub const PERFINFO_LOG_TYPE_REG_SET_VALUE: u32 = 2337;
pub const PERFINFO_LOG_TYPE_REG_COUNTERS: u32 = 2338;
pub const PERFINFO_LOG_TYPE_REG_CONFIG: u32 = 2339;
pub const PERFINFO_LOG_TYPE_REG_HIVE_INITIALIZE: u32 = 2340;
pub const PERFINFO_LOG_TYPE_REG_HIVE_DESTROY: u32 = 2341;
pub const PERFINFO_LOG_TYPE_REG_HIVE_LINK: u32 = 2342;
pub const PERFINFO_LOG_TYPE_REG_HIVE_RUNDOWN_DC_END: u32 = 2343;
pub const PERFINFO_LOG_TYPE_REG_HIVE_DIRTY: u32 = 2344;
pub const PERFINFO_LOG_TYPE_REG_NOTIF_REGISTER: u32 = 2352;
pub const PERFINFO_LOG_TYPE_REG_NOTIF_DELIVER: u32 = 2353;
pub const PERFINFO_LOG_TYPE_RUNDOWN_CHECKPOINT: u32 = 3872;
pub const PERFINFO_LOG_TYPE_MARK: u32 = 3874;
pub const PERFINFO_LOG_TYPE_ASYNCMARK: u32 = 3876;
pub const PERFINFO_LOG_TYPE_IMAGENAME: u32 = 3878;
pub const PERFINFO_LOG_TYPE_DELAYS_CC_CAN_I_WRITE: u32 = 3879;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE: u32 = 3886;
pub const PERFINFO_LOG_TYPE_PMC_INTERRUPT: u32 = 3887;
pub const PERFINFO_LOG_TYPE_PMC_CONFIG: u32 = 3888;
pub const PERFINFO_LOG_TYPE_MSI_INTERRUPT: u32 = 3890;
pub const PERFINFO_LOG_TYPE_SYSCALL_ENTER: u32 = 3891;
pub const PERFINFO_LOG_TYPE_SYSCALL_EXIT: u32 = 3892;
pub const PERFINFO_LOG_TYPE_BACKTRACE: u32 = 3893;
pub const PERFINFO_LOG_TYPE_BACKTRACE_USERSTACK: u32 = 3894;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_CACHE: u32 = 3895;
pub const PERFINFO_LOG_TYPE_EXCEPTION_STACK: u32 = 3896;
pub const PERFINFO_LOG_TYPE_BRANCH_TRACE: u32 = 3897;
pub const PERFINFO_LOG_TYPE_DEBUGGER_ENABLED: u32 = 3898;
pub const PERFINFO_LOG_TYPE_DEBUGGER_EXIT: u32 = 3899;
pub const PERFINFO_LOG_TYPE_BRANCH_TRACE_DEBUG: u32 = 3904;
pub const PERFINFO_LOG_TYPE_BRANCH_ADDRESS_DEBUG: u32 = 3905;
pub const PERFINFO_LOG_TYPE_THREADED_DPC: u32 = 3906;
pub const PERFINFO_LOG_TYPE_INTERRUPT: u32 = 3907;
pub const PERFINFO_LOG_TYPE_DPC: u32 = 3908;
pub const PERFINFO_LOG_TYPE_TIMERDPC: u32 = 3909;
pub const PERFINFO_LOG_TYPE_IOTIMER_EXPIRATION: u32 = 3910;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_NMI: u32 = 3911;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_SET_INTERVAL: u32 = 3912;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_DC_START: u32 = 3913;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_DC_END: u32 = 3914;
pub const PERFINFO_LOG_TYPE_SPINLOCK_DC_START: u32 = 3915;
pub const PERFINFO_LOG_TYPE_SPINLOCK_DC_END: u32 = 3916;
pub const PERFINFO_LOG_TYPE_ERESOURCE_DC_START: u32 = 3917;
pub const PERFINFO_LOG_TYPE_ERESOURCE_DC_END: u32 = 3918;
pub const PERFINFO_LOG_TYPE_CLOCK_INTERRUPT: u32 = 3919;
pub const PERFINFO_LOG_TYPE_TIMER_EXPIRATION_START: u32 = 3920;
pub const PERFINFO_LOG_TYPE_TIMER_EXPIRATION: u32 = 3921;
pub const PERFINFO_LOG_TYPE_TIMER_SET_PERIODIC: u32 = 3922;
pub const PERFINFO_LOG_TYPE_TIMER_SET_ONE_SHOT: u32 = 3923;
pub const PERFINFO_LOG_TYPE_TIMER_SET_THREAD: u32 = 3924;
pub const PERFINFO_LOG_TYPE_TIMER_CANCEL: u32 = 3925;
pub const PERFINFO_LOG_TYPE_TIME_ADJUSTMENT: u32 = 3926;
pub const PERFINFO_LOG_TYPE_CLOCK_MODE_SWITCH: u32 = 3927;
pub const PERFINFO_LOG_TYPE_CLOCK_TIME_UPDATE: u32 = 3928;
pub const PERFINFO_LOG_TYPE_CLOCK_DYNAMIC_TICK_VETO: u32 = 3929;
pub const PERFINFO_LOG_TYPE_CLOCK_CONFIGURATION: u32 = 3930;
pub const PERFINFO_LOG_TYPE_IPI: u32 = 3931;
pub const PERFINFO_LOG_TYPE_UNEXPECTED_INTERRUPT: u32 = 3932;
pub const PERFINFO_LOG_TYPE_IOTIMER_START: u32 = 3933;
pub const PERFINFO_LOG_TYPE_IOTIMER_STOP: u32 = 3934;
pub const PERFINFO_LOG_TYPE_PASSIVE_INTERRUPT: u32 = 3935;
pub const PERFINFO_LOG_TYPE_WDF_INTERRUPT: u32 = 3936;
pub const PERFINFO_LOG_TYPE_WDF_PASSIVE_INTERRUPT: u32 = 3937;
pub const PERFINFO_LOG_TYPE_WDF_DPC: u32 = 3938;
pub const PERFINFO_LOG_TYPE_CPU_CACHE_FLUSH: u32 = 3939;
pub const PERFINFO_LOG_TYPE_DPC_ENQUEUE: u32 = 3940;
pub const PERFINFO_LOG_TYPE_DPC_EXECUTION: u32 = 3941;
pub const PERFINFO_LOG_TYPE_INTERRUPT_STEERING: u32 = 3942;
pub const PERFINFO_LOG_TYPE_WDF_WORK_ITEM: u32 = 3943;
pub const PERFINFO_LOG_TYPE_KTIMER2_SET: u32 = 3944;
pub const PERFINFO_LOG_TYPE_KTIMER2_EXPIRATION: u32 = 3945;
pub const PERFINFO_LOG_TYPE_KTIMER2_CANCEL: u32 = 3946;
pub const PERFINFO_LOG_TYPE_KTIMER2_DISABLE: u32 = 3947;
pub const PERFINFO_LOG_TYPE_KTIMER2_FINALIZATION: u32 = 3948;
pub const PERFINFO_LOG_TYPE_SHOULD_YIELD_PROCESSOR: u32 = 3949;
pub const PERFINFO_LOG_TYPE_FUNCTION_CALL: u32 = 3968;
pub const PERFINFO_LOG_TYPE_FUNCTION_RETURN: u32 = 3969;
pub const PERFINFO_LOG_TYPE_FUNCTION_ENTER: u32 = 3970;
pub const PERFINFO_LOG_TYPE_FUNCTION_EXIT: u32 = 3971;
pub const PERFINFO_LOG_TYPE_TAILCALL: u32 = 3972;
pub const PERFINFO_LOG_TYPE_TRAP: u32 = 3973;
pub const PERFINFO_LOG_TYPE_SPINLOCK_ACQUIRE: u32 = 3974;
pub const PERFINFO_LOG_TYPE_SPINLOCK_RELEASE: u32 = 3975;
pub const PERFINFO_LOG_TYPE_CAP_COMMENT: u32 = 3976;
pub const PERFINFO_LOG_TYPE_CAP_RUNDOWN: u32 = 3977;
pub const PERFINFO_LOG_TYPE_DEBUG_PRINT: u32 = 2592;
pub const PERFINFO_LOG_TYPE_WNF_SUBSCRIBE: u32 = 3360;
pub const PERFINFO_LOG_TYPE_WNF_UNSUBSCRIBE: u32 = 3361;
pub const PERFINFO_LOG_TYPE_WNF_CALLBACK: u32 = 3362;
pub const PERFINFO_LOG_TYPE_WNF_PUBLISH: u32 = 3363;
pub const PERFINFO_LOG_TYPE_WNF_NAME_SUB_RUNDOWN: u32 = 3364;
pub const PERFINFO_LOG_TYPE_ALLOCATEPOOL: u32 = 3616;
pub const PERFINFO_LOG_TYPE_ALLOCATEPOOL_SESSION: u32 = 3617;
pub const PERFINFO_LOG_TYPE_FREEPOOL: u32 = 3618;
pub const PERFINFO_LOG_TYPE_FREEPOOL_SESSION: u32 = 3619;
pub const PERFINFO_LOG_TYPE_ADDPOOLPAGE: u32 = 3620;
pub const PERFINFO_LOG_TYPE_ADDPOOLPAGE_SESSION: u32 = 3621;
pub const PERFINFO_LOG_TYPE_BIGPOOLPAGE: u32 = 3622;
pub const PERFINFO_LOG_TYPE_BIGPOOLPAGE_SESSION: u32 = 3623;
pub const PERFINFO_LOG_TYPE_POOLSNAP_DC_START: u32 = 3624;
pub const PERFINFO_LOG_TYPE_POOLSNAP_DC_END: u32 = 3625;
pub const PERFINFO_LOG_TYPE_BIGPOOLSNAP_DC_START: u32 = 3626;
pub const PERFINFO_LOG_TYPE_BIGPOOLSNAP_DC_END: u32 = 3627;
pub const PERFINFO_LOG_TYPE_POOLSNAP_SESSION_DC_START: u32 = 3628;
pub const PERFINFO_LOG_TYPE_POOLSNAP_SESSION_DC_END: u32 = 3629;
pub const PERFINFO_LOG_TYPE_SESSIONBIGPOOLSNAP_DC_START: u32 = 3630;
pub const PERFINFO_LOG_TYPE_SESSIONBIGPOOLSNAP_DC_END: u32 = 3631;
pub const PERFINFO_LOG_TYPE_HEAP_CREATE: u32 = 4128;
pub const PERFINFO_LOG_TYPE_HEAP_ALLOC: u32 = 4129;
pub const PERFINFO_LOG_TYPE_HEAP_REALLOC: u32 = 4130;
pub const PERFINFO_LOG_TYPE_HEAP_DESTROY: u32 = 4131;
pub const PERFINFO_LOG_TYPE_HEAP_FREE: u32 = 4132;
pub const PERFINFO_LOG_TYPE_HEAP_EXTEND: u32 = 4133;
pub const PERFINFO_LOG_TYPE_HEAP_SNAPSHOT: u32 = 4134;
pub const PERFINFO_LOG_TYPE_HEAP_CREATE_SNAPSHOT: u32 = 4135;
pub const PERFINFO_LOG_TYPE_HEAP_DESTROY_SNAPSHOT: u32 = 4136;
pub const PERFINFO_LOG_TYPE_HEAP_EXTEND_SNAPSHOT: u32 = 4137;
pub const PERFINFO_LOG_TYPE_HEAP_CONTRACT: u32 = 4138;
pub const PERFINFO_LOG_TYPE_HEAP_LOCK: u32 = 4139;
pub const PERFINFO_LOG_TYPE_HEAP_UNLOCK: u32 = 4140;
pub const PERFINFO_LOG_TYPE_HEAP_VALIDATE: u32 = 4141;
pub const PERFINFO_LOG_TYPE_HEAP_WALK: u32 = 4142;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ALLOC: u32 = 4143;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_FREE: u32 = 4144;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ALLOC_CACHE: u32 = 4145;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_FREE_CACHE: u32 = 4146;
pub const PERFINFO_LOG_TYPE_HEAP_COMMIT: u32 = 4147;
pub const PERFINFO_LOG_TYPE_HEAP_DECOMMIT: u32 = 4148;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_INIT: u32 = 4149;
pub const PERFINFO_LOG_TYPE_HEAP_AFFINITY_ENABLE: u32 = 4150;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ACTIVATED: u32 = 4152;
pub const PERFINFO_LOG_TYPE_HEAP_AFFINITY_ASSIGN: u32 = 4153;
pub const PERFINFO_LOG_TYPE_HEAP_REUSE_THRESHOLD_ACTIVATED: u32 = 4154;
pub const PERFINFO_LOG_TYPE_CRITSEC_ENTER: u32 = 5920;
pub const PERFINFO_LOG_TYPE_CRITSEC_LEAVE: u32 = 5921;
pub const PERFINFO_LOG_TYPE_CRITSEC_COLLISION: u32 = 5922;
pub const PERFINFO_LOG_TYPE_CRITSEC_INITIALIZE: u32 = 5923;
pub const PERFINFO_LOG_TYPE_STACKWALK: u32 = 6176;
pub const PERFINFO_LOG_TYPE_STACKTRACE_CREATE: u32 = 6178;
pub const PERFINFO_LOG_TYPE_STACKTRACE_DELETE: u32 = 6179;
pub const PERFINFO_LOG_TYPE_STACKTRACE_RUNDOWN: u32 = 6180;
pub const PERFINFO_LOG_TYPE_STACKTRACE_KEY_KERNEL: u32 = 6181;
pub const PERFINFO_LOG_TYPE_STACKTRACE_KEY_USER: u32 = 6182;
pub const WMI_LOG_TYPE_ALPC_SEND_MESSAGE: u32 = 6689;
pub const WMI_LOG_TYPE_ALPC_RECEIVE_MESSAGE: u32 = 6690;
pub const WMI_LOG_TYPE_ALPC_WAIT_FOR_REPLY: u32 = 6691;
pub const WMI_LOG_TYPE_ALPC_WAIT_FOR_NEW_MESSAGE: u32 = 6692;
pub const WMI_LOG_TYPE_ALPC_UNWAIT: u32 = 6693;
pub const WMI_LOG_TYPE_ALPC_CONNECT_REQUEST: u32 = 6694;
pub const WMI_LOG_TYPE_ALPC_CONNECT_SUCCESS: u32 = 6695;
pub const WMI_LOG_TYPE_ALPC_CONNECT_FAIL: u32 = 6696;
pub const WMI_LOG_TYPE_ALPC_CLOSE_PORT: u32 = 6697;
pub const PERFINFO_LOG_TYPE_CREATE_HANDLE: u32 = 4384;
pub const PERFINFO_LOG_TYPE_CLOSE_HANDLE: u32 = 4385;
pub const PERFINFO_LOG_TYPE_DUPLICATE_HANDLE: u32 = 4386;
pub const PERFINFO_LOG_TYPE_OBJECT_TYPE_DC_START: u32 = 4388;
pub const PERFINFO_LOG_TYPE_OBJECT_TYPE_DC_END: u32 = 4389;
pub const PERFINFO_LOG_TYPE_OBJECT_HANDLE_DC_START: u32 = 4390;
pub const PERFINFO_LOG_TYPE_OBJECT_HANDLE_DC_END: u32 = 4391;
pub const PERFINFO_LOG_TYPE_CREATE_OBJECT: u32 = 4400;
pub const PERFINFO_LOG_TYPE_DELETE_OBJECT: u32 = 4401;
pub const PERFINFO_LOG_TYPE_REFERENCE_OBJECT: u32 = 4402;
pub const PERFINFO_LOG_TYPE_DEREFERENCE_OBJECT: u32 = 4403;
pub const PERFINFO_LOG_TYPE_BATTERY_LIFE_INFO: u32 = 4640;
pub const PERFINFO_LOG_TYPE_IDLE_STATE_CHANGE: u32 = 4641;
pub const PERFINFO_LOG_TYPE_SET_POWER_ACTION: u32 = 4642;
pub const PERFINFO_LOG_TYPE_SET_POWER_ACTION_RET: u32 = 4643;
pub const PERFINFO_LOG_TYPE_SET_DEVICES_STATE: u32 = 4644;
pub const PERFINFO_LOG_TYPE_SET_DEVICES_STATE_RET: u32 = 4645;
pub const PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE: u32 = 4646;
pub const PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE_COMPLETE: u32 = 4647;
pub const PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT: u32 = 4648;
pub const PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT_RET: u32 = 4649;
pub const PERFINFO_LOG_TYPE_PO_PRESLEEP: u32 = 4656;
pub const PERFINFO_LOG_TYPE_PO_POSTSLEEP: u32 = 4657;
pub const PERFINFO_LOG_TYPE_PO_CALIBRATED_PERFCOUNTER: u32 = 4658;
pub const PERFINFO_LOG_TYPE_PPM_PERF_STATE_CHANGE: u32 = 4659;
pub const PERFINFO_LOG_TYPE_PPM_THROTTLE_STATE_CHANGE: u32 = 4660;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_CHANGE: u32 = 4661;
pub const PERFINFO_LOG_TYPE_PPM_THERMAL_CONSTRAINT: u32 = 4662;
pub const PERFINFO_LOG_TYPE_PO_SIGNAL_RESUME_UI: u32 = 4663;
pub const PERFINFO_LOG_TYPE_PO_SIGNAL_VIDEO_ON: u32 = 4664;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_ENTER: u32 = 4665;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_EXIT: u32 = 4666;
pub const PERFINFO_LOG_TYPE_PPM_PLATFORM_IDLE_STATE_ENTER: u32 = 4667;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_EXIT_LATENCY: u32 = 4668;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_PROCESSOR_SELECTION: u32 = 4669;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_PLATFORM_SELECTION: u32 = 4670;
pub const PERFINFO_LOG_TYPE_PPM_COORDINATED_IDLE_ENTER: u32 = 4671;
pub const PERFINFO_LOG_TYPE_PPM_COORDINATED_IDLE_EXIT: u32 = 4672;
pub const PERFINFO_LOG_TYPE_COWHEADER: u32 = 4888;
pub const PERFINFO_LOG_TYPE_COWBLOB: u32 = 4889;
pub const PERFINFO_LOG_TYPE_COWBLOB_CLOSED: u32 = 4890;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_ENT: u32 = 4896;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_JUMP: u32 = 4897;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_RET: u32 = 4898;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_CALL: u32 = 4899;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_CALLRET: u32 = 4900;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_INT2E: u32 = 4901;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_INT2B: u32 = 4902;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_FULLTRACE: u32 = 4903;
pub const PERFINFO_LOG_TYPE_MMCSS_START: u32 = 32;
pub const PERFINFO_LOG_TYPE_MMCSS_STOP: u32 = 33;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_EVENT: u32 = 34;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_WAKEUP: u32 = 35;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_SLEEP: u32 = 36;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_SLEEP_RESP: u32 = 37;
pub const PERFINFO_LOG_TYPE_SPLITIO_VOLMGR: u32 = 6944;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_ENQUEUE: u32 = 7200;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_DEQUEUE: u32 = 7201;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_START: u32 = 7202;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_STOP: u32 = 7203;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_CANCEL: u32 = 7204;
pub const PERFINFO_LOG_TYPE_TP_POOL_CREATE: u32 = 7205;
pub const PERFINFO_LOG_TYPE_TP_POOL_CLOSE: u32 = 7206;
pub const PERFINFO_LOG_TYPE_TP_POOL_TH_MIN_SET: u32 = 7207;
pub const PERFINFO_LOG_TYPE_TP_POOL_TH_MAX_SET: u32 = 7208;
pub const PERFINFO_LOG_TYPE_TP_WORKER_NUMANODE_SWITCH: u32 = 7209;
pub const PERFINFO_LOG_TYPE_TP_TIMER_SET: u32 = 7210;
pub const PERFINFO_LOG_TYPE_TP_TIMER_CANCELLED: u32 = 7211;
pub const PERFINFO_LOG_TYPE_TP_TIMER_SET_NTTIMER: u32 = 7212;
pub const PERFINFO_LOG_TYPE_TP_TIMER_CANCEL_NTTIMER: u32 = 7213;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION_BEGIN: u32 = 7214;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION_END: u32 = 7215;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION: u32 = 7216;
pub const PERFINFO_LOG_TYPE_UMS_DIRECTED_SWITCH_START: u32 = 6432;
pub const PERFINFO_LOG_TYPE_UMS_DIRECTED_SWITCH_END: u32 = 6433;
pub const PERFINFO_LOG_TYPE_UMS_PARK: u32 = 6434;
pub const PERFINFO_LOG_TYPE_UMS_DISASSOCIATE: u32 = 6435;
pub const PERFINFO_LOG_TYPE_UMS_CONTEXT_SWITCH: u32 = 6436;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_ENQUEUE: u32 = 5632;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_DEQUEUE: u32 = 5633;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_COMPLETE: u32 = 5634;
pub const PERFINFO_LOG_TYPE_CC_READ_AHEAD: u32 = 5635;
pub const PERFINFO_LOG_TYPE_CC_WRITE_BEHIND: u32 = 5636;
pub const PERFINFO_LOG_TYPE_CC_LAZY_WRITE_SCAN: u32 = 5637;
pub const PERFINFO_LOG_TYPE_CC_CAN_I_WRITE_FAIL: u32 = 5638;
pub const PERFINFO_LOG_TYPE_CC_FLUSH_CACHE: u32 = 5641;
pub const PERFINFO_LOG_TYPE_CC_FLUSH_SECTION: u32 = 5642;
pub const PERFINFO_LOG_TYPE_CC_READ_AHEAD_PREFETCH: u32 = 5643;
pub const PERFINFO_LOG_TYPE_CC_SCHEDULE_READ_AHEAD: u32 = 5644;
pub const PERFINFO_LOG_TYPE_CC_LOGGED_STREAM_INFO: u32 = 5645;
pub const PERFINFO_LOG_TYPE_CC_EXTRA_WRITEBEHIND_THREAD: u32 = 5646;
pub const MAX_DEVICE_ID_LENGTH: u32 = 256;
pub const CONFIG_MAX_DOMAIN_NAME_LEN: u32 = 134;
pub const CONFIG_WRITE_CACHE_ENABLED: u32 = 1;
pub const CONFIG_FS_NAME_LEN: u32 = 16;
pub const CONFIG_BOOT_DRIVE_LEN: u32 = 3;
pub const CONFIG_DRIVE_PARTITION: u32 = 1;
pub const CONFIG_DRIVE_VOLUME: u32 = 2;
pub const CONFIG_DRIVE_EXTENT: u32 = 4;
pub const CONFIG_DRIVE_LETTER_LEN: u32 = 4;
pub const CONFIG_MAX_DNS_SERVER: u32 = 4;
pub const CONFIG_MAX_ADAPTER_ADDRESS_LENGTH: u32 = 8;
pub const ETW_PROCESS_EVENT_FLAG_APPLICATION_ID: u32 = 1;
pub const ETW_PROCESS_EVENT_FLAG_WOW64: u32 = 2;
pub const ETW_PROCESS_EVENT_FLAG_PROTECTED: u32 = 4;
pub const ETW_PROCESS_EVENT_FLAG_PACKAGED: u32 = 8;
pub const ETW_THREAD_FLAG_REGISTRY_NOTIFICATION: u32 = 1;
pub const ETW_IMAGE_CATALOG_SIGNED: u32 = 16;
pub const ETW_IMAGE_EMBEDDED_SIGNED: u32 = 32;
pub const ETW_IO_FLAG_BACKUP: u32 = 1;
pub const ETW_IO_FLAG_PREFETCH: u32 = 2;
pub const ETW_IO_FLAG_WRITE_AGGREGATION: u32 = 4;
pub const WMI_SPINLOCK_EVENT_EXECUTE_DPC_BIT: u32 = 6;
pub const WMI_SPINLOCK_EVENT_EXECUTE_ISR_BIT: u32 = 7;
pub const WMI_SPINLOCK_ACQUIRE_MODE_MASK: u32 = 63;
pub const WMI_RESOURCE_ACTION_COMPLETE_RELEASE_EXCLUSIVE: u32 = 65570;
pub const WMI_RESOURCE_ACTION_COMPLETE_RELEASE_SHARED: u32 = 65602;
pub const WMI_RESOURCE_ACTION_WAIT_EXCESSIVE_FOR_EXCLUSIVE: u32 = 66084;
pub const WMI_RESOURCE_ACTION_WAIT_EXCESSIVE_FOR_SHARED: u32 = 66116;
pub const WMI_QUEUE_ACTION_WAIT_FOR_ITEM: u32 = 1;
pub const WMI_PUSHLOCK_ACTION_WAIT_FOR_EXCLUSIVE: u32 = 1;
pub const WMI_PUSHLOCK_ACTION_WAIT_FOR_SHARED: u32 = 2;
pub const WMI_WAIT_MULTIPLE_MAX_OBJECTS: u32 = 64;
pub const WMI_WAIT_MULTIPLE_WAIT_ANY: u32 = 1;
pub const WMI_WAIT_MULTIPLE_WAIT_ALL: u32 = 2;
pub const ETW_POOLTRACE_BIGPOOL_MASK: u32 = 268435456;
pub const ETW_KERNEL_HANDLE_MASK: u32 = 2147483648;
pub const HEAP_LOG_CREATE_HEAP: u32 = 1;
pub const HEAP_LOG_FIND_AND_COMMIT_PAGES: u32 = 2;
pub const HEAP_LOG_INITIALIZE_SEGMENT: u32 = 3;
pub const HEAP_LOG_EXTEND_HEAP: u32 = 4;
pub const HEAP_LOG_DECOMMIT_FREE_BLOCK: u32 = 5;
pub const HEAP_LOG_DECOMMIT_FREE_BLOCK2: u32 = 6;
pub const HEAP_LOG_DECOMMIT_BLOCK: u32 = 7;
pub const HEAP_LOG_COMMIT_BLOCK: u32 = 8;
pub const HEAP_LOG_ALLOCATE_HEAP: u32 = 9;
pub const HEAP_LOG_COMMIT_AND_INITIALIZE_PAGES: u32 = 10;
pub const HEAP_LOG_ALLOCATE_SEGMENT_HEAP: u32 = 11;
pub const HEAP_LOG_ALLOCATE_NEW_SEGMENT: u32 = 12;
pub const HEAP_LOG_DECOMMIT_PAGE_RANGE: u32 = 13;
pub const UMS_ETW_DIRECTED_SWITCH_START_VOLATILE: u32 = 1;
pub const UMS_ETW_DIRECTED_SWITCH_END_FAST: u32 = 1;
pub const UMS_ETW_PARK_VOLATILE: u32 = 1;
pub const UMS_ETW_PARK_PRIMARY_PRESENT: u32 = 2;
pub const UMS_ETW_PARK_PRIMARY_DELIVERED_CONTEXT: u32 = 4;
pub const ETW_KTIMER2_HAS_CALLBACK: u32 = 1;
pub const ETW_KTIMER2_PERIODIC: u32 = 2;
pub const ETW_KTIMER2_IDLE_RESILIENT: u32 = 4;
pub const ETW_KTIMER2_HIGH_RESOLUTION: u32 = 8;
pub const ETW_KTIMER2_NO_WAKE: u32 = 16;
pub const ETW_KTIMER2_NO_WAKE_FINITE: u32 = 32;
pub const ETW_TIMER_COALESCABLE: u32 = 1;
pub const ETW_TIMER_DPC: u32 = 2;
pub const ETW_TIMER_IDLE_RESILIENT: u32 = 4;
pub const ETW_TIMER_HIGH_RESOLUTION: u32 = 8;
pub const ETW_TIMER_NO_WAKE: u32 = 16;
pub const ETW_DISABLE_KTIMER2_CANCEL: u32 = 1;
pub const ETW_DISABLE_KTIMER2_WAIT: u32 = 2;
pub const ETW_DISABLE_KTIMER2_DELAYED: u32 = 4;
pub const ETW_DISABLE_KTIMER2_HAS_DISABLE_CALLBACK: u32 = 8;
pub const CKCL_NAMEW: &[u8; 31] = b"Circular Kernel Context Logger\0";
pub const CKCL_NAMEA: &[u8; 31] = b"Circular Kernel Context Logger\0";
pub const AUDIT_LOGGER_NAMEW: &[u8; 18] = b"Eventlog-Security\0";
pub const AUDIT_LOGGER_NAMEA: &[u8; 18] = b"Eventlog-Security\0";
pub const PERFINFO_THREAD_SWAPABLE: u32 = 0;
pub const PERFINFO_THREAD_NONSWAPABLE: u32 = 1;
pub const PERFINFO_PPM_IDLE_FLAG_DUE_INTERRUPT: u32 = 1;
pub const PERFINFO_PPM_IDLE_FLAG_IR_RETRY: u32 = 2;
pub const PERFINFO_PPM_IDLE_FLAG_IR_ENABLED: u32 = 4;
pub const PERFINFO_PPM_IDLE_FLAG_CLOCK_OWNER: u32 = 8;
pub const PERFINFO_PPM_IDLE_FLAG_PLATFORM_ENTER: u32 = 16;
pub const PERFINFO_PPM_IDLE_FLAG_LOCK_PROCESSORS: u32 = 32;
pub const PERFINFO_PPM_IDLE_FLAG_CONSTRAINT_NI: u32 = 64;
pub const PERFINFO_PPM_IDLE_FLAG_CONSTRAINT_PLATFORM: u32 = 128;
pub const PERFINFO_PPM_IDLE_FLAG_OVERRIDE_ENABLED: u32 = 256;
pub const PERFINFO_PPM_IDLE_FLAG_MEASURING_EXIT_LATENCY: u32 = 512;
pub const PERFINFO_PPM_IDLE_FLAG_WAKE_REQUESTED: u32 = 1024;
pub const PERFINFO_PPM_IDLE_FLAG_IPI_CLOCK_OWNER: u32 = 2048;
pub const PERFINFO_PPM_IDLE_FLAG_PLATFORM_HINT_OVERRIDE: u32 = 4096;
pub const PERFINFO_PPM_IDLE_FLAG_DURATION_EXPIRATION: u32 = 8192;
pub const PERFINFO_PPM_IDLE_VETO_PREREGISTERED_VETO: u32 = 2147483648;
pub const PERFINFO_PPM_IDLE_VETO_WRONG_INITIATOR: u32 = 2147483649;
pub const PERFINFO_PPM_IDLE_VETO_SYSTEM_LATENCY: u32 = 2147483650;
pub const PERFINFO_PPM_IDLE_VETO_IDLE_DURATION: u32 = 2147483651;
pub const PERFINFO_PPM_IDLE_VETO_DEVICE_DEPENDENCY: u32 = 2147483652;
pub const PERFINFO_PPM_IDLE_VETO_PROCESSOR_DEPENDENCY: u32 = 2147483653;
pub const PERFINFO_PPM_IDLE_VETO_PLATFORM_ONLY: u32 = 2147483654;
pub const PERFINFO_PPM_IDLE_VETO_INTERRUPTIBLE: u32 = 2147483655;
pub const PERFINFO_PPM_IDLE_VETO_LEGACY_OVEERIDE: u32 = 2147483656;
pub const PERFINFO_PPM_IDLE_VETO_C_STATE_CHECK: u32 = 2147483657;
pub const PERFINFO_PPM_IDLE_VETO_NO_C_STATE: u32 = 2147483658;
pub const PERFINFO_PPM_IDLE_VETO_COORDINATED_DEPENDENCY: u32 = 2147483659;
pub const PERFINFO_PPM_IDLE_VETO_DISABLED_IN_MENU: u32 = 4294967294;
pub const PERFINFO_PPM_IDLE_VETO_ACTIVE_PROCESSOR: u32 = 4294967295;
pub const PERFINFO_PPM_IDLE_NON_INTERRUPTIBLE: u32 = 1;
pub const PERFINFO_PPM_IDLE_ALL_PROC_LOCKED: u32 = 2;
pub const PERFINFO_PPM_IDLE_EXIT_SAMPLE_INVALID: u32 = 4;
pub const PERFINFO_PPM_FREQUENCY_VOLTAGE_STATE: u32 = 1;
pub const PERFINFO_PPM_STOPCLOCK_THROTTLE_STATE: u32 = 2;
pub const PERFINFO_SAMPLED_PROFILE_CACHE_MAX: u32 = 20;
pub const PERFINFO_CLOCK_INTERRUPT_CLOCK_OWNER: u32 = 1;
pub const PERFINFO_CLOCK_INTERRUPT_TIMER_PENDING: u32 = 8;
pub const PERFINFO_IPI_APC_REQUEST: u32 = 1;
pub const PERFINFO_IPI_DPC_REQUEST: u32 = 2;
pub const PERFINFO_MM_KERNELMEMORY_USAGE_TYPE_BITS: u32 = 5;
pub const PERFINFO_MM_STAT_TYPE_BITS: u32 = 6;
pub const PERFINFO_CC_WORKQUEUE_FAST_TEARDOWN: u32 = 1;
pub const PERFINFO_CC_WORKQUEUE_EXPRESS: u32 = 2;
pub const PERFINFO_CC_WORKQUEUE_REGULAR: u32 = 3;
pub const PERFINFO_CC_WORKQUEUE_POST_TICK: u32 = 4;
pub const PERFINFO_CC_WORKQUEUE_ASYNC_READ: u32 = 5;
pub const PERFINFO_CC_WORKQUEUE_COMP_ASYNC_READ: u32 = 6;
pub const PERFINFO_CC_WORKITEM_TYPE_READAHEAD: u32 = 1;
pub const PERFINFO_CC_WORKITEM_TYPE_WRITEBEHIND: u32 = 2;
pub const PERFINFO_CC_WORKITEM_TYPE_LAZYWRITESCAN: u32 = 3;
pub const PERFINFO_CC_WORKITEM_TYPE_EVENT_SET: u32 = 4;
pub const PERFINFO_CC_FLUSH_DATA_IS_LAZY_WRITER: u32 = 1;
pub const PERFINFO_CC_FLUSH_DATA_FAST_LAZY_WRITE: u32 = 2;
pub const PERFINFO_CC_FLUSH_DATA_FORCE_FULL_FLUSH: u32 = 4;
pub const PERFINFO_CC_NOTIFY_LOW_MEMORY: u32 = 1;
pub const PERFINFO_CC_NOTIFY_POWER: u32 = 2;
pub const PERFINFO_CC_NOTIFY_PERIODIC_SCAN: u32 = 4;
pub const PERFINFO_CC_NOTIFY_WAITING_TEARDOWN: u32 = 8;
pub const PERFINFO_CC_NOTIFY_FLUSH_DURING_COALESCING: u32 = 16;
pub const PERFINFO_CC_EXTRA_WB_THREAD_ADD: u32 = 1;
pub const PERFINFO_CC_EXTRA_WB_THREAD_REMOVE: u32 = 2;
pub const PERFINFO_FILE_READ_WRITE_FLAG_MDL: u32 = 1;
pub const PERFINFO_PAGE_PRIORITY_LEVELS: u32 = 8;
pub const PERFINFO_CCSWAP_BIT_TYPE: u32 = 2;
pub const PERFINFO_CCSWAP_BIT_TID: u32 = 4;
pub const PERFINFO_CCSWAP_BIT_STATE_WR: u32 = 6;
pub const PERFINFO_CCSWAP_BIT_PRIORITY: u32 = 5;
pub const PERFINFO_CCSWAP_BIT_PRI_INC: u32 = 3;
pub const PERFINFO_CCSWAP_BIT_FULL_TS: u32 = 30;
pub const PERFINFO_CCSWAP_BIT_SHORT_TS: u32 = 14;
pub const PERFINFO_CCSWAP_BIT_SMALL_TS: u32 = 17;
pub const PERFINFO_CCSWAP_BIT_WAIT_TIME: u32 = 17;
pub const PERFINFO_CCSWAP_MAX_TID: u32 = 16;
pub const TLG_KERNEL_PSPROV_KEYWORD_PROCESS: u32 = 1;
pub const TLG_KERNEL_PSPROV_KEYWORD_UTC: u32 = 2;
pub const ETW_SYSTEM_EVENT_VERSION_MASK: u32 = 255;
pub const ETW_SYSTEM_EVENT_V1: u32 = 1;
pub const ETW_SYSTEM_EVENT_V2: u32 = 2;
pub const ETW_SYSTEM_EVENT_V3: u32 = 3;
pub const ETW_SYSTEM_EVENT_V4: u32 = 4;
pub const ETW_SYSTEM_EVENT_V5: u32 = 5;
pub const ETW_SYSTEM_EVENT_V6: u32 = 6;
pub const ETW_NT_TRACE_TYPE_MASK: u32 = 65280;
pub const ETW_NT_FLAGS_TRACE_HEADER: u32 = 256;
pub const ETW_NT_FLAGS_TRACE_MESSAGE: u32 = 512;
pub const ETW_NT_FLAGS_TRACE_EVENT: u32 = 768;
pub const ETW_NT_FLAGS_TRACE_SYSTEM: u32 = 1024;
pub const ETW_NT_FLAGS_TRACE_SECURITY: u32 = 1280;
pub const ETW_NT_FLAGS_TRACE_MARK: u32 = 1536;
pub const ETW_NT_FLAGS_TRACE_EVENT_NOREG: u32 = 1792;
pub const ETW_NT_FLAGS_TRACE_INSTANCE: u32 = 2048;
pub const ETW_NT_FLAGS_USE_NATIVE_HEADER: u32 = 1073741824;
pub const ETW_NT_FLAGS_WOW64_CALL: u32 = 2147483648;
pub const ETW_USER_FRAMES_TO_SKIP_MASK: u32 = 983040;
pub const ETW_USER_FRAMES_TO_SKIP_SHIFT: u32 = 16;
pub const ETW_NT_FLAGS_TRACE_SYSTEM_V1: u32 = 1025;
pub const ETW_NT_FLAGS_TRACE_SYSTEM_V2: u32 = 1026;
pub const ETW_NT_FLAGS_TRACE_SYSTEM_V3: u32 = 1027;
pub const ETW_NT_FLAGS_TRACE_SYSTEM_V4: u32 = 1028;
pub const ETW_NT_FLAGS_TRACE_SYSTEM_V5: u32 = 1029;
pub const ETW_UMGL_INDEX_HEAP: u32 = 0;
pub const ETW_UMGL_INDEX_CRITSEC: u32 = 1;
pub const ETW_UMGL_INDEX_LDR: u32 = 2;
pub const ETW_UMGL_INDEX_THREAD_POOL: u32 = 3;
pub const ETW_UMGL_INDEX_HEAPRANGE: u32 = 4;
pub const ETW_UMGL_INDEX_HEAPSUMMARY: u32 = 5;
pub const ETW_UMGL_INDEX_UMS: u32 = 6;
pub const ETW_UMGL_INDEX_WNF: u32 = 7;
pub const ETW_UMGL_INDEX_THREAD: u32 = 8;
pub const ETW_UMGL_INDEX_SPARE2: u32 = 9;
pub const ETW_UMGL_INDEX_SPARE3: u32 = 10;
pub const ETW_UMGL_INDEX_SPARE4: u32 = 11;
pub const ETW_UMGL_INDEX_SPARE5: u32 = 12;
pub const ETW_UMGL_INDEX_SPARE6: u32 = 13;
pub const ETW_UMGL_INDEX_SPARE7: u32 = 14;
pub const ETW_UMGL_INDEX_SPARE8: u32 = 15;
pub const ETW_UMGL_MAX_PROVIDERS: u32 = 9;
pub const ETW_UMGL_LDR_MUI_VERBOSE_FLAG: u32 = 1;
pub const ETW_UMGL_LDR_MUI_TEST_FLAG: u32 = 2;
pub const ETW_UMGL_LDR_RELOCATION_FLAG: u32 = 4;
pub const ETW_UMGL_LDR_NEW_DLL_FLAG: u32 = 16;
pub const ETW_UMGL_LDR_TEST_FLAG: u32 = 32;
pub const ETW_UMGL_LDR_SECURITY_FLAG: u32 = 64;
pub const MEMORY_FROM_LOOKASIDE: u32 = 1;
pub const MEMORY_FROM_LOWFRAG: u32 = 2;
pub const MEMORY_FROM_MAINPATH: u32 = 3;
pub const MEMORY_FROM_SLOWPATH: u32 = 4;
pub const MEMORY_FROM_INVALID: u32 = 5;
pub const MEMORY_FROM_SEGMENT_HEAP: u32 = 6;
pub const TRACE_HEADER_FULL32: u32 = 3221880832;
pub const TRACE_HEADER_FULL64: u32 = 3222536192;
pub const TRACE_HEADER_INSTANCE32: u32 = 3221946368;
pub const TRACE_HEADER_INSTANCE64: u32 = 3222601728;
pub const TRACE_HEADER_FULL: u32 = 3222536192;
pub const TRACE_HEADER_INSTANCE: u32 = 3222601728;
pub const EVENT_TRACE_USE_RAWTIMESTAMP: u32 = 2;
pub const EVENT_TRACE_GET_RAWEVENT: u32 = 256;
pub const EVENT_TRACE_READ_BEHIND: u32 = 512;
pub const EVENT_TRACE_USE_SEQUENCE: u32 = 4;
pub const ETW_KERNEL_EVENT_VERSION: u32 = 60;
pub const ETW_SET_MARK_WITH_FLUSH: u32 = 1;
pub const ETW_MAX_DATA_BLOCK_BUFFER_SIZE: u32 = 65536;
pub const NOTIFICATION_TRACE_FLAG: u32 = 65536;
pub const NOTIFICATION_CALLBACK_DIRECT: u32 = 4;
pub const NOTIFICATION_CHECK_ACCESS: u32 = 8;
pub const NOTIFICATION_LIGHTWEIGHT_FLAG: u32 = 32;
pub const MOFCI_RESERVED0: u32 = 1;
pub const MOFCI_RESERVED1: u32 = 2;
pub const MOFCI_RESERVED2: u32 = 4;
pub const CPI_NEWPROCESSWINDOW: u32 = 1;
pub type va_list = *mut ::core::ffi::c_char;
pub type wchar_t = ::core::ffi::c_ushort;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EXCEPTION_DISPOSITION {
   ExceptionContinueExecution = 0,
   ExceptionContinueSearch = 1,
   ExceptionNestedException = 2,
   ExceptionCollidedUnwind = 3,
}
pub use self::_EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION;
pub type ULONG = ::core::ffi::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = ::core::ffi::c_ushort;
pub type PUSHORT = *mut USHORT;
pub type UCHAR = ::core::ffi::c_uchar;
pub type PUCHAR = *mut UCHAR;
pub type DWORD = ::core::ffi::c_ulong;
pub type BYTE = ::core::ffi::c_uchar;
pub type WORD = ::core::ffi::c_ushort;
pub type PBOOL = *mut BOOL;
pub type PDWORD = *mut DWORD;
pub type LPVOID = *mut ::core::ffi::c_void;
pub type UINT = ::core::ffi::c_uint;
pub type ULONG32 = ::core::ffi::c_uint;
pub type UINT_PTR = ::core::ffi::c_ulonglong;
pub type LONG_PTR = ::core::ffi::c_longlong;
pub type ULONG_PTR = ::core::ffi::c_ulonglong;
pub type PULONG_PTR = *mut ::core::ffi::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type LONG64 = ::core::ffi::c_longlong;
pub type PLONG64 = *mut ::core::ffi::c_longlong;
pub type ULONG64 = ::core::ffi::c_ulonglong;
pub type PULONG64 = *mut ::core::ffi::c_ulonglong;
pub type DWORD64 = ::core::ffi::c_ulonglong;
pub type PDWORD64 = *mut ::core::ffi::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PVOID = *mut ::core::ffi::c_void;
pub type CHAR = ::core::ffi::c_char;
pub type SHORT = ::core::ffi::c_short;
pub type LONG = ::core::ffi::c_long;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type PCWCH = *const WCHAR;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PCHAR = *mut CHAR;
pub type PCH = *mut CHAR;
pub type PCCH = *const CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PCSTR = *const CHAR;
pub type PLONG = *mut LONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_NUMBER {
   pub Group: WORD,
   pub Number: BYTE,
   pub Reserved: BYTE,
}
pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GROUP_AFFINITY {
   pub Mask: KAFFINITY,
   pub Group: WORD,
   pub Reserved: [WORD; 3usize],
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
pub type HANDLE = *mut ::core::ffi::c_void;
pub type PHANDLE = *mut HANDLE;
pub type CCHAR = ::core::ffi::c_char;
pub type LCID = DWORD;
pub type PLCID = PDWORD;
pub type LANGID = WORD;
pub type LONGLONG = ::core::ffi::c_longlong;
pub type ULONGLONG = ::core::ffi::c_ulonglong;
pub type PULONGLONG = *mut ULONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
   pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
   pub u: _LARGE_INTEGER__bindgen_ty_2,
   pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
   pub LowPart: DWORD,
   pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
   pub LowPart: DWORD,
   pub HighPart: LONG,
}
impl Default for _LARGE_INTEGER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
   pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
   pub u: _ULARGE_INTEGER__bindgen_ty_2,
   pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
   pub LowPart: DWORD,
   pub HighPart: DWORD,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
   pub LowPart: DWORD,
   pub HighPart: DWORD,
}
impl Default for _ULARGE_INTEGER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LUID {
   pub LowPart: DWORD,
   pub HighPart: LONG,
}
pub type LUID = _LUID;
pub type PLUID = *mut _LUID;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
   pub Flink: *mut _LIST_ENTRY,
   pub Blink: *mut _LIST_ENTRY,
}
impl Default for _LIST_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
   pub Next: *mut _SINGLE_LIST_ENTRY,
}
impl Default for _SINGLE_LIST_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LIST_ENTRY32 {
   pub Flink: DWORD,
   pub Blink: DWORD,
}
pub type PLIST_ENTRY32 = *mut LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GUID {
   pub Data1: ::core::ffi::c_ulong,
   pub Data2: ::core::ffi::c_ushort,
   pub Data3: ::core::ffi::c_ushort,
   pub Data4: [::core::ffi::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type PEXCEPTION_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      arg1: *mut _EXCEPTION_RECORD,
      arg2: PVOID,
      arg3: *mut _CONTEXT,
      arg4: PVOID,
   ) -> EXCEPTION_DISPOSITION,
>;
pub type __C_ASSERT__ = [::core::ffi::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSAVE_AREA_HEADER {
   pub Mask: DWORD64,
   pub CompactionMask: DWORD64,
   pub Reserved2: [DWORD64; 6usize],
}
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARM64_NT_NEON128 {
   pub __bindgen_anon_1: _ARM64_NT_NEON128__bindgen_ty_1,
   pub D: [f64; 2usize],
   pub S: [f32; 4usize],
   pub H: [WORD; 8usize],
   pub B: [BYTE; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ARM64_NT_NEON128__bindgen_ty_1 {
   pub Low: ULONGLONG,
   pub High: LONGLONG,
}
impl Default for _ARM64_NT_NEON128 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ARM64_NT_NEON128 = _ARM64_NT_NEON128;
pub type NEON128 = ARM64_NT_NEON128;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _CONTEXT {
   pub ContextFlags: DWORD,
   pub Cpsr: DWORD,
   pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1,
   pub Sp: DWORD64,
   pub Pc: DWORD64,
   pub V: [NEON128; 32usize],
   pub Fpcr: DWORD,
   pub Fpsr: DWORD,
   pub Bcr: [DWORD; 8usize],
   pub Bvr: [DWORD64; 8usize],
   pub Wcr: [DWORD; 2usize],
   pub Wvr: [DWORD64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTEXT__bindgen_ty_1 {
   pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1__bindgen_ty_1,
   pub X: [DWORD64; 31usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   pub X0: DWORD64,
   pub X1: DWORD64,
   pub X2: DWORD64,
   pub X3: DWORD64,
   pub X4: DWORD64,
   pub X5: DWORD64,
   pub X6: DWORD64,
   pub X7: DWORD64,
   pub X8: DWORD64,
   pub X9: DWORD64,
   pub X10: DWORD64,
   pub X11: DWORD64,
   pub X12: DWORD64,
   pub X13: DWORD64,
   pub X14: DWORD64,
   pub X15: DWORD64,
   pub X16: DWORD64,
   pub X17: DWORD64,
   pub X18: DWORD64,
   pub X19: DWORD64,
   pub X20: DWORD64,
   pub X21: DWORD64,
   pub X22: DWORD64,
   pub X23: DWORD64,
   pub X24: DWORD64,
   pub X25: DWORD64,
   pub X26: DWORD64,
   pub X27: DWORD64,
   pub X28: DWORD64,
   pub Fp: DWORD64,
   pub Lr: DWORD64,
}
impl Default for _CONTEXT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ARM64_NT_CONTEXT = _CONTEXT;
pub type CONTEXT = ARM64_NT_CONTEXT;
pub type PCONTEXT = *mut ARM64_NT_CONTEXT;
pub type PARM64_RUNTIME_FUNCTION = *mut _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub type PRUNTIME_FUNCTION = *mut _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub type GET_RUNTIME_FUNCTION_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(ControlPc: DWORD64, Context: PVOID) -> PARM64_RUNTIME_FUNCTION,
>;
pub type PGET_RUNTIME_FUNCTION_CALLBACK = GET_RUNTIME_FUNCTION_CALLBACK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDT_ENTRY {
   pub LimitLow: WORD,
   pub BaseLow: WORD,
   pub HighWord: _LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDT_ENTRY__bindgen_ty_1 {
   pub Bytes: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
   pub Bits: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub BaseMid: BYTE,
   pub Flags1: BYTE,
   pub Flags2: BYTE,
   pub BaseHi: BYTE,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   #[inline]
   pub fn BaseMid(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_BaseMid(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BaseMid_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BaseMid_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Type(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Type_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            5u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Type_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            5u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Dpl(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Dpl(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Dpl_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Dpl_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Pres(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Pres(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Pres_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Pres_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LimitHi(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_LimitHi(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LimitHi_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LimitHi_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Sys(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Sys(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Sys_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Sys_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved_0(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved_0(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_0_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            21usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_0_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            21usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Default_Big(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Default_Big(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Default_Big_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            22usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Default_Big_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            22usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Granularity(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Granularity(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Granularity_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            23usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Granularity_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            23usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BaseHi(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_BaseHi(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BaseHi_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BaseHi_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      BaseMid: DWORD,
      Type: DWORD,
      Dpl: DWORD,
      Pres: DWORD,
      LimitHi: DWORD,
      Sys: DWORD,
      Reserved_0: DWORD,
      Default_Big: DWORD,
      Granularity: DWORD,
      BaseHi: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let BaseMid: u32 = unsafe { ::core::mem::transmute(BaseMid) };
         BaseMid as u64
      });
      __bindgen_bitfield_unit.set(8usize, 5u8, {
         let Type: u32 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(13usize, 2u8, {
         let Dpl: u32 = unsafe { ::core::mem::transmute(Dpl) };
         Dpl as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let Pres: u32 = unsafe { ::core::mem::transmute(Pres) };
         Pres as u64
      });
      __bindgen_bitfield_unit.set(16usize, 4u8, {
         let LimitHi: u32 = unsafe { ::core::mem::transmute(LimitHi) };
         LimitHi as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let Sys: u32 = unsafe { ::core::mem::transmute(Sys) };
         Sys as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let Reserved_0: u32 = unsafe { ::core::mem::transmute(Reserved_0) };
         Reserved_0 as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let Default_Big: u32 = unsafe { ::core::mem::transmute(Default_Big) };
         Default_Big as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let Granularity: u32 = unsafe { ::core::mem::transmute(Granularity) };
         Granularity as u64
      });
      __bindgen_bitfield_unit.set(24usize, 8u8, {
         let BaseHi: u32 = unsafe { ::core::mem::transmute(BaseHi) };
         BaseHi as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _LDT_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDT_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDT_ENTRY = _LDT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_FLOATING_SAVE_AREA {
   pub ControlWord: DWORD,
   pub StatusWord: DWORD,
   pub TagWord: DWORD,
   pub ErrorOffset: DWORD,
   pub ErrorSelector: DWORD,
   pub DataOffset: DWORD,
   pub DataSelector: DWORD,
   pub RegisterArea: [BYTE; 80usize],
   pub Cr0NpxState: DWORD,
}
impl Default for _WOW64_FLOATING_SAVE_AREA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64_FLOATING_SAVE_AREA = _WOW64_FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_CONTEXT {
   pub ContextFlags: DWORD,
   pub Dr0: DWORD,
   pub Dr1: DWORD,
   pub Dr2: DWORD,
   pub Dr3: DWORD,
   pub Dr6: DWORD,
   pub Dr7: DWORD,
   pub FloatSave: WOW64_FLOATING_SAVE_AREA,
   pub SegGs: DWORD,
   pub SegFs: DWORD,
   pub SegEs: DWORD,
   pub SegDs: DWORD,
   pub Edi: DWORD,
   pub Esi: DWORD,
   pub Ebx: DWORD,
   pub Edx: DWORD,
   pub Ecx: DWORD,
   pub Eax: DWORD,
   pub Ebp: DWORD,
   pub Eip: DWORD,
   pub SegCs: DWORD,
   pub EFlags: DWORD,
   pub Esp: DWORD,
   pub SegSs: DWORD,
   pub ExtendedRegisters: [BYTE; 512usize],
}
impl Default for _WOW64_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64_CONTEXT = _WOW64_CONTEXT;
pub type PWOW64_CONTEXT = *mut WOW64_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
   pub ExceptionCode: DWORD,
   pub ExceptionFlags: DWORD,
   pub ExceptionRecord: *mut _EXCEPTION_RECORD,
   pub ExceptionAddress: PVOID,
   pub NumberParameters: DWORD,
   pub ExceptionInformation: [ULONG_PTR; 15usize],
}
impl Default for _EXCEPTION_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
   pub ExceptionRecord: PEXCEPTION_RECORD,
   pub ContextRecord: PCONTEXT,
}
impl Default for _EXCEPTION_POINTERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = DWORD;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GENERIC_MAPPING {
   pub GenericRead: ACCESS_MASK,
   pub GenericWrite: ACCESS_MASK,
   pub GenericExecute: ACCESS_MASK,
   pub GenericAll: ACCESS_MASK,
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
   pub Luid: LUID,
   pub Attributes: DWORD,
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
   pub Value: [BYTE; 6usize],
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SID {
   pub Revision: BYTE,
   pub SubAuthorityCount: BYTE,
   pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
   pub SubAuthority: [DWORD; 1usize],
}
pub type SID = _SID;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SID_NAME_USE {
   SidTypeUser = 1,
   SidTypeGroup = 2,
   SidTypeDomain = 3,
   SidTypeAlias = 4,
   SidTypeWellKnownGroup = 5,
   SidTypeDeletedAccount = 6,
   SidTypeInvalid = 7,
   SidTypeUnknown = 8,
   SidTypeComputer = 9,
   SidTypeLabel = 10,
   SidTypeLogonSession = 11,
}
pub use self::_SID_NAME_USE as SID_NAME_USE;
pub type PSID_NAME_USE = *mut _SID_NAME_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
   pub Sid: PSID,
   pub Attributes: DWORD,
}
impl Default for _SID_AND_ATTRIBUTES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_HASH_ENTRY = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
   pub SidCount: DWORD,
   pub SidAttr: PSID_AND_ATTRIBUTES,
   pub Hash: [SID_HASH_ENTRY; 32usize],
}
impl Default for _SID_AND_ATTRIBUTES_HASH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PSID_AND_ATTRIBUTES_HASH = *mut _SID_AND_ATTRIBUTES_HASH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACL {
   pub AclRevision: BYTE,
   pub Sbz1: BYTE,
   pub AclSize: WORD,
   pub AceCount: WORD,
   pub Sbz2: WORD,
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACE_HEADER {
   pub AceType: BYTE,
   pub AceFlags: BYTE,
   pub AceSize: WORD,
}
pub type ACE_HEADER = _ACE_HEADER;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ACL_INFORMATION_CLASS {
   AclRevisionInformation = 1,
   AclSizeInformation = 2,
}
pub use self::_ACL_INFORMATION_CLASS as ACL_INFORMATION_CLASS;
pub type SECURITY_DESCRIPTOR_CONTROL = WORD;
pub type PSECURITY_DESCRIPTOR_CONTROL = *mut WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_LIST {
   pub Level: WORD,
   pub Sbz: WORD,
   pub ObjectType: *mut GUID,
}
impl Default for _OBJECT_TYPE_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _AUDIT_EVENT_TYPE {
   AuditEventObjectAccess = 0,
   AuditEventDirectoryServiceAccess = 1,
}
pub use self::_AUDIT_EVENT_TYPE as AUDIT_EVENT_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PRIVILEGE_SET {
   pub PrivilegeCount: DWORD,
   pub Control: DWORD,
   pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_IMPERSONATION_LEVEL {
   SecurityAnonymous = 0,
   SecurityIdentification = 1,
   SecurityImpersonation = 2,
   SecurityDelegation = 3,
}
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_TYPE {
   TokenPrimary = 1,
   TokenImpersonation = 2,
}
pub use self::_TOKEN_TYPE as TOKEN_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER {
   pub User: SID_AND_ATTRIBUTES,
}
impl Default for _TOKEN_USER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_USER = *mut _TOKEN_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS {
   pub GroupCount: DWORD,
   pub Groups: [SID_AND_ATTRIBUTES; 1usize],
}
impl Default for _TOKEN_GROUPS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_GROUPS = *mut _TOKEN_GROUPS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_PRIVILEGES {
   pub PrivilegeCount: DWORD,
   pub Privileges: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PTOKEN_PRIVILEGES = *mut _TOKEN_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_OWNER {
   pub Owner: PSID,
}
impl Default for _TOKEN_OWNER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_OWNER = *mut _TOKEN_OWNER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIMARY_GROUP {
   pub PrimaryGroup: PSID,
}
impl Default for _TOKEN_PRIMARY_GROUP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_PRIMARY_GROUP = *mut _TOKEN_PRIMARY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEFAULT_DACL {
   pub DefaultDacl: PACL,
}
impl Default for _TOKEN_DEFAULT_DACL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTOKEN_DEFAULT_DACL = *mut _TOKEN_DEFAULT_DACL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_MANDATORY_POLICY {
   pub Policy: DWORD,
}
pub type PTOKEN_MANDATORY_POLICY = *mut _TOKEN_MANDATORY_POLICY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TOKEN_SOURCE {
   pub SourceName: [CHAR; 8usize],
   pub SourceIdentifier: LUID,
}
pub type PTOKEN_SOURCE = *mut _TOKEN_SOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
   pub Version: DWORD64,
   pub Name: PWSTR,
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
   pub pValue: PVOID,
   pub ValueLength: DWORD,
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
   *mut _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
   pub Name: PWSTR,
   pub ValueType: WORD,
   pub Reserved: WORD,
   pub Flags: DWORD,
   pub ValueCount: DWORD,
   pub Values: _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
   pub pInt64: PLONG64,
   pub pUint64: PDWORD64,
   pub ppString: *mut PWSTR,
   pub pFqbn: PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
   pub pOctetString: PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _CLAIM_SECURITY_ATTRIBUTE_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCLAIM_SECURITY_ATTRIBUTE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
   pub Version: WORD,
   pub Reserved: WORD,
   pub AttributeCount: DWORD,
   pub Attribute: _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
   pub pAttributeV1: PCLAIM_SECURITY_ATTRIBUTE_V1,
}
impl Default for _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = *mut _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
#[repr(C)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
   pub Length: DWORD,
   pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
   pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
   pub EffectiveOnly: BOOLEAN,
}
impl Default for _SECURITY_QUALITY_OF_SERVICE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
pub type SECURITY_INFORMATION = DWORD;
pub type SE_SIGNING_LEVEL = BYTE;
pub type PSE_SIGNING_LEVEL = *mut BYTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_SET_ARRAY {
   pub JobHandle: HANDLE,
   pub MemberLevel: DWORD,
   pub Flags: DWORD,
}
impl Default for _JOB_SET_ARRAY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PJOB_SET_ARRAY = *mut _JOB_SET_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
   pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
   pub Handler: PEXCEPTION_ROUTINE,
}
impl Default for _EXCEPTION_REGISTRATION_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
   pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
   pub StackBase: PVOID,
   pub StackLimit: PVOID,
   pub SubSystemTib: PVOID,
   pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
   pub ArbitraryUserPointer: PVOID,
   pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
   pub FiberData: PVOID,
   pub Version: DWORD,
}
impl Default for _NT_TIB__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _NT_TIB {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NT_TIB = _NT_TIB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
   pub ExceptionList: DWORD,
   pub StackBase: DWORD,
   pub StackLimit: DWORD,
   pub SubSystemTib: DWORD,
   pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
   pub ArbitraryUserPointer: DWORD,
   pub Self_: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
   pub FiberData: DWORD,
   pub Version: DWORD,
}
impl Default for _NT_TIB32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _NT_TIB32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NT_TIB32 = _NT_TIB32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_COUNTERS {
   pub ReadOperationCount: ULONGLONG,
   pub WriteOperationCount: ULONGLONG,
   pub OtherOperationCount: ULONGLONG,
   pub ReadTransferCount: ULONGLONG,
   pub WriteTransferCount: ULONGLONG,
   pub OtherTransferCount: ULONGLONG,
}
pub type IO_COUNTERS = _IO_COUNTERS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HARDWARE_COUNTER_TYPE {
   PMCCounter = 0,
   MaxHardwareCounterType = 1,
}
pub use self::_HARDWARE_COUNTER_TYPE as HARDWARE_COUNTER_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_MITIGATION_POLICY {
   ProcessDEPPolicy = 0,
   ProcessASLRPolicy = 1,
   ProcessDynamicCodePolicy = 2,
   ProcessStrictHandleCheckPolicy = 3,
   ProcessSystemCallDisablePolicy = 4,
   ProcessMitigationOptionsMask = 5,
   ProcessExtensionPointDisablePolicy = 6,
   ProcessControlFlowGuardPolicy = 7,
   ProcessSignaturePolicy = 8,
   ProcessFontDisablePolicy = 9,
   ProcessImageLoadPolicy = 10,
   ProcessSystemCallFilterPolicy = 11,
   ProcessPayloadRestrictionPolicy = 12,
   ProcessChildProcessPolicy = 13,
   ProcessSideChannelIsolationPolicy = 14,
   ProcessUserShadowStackPolicy = 15,
   ProcessRedirectionTrustPolicy = 16,
   ProcessUserPointerAuthPolicy = 17,
   ProcessSEHOPPolicy = 18,
   ProcessActivationContextTrustPolicy = 19,
   MaxProcessMitigationPolicy = 20,
}
pub use self::_PROCESS_MITIGATION_POLICY as PROCESS_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableBottomUpRandomization(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableBottomUpRandomization(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableBottomUpRandomization_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableBottomUpRandomization_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableForceRelocateImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableForceRelocateImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableForceRelocateImages_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableForceRelocateImages_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableHighEntropy(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableHighEntropy(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableHighEntropy_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableHighEntropy_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DisallowStrippedImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisallowStrippedImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisallowStrippedImages_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DisallowStrippedImages_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableBottomUpRandomization: DWORD,
      EnableForceRelocateImages: DWORD,
      EnableHighEntropy: DWORD,
      DisallowStrippedImages: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableBottomUpRandomization: u32 =
            unsafe { ::core::mem::transmute(EnableBottomUpRandomization) };
         EnableBottomUpRandomization as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnableForceRelocateImages: u32 =
            unsafe { ::core::mem::transmute(EnableForceRelocateImages) };
         EnableForceRelocateImages as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let EnableHighEntropy: u32 = unsafe { ::core::mem::transmute(EnableHighEntropy) };
         EnableHighEntropy as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DisallowStrippedImages: u32 =
            unsafe { ::core::mem::transmute(DisallowStrippedImages) };
         DisallowStrippedImages as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_ASLR_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableSehop(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableSehop(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableSehop_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableSehop_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableSehop: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableSehop: u32 = unsafe { ::core::mem::transmute(EnableSehop) };
         EnableSehop as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_SEHOP_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_SEHOP_POLICY = _PROCESS_MITIGATION_SEHOP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn RaiseExceptionOnInvalidHandleReference(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RaiseExceptionOnInvalidHandleReference(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RaiseExceptionOnInvalidHandleReference_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RaiseExceptionOnInvalidHandleReference_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HandleExceptionsPermanentlyEnabled(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HandleExceptionsPermanentlyEnabled(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HandleExceptionsPermanentlyEnabled_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HandleExceptionsPermanentlyEnabled_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      RaiseExceptionOnInvalidHandleReference: DWORD,
      HandleExceptionsPermanentlyEnabled: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let RaiseExceptionOnInvalidHandleReference: u32 =
            unsafe { ::core::mem::transmute(RaiseExceptionOnInvalidHandleReference) };
         RaiseExceptionOnInvalidHandleReference as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let HandleExceptionsPermanentlyEnabled: u32 =
            unsafe { ::core::mem::transmute(HandleExceptionsPermanentlyEnabled) };
         HandleExceptionsPermanentlyEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
   _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn DisallowWin32kSystemCalls(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisallowWin32kSystemCalls(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisallowWin32kSystemCalls_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DisallowWin32kSystemCalls_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditDisallowWin32kSystemCalls(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditDisallowWin32kSystemCalls(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditDisallowWin32kSystemCalls_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditDisallowWin32kSystemCalls_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DisallowFsctlSystemCalls(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisallowFsctlSystemCalls(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisallowFsctlSystemCalls_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DisallowFsctlSystemCalls_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditDisallowFsctlSystemCalls(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditDisallowFsctlSystemCalls(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditDisallowFsctlSystemCalls_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditDisallowFsctlSystemCalls_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DisallowWin32kSystemCalls: DWORD,
      AuditDisallowWin32kSystemCalls: DWORD,
      DisallowFsctlSystemCalls: DWORD,
      AuditDisallowFsctlSystemCalls: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DisallowWin32kSystemCalls: u32 =
            unsafe { ::core::mem::transmute(DisallowWin32kSystemCalls) };
         DisallowWin32kSystemCalls as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditDisallowWin32kSystemCalls: u32 =
            unsafe { ::core::mem::transmute(AuditDisallowWin32kSystemCalls) };
         AuditDisallowWin32kSystemCalls as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DisallowFsctlSystemCalls: u32 =
            unsafe { ::core::mem::transmute(DisallowFsctlSystemCalls) };
         DisallowFsctlSystemCalls as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditDisallowFsctlSystemCalls: u32 =
            unsafe { ::core::mem::transmute(AuditDisallowFsctlSystemCalls) };
         AuditDisallowFsctlSystemCalls as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
   _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1:
      _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn DisableExtensionPoints(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisableExtensionPoints(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisableExtensionPoints_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DisableExtensionPoints_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DisableExtensionPoints: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DisableExtensionPoints: u32 =
            unsafe { ::core::mem::transmute(DisableExtensionPoints) };
         DisableExtensionPoints as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
   _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ProhibitDynamicCode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProhibitDynamicCode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProhibitDynamicCode_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProhibitDynamicCode_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AllowThreadOptOut(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AllowThreadOptOut(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AllowThreadOptOut_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AllowThreadOptOut_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AllowRemoteDowngrade(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AllowRemoteDowngrade(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AllowRemoteDowngrade_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AllowRemoteDowngrade_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditProhibitDynamicCode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditProhibitDynamicCode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditProhibitDynamicCode_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditProhibitDynamicCode_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ProhibitDynamicCode: DWORD,
      AllowThreadOptOut: DWORD,
      AllowRemoteDowngrade: DWORD,
      AuditProhibitDynamicCode: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ProhibitDynamicCode: u32 = unsafe { ::core::mem::transmute(ProhibitDynamicCode) };
         ProhibitDynamicCode as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AllowThreadOptOut: u32 = unsafe { ::core::mem::transmute(AllowThreadOptOut) };
         AllowThreadOptOut as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let AllowRemoteDowngrade: u32 = unsafe { ::core::mem::transmute(AllowRemoteDowngrade) };
         AllowRemoteDowngrade as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditProhibitDynamicCode: u32 =
            unsafe { ::core::mem::transmute(AuditProhibitDynamicCode) };
         AuditProhibitDynamicCode as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableControlFlowGuard(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableControlFlowGuard(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableControlFlowGuard_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableControlFlowGuard_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableExportSuppression(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableExportSuppression(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableExportSuppression_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableExportSuppression_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn StrictMode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_StrictMode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StrictMode_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StrictMode_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableXfg(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableXfg(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableXfg_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableXfg_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableXfgAuditMode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableXfgAuditMode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableXfgAuditMode_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableXfgAuditMode_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableControlFlowGuard: DWORD,
      EnableExportSuppression: DWORD,
      StrictMode: DWORD,
      EnableXfg: DWORD,
      EnableXfgAuditMode: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableControlFlowGuard: u32 =
            unsafe { ::core::mem::transmute(EnableControlFlowGuard) };
         EnableControlFlowGuard as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnableExportSuppression: u32 =
            unsafe { ::core::mem::transmute(EnableExportSuppression) };
         EnableExportSuppression as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let StrictMode: u32 = unsafe { ::core::mem::transmute(StrictMode) };
         StrictMode as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let EnableXfg: u32 = unsafe { ::core::mem::transmute(EnableXfg) };
         EnableXfg as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let EnableXfgAuditMode: u32 = unsafe { ::core::mem::transmute(EnableXfgAuditMode) };
         EnableXfgAuditMode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
   _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn MicrosoftSignedOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MicrosoftSignedOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MicrosoftSignedOnly_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MicrosoftSignedOnly_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn StoreSignedOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_StoreSignedOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StoreSignedOnly_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StoreSignedOnly_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MitigationOptIn(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MitigationOptIn(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MitigationOptIn_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MitigationOptIn_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditMicrosoftSignedOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditMicrosoftSignedOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditMicrosoftSignedOnly_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditMicrosoftSignedOnly_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditStoreSignedOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditStoreSignedOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditStoreSignedOnly_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditStoreSignedOnly_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      MicrosoftSignedOnly: DWORD,
      StoreSignedOnly: DWORD,
      MitigationOptIn: DWORD,
      AuditMicrosoftSignedOnly: DWORD,
      AuditStoreSignedOnly: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let MicrosoftSignedOnly: u32 = unsafe { ::core::mem::transmute(MicrosoftSignedOnly) };
         MicrosoftSignedOnly as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let StoreSignedOnly: u32 = unsafe { ::core::mem::transmute(StoreSignedOnly) };
         StoreSignedOnly as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let MitigationOptIn: u32 = unsafe { ::core::mem::transmute(MitigationOptIn) };
         MitigationOptIn as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditMicrosoftSignedOnly: u32 =
            unsafe { ::core::mem::transmute(AuditMicrosoftSignedOnly) };
         AuditMicrosoftSignedOnly as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let AuditStoreSignedOnly: u32 = unsafe { ::core::mem::transmute(AuditStoreSignedOnly) };
         AuditStoreSignedOnly as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn DisableNonSystemFonts(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisableNonSystemFonts(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisableNonSystemFonts_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DisableNonSystemFonts_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditNonSystemFontLoading(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditNonSystemFontLoading(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditNonSystemFontLoading_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditNonSystemFontLoading_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DisableNonSystemFonts: DWORD,
      AuditNonSystemFontLoading: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DisableNonSystemFonts: u32 = unsafe { ::core::mem::transmute(DisableNonSystemFonts) };
         DisableNonSystemFonts as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditNonSystemFontLoading: u32 =
            unsafe { ::core::mem::transmute(AuditNonSystemFontLoading) };
         AuditNonSystemFontLoading as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NoRemoteImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoRemoteImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoRemoteImages_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoRemoteImages_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoLowMandatoryLabelImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoLowMandatoryLabelImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoLowMandatoryLabelImages_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoLowMandatoryLabelImages_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PreferSystem32Images(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PreferSystem32Images(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PreferSystem32Images_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PreferSystem32Images_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditNoRemoteImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditNoRemoteImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditNoRemoteImages_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditNoRemoteImages_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditNoLowMandatoryLabelImages(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditNoLowMandatoryLabelImages(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditNoLowMandatoryLabelImages_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditNoLowMandatoryLabelImages_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NoRemoteImages: DWORD,
      NoLowMandatoryLabelImages: DWORD,
      PreferSystem32Images: DWORD,
      AuditNoRemoteImages: DWORD,
      AuditNoLowMandatoryLabelImages: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let NoRemoteImages: u32 = unsafe { ::core::mem::transmute(NoRemoteImages) };
         NoRemoteImages as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let NoLowMandatoryLabelImages: u32 =
            unsafe { ::core::mem::transmute(NoLowMandatoryLabelImages) };
         NoLowMandatoryLabelImages as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let PreferSystem32Images: u32 = unsafe { ::core::mem::transmute(PreferSystem32Images) };
         PreferSystem32Images as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditNoRemoteImages: u32 = unsafe { ::core::mem::transmute(AuditNoRemoteImages) };
         AuditNoRemoteImages as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let AuditNoLowMandatoryLabelImages: u32 =
            unsafe { ::core::mem::transmute(AuditNoLowMandatoryLabelImages) };
         AuditNoLowMandatoryLabelImages as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn FilterId(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_FilterId(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FilterId_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FilterId_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FilterId: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let FilterId: u32 = unsafe { ::core::mem::transmute(FilterId) };
         FilterId as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
   _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableExportAddressFilter(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableExportAddressFilter(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableExportAddressFilter_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableExportAddressFilter_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditExportAddressFilter(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditExportAddressFilter(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditExportAddressFilter_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditExportAddressFilter_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableExportAddressFilterPlus(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableExportAddressFilterPlus(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableExportAddressFilterPlus_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableExportAddressFilterPlus_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditExportAddressFilterPlus(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditExportAddressFilterPlus(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditExportAddressFilterPlus_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditExportAddressFilterPlus_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableImportAddressFilter(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableImportAddressFilter(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableImportAddressFilter_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableImportAddressFilter_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditImportAddressFilter(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditImportAddressFilter(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditImportAddressFilter_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditImportAddressFilter_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableRopStackPivot(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableRopStackPivot(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableRopStackPivot_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableRopStackPivot_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditRopStackPivot(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditRopStackPivot(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditRopStackPivot_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditRopStackPivot_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableRopCallerCheck(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableRopCallerCheck(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableRopCallerCheck_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableRopCallerCheck_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditRopCallerCheck(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditRopCallerCheck(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditRopCallerCheck_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditRopCallerCheck_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableRopSimExec(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableRopSimExec(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableRopSimExec_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableRopSimExec_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditRopSimExec(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditRopSimExec(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditRopSimExec_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditRopSimExec_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 20u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            20u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            20u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableExportAddressFilter: DWORD,
      AuditExportAddressFilter: DWORD,
      EnableExportAddressFilterPlus: DWORD,
      AuditExportAddressFilterPlus: DWORD,
      EnableImportAddressFilter: DWORD,
      AuditImportAddressFilter: DWORD,
      EnableRopStackPivot: DWORD,
      AuditRopStackPivot: DWORD,
      EnableRopCallerCheck: DWORD,
      AuditRopCallerCheck: DWORD,
      EnableRopSimExec: DWORD,
      AuditRopSimExec: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableExportAddressFilter: u32 =
            unsafe { ::core::mem::transmute(EnableExportAddressFilter) };
         EnableExportAddressFilter as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditExportAddressFilter: u32 =
            unsafe { ::core::mem::transmute(AuditExportAddressFilter) };
         AuditExportAddressFilter as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let EnableExportAddressFilterPlus: u32 =
            unsafe { ::core::mem::transmute(EnableExportAddressFilterPlus) };
         EnableExportAddressFilterPlus as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditExportAddressFilterPlus: u32 =
            unsafe { ::core::mem::transmute(AuditExportAddressFilterPlus) };
         AuditExportAddressFilterPlus as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let EnableImportAddressFilter: u32 =
            unsafe { ::core::mem::transmute(EnableImportAddressFilter) };
         EnableImportAddressFilter as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let AuditImportAddressFilter: u32 =
            unsafe { ::core::mem::transmute(AuditImportAddressFilter) };
         AuditImportAddressFilter as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let EnableRopStackPivot: u32 = unsafe { ::core::mem::transmute(EnableRopStackPivot) };
         EnableRopStackPivot as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let AuditRopStackPivot: u32 = unsafe { ::core::mem::transmute(AuditRopStackPivot) };
         AuditRopStackPivot as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let EnableRopCallerCheck: u32 = unsafe { ::core::mem::transmute(EnableRopCallerCheck) };
         EnableRopCallerCheck as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let AuditRopCallerCheck: u32 = unsafe { ::core::mem::transmute(AuditRopCallerCheck) };
         AuditRopCallerCheck as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let EnableRopSimExec: u32 = unsafe { ::core::mem::transmute(EnableRopSimExec) };
         EnableRopSimExec as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let AuditRopSimExec: u32 = unsafe { ::core::mem::transmute(AuditRopSimExec) };
         AuditRopSimExec as u64
      });
      __bindgen_bitfield_unit.set(12usize, 20u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
   _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NoChildProcessCreation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoChildProcessCreation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoChildProcessCreation_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoChildProcessCreation_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditNoChildProcessCreation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditNoChildProcessCreation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditNoChildProcessCreation_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditNoChildProcessCreation_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AllowSecureProcessCreation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AllowSecureProcessCreation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AllowSecureProcessCreation_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AllowSecureProcessCreation_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            29u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            29u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NoChildProcessCreation: DWORD,
      AuditNoChildProcessCreation: DWORD,
      AllowSecureProcessCreation: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let NoChildProcessCreation: u32 =
            unsafe { ::core::mem::transmute(NoChildProcessCreation) };
         NoChildProcessCreation as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditNoChildProcessCreation: u32 =
            unsafe { ::core::mem::transmute(AuditNoChildProcessCreation) };
         AuditNoChildProcessCreation as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let AllowSecureProcessCreation: u32 =
            unsafe { ::core::mem::transmute(AllowSecureProcessCreation) };
         AllowSecureProcessCreation as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1:
      _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn SmtBranchTargetIsolation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SmtBranchTargetIsolation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SmtBranchTargetIsolation_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SmtBranchTargetIsolation_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsolateSecurityDomain(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsolateSecurityDomain(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsolateSecurityDomain_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsolateSecurityDomain_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DisablePageCombine(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisablePageCombine(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisablePageCombine_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DisablePageCombine_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisable(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisable(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpeculativeStoreBypassDisable_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpeculativeStoreBypassDisable_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RestrictCoreSharing(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RestrictCoreSharing(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RestrictCoreSharing_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RestrictCoreSharing_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SmtBranchTargetIsolation: DWORD,
      IsolateSecurityDomain: DWORD,
      DisablePageCombine: DWORD,
      SpeculativeStoreBypassDisable: DWORD,
      RestrictCoreSharing: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SmtBranchTargetIsolation: u32 =
            unsafe { ::core::mem::transmute(SmtBranchTargetIsolation) };
         SmtBranchTargetIsolation as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsolateSecurityDomain: u32 = unsafe { ::core::mem::transmute(IsolateSecurityDomain) };
         IsolateSecurityDomain as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DisablePageCombine: u32 = unsafe { ::core::mem::transmute(DisablePageCombine) };
         DisablePageCombine as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SpeculativeStoreBypassDisable: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisable) };
         SpeculativeStoreBypassDisable as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let RestrictCoreSharing: u32 = unsafe { ::core::mem::transmute(RestrictCoreSharing) };
         RestrictCoreSharing as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
   _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnableUserShadowStack(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableUserShadowStack(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableUserShadowStack_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableUserShadowStack_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditUserShadowStack(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditUserShadowStack(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditUserShadowStack_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditUserShadowStack_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SetContextIpValidation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SetContextIpValidation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SetContextIpValidation_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SetContextIpValidation_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditSetContextIpValidation(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditSetContextIpValidation(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditSetContextIpValidation_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditSetContextIpValidation_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableUserShadowStackStrictMode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableUserShadowStackStrictMode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableUserShadowStackStrictMode_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableUserShadowStackStrictMode_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BlockNonCetBinaries(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BlockNonCetBinaries(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BlockNonCetBinaries_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BlockNonCetBinaries_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BlockNonCetBinariesNonEhcont(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BlockNonCetBinariesNonEhcont(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BlockNonCetBinariesNonEhcont_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BlockNonCetBinariesNonEhcont_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditBlockNonCetBinaries(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditBlockNonCetBinaries(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditBlockNonCetBinaries_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditBlockNonCetBinaries_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CetDynamicApisOutOfProcOnly(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CetDynamicApisOutOfProcOnly(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CetDynamicApisOutOfProcOnly_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CetDynamicApisOutOfProcOnly_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SetContextIpValidationRelaxedMode(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SetContextIpValidationRelaxedMode(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SetContextIpValidationRelaxedMode_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SetContextIpValidationRelaxedMode_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 22u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            22u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            22u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableUserShadowStack: DWORD,
      AuditUserShadowStack: DWORD,
      SetContextIpValidation: DWORD,
      AuditSetContextIpValidation: DWORD,
      EnableUserShadowStackStrictMode: DWORD,
      BlockNonCetBinaries: DWORD,
      BlockNonCetBinariesNonEhcont: DWORD,
      AuditBlockNonCetBinaries: DWORD,
      CetDynamicApisOutOfProcOnly: DWORD,
      SetContextIpValidationRelaxedMode: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableUserShadowStack: u32 = unsafe { ::core::mem::transmute(EnableUserShadowStack) };
         EnableUserShadowStack as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditUserShadowStack: u32 = unsafe { ::core::mem::transmute(AuditUserShadowStack) };
         AuditUserShadowStack as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let SetContextIpValidation: u32 =
            unsafe { ::core::mem::transmute(SetContextIpValidation) };
         SetContextIpValidation as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AuditSetContextIpValidation: u32 =
            unsafe { ::core::mem::transmute(AuditSetContextIpValidation) };
         AuditSetContextIpValidation as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let EnableUserShadowStackStrictMode: u32 =
            unsafe { ::core::mem::transmute(EnableUserShadowStackStrictMode) };
         EnableUserShadowStackStrictMode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let BlockNonCetBinaries: u32 = unsafe { ::core::mem::transmute(BlockNonCetBinaries) };
         BlockNonCetBinaries as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let BlockNonCetBinariesNonEhcont: u32 =
            unsafe { ::core::mem::transmute(BlockNonCetBinariesNonEhcont) };
         BlockNonCetBinariesNonEhcont as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let AuditBlockNonCetBinaries: u32 =
            unsafe { ::core::mem::transmute(AuditBlockNonCetBinaries) };
         AuditBlockNonCetBinaries as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let CetDynamicApisOutOfProcOnly: u32 =
            unsafe { ::core::mem::transmute(CetDynamicApisOutOfProcOnly) };
         CetDynamicApisOutOfProcOnly as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let SetContextIpValidationRelaxedMode: u32 =
            unsafe { ::core::mem::transmute(SetContextIpValidationRelaxedMode) };
         SetContextIpValidationRelaxedMode as u64
      });
      __bindgen_bitfield_unit.set(10usize, 22u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnablePointerAuthUserIp(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnablePointerAuthUserIp(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnablePointerAuthUserIp_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnablePointerAuthUserIp_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnablePointerAuthUserIp: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnablePointerAuthUserIp: u32 =
            unsafe { ::core::mem::transmute(EnablePointerAuthUserIp) };
         EnablePointerAuthUserIp as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY = _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1 {
   pub Flags: DWORD,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn EnforceRedirectionTrust(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnforceRedirectionTrust(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnforceRedirectionTrust_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnforceRedirectionTrust_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditRedirectionTrust(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AuditRedirectionTrust(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditRedirectionTrust_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AuditRedirectionTrust_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnforceRedirectionTrust: DWORD,
      AuditRedirectionTrust: DWORD,
      ReservedFlags: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnforceRedirectionTrust: u32 =
            unsafe { ::core::mem::transmute(EnforceRedirectionTrust) };
         EnforceRedirectionTrust as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AuditRedirectionTrust: u32 = unsafe { ::core::mem::transmute(AuditRedirectionTrust) };
         AuditRedirectionTrust as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY = _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
   pub TotalUserTime: LARGE_INTEGER,
   pub TotalKernelTime: LARGE_INTEGER,
   pub ThisPeriodTotalUserTime: LARGE_INTEGER,
   pub ThisPeriodTotalKernelTime: LARGE_INTEGER,
   pub TotalPageFaultCount: DWORD,
   pub TotalProcesses: DWORD,
   pub ActiveProcesses: DWORD,
   pub TotalTerminatedProcesses: DWORD,
}
impl Default for _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
   pub PerProcessUserTimeLimit: LARGE_INTEGER,
   pub PerJobUserTimeLimit: LARGE_INTEGER,
   pub LimitFlags: DWORD,
   pub MinimumWorkingSetSize: SIZE_T,
   pub MaximumWorkingSetSize: SIZE_T,
   pub ActiveProcessLimit: DWORD,
   pub Affinity: ULONG_PTR,
   pub PriorityClass: DWORD,
   pub SchedulingClass: DWORD,
}
impl Default for _JOBOBJECT_BASIC_LIMIT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_BASIC_LIMIT_INFORMATION = _JOBOBJECT_BASIC_LIMIT_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECTINFOCLASS {
   JobObjectBasicAccountingInformation = 1,
   JobObjectBasicLimitInformation = 2,
   JobObjectBasicProcessIdList = 3,
   JobObjectBasicUIRestrictions = 4,
   JobObjectSecurityLimitInformation = 5,
   JobObjectEndOfJobTimeInformation = 6,
   JobObjectAssociateCompletionPortInformation = 7,
   JobObjectBasicAndIoAccountingInformation = 8,
   JobObjectExtendedLimitInformation = 9,
   JobObjectJobSetInformation = 10,
   JobObjectGroupInformation = 11,
   JobObjectNotificationLimitInformation = 12,
   JobObjectLimitViolationInformation = 13,
   JobObjectGroupInformationEx = 14,
   JobObjectCpuRateControlInformation = 15,
   JobObjectCompletionFilter = 16,
   JobObjectCompletionCounter = 17,
   JobObjectReserved1Information = 18,
   JobObjectReserved2Information = 19,
   JobObjectReserved3Information = 20,
   JobObjectReserved4Information = 21,
   JobObjectReserved5Information = 22,
   JobObjectReserved6Information = 23,
   JobObjectReserved7Information = 24,
   JobObjectReserved8Information = 25,
   JobObjectReserved9Information = 26,
   JobObjectReserved10Information = 27,
   JobObjectReserved11Information = 28,
   JobObjectReserved12Information = 29,
   JobObjectReserved13Information = 30,
   JobObjectReserved14Information = 31,
   JobObjectNetRateControlInformation = 32,
   JobObjectNotificationLimitInformation2 = 33,
   JobObjectLimitViolationInformation2 = 34,
   JobObjectCreateSilo = 35,
   JobObjectSiloBasicInformation = 36,
   JobObjectReserved15Information = 37,
   JobObjectReserved16Information = 38,
   JobObjectReserved17Information = 39,
   JobObjectReserved18Information = 40,
   JobObjectReserved19Information = 41,
   JobObjectReserved20Information = 42,
   JobObjectReserved21Information = 43,
   JobObjectReserved22Information = 44,
   JobObjectReserved23Information = 45,
   JobObjectReserved24Information = 46,
   JobObjectReserved25Information = 47,
   JobObjectReserved26Information = 48,
   JobObjectReserved27Information = 49,
   MaxJobObjectInfoClass = 50,
}
pub use self::_JOBOBJECTINFOCLASS as JOBOBJECTINFOCLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FIRMWARE_TYPE {
   FirmwareTypeUnknown = 0,
   FirmwareTypeBios = 1,
   FirmwareTypeUefi = 2,
   FirmwareTypeMax = 3,
}
pub use self::_FIRMWARE_TYPE as FIRMWARE_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSTATE_FEATURE {
   pub Offset: DWORD,
   pub Size: DWORD,
}
pub type XSTATE_FEATURE = _XSTATE_FEATURE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_CONFIGURATION {
   pub EnabledFeatures: DWORD64,
   pub EnabledVolatileFeatures: DWORD64,
   pub Size: DWORD,
   pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
   pub Features: [XSTATE_FEATURE; 64usize],
   pub EnabledSupervisorFeatures: DWORD64,
   pub AlignedFeatures: DWORD64,
   pub AllFeatureSize: DWORD,
   pub AllFeatures: [DWORD; 64usize],
   pub EnabledUserVisibleSupervisorFeatures: DWORD64,
   pub ExtendedFeatureDisableFeatures: DWORD64,
   pub AllNonLargeFeatureSize: DWORD,
   pub Spare: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_CONFIGURATION__bindgen_ty_1 {
   pub ControlFlags: DWORD,
   pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn OptimizedSave(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_OptimizedSave(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn OptimizedSave_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_OptimizedSave_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CompactionEnabled(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompactionEnabled(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CompactionEnabled_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CompactionEnabled_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ExtendedFeatureDisable(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ExtendedFeatureDisable(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ExtendedFeatureDisable_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ExtendedFeatureDisable_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      OptimizedSave: DWORD,
      CompactionEnabled: DWORD,
      ExtendedFeatureDisable: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let OptimizedSave: u32 = unsafe { ::core::mem::transmute(OptimizedSave) };
         OptimizedSave as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let CompactionEnabled: u32 = unsafe { ::core::mem::transmute(CompactionEnabled) };
         CompactionEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ExtendedFeatureDisable: u32 =
            unsafe { ::core::mem::transmute(ExtendedFeatureDisable) };
         ExtendedFeatureDisable as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _XSTATE_CONFIGURATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _XSTATE_CONFIGURATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CFG_CALL_TARGET_INFO {
   pub Offset: ULONG_PTR,
   pub Flags: ULONG_PTR,
}
pub type PCFG_CALL_TARGET_INFO = *mut _CFG_CALL_TARGET_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER {
   pub __bindgen_anon_1: MEM_EXTENDED_PARAMETER__bindgen_ty_1,
   pub __bindgen_anon_2: MEM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
   #[inline]
   pub fn Type(&self) -> DWORD64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: DWORD64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Type_raw(this: *const Self) -> DWORD64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Type_raw(this: *mut Self, val: DWORD64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> DWORD64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: DWORD64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 56u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> DWORD64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            56u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: DWORD64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            56u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Type: DWORD64, Reserved: DWORD64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Type: u64 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(8usize, 56u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
   pub ULong64: DWORD64,
   pub Pointer: PVOID,
   pub Size: SIZE_T,
   pub Handle: HANDLE,
   pub ULong: DWORD,
}
impl Default for MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for MEM_EXTENDED_PARAMETER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PMEM_EXTENDED_PARAMETER = *mut MEM_EXTENDED_PARAMETER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ID_128 {
   pub Identifier: [BYTE; 16usize],
}
pub type FILE_ID_128 = _FILE_ID_128;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
   pub Buffer: *mut ::core::ffi::c_void,
   pub Alignment: ULONGLONG,
}
impl Default for _FILE_SEGMENT_ELEMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER {
   pub ReparseTag: DWORD,
   pub ReparseDataLength: WORD,
   pub Reserved: WORD,
   pub ReparseGuid: GUID,
   pub GenericReparseBuffer: _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1 {
   pub DataBuffer: [BYTE; 1usize],
}
pub type REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_POWER_STATE {
   PowerSystemUnspecified = 0,
   PowerSystemWorking = 1,
   PowerSystemSleeping1 = 2,
   PowerSystemSleeping2 = 3,
   PowerSystemSleeping3 = 4,
   PowerSystemHibernate = 5,
   PowerSystemShutdown = 6,
   PowerSystemMaximum = 7,
}
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_ACTION {
   PowerActionNone = 0,
   PowerActionReserved = 1,
   PowerActionSleep = 2,
   PowerActionHibernate = 3,
   PowerActionShutdown = 4,
   PowerActionShutdownReset = 5,
   PowerActionShutdownOff = 6,
   PowerActionWarmEject = 7,
   PowerActionDisplayOff = 8,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_POWER_STATE {
   PowerDeviceUnspecified = 0,
   PowerDeviceD0 = 1,
   PowerDeviceD1 = 2,
   PowerDeviceD2 = 3,
   PowerDeviceD3 = 4,
   PowerDeviceMaximum = 5,
}
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE;
pub type EXECUTION_STATE = DWORD;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LATENCY_TIME {
   LT_DONT_CARE = 0,
   LT_LOWEST_LATENCY = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_INFORMATION_LEVEL {
   SystemPowerPolicyAc = 0,
   SystemPowerPolicyDc = 1,
   VerifySystemPolicyAc = 2,
   VerifySystemPolicyDc = 3,
   SystemPowerCapabilities = 4,
   SystemBatteryState = 5,
   SystemPowerStateHandler = 6,
   ProcessorStateHandler = 7,
   SystemPowerPolicyCurrent = 8,
   AdministratorPowerPolicy = 9,
   SystemReserveHiberFile = 10,
   ProcessorInformation = 11,
   SystemPowerInformation = 12,
   ProcessorStateHandler2 = 13,
   LastWakeTime = 14,
   LastSleepTime = 15,
   SystemExecutionState = 16,
   SystemPowerStateNotifyHandler = 17,
   ProcessorPowerPolicyAc = 18,
   ProcessorPowerPolicyDc = 19,
   VerifyProcessorPowerPolicyAc = 20,
   VerifyProcessorPowerPolicyDc = 21,
   ProcessorPowerPolicyCurrent = 22,
   SystemPowerStateLogging = 23,
   SystemPowerLoggingEntry = 24,
   SetPowerSettingValue = 25,
   NotifyUserPowerSetting = 26,
   PowerInformationLevelUnused0 = 27,
   SystemMonitorHiberBootPowerOff = 28,
   SystemVideoState = 29,
   TraceApplicationPowerMessage = 30,
   TraceApplicationPowerMessageEnd = 31,
   ProcessorPerfStates = 32,
   ProcessorIdleStates = 33,
   ProcessorCap = 34,
   SystemWakeSource = 35,
   SystemHiberFileInformation = 36,
   TraceServicePowerMessage = 37,
   ProcessorLoad = 38,
   PowerShutdownNotification = 39,
   MonitorCapabilities = 40,
   SessionPowerInit = 41,
   SessionDisplayState = 42,
   PowerRequestCreate = 43,
   PowerRequestAction = 44,
   GetPowerRequestList = 45,
   ProcessorInformationEx = 46,
   NotifyUserModeLegacyPowerEvent = 47,
   GroupPark = 48,
   ProcessorIdleDomains = 49,
   WakeTimerList = 50,
   SystemHiberFileSize = 51,
   ProcessorIdleStatesHv = 52,
   ProcessorPerfStatesHv = 53,
   ProcessorPerfCapHv = 54,
   ProcessorSetIdle = 55,
   LogicalProcessorIdling = 56,
   UserPresence = 57,
   PowerSettingNotificationName = 58,
   GetPowerSettingValue = 59,
   IdleResiliency = 60,
   SessionRITState = 61,
   SessionConnectNotification = 62,
   SessionPowerCleanup = 63,
   SessionLockState = 64,
   SystemHiberbootState = 65,
   PlatformInformation = 66,
   PdcInvocation = 67,
   MonitorInvocation = 68,
   FirmwareTableInformationRegistered = 69,
   SetShutdownSelectedTime = 70,
   SuspendResumeInvocation = 71,
   PlmPowerRequestCreate = 72,
   ScreenOff = 73,
   CsDeviceNotification = 74,
   PlatformRole = 75,
   LastResumePerformance = 76,
   DisplayBurst = 77,
   ExitLatencySamplingPercentage = 78,
   RegisterSpmPowerSettings = 79,
   PlatformIdleStates = 80,
   ProcessorIdleVeto = 81,
   PlatformIdleVeto = 82,
   SystemBatteryStatePrecise = 83,
   ThermalEvent = 84,
   PowerRequestActionInternal = 85,
   BatteryDeviceState = 86,
   PowerInformationInternal = 87,
   ThermalStandby = 88,
   SystemHiberFileType = 89,
   PhysicalPowerButtonPress = 90,
   QueryPotentialDripsConstraint = 91,
   EnergyTrackerCreate = 92,
   EnergyTrackerQuery = 93,
   UpdateBlackBoxRecorder = 94,
   SessionAllowExternalDmaDevices = 95,
   SendSuspendResumeNotification = 96,
   BlackBoxRecorderDirectAccessBuffer = 97,
   PowerInformationLevelMaximum = 98,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_MONITOR_REQUEST_REASON {
   MonitorRequestReasonUnknown = 0,
   MonitorRequestReasonPowerButton = 1,
   MonitorRequestReasonRemoteConnection = 2,
   MonitorRequestReasonScMonitorpower = 3,
   MonitorRequestReasonUserInput = 4,
   MonitorRequestReasonAcDcDisplayBurst = 5,
   MonitorRequestReasonUserDisplayBurst = 6,
   MonitorRequestReasonPoSetSystemState = 7,
   MonitorRequestReasonSetThreadExecutionState = 8,
   MonitorRequestReasonFullWake = 9,
   MonitorRequestReasonSessionUnlock = 10,
   MonitorRequestReasonScreenOffRequest = 11,
   MonitorRequestReasonIdleTimeout = 12,
   MonitorRequestReasonPolicyChange = 13,
   MonitorRequestReasonSleepButton = 14,
   MonitorRequestReasonLid = 15,
   MonitorRequestReasonBatteryCountChange = 16,
   MonitorRequestReasonGracePeriod = 17,
   MonitorRequestReasonPnP = 18,
   MonitorRequestReasonDP = 19,
   MonitorRequestReasonSxTransition = 20,
   MonitorRequestReasonSystemIdle = 21,
   MonitorRequestReasonNearProximity = 22,
   MonitorRequestReasonThermalStandby = 23,
   MonitorRequestReasonResumePdc = 24,
   MonitorRequestReasonResumeS4 = 25,
   MonitorRequestReasonTerminal = 26,
   MonitorRequestReasonPdcSignal = 27,
   MonitorRequestReasonAcDcDisplayBurstSuppressed = 28,
   MonitorRequestReasonSystemStateEntered = 29,
   MonitorRequestReasonWinrt = 30,
   MonitorRequestReasonUserInputKeyboard = 31,
   MonitorRequestReasonUserInputMouse = 32,
   MonitorRequestReasonUserInputTouchpad = 33,
   MonitorRequestReasonUserInputPen = 34,
   MonitorRequestReasonUserInputAccelerometer = 35,
   MonitorRequestReasonUserInputHid = 36,
   MonitorRequestReasonUserInputPoUserPresent = 37,
   MonitorRequestReasonUserInputSessionSwitch = 38,
   MonitorRequestReasonUserInputInitialization = 39,
   MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = 40,
   MonitorRequestReasonPdcSignalWindowsMobileShell = 41,
   MonitorRequestReasonPdcSignalHeyCortana = 42,
   MonitorRequestReasonPdcSignalHolographicShell = 43,
   MonitorRequestReasonPdcSignalFingerprint = 44,
   MonitorRequestReasonDirectedDrips = 45,
   MonitorRequestReasonDim = 46,
   MonitorRequestReasonBuiltinPanel = 47,
   MonitorRequestReasonDisplayRequiredUnDim = 48,
   MonitorRequestReasonBatteryCountChangeSuppressed = 49,
   MonitorRequestReasonResumeModernStandby = 50,
   MonitorRequestReasonTerminalInit = 51,
   MonitorRequestReasonPdcSignalSensorsHumanPresence = 52,
   MonitorRequestReasonBatteryPreCritical = 53,
   MonitorRequestReasonUserInputTouch = 54,
   MonitorRequestReasonMax = 55,
}
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DOS_HEADER {
   pub e_magic: WORD,
   pub e_cblp: WORD,
   pub e_cp: WORD,
   pub e_crlc: WORD,
   pub e_cparhdr: WORD,
   pub e_minalloc: WORD,
   pub e_maxalloc: WORD,
   pub e_ss: WORD,
   pub e_sp: WORD,
   pub e_csum: WORD,
   pub e_ip: WORD,
   pub e_cs: WORD,
   pub e_lfarlc: WORD,
   pub e_ovno: WORD,
   pub e_res: [WORD; 4usize],
   pub e_oemid: WORD,
   pub e_oeminfo: WORD,
   pub e_res2: [WORD; 10usize],
   pub e_lfanew: LONG,
}
pub type IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_FILE_HEADER {
   pub Machine: WORD,
   pub NumberOfSections: WORD,
   pub TimeDateStamp: DWORD,
   pub PointerToSymbolTable: DWORD,
   pub NumberOfSymbols: DWORD,
   pub SizeOfOptionalHeader: WORD,
   pub Characteristics: WORD,
}
pub type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DATA_DIRECTORY {
   pub VirtualAddress: DWORD,
   pub Size: DWORD,
}
pub type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER64 {
   pub Magic: WORD,
   pub MajorLinkerVersion: BYTE,
   pub MinorLinkerVersion: BYTE,
   pub SizeOfCode: DWORD,
   pub SizeOfInitializedData: DWORD,
   pub SizeOfUninitializedData: DWORD,
   pub AddressOfEntryPoint: DWORD,
   pub BaseOfCode: DWORD,
   pub ImageBase: ULONGLONG,
   pub SectionAlignment: DWORD,
   pub FileAlignment: DWORD,
   pub MajorOperatingSystemVersion: WORD,
   pub MinorOperatingSystemVersion: WORD,
   pub MajorImageVersion: WORD,
   pub MinorImageVersion: WORD,
   pub MajorSubsystemVersion: WORD,
   pub MinorSubsystemVersion: WORD,
   pub Win32VersionValue: DWORD,
   pub SizeOfImage: DWORD,
   pub SizeOfHeaders: DWORD,
   pub CheckSum: DWORD,
   pub Subsystem: WORD,
   pub DllCharacteristics: WORD,
   pub SizeOfStackReserve: ULONGLONG,
   pub SizeOfStackCommit: ULONGLONG,
   pub SizeOfHeapReserve: ULONGLONG,
   pub SizeOfHeapCommit: ULONGLONG,
   pub LoaderFlags: DWORD,
   pub NumberOfRvaAndSizes: DWORD,
   pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
pub type IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS64 {
   pub Signature: DWORD,
   pub FileHeader: IMAGE_FILE_HEADER,
   pub OptionalHeader: IMAGE_OPTIONAL_HEADER64,
}
pub type PIMAGE_NT_HEADERS64 = *mut _IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECTION_HEADER {
   pub Name: [BYTE; 8usize],
   pub Misc: _IMAGE_SECTION_HEADER__bindgen_ty_1,
   pub VirtualAddress: DWORD,
   pub SizeOfRawData: DWORD,
   pub PointerToRawData: DWORD,
   pub PointerToRelocations: DWORD,
   pub PointerToLinenumbers: DWORD,
   pub NumberOfRelocations: WORD,
   pub NumberOfLinenumbers: WORD,
   pub Characteristics: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
   pub PhysicalAddress: DWORD,
   pub VirtualSize: DWORD,
}
impl Default for _IMAGE_SECTION_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_SECTION_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PIMAGE_SECTION_HEADER = *mut _IMAGE_SECTION_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_BASE_RELOCATION {
   pub VirtualAddress: DWORD,
   pub SizeOfBlock: DWORD,
}
pub type IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION;
pub type PIMAGE_BASE_RELOCATION = *mut IMAGE_BASE_RELOCATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_EXPORT_DIRECTORY {
   pub Characteristics: DWORD,
   pub TimeDateStamp: DWORD,
   pub MajorVersion: WORD,
   pub MinorVersion: WORD,
   pub Name: DWORD,
   pub Base: DWORD,
   pub NumberOfFunctions: DWORD,
   pub NumberOfNames: DWORD,
   pub AddressOfFunctions: DWORD,
   pub AddressOfNames: DWORD,
   pub AddressOfNameOrdinals: DWORD,
}
pub type PIMAGE_EXPORT_DIRECTORY = *mut _IMAGE_EXPORT_DIRECTORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA64 {
   pub u1: _IMAGE_THUNK_DATA64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA64__bindgen_ty_1 {
   pub ForwarderString: ULONGLONG,
   pub Function: ULONGLONG,
   pub Ordinal: ULONGLONG,
   pub AddressOfData: ULONGLONG,
}
impl Default for _IMAGE_THUNK_DATA64__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_THUNK_DATA64 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_THUNK_DATA64 = _IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA64 = *mut IMAGE_THUNK_DATA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA32 {
   pub u1: _IMAGE_THUNK_DATA32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA32__bindgen_ty_1 {
   pub ForwarderString: DWORD,
   pub Function: DWORD,
   pub Ordinal: DWORD,
   pub AddressOfData: DWORD,
}
impl Default for _IMAGE_THUNK_DATA32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_THUNK_DATA32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32;
pub type PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR {
   pub Attributes: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1,
   pub DllNameRVA: DWORD,
   pub ModuleHandleRVA: DWORD,
   pub ImportAddressTableRVA: DWORD,
   pub ImportNameTableRVA: DWORD,
   pub BoundImportAddressTableRVA: DWORD,
   pub UnloadInformationTableRVA: DWORD,
   pub TimeDateStamp: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
   pub AllAttributes: DWORD,
   pub __bindgen_anon_1: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn RvaBased(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RvaBased(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RvaBased_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RvaBased_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedAttributes(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedAttributes(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedAttributes_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedAttributes_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      RvaBased: DWORD,
      ReservedAttributes: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let RvaBased: u32 = unsafe { ::core::mem::transmute(RvaBased) };
         RvaBased as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedAttributes: u32 = unsafe { ::core::mem::transmute(ReservedAttributes) };
         ReservedAttributes as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_DELAYLOAD_DESCRIPTOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_DELAYLOAD_DESCRIPTOR = _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PCIMAGE_DELAYLOAD_DESCRIPTOR = *const IMAGE_DELAYLOAD_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY {
   pub Characteristics: DWORD,
   pub TimeDateStamp: DWORD,
   pub MajorVersion: WORD,
   pub MinorVersion: WORD,
   pub NumberOfNamedEntries: WORD,
   pub NumberOfIdEntries: WORD,
}
pub type PIMAGE_RESOURCE_DIRECTORY = *mut _IMAGE_RESOURCE_DIRECTORY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_STRING {
   pub Length: WORD,
   pub NameString: [CHAR; 1usize],
}
pub type PIMAGE_RESOURCE_DIRECTORY_STRING = *mut _IMAGE_RESOURCE_DIRECTORY_STRING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DATA_ENTRY {
   pub OffsetToData: DWORD,
   pub Size: DWORD,
   pub CodePage: DWORD,
   pub Reserved: DWORD,
}
pub type PIMAGE_RESOURCE_DATA_ENTRY = *mut _IMAGE_RESOURCE_DATA_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
   pub BeginAddress: DWORD,
   pub __bindgen_anon_1: _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
   pub UnwindData: DWORD,
   pub __bindgen_anon_1: _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Flag(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Flag(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Flag_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Flag_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FunctionLength(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
   }
   #[inline]
   pub fn set_FunctionLength(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 11u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FunctionLength_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            11u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FunctionLength_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            11u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RegF(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
   }
   #[inline]
   pub fn set_RegF(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RegF_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            3u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RegF_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RegI(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_RegI(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RegI_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RegI_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn H(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_H(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn H_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_H_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CR(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_CR(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CR_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            21usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CR_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            21usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FrameSize(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
   }
   #[inline]
   pub fn set_FrameSize(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 9u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FrameSize_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            23usize,
            9u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FrameSize_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            23usize,
            9u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Flag: DWORD,
      FunctionLength: DWORD,
      RegF: DWORD,
      RegI: DWORD,
      H: DWORD,
      CR: DWORD,
      FrameSize: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let Flag: u32 = unsafe { ::core::mem::transmute(Flag) };
         Flag as u64
      });
      __bindgen_bitfield_unit.set(2usize, 11u8, {
         let FunctionLength: u32 = unsafe { ::core::mem::transmute(FunctionLength) };
         FunctionLength as u64
      });
      __bindgen_bitfield_unit.set(13usize, 3u8, {
         let RegF: u32 = unsafe { ::core::mem::transmute(RegF) };
         RegF as u64
      });
      __bindgen_bitfield_unit.set(16usize, 4u8, {
         let RegI: u32 = unsafe { ::core::mem::transmute(RegI) };
         RegI as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let H: u32 = unsafe { ::core::mem::transmute(H) };
         H as u64
      });
      __bindgen_bitfield_unit.set(21usize, 2u8, {
         let CR: u32 = unsafe { ::core::mem::transmute(CR) };
         CR as u64
      });
      __bindgen_bitfield_unit.set(23usize, 9u8, {
         let FrameSize: u32 = unsafe { ::core::mem::transmute(FrameSize) };
         FrameSize as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_ENTRY {
   pub Next: *mut _SLIST_ENTRY,
}
impl Default for _SLIST_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PSLIST_ENTRY = *mut _SLIST_ENTRY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
   pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
   pub HeaderArm64: _SLIST_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
   pub Alignment: ULONGLONG,
   pub Region: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _SLIST_HEADER__bindgen_ty_2 {
   #[inline]
   pub fn Depth(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
   }
   #[inline]
   pub fn set_Depth(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Depth_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            16u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Depth_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Sequence(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_Sequence(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Sequence_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            48u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Sequence_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            48u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(64usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            64usize,
            4u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            64usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NextEntry(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
   }
   #[inline]
   pub fn set_NextEntry(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(68usize, 60u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NextEntry_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            68usize,
            60u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_NextEntry_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            68usize,
            60u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Depth: ULONGLONG,
      Sequence: ULONGLONG,
      Reserved: ULONGLONG,
      NextEntry: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 16u8, {
         let Depth: u64 = unsafe { ::core::mem::transmute(Depth) };
         Depth as u64
      });
      __bindgen_bitfield_unit.set(16usize, 48u8, {
         let Sequence: u64 = unsafe { ::core::mem::transmute(Sequence) };
         Sequence as u64
      });
      __bindgen_bitfield_unit.set(64usize, 4u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(68usize, 60u8, {
         let NextEntry: u64 = unsafe { ::core::mem::transmute(NextEntry) };
         NextEntry as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SLIST_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SLIST_HEADER = _SLIST_HEADER;
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_RUN_ONCE {
   pub Ptr: PVOID,
}
impl Default for _RTL_RUN_ONCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRTL_RUN_ONCE = *mut _RTL_RUN_ONCE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BARRIER {
   pub Reserved1: DWORD,
   pub Reserved2: DWORD,
   pub Reserved3: [ULONG_PTR; 2usize],
   pub Reserved4: DWORD,
   pub Reserved5: DWORD,
}
pub type PRTL_BARRIER = *mut _RTL_BARRIER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_ENTRY {
   pub Length: WORD,
   pub Flags: WORD,
   pub Text: [BYTE; 1usize],
}
pub type PMESSAGE_RESOURCE_ENTRY = *mut _MESSAGE_RESOURCE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXW {
   pub dwOSVersionInfoSize: DWORD,
   pub dwMajorVersion: DWORD,
   pub dwMinorVersion: DWORD,
   pub dwBuildNumber: DWORD,
   pub dwPlatformId: DWORD,
   pub szCSDVersion: [WCHAR; 128usize],
   pub wServicePackMajor: WORD,
   pub wServicePackMinor: WORD,
   pub wSuiteMask: WORD,
   pub wProductType: BYTE,
   pub wReserved: BYTE,
}
impl Default for _OSVERSIONINFOEXW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_SYSTEM_GLOBAL_DATA_ID {
   GlobalDataIdUnknown = 0,
   GlobalDataIdRngSeedVersion = 1,
   GlobalDataIdInterruptTime = 2,
   GlobalDataIdTimeZoneBias = 3,
   GlobalDataIdImageNumberLow = 4,
   GlobalDataIdImageNumberHigh = 5,
   GlobalDataIdTimeZoneId = 6,
   GlobalDataIdNtMajorVersion = 7,
   GlobalDataIdNtMinorVersion = 8,
   GlobalDataIdSystemExpirationDate = 9,
   GlobalDataIdKdDebuggerEnabled = 10,
   GlobalDataIdCyclesPerYield = 11,
   GlobalDataIdSafeBootMode = 12,
   GlobalDataIdLastSystemRITEventTickCount = 13,
   GlobalDataIdConsoleSharedDataFlags = 14,
   GlobalDataIdNtSystemRootDrive = 15,
   GlobalDataIdQpcShift = 16,
   GlobalDataIdQpcBypassEnabled = 17,
   GlobalDataIdQpcData = 18,
   GlobalDataIdQpcBias = 19,
}
pub use self::_RTL_SYSTEM_GLOBAL_DATA_ID as RTL_SYSTEM_GLOBAL_DATA_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
   pub Type: WORD,
   pub CreatorBackTraceIndex: WORD,
   pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
   pub ProcessLocksList: LIST_ENTRY,
   pub EntryCount: DWORD,
   pub ContentionCount: DWORD,
   pub Flags: DWORD,
   pub CreatorBackTraceIndexHigh: WORD,
   pub Identifier: WORD,
}
impl Default for _RTL_CRITICAL_SECTION_DEBUG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_RESOURCE_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
   pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
   pub LockCount: LONG,
   pub RecursionCount: LONG,
   pub OwningThread: HANDLE,
   pub LockSemaphore: HANDLE,
   pub SpinCount: ULONG_PTR,
}
impl Default for _RTL_CRITICAL_SECTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
   pub Ptr: PVOID,
}
impl Default for _RTL_SRWLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
pub type PRTL_SRWLOCK = *mut _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CONDITION_VARIABLE {
   pub Ptr: PVOID,
}
impl Default for _RTL_CONDITION_VARIABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRTL_CONDITION_VARIABLE = *mut _RTL_CONDITION_VARIABLE;
pub type PAPCFUNC = ::core::option::Option<unsafe extern "C" fn(Parameter: ULONG_PTR)>;
pub type PVECTORED_EXCEPTION_HANDLER =
   ::core::option::Option<unsafe extern "C" fn(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HEAP_INFORMATION_CLASS {
   HeapCompatibilityInformation = 0,
   HeapEnableTerminationOnCorruption = 1,
   HeapOptimizeResources = 3,
   HeapTag = 7,
}
pub use self::_HEAP_INFORMATION_CLASS as HEAP_INFORMATION_CLASS;
pub type WAITORTIMERCALLBACKFUNC =
   ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: BOOLEAN)>;
pub type WORKERCALLBACKFUNC = ::core::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
pub type APC_CALLBACK_FUNCTION =
   ::core::option::Option<unsafe extern "C" fn(arg1: DWORD, arg2: PVOID, arg3: PVOID)>;
pub type PFLS_CALLBACK_FUNCTION = ::core::option::Option<unsafe extern "C" fn(lpFlsData: PVOID)>;
impl _ACTIVATION_CONTEXT_INFO_CLASS {
   pub const AssemblyDetailedInformationInActivationContxt: _ACTIVATION_CONTEXT_INFO_CLASS =
      _ACTIVATION_CONTEXT_INFO_CLASS::AssemblyDetailedInformationInActivationContext;
}
impl _ACTIVATION_CONTEXT_INFO_CLASS {
   pub const FileInformationInAssemblyOfAssemblyInActivationContxt: _ACTIVATION_CONTEXT_INFO_CLASS =
      _ACTIVATION_CONTEXT_INFO_CLASS::FileInformationInAssemblyOfAssemblyInActivationContext;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ACTIVATION_CONTEXT_INFO_CLASS {
   ActivationContextBasicInformation = 1,
   ActivationContextDetailedInformation = 2,
   AssemblyDetailedInformationInActivationContext = 3,
   FileInformationInAssemblyOfAssemblyInActivationContext = 4,
   RunlevelInformationInActivationContext = 5,
   CompatibilityInformationInActivationContext = 6,
   ActivationContextManifestResourceName = 7,
   MaxActivationContextInfoClass = 8,
}
pub use self::_ACTIVATION_CONTEXT_INFO_CLASS as ACTIVATION_CONTEXT_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_QUERY_INDEX {
   pub ulAssemblyIndex: DWORD,
   pub ulFileIndexInAssembly: DWORD,
}
pub type PACTIVATION_CONTEXT_QUERY_INDEX = *mut _ACTIVATION_CONTEXT_QUERY_INDEX;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ACTCTX_REQUESTED_RUN_LEVEL {
   ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
   ACTCTX_RUN_LEVEL_AS_INVOKER = 1,
   ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2,
   ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3,
   ACTCTX_RUN_LEVEL_NUMBERS = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE {
   ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
   ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1,
   ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2,
   ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_COUNTER_DATA {
   pub Type: HARDWARE_COUNTER_TYPE,
   pub Reserved: DWORD,
   pub Value: DWORD64,
}
impl Default for _HARDWARE_COUNTER_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HARDWARE_COUNTER_DATA = _HARDWARE_COUNTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFORMANCE_DATA {
   pub Size: WORD,
   pub Version: BYTE,
   pub HwCountersCount: BYTE,
   pub ContextSwitchCount: DWORD,
   pub WaitReasonBitMap: DWORD64,
   pub CycleTime: DWORD64,
   pub RetryCount: DWORD,
   pub Reserved: DWORD,
   pub HwCounters: [HARDWARE_COUNTER_DATA; 16usize],
}
impl Default for _PERFORMANCE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PPERFORMANCE_DATA = *mut _PERFORMANCE_DATA;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION {
   pub TransactionKey: PVOID,
   pub TransactionNotification: ULONG,
   pub TmVirtualClock: LARGE_INTEGER,
   pub ArgumentLength: ULONG,
}
impl Default for _TRANSACTION_NOTIFICATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSACTION_INFORMATION_CLASS {
   TransactionBasicInformation = 0,
   TransactionPropertiesInformation = 1,
   TransactionEnlistmentInformation = 2,
   TransactionSuperiorEnlistmentInformation = 3,
   TransactionBindInformation = 4,
   TransactionDTCPrivateInformation = 5,
}
pub use self::_TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
   TransactionManagerBasicInformation = 0,
   TransactionManagerLogInformation = 1,
   TransactionManagerLogPathInformation = 2,
   TransactionManagerRecoveryInformation = 4,
   TransactionManagerOnlineProbeInformation = 3,
   TransactionManagerOldestTransactionInformation = 5,
}
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS as TRANSACTIONMANAGER_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RESOURCEMANAGER_INFORMATION_CLASS {
   ResourceManagerBasicInformation = 0,
   ResourceManagerCompletionInformation = 1,
}
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS as RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ENLISTMENT_INFORMATION_CLASS {
   EnlistmentBasicInformation = 0,
   EnlistmentRecoveryInformation = 1,
   EnlistmentCrmInformation = 2,
}
pub use self::_ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTMOBJECT_TYPE {
   KTMOBJECT_TRANSACTION = 0,
   KTMOBJECT_TRANSACTION_MANAGER = 1,
   KTMOBJECT_RESOURCE_MANAGER = 2,
   KTMOBJECT_ENLISTMENT = 3,
   KTMOBJECT_INVALID = 4,
}
pub use self::_KTMOBJECT_TYPE as KTMOBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KTMOBJECT_CURSOR {
   pub LastQuery: GUID,
   pub ObjectIdCount: DWORD,
   pub ObjectIds: [GUID; 1usize],
}
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
pub type TP_VERSION = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_INSTANCE {
   _unused: [u8; 0],
}
pub type PTP_CALLBACK_INSTANCE = *mut _TP_CALLBACK_INSTANCE;
pub type PTP_SIMPLE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL {
   _unused: [u8; 0],
}
pub type PTP_POOL = *mut _TP_POOL;
impl _TP_CALLBACK_PRIORITY {
   pub const TP_CALLBACK_PRIORITY_COUNT: _TP_CALLBACK_PRIORITY =
      _TP_CALLBACK_PRIORITY::TP_CALLBACK_PRIORITY_INVALID;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TP_CALLBACK_PRIORITY {
   TP_CALLBACK_PRIORITY_HIGH = 0,
   TP_CALLBACK_PRIORITY_NORMAL = 1,
   TP_CALLBACK_PRIORITY_LOW = 2,
   TP_CALLBACK_PRIORITY_INVALID = 3,
}
pub use self::_TP_CALLBACK_PRIORITY as TP_CALLBACK_PRIORITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TP_POOL_STACK_INFORMATION {
   pub StackReserve: SIZE_T,
   pub StackCommit: SIZE_T,
}
pub type PTP_POOL_STACK_INFORMATION = *mut _TP_POOL_STACK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CLEANUP_GROUP {
   _unused: [u8; 0],
}
pub type PTP_CLEANUP_GROUP = *mut _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP_CANCEL_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(ObjectContext: PVOID, CleanupContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3 {
   pub Version: TP_VERSION,
   pub Pool: PTP_POOL,
   pub CleanupGroup: PTP_CLEANUP_GROUP,
   pub CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
   pub RaceDll: PVOID,
   pub ActivationContext: *mut _ACTIVATION_CONTEXT,
   pub FinalizationCallback: PTP_SIMPLE_CALLBACK,
   pub u: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1,
   pub CallbackPriority: TP_CALLBACK_PRIORITY,
   pub Size: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
   pub Flags: DWORD,
   pub s: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn LongFunction(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LongFunction(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LongFunction_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LongFunction_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Persistent(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Persistent(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Persistent_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Persistent_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Private(&self) -> DWORD {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Private(&mut self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Private_raw(this: *const Self) -> DWORD {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Private_raw(this: *mut Self, val: DWORD) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      LongFunction: DWORD,
      Persistent: DWORD,
      Private: DWORD,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let LongFunction: u32 = unsafe { ::core::mem::transmute(LongFunction) };
         LongFunction as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Persistent: u32 = unsafe { ::core::mem::transmute(Persistent) };
         Persistent as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Private: u32 = unsafe { ::core::mem::transmute(Private) };
         Private as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TP_CALLBACK_ENVIRON_V3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TP_CALLBACK_ENVIRON_V3 = _TP_CALLBACK_ENVIRON_V3;
pub type PTP_CALLBACK_ENVIRON = *mut TP_CALLBACK_ENVIRON_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WORK {
   _unused: [u8; 0],
}
pub type PTP_WORK = *mut _TP_WORK;
pub type PTP_WORK_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Work: PTP_WORK),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_TIMER {
   _unused: [u8; 0],
}
pub type PTP_TIMER = *mut _TP_TIMER;
pub type PTP_TIMER_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Timer: PTP_TIMER),
>;
pub type TP_WAIT_RESULT = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WAIT {
   _unused: [u8; 0],
}
pub type PTP_WAIT = *mut _TP_WAIT;
pub type PTP_WAIT_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      Instance: PTP_CALLBACK_INSTANCE,
      Context: PVOID,
      Wait: PTP_WAIT,
      WaitResult: TP_WAIT_RESULT,
   ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_IO {
   _unused: [u8; 0],
}
pub type PTP_IO = *mut _TP_IO;
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HRGN__ {
   pub unused: ::core::ffi::c_int,
}
pub type HRGN = *mut HRGN__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HWINSTA__ {
   pub unused: ::core::ffi::c_int,
}
pub type HWINSTA = *mut HWINSTA__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HWND__ {
   pub unused: ::core::ffi::c_int,
}
pub type HWND = *mut HWND__;
pub type HGDIOBJ = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HACCEL__ {
   pub unused: ::core::ffi::c_int,
}
pub type HACCEL = *mut HACCEL__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HBITMAP__ {
   pub unused: ::core::ffi::c_int,
}
pub type HBITMAP = *mut HBITMAP__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HDC__ {
   pub unused: ::core::ffi::c_int,
}
pub type HDC = *mut HDC__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HDESK__ {
   pub unused: ::core::ffi::c_int,
}
pub type HDESK = *mut HDESK__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HICON__ {
   pub unused: ::core::ffi::c_int,
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HMENU__ {
   pub unused: ::core::ffi::c_int,
}
pub type HMENU = *mut HMENU__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HWINEVENTHOOK__ {
   pub unused: ::core::ffi::c_int,
}
pub type HWINEVENTHOOK = *mut HWINEVENTHOOK__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HMONITOR__ {
   pub unused: ::core::ffi::c_int,
}
pub type HMONITOR = *mut HMONITOR__;
pub type HCURSOR = HICON;
pub type COLORREF = DWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagRECT {
   pub left: LONG,
   pub top: LONG,
   pub right: LONG,
   pub bottom: LONG,
}
pub type RECT = tagRECT;
pub type PRECT = *mut tagRECT;
pub type LPRECT = *mut tagRECT;
pub type LPCRECT = *const RECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagPOINT {
   pub x: LONG,
   pub y: LONG,
}
pub type POINT = tagPOINT;
pub type LPPOINT = *mut tagPOINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagSIZE {
   pub cx: LONG,
   pub cy: LONG,
}
pub type SIZE = tagSIZE;
pub type PTHREAD_START_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(lpThreadParameter: LPVOID) -> DWORD>;
pub type LPTHREAD_START_ROUTINE = PTHREAD_START_ROUTINE;
pub type PENCLAVE_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(lpThreadParameter: LPVOID) -> LPVOID>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_DEBUG_INFO {
   pub ExceptionRecord: EXCEPTION_RECORD,
   pub dwFirstChance: DWORD,
}
impl Default for _EXCEPTION_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EXCEPTION_DEBUG_INFO = _EXCEPTION_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_THREAD_DEBUG_INFO {
   pub hThread: HANDLE,
   pub lpThreadLocalBase: LPVOID,
   pub lpStartAddress: LPTHREAD_START_ROUTINE,
}
impl Default for _CREATE_THREAD_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CREATE_THREAD_DEBUG_INFO = _CREATE_THREAD_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_PROCESS_DEBUG_INFO {
   pub hFile: HANDLE,
   pub hProcess: HANDLE,
   pub hThread: HANDLE,
   pub lpBaseOfImage: LPVOID,
   pub dwDebugInfoFileOffset: DWORD,
   pub nDebugInfoSize: DWORD,
   pub lpThreadLocalBase: LPVOID,
   pub lpStartAddress: LPTHREAD_START_ROUTINE,
   pub lpImageName: LPVOID,
   pub fUnicode: WORD,
}
impl Default for _CREATE_PROCESS_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CREATE_PROCESS_DEBUG_INFO = _CREATE_PROCESS_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EXIT_THREAD_DEBUG_INFO {
   pub dwExitCode: DWORD,
}
pub type EXIT_THREAD_DEBUG_INFO = _EXIT_THREAD_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EXIT_PROCESS_DEBUG_INFO {
   pub dwExitCode: DWORD,
}
pub type EXIT_PROCESS_DEBUG_INFO = _EXIT_PROCESS_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOAD_DLL_DEBUG_INFO {
   pub hFile: HANDLE,
   pub lpBaseOfDll: LPVOID,
   pub dwDebugInfoFileOffset: DWORD,
   pub nDebugInfoSize: DWORD,
   pub lpImageName: LPVOID,
   pub fUnicode: WORD,
}
impl Default for _LOAD_DLL_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LOAD_DLL_DEBUG_INFO = _LOAD_DLL_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNLOAD_DLL_DEBUG_INFO {
   pub lpBaseOfDll: LPVOID,
}
impl Default for _UNLOAD_DLL_DEBUG_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type UNLOAD_DLL_DEBUG_INFO = _UNLOAD_DLL_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OUTPUT_DEBUG_STRING_INFO {
   pub lpDebugStringData: LPSTR,
   pub fUnicode: WORD,
   pub nDebugStringLength: WORD,
}
impl Default for _OUTPUT_DEBUG_STRING_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OUTPUT_DEBUG_STRING_INFO = _OUTPUT_DEBUG_STRING_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RIP_INFO {
   pub dwError: DWORD,
   pub dwType: DWORD,
}
pub type RIP_INFO = _RIP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEBUG_EVENT {
   pub dwDebugEventCode: DWORD,
   pub dwProcessId: DWORD,
   pub dwThreadId: DWORD,
   pub u: _DEBUG_EVENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEBUG_EVENT__bindgen_ty_1 {
   pub Exception: EXCEPTION_DEBUG_INFO,
   pub CreateThread: CREATE_THREAD_DEBUG_INFO,
   pub CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO,
   pub ExitThread: EXIT_THREAD_DEBUG_INFO,
   pub ExitProcess: EXIT_PROCESS_DEBUG_INFO,
   pub LoadDll: LOAD_DLL_DEBUG_INFO,
   pub UnloadDll: UNLOAD_DLL_DEBUG_INFO,
   pub DebugString: OUTPUT_DEBUG_STRING_INFO,
   pub RipInfo: RIP_INFO,
}
impl Default for _DEBUG_EVENT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _DEBUG_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LPDEBUG_EVENT = *mut _DEBUG_EVENT;
#[doc = "The PROC_THREAD_ATTRIBUTE_LIST structure contains the list of attributes for process and thread creation."]
pub type PPROC_THREAD_ATTRIBUTE_LIST = *mut _PROC_THREAD_ATTRIBUTE_LIST;
pub type DLL_DIRECTORY_COOKIE = PVOID;
pub type PDLL_DIRECTORY_COOKIE = *mut PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
   pub lpInformation: PVOID,
   pub lpSectionBase: PVOID,
   pub ulSectionLength: ULONG,
   pub lpSectionGlobalDataBase: PVOID,
   pub ulSectionGlobalDataLength: ULONG,
}
impl Default for tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA =
   tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTX_SECTION_KEYED_DATA {
   pub cbSize: ULONG,
   pub ulDataFormatVersion: ULONG,
   pub lpData: PVOID,
   pub ulLength: ULONG,
   pub lpSectionGlobalData: PVOID,
   pub ulSectionGlobalDataLength: ULONG,
   pub lpSectionBase: PVOID,
   pub ulSectionTotalLength: ULONG,
   pub hActCtx: HANDLE,
   pub ulAssemblyRosterIndex: ULONG,
   pub ulFlags: ULONG,
   pub AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
}
impl Default for tagACTCTX_SECTION_KEYED_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PACTCTX_SECTION_KEYED_DATA = *mut tagACTCTX_SECTION_KEYED_DATA;
pub type TIMERPROC = ::core::option::Option<
   unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: UINT_PTR, arg4: DWORD),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagMOUSEMOVEPOINT {
   pub x: ::core::ffi::c_int,
   pub y: ::core::ffi::c_int,
   pub time: DWORD,
   pub dwExtraInfo: ULONG_PTR,
}
pub type LPMOUSEMOVEPOINT = *mut tagMOUSEMOVEPOINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMSG {
   pub hwnd: HWND,
   pub message: UINT,
   pub wParam: WPARAM,
   pub lParam: LPARAM,
   pub time: DWORD,
   pub pt: POINT,
}
impl Default for tagMSG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MSG = tagMSG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTRACKMOUSEEVENT {
   pub cbSize: DWORD,
   pub dwFlags: DWORD,
   pub hwndTrack: HWND,
   pub dwHoverTime: DWORD,
}
impl Default for tagTRACKMOUSEEVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LPTRACKMOUSEEVENT = *mut tagTRACKMOUSEEVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagACCEL {
   pub fVirt: BYTE,
   pub key: WORD,
   pub cmd: WORD,
}
pub type LPACCEL = *mut tagACCEL;
#[repr(C)]
pub struct tagPAINTSTRUCT {
   pub hdc: HDC,
   pub fErase: BOOL,
   pub rcPaint: RECT,
   pub fRestore: BOOL,
   pub fIncUpdate: BOOL,
   pub rgbReserved: [BYTE; 32usize],
}
impl Default for tagPAINTSTRUCT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PAINTSTRUCT = tagPAINTSTRUCT;
pub type LPPAINTSTRUCT = *mut tagPAINTSTRUCT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagWINDOWPLACEMENT {
   pub length: UINT,
   pub flags: UINT,
   pub showCmd: UINT,
   pub ptMinPosition: POINT,
   pub ptMaxPosition: POINT,
   pub rcNormalPosition: RECT,
}
pub type WINDOWPLACEMENT = tagWINDOWPLACEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLASHWINFO {
   pub cbSize: UINT,
   pub hwnd: HWND,
   pub dwFlags: DWORD,
   pub uCount: UINT,
   pub dwTimeout: DWORD,
}
impl Default for FLASHWINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PFLASHWINFO = *mut FLASHWINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagMOUSEINPUT {
   pub dx: LONG,
   pub dy: LONG,
   pub mouseData: DWORD,
   pub dwFlags: DWORD,
   pub time: DWORD,
   pub dwExtraInfo: ULONG_PTR,
}
pub type MOUSEINPUT = tagMOUSEINPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagKEYBDINPUT {
   pub wVk: WORD,
   pub wScan: WORD,
   pub dwFlags: DWORD,
   pub time: DWORD,
   pub dwExtraInfo: ULONG_PTR,
}
pub type KEYBDINPUT = tagKEYBDINPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagHARDWAREINPUT {
   pub uMsg: DWORD,
   pub wParamL: WORD,
   pub wParamH: WORD,
}
pub type HARDWAREINPUT = tagHARDWAREINPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagINPUT {
   pub type_: DWORD,
   pub __bindgen_anon_1: tagINPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagINPUT__bindgen_ty_1 {
   pub mi: MOUSEINPUT,
   pub ki: KEYBDINPUT,
   pub hi: HARDWAREINPUT,
}
impl Default for tagINPUT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for tagINPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LPINPUT = *mut tagINPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagTPMPARAMS {
   pub cbSize: UINT,
   pub rcExclude: RECT,
}
pub type TPMPARAMS = tagTPMPARAMS;
pub type LPTPMPARAMS = *mut TPMPARAMS;
#[repr(C)]
pub struct _ICONINFO {
   pub fIcon: BOOL,
   pub xHotspot: DWORD,
   pub yHotspot: DWORD,
   pub hbmMask: HBITMAP,
   pub hbmColor: HBITMAP,
}
impl Default for _ICONINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ICONINFO = _ICONINFO;
pub type PICONINFO = *mut ICONINFO;
pub type MONITORENUMPROC = ::core::option::Option<
   unsafe extern "C" fn(arg1: HMONITOR, arg2: HDC, arg3: LPRECT, arg4: LPARAM) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGUITHREADINFO {
   pub cbSize: DWORD,
   pub flags: DWORD,
   pub hwndActive: HWND,
   pub hwndFocus: HWND,
   pub hwndCapture: HWND,
   pub hwndMenuOwner: HWND,
   pub hwndMoveSize: HWND,
   pub hwndCaret: HWND,
   pub rcCaret: RECT,
}
impl Default for tagGUITHREADINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PGUITHREADINFO = *mut tagGUITHREADINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCURSORINFO {
   pub cbSize: DWORD,
   pub flags: DWORD,
   pub hCursor: HCURSOR,
   pub ptScreenPos: POINT,
}
impl Default for tagCURSORINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCURSORINFO = *mut tagCURSORINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagTITLEBARINFO {
   pub cbSize: DWORD,
   pub rcTitleBar: RECT,
   pub rgstate: [DWORD; 6usize],
}
pub type PTITLEBARINFO = *mut tagTITLEBARINFO;
#[repr(C)]
pub struct tagMENUBARINFO {
   pub cbSize: DWORD,
   pub rcBar: RECT,
   pub hMenu: HMENU,
   pub hwndMenu: HWND,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub __bindgen_padding_0: u32,
}
impl Default for tagMENUBARINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl tagMENUBARINFO {
   #[inline]
   pub fn fBarFocused(&self) -> BOOL {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_fBarFocused(&mut self, val: BOOL) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn fBarFocused_raw(this: *const Self) -> BOOL {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_fBarFocused_raw(this: *mut Self, val: BOOL) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn fFocused(&self) -> BOOL {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_fFocused(&mut self, val: BOOL) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn fFocused_raw(this: *const Self) -> BOOL {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_fFocused_raw(this: *mut Self, val: BOOL) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn fUnused(&self) -> BOOL {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_fUnused(&mut self, val: BOOL) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn fUnused_raw(this: *const Self) -> BOOL {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_fUnused_raw(this: *mut Self, val: BOOL) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      fBarFocused: BOOL,
      fFocused: BOOL,
      fUnused: BOOL,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let fBarFocused: u32 = unsafe { ::core::mem::transmute(fBarFocused) };
         fBarFocused as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let fFocused: u32 = unsafe { ::core::mem::transmute(fFocused) };
         fFocused as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let fUnused: u32 = unsafe { ::core::mem::transmute(fUnused) };
         fUnused as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PMENUBARINFO = *mut tagMENUBARINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCOMBOBOXINFO {
   pub cbSize: DWORD,
   pub rcItem: RECT,
   pub rcButton: RECT,
   pub stateButton: DWORD,
   pub hwndCombo: HWND,
   pub hwndItem: HWND,
   pub hwndList: HWND,
}
impl Default for tagCOMBOBOXINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PCOMBOBOXINFO = *mut tagCOMBOBOXINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HRAWINPUT__ {
   pub unused: ::core::ffi::c_int,
}
pub type HRAWINPUT = *mut HRAWINPUT__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRAWINPUTDEVICE {
   pub usUsagePage: USHORT,
   pub usUsage: USHORT,
   pub dwFlags: DWORD,
   pub hwndTarget: HWND,
}
impl Default for tagRAWINPUTDEVICE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRAWINPUTDEVICE = *mut tagRAWINPUTDEVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRAWINPUTDEVICELIST {
   pub hDevice: HANDLE,
   pub dwType: DWORD,
}
impl Default for tagRAWINPUTDEVICELIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PRAWINPUTDEVICELIST = *mut tagRAWINPUTDEVICELIST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagCHANGEFILTERSTRUCT {
   pub cbSize: DWORD,
   pub ExtStatus: DWORD,
}
pub type PCHANGEFILTERSTRUCT = *mut tagCHANGEFILTERSTRUCT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagINPUT_MESSAGE_DEVICE_TYPE {
   IMDT_UNAVAILABLE = 0,
   IMDT_KEYBOARD = 1,
   IMDT_MOUSE = 2,
   IMDT_TOUCH = 4,
   IMDT_PEN = 8,
   IMDT_TOUCHPAD = 16,
}
pub use self::tagINPUT_MESSAGE_DEVICE_TYPE as INPUT_MESSAGE_DEVICE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagINPUT_MESSAGE_ORIGIN_ID {
   IMO_UNAVAILABLE = 0,
   IMO_HARDWARE = 1,
   IMO_INJECTED = 2,
   IMO_SYSTEM = 4,
}
pub use self::tagINPUT_MESSAGE_ORIGIN_ID as INPUT_MESSAGE_ORIGIN_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagINPUT_MESSAGE_SOURCE {
   pub deviceType: INPUT_MESSAGE_DEVICE_TYPE,
   pub originId: INPUT_MESSAGE_ORIGIN_ID,
}
impl Default for tagINPUT_MESSAGE_SOURCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type INPUT_MESSAGE_SOURCE = tagINPUT_MESSAGE_SOURCE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ORIENTATION_PREFERENCE {
   ORIENTATION_PREFERENCE_NONE = 0,
   ORIENTATION_PREFERENCE_LANDSCAPE = 1,
   ORIENTATION_PREFERENCE_PORTRAIT = 2,
   ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 4,
   ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = 8,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_RESERVE_ID {
   StorageReserveIdNone = 0,
   StorageReserveIdHard = 1,
   StorageReserveIdSoft = 2,
   StorageReserveIdUpdateScratch = 3,
   StorageReserveIdMax = 4,
}
pub use self::_STORAGE_RESERVE_ID as STORAGE_RESERVE_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WNODE_HEADER {
   pub BufferSize: ULONG,
   pub ProviderId: ULONG,
   pub __bindgen_anon_1: _WNODE_HEADER__bindgen_ty_1,
   pub __bindgen_anon_2: _WNODE_HEADER__bindgen_ty_2,
   pub Guid: GUID,
   pub ClientContext: ULONG,
   pub Flags: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WNODE_HEADER__bindgen_ty_1 {
   pub HistoricalContext: ULONG64,
   pub __bindgen_anon_1: _WNODE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNODE_HEADER__bindgen_ty_1__bindgen_ty_1 {
   pub Version: ULONG,
   pub Linkage: ULONG,
}
impl Default for _WNODE_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WNODE_HEADER__bindgen_ty_2 {
   pub CountLost: ULONG,
   pub KernelHandle: HANDLE,
   pub TimeStamp: LARGE_INTEGER,
}
impl Default for _WNODE_HEADER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WNODE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WNODE_HEADER = _WNODE_HEADER;
pub type PWNODE_HEADER = *mut _WNODE_HEADER;
pub type TRACEHANDLE = ULONG64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_TRACE_HEADER {
   pub Size: USHORT,
   pub __bindgen_anon_1: _EVENT_TRACE_HEADER__bindgen_ty_1,
   pub __bindgen_anon_2: _EVENT_TRACE_HEADER__bindgen_ty_2,
   pub ThreadId: ULONG,
   pub ProcessId: ULONG,
   pub TimeStamp: LARGE_INTEGER,
   pub __bindgen_anon_3: _EVENT_TRACE_HEADER__bindgen_ty_3,
   pub __bindgen_anon_4: _EVENT_TRACE_HEADER__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_TRACE_HEADER__bindgen_ty_1 {
   pub FieldTypeFlags: USHORT,
   pub __bindgen_anon_1: _EVENT_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1 {
   pub HeaderType: UCHAR,
   pub MarkerFlags: UCHAR,
}
impl Default for _EVENT_TRACE_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_TRACE_HEADER__bindgen_ty_2 {
   pub Version: ULONG,
   pub Class: _EVENT_TRACE_HEADER__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_HEADER__bindgen_ty_2__bindgen_ty_1 {
   pub Type: UCHAR,
   pub Level: UCHAR,
   pub Version: USHORT,
}
impl Default for _EVENT_TRACE_HEADER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_TRACE_HEADER__bindgen_ty_3 {
   pub Guid: GUID,
   pub GuidPtr: ULONGLONG,
}
impl Default for _EVENT_TRACE_HEADER__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_TRACE_HEADER__bindgen_ty_4 {
   pub __bindgen_anon_1: _EVENT_TRACE_HEADER__bindgen_ty_4__bindgen_ty_1,
   pub ProcessorTime: ULONG64,
   pub __bindgen_anon_2: _EVENT_TRACE_HEADER__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_HEADER__bindgen_ty_4__bindgen_ty_1 {
   pub KernelTime: ULONG,
   pub UserTime: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_HEADER__bindgen_ty_4__bindgen_ty_2 {
   pub ClientContext: ULONG,
   pub Flags: ULONG,
}
impl Default for _EVENT_TRACE_HEADER__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _EVENT_TRACE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_HEADER = _EVENT_TRACE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_FILTER_DESCRIPTOR {
   _unused: [u8; 0],
}
pub type PEVENT_FILTER_DESCRIPTOR = *mut _EVENT_FILTER_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_BUFFER_CONTEXT {
   pub __bindgen_anon_1: _ETW_BUFFER_CONTEXT__bindgen_ty_1,
   pub LoggerId: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_BUFFER_CONTEXT__bindgen_ty_1 {
   pub __bindgen_anon_1: _ETW_BUFFER_CONTEXT__bindgen_ty_1__bindgen_ty_1,
   pub ProcessorIndex: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_BUFFER_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   pub ProcessorNumber: UCHAR,
   pub Alignment: UCHAR,
}
impl Default for _ETW_BUFFER_CONTEXT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ETW_BUFFER_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_BUFFER_CONTEXT = _ETW_BUFFER_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROFILE_SOURCE_INFO {
   pub NextEntryOffset: ULONG,
   pub Source: ULONG,
   pub MinInterval: ULONG,
   pub MaxInterval: ULONG,
   pub Reserved: ULONG64,
   pub Description: [WCHAR; 1usize],
}
pub type PPROFILE_SOURCE_INFO = *mut _PROFILE_SOURCE_INFO;
pub type DOUBLE = f64;
pub type PDOUBLE = *mut DOUBLE;
pub type PGUID = *mut GUID;
pub type PCGUID = *const GUID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUAD {
   pub __bindgen_anon_1: _QUAD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUAD__bindgen_ty_1 {
   pub UseThisFieldToCopy: ::core::ffi::c_longlong,
   pub DoNotUseThisField: f64,
}
impl Default for _QUAD__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _QUAD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type QUAD = _QUAD;
pub type PQUAD = *mut _QUAD;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _QUAD_PTR {
   pub DoNotUseThisField1: ULONG_PTR,
   pub DoNotUseThisField2: ULONG_PTR,
}
pub type QUAD_PTR = _QUAD_PTR;
pub type PQUAD_PTR = *mut _QUAD_PTR;
pub type LOGICAL = ULONG;
pub type PLOGICAL = *mut ULONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type CSHORT = ::core::ffi::c_short;
pub type CLONG = ULONG;
pub type PCCHAR = *mut CCHAR;
pub type PCSHORT = *mut CSHORT;
pub type PCLONG = *mut CLONG;
pub type PCSZ = PCSTR;
pub type PPVOID = *mut PVOID;
pub type PCVOID = *const ::core::ffi::c_void;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut UCHAR;
pub type KPRIORITY = LONG;
pub type PKPRIORITY = *mut LONG;
pub type RTL_ATOM = USHORT;
pub type PRTL_ATOM = *mut USHORT;
pub type PHYSICAL_ADDRESS = LARGE_INTEGER;
pub type PPHYSICAL_ADDRESS = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER_128 {
   pub QuadPart: [LONGLONG; 2usize],
}
pub type LARGE_INTEGER_128 = _LARGE_INTEGER_128;
pub type PLARGE_INTEGER_128 = *mut _LARGE_INTEGER_128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ULARGE_INTEGER_128 {
   pub QuadPart: [ULONGLONG; 2usize],
}
pub type ULARGE_INTEGER_128 = _ULARGE_INTEGER_128;
pub type PULARGE_INTEGER_128 = *mut _ULARGE_INTEGER_128;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_TYPE {
   NotificationEvent = 0,
   SynchronizationEvent = 1,
}
pub use self::_EVENT_TYPE as EVENT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TIMER_TYPE {
   NotificationTimer = 0,
   SynchronizationTimer = 1,
}
pub use self::_TIMER_TYPE as TIMER_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WAIT_TYPE {
   WaitAll = 0,
   WaitAny = 1,
   WaitNotification = 2,
   WaitDequeue = 3,
   WaitDpc = 4,
}
pub use self::_WAIT_TYPE as WAIT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
   pub Length: USHORT,
   pub MaximumLength: USHORT,
   pub Buffer: PCHAR,
}
impl Default for _STRING {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type STRING = _STRING;
pub type PSTRING = *mut _STRING;
pub type ANSI_STRING = _STRING;
pub type PANSI_STRING = *mut _STRING;
pub type OEM_STRING = _STRING;
pub type POEM_STRING = *mut _STRING;
pub type UTF8_STRING = STRING;
pub type PUTF8_STRING = PSTRING;
pub type PCSTRING = *const STRING;
pub type PCANSI_STRING = *const ANSI_STRING;
pub type PCOEM_STRING = *const OEM_STRING;
pub type PUNICODE_STRING = *mut _UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BALANCED_NODE {
   pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1,
   pub __bindgen_anon_2: _RTL_BALANCED_NODE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_1 {
   pub Children: [*mut _RTL_BALANCED_NODE; 2usize],
   pub __bindgen_anon_1: _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
   pub Left: *mut _RTL_BALANCED_NODE,
   pub Right: *mut _RTL_BALANCED_NODE,
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE__bindgen_ty_2 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub ParentValue: ULONG_PTR,
}
impl Default for _RTL_BALANCED_NODE__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _RTL_BALANCED_NODE__bindgen_ty_2 {
   #[inline]
   pub fn Red(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Red(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Red_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Red_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Balance(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_Balance(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Balance_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            2u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Balance_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Red: UCHAR, Balance: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Red: u8 = unsafe { ::core::mem::transmute(Red) };
         Red as u64
      });
      __bindgen_bitfield_unit.set(1usize, 2u8, {
         let Balance: u8 = unsafe { ::core::mem::transmute(Balance) };
         Balance as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_BALANCED_NODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BALANCED_NODE = _RTL_BALANCED_NODE;
pub type PRTL_BALANCED_NODE = *mut _RTL_BALANCED_NODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY32 {
   pub Next: ULONG,
}
pub type SINGLE_LIST_ENTRY32 = _SINGLE_LIST_ENTRY32;
pub type PSINGLE_LIST_ENTRY32 = *mut _SINGLE_LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _STRING32 {
   pub Length: USHORT,
   pub MaximumLength: USHORT,
   pub Buffer: ULONG,
}
pub type STRING32 = _STRING32;
pub type PSTRING32 = *mut _STRING32;
pub type UNICODE_STRING32 = STRING32;
pub type PUNICODE_STRING32 = *mut STRING32;
pub type ANSI_STRING32 = STRING32;
pub type PANSI_STRING32 = *mut STRING32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _STRING64 {
   pub Length: USHORT,
   pub MaximumLength: USHORT,
   pub Buffer: ULONGLONG,
}
pub type STRING64 = _STRING64;
pub type PSTRING64 = *mut _STRING64;
pub type UNICODE_STRING64 = STRING64;
pub type PUNICODE_STRING64 = *mut STRING64;
pub type ANSI_STRING64 = STRING64;
pub type PANSI_STRING64 = *mut STRING64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
   pub Length: ULONG,
   pub RootDirectory: HANDLE,
   pub ObjectName: PCUNICODE_STRING,
   pub Attributes: ULONG,
   pub SecurityDescriptor: PVOID,
   pub SecurityQualityOfService: PVOID,
}
impl Default for _OBJECT_ATTRIBUTES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
pub type POBJECT_ATTRIBUTES = *mut _OBJECT_ATTRIBUTES;
pub type PCOBJECT_ATTRIBUTES = *const OBJECT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES64 {
   pub Length: ULONG,
   pub RootDirectory: ULONG64,
   pub ObjectName: ULONG64,
   pub Attributes: ULONG,
   pub SecurityDescriptor: ULONG64,
   pub SecurityQualityOfService: ULONG64,
}
pub type OBJECT_ATTRIBUTES64 = _OBJECT_ATTRIBUTES64;
pub type POBJECT_ATTRIBUTES64 = *mut _OBJECT_ATTRIBUTES64;
pub type PCOBJECT_ATTRIBUTES64 = *const OBJECT_ATTRIBUTES64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES32 {
   pub Length: ULONG,
   pub RootDirectory: ULONG,
   pub ObjectName: ULONG,
   pub Attributes: ULONG,
   pub SecurityDescriptor: ULONG,
   pub SecurityQualityOfService: ULONG,
}
pub type OBJECT_ATTRIBUTES32 = _OBJECT_ATTRIBUTES32;
pub type POBJECT_ATTRIBUTES32 = *mut _OBJECT_ATTRIBUTES32;
pub type PCOBJECT_ATTRIBUTES32 = *const OBJECT_ATTRIBUTES32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NT_PRODUCT_TYPE {
   NtProductWinNt = 1,
   NtProductLanManNt = 2,
   NtProductServer = 3,
}
pub use self::_NT_PRODUCT_TYPE as NT_PRODUCT_TYPE;
pub type PNT_PRODUCT_TYPE = *mut _NT_PRODUCT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SUITE_TYPE {
   SmallBusiness = 0,
   Enterprise = 1,
   BackOffice = 2,
   CommunicationServer = 3,
   TerminalServer = 4,
   SmallBusinessRestricted = 5,
   EmbeddedNT = 6,
   DataCenter = 7,
   SingleUserTS = 8,
   Personal = 9,
   Blade = 10,
   EmbeddedRestricted = 11,
   SecurityAppliance = 12,
   StorageServer = 13,
   ComputeServer = 14,
   WHServer = 15,
   PhoneNT = 16,
   MaxSuiteType = 17,
}
pub use self::_SUITE_TYPE as SUITE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLIENT_ID {
   pub UniqueProcess: HANDLE,
   pub UniqueThread: HANDLE,
}
impl Default for _CLIENT_ID {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CLIENT_ID = _CLIENT_ID;
pub type PCLIENT_ID = *mut _CLIENT_ID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CLIENT_ID32 {
   pub UniqueProcess: ULONG,
   pub UniqueThread: ULONG,
}
pub type CLIENT_ID32 = _CLIENT_ID32;
pub type PCLIENT_ID32 = *mut _CLIENT_ID32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CLIENT_ID64 {
   pub UniqueProcess: ULONGLONG,
   pub UniqueThread: ULONGLONG,
}
pub type CLIENT_ID64 = _CLIENT_ID64;
pub type PCLIENT_ID64 = *mut _CLIENT_ID64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KSYSTEM_TIME {
   pub LowPart: ULONG,
   pub High1Time: LONG,
   pub High2Time: LONG,
}
pub type KSYSTEM_TIME = _KSYSTEM_TIME;
pub type PKSYSTEM_TIME = *mut _KSYSTEM_TIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPTABLEINFO {
   pub CodePage: USHORT,
   pub MaximumCharacterSize: USHORT,
   pub DefaultChar: USHORT,
   pub UniDefaultChar: USHORT,
   pub TransDefaultChar: USHORT,
   pub TransUniDefaultChar: USHORT,
   pub DBCSCodePage: USHORT,
   pub LeadByte: [UCHAR; 12usize],
   pub MultiByteTable: PUSHORT,
   pub WideCharTable: PVOID,
   pub DBCSRanges: PUSHORT,
   pub DBCSOffsets: PUSHORT,
}
impl Default for _CPTABLEINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CPTABLEINFO = _CPTABLEINFO;
pub type PCPTABLEINFO = *mut _CPTABLEINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NLSTABLEINFO {
   pub OemTableInfo: CPTABLEINFO,
   pub AnsiTableInfo: CPTABLEINFO,
   pub UpperCaseTable: PUSHORT,
   pub LowerCaseTable: PUSHORT,
}
impl Default for _NLSTABLEINFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NLSTABLEINFO = _NLSTABLEINFO;
pub type PNLSTABLEINFO = *mut _NLSTABLEINFO;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTHREAD_STATE {
   Initialized = 0,
   Ready = 1,
   Running = 2,
   Standby = 3,
   Terminated = 4,
   Waiting = 5,
   Transition = 6,
   DeferredReady = 7,
   GateWaitObsolete = 8,
   WaitingForProcessInSwap = 9,
   MaximumThreadState = 10,
}
pub use self::_KTHREAD_STATE as KTHREAD_STATE;
pub type PKTHREAD_STATE = *mut _KTHREAD_STATE;
impl _KHETERO_CPU_POLICY {
   pub const KHeteroCpuPolicyStaticMax: _KHETERO_CPU_POLICY =
      _KHETERO_CPU_POLICY::KHeteroCpuPolicyDynamic;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KHETERO_CPU_POLICY {
   KHeteroCpuPolicyAll = 0,
   KHeteroCpuPolicyLarge = 1,
   KHeteroCpuPolicyLargeOrIdle = 2,
   KHeteroCpuPolicySmall = 3,
   KHeteroCpuPolicySmallOrIdle = 4,
   KHeteroCpuPolicyDynamic = 5,
   KHeteroCpuPolicyBiasedSmall = 6,
   KHeteroCpuPolicyBiasedLarge = 7,
   KHeteroCpuPolicyDefault = 8,
   KHeteroCpuPolicyMax = 9,
}
pub use self::_KHETERO_CPU_POLICY as KHETERO_CPU_POLICY;
pub type PKHETERO_CPU_POLICY = *mut _KHETERO_CPU_POLICY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KWAIT_REASON {
   Executive = 0,
   FreePage = 1,
   PageIn = 2,
   PoolAllocation = 3,
   DelayExecution = 4,
   Suspended = 5,
   UserRequest = 6,
   WrExecutive = 7,
   WrFreePage = 8,
   WrPageIn = 9,
   WrPoolAllocation = 10,
   WrDelayExecution = 11,
   WrSuspended = 12,
   WrUserRequest = 13,
   WrEventPair = 14,
   WrQueue = 15,
   WrLpcReceive = 16,
   WrLpcReply = 17,
   WrVirtualMemory = 18,
   WrPageOut = 19,
   WrRendezvous = 20,
   WrKeyedEvent = 21,
   WrTerminated = 22,
   WrProcessInSwap = 23,
   WrCpuRateControl = 24,
   WrCalloutStack = 25,
   WrKernel = 26,
   WrResource = 27,
   WrPushLock = 28,
   WrMutex = 29,
   WrQuantumEnd = 30,
   WrDispatchInt = 31,
   WrPreempted = 32,
   WrYieldExecution = 33,
   WrFastMutex = 34,
   WrGuardedMutex = 35,
   WrRundown = 36,
   WrAlertByThreadId = 37,
   WrDeferredPreempt = 38,
   WrPhysicalFault = 39,
   WrIoRing = 40,
   WrMdlCache = 41,
   WrRcu = 42,
   MaximumWaitReason = 43,
}
pub use self::_KWAIT_REASON as KWAIT_REASON;
pub type PKWAIT_REASON = *mut _KWAIT_REASON;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KPROFILE_SOURCE {
   ProfileTime = 0,
   ProfileAlignmentFixup = 1,
   ProfileTotalIssues = 2,
   ProfilePipelineDry = 3,
   ProfileLoadInstructions = 4,
   ProfilePipelineFrozen = 5,
   ProfileBranchInstructions = 6,
   ProfileTotalNonissues = 7,
   ProfileDcacheMisses = 8,
   ProfileIcacheMisses = 9,
   ProfileCacheMisses = 10,
   ProfileBranchMispredictions = 11,
   ProfileStoreInstructions = 12,
   ProfileFpInstructions = 13,
   ProfileIntegerInstructions = 14,
   Profile2Issue = 15,
   Profile3Issue = 16,
   Profile4Issue = 17,
   ProfileSpecialInstructions = 18,
   ProfileTotalCycles = 19,
   ProfileIcacheIssues = 20,
   ProfileDcacheAccesses = 21,
   ProfileMemoryBarrierCycles = 22,
   ProfileLoadLinkedIssues = 23,
   ProfileMaximum = 24,
}
pub use self::_KPROFILE_SOURCE as KPROFILE_SOURCE;
pub type PLDR_INIT_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(DllHandle: PVOID, Reason: ULONG, Context: PVOID) -> BOOLEAN,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_SERVICE_TAG_RECORD {
   pub Next: *mut _LDR_SERVICE_TAG_RECORD,
   pub ServiceTag: ULONG,
}
impl Default for _LDR_SERVICE_TAG_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_SERVICE_TAG_RECORD = _LDR_SERVICE_TAG_RECORD;
pub type PLDR_SERVICE_TAG_RECORD = *mut _LDR_SERVICE_TAG_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDRP_CSLIST {
   pub Tail: PSINGLE_LIST_ENTRY,
}
impl Default for _LDRP_CSLIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDRP_CSLIST = _LDRP_CSLIST;
pub type PLDRP_CSLIST = *mut _LDRP_CSLIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LDR_DDAG_STATE {
   LdrModulesMerged = -5,
   LdrModulesInitError = -4,
   LdrModulesSnapError = -3,
   LdrModulesUnloaded = -2,
   LdrModulesUnloading = -1,
   LdrModulesPlaceHolder = 0,
   LdrModulesMapping = 1,
   LdrModulesMapped = 2,
   LdrModulesWaitingForDependencies = 3,
   LdrModulesSnapping = 4,
   LdrModulesSnapped = 5,
   LdrModulesCondensed = 6,
   LdrModulesReadyToInit = 7,
   LdrModulesInitializing = 8,
   LdrModulesReadyToRun = 9,
}
pub use self::_LDR_DDAG_STATE as LDR_DDAG_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DDAG_NODE {
   pub Modules: LIST_ENTRY,
   pub ServiceTagList: PLDR_SERVICE_TAG_RECORD,
   pub LoadCount: ULONG,
   pub LoadWhileUnloadingCount: ULONG,
   pub LowestLink: ULONG,
   pub __bindgen_anon_1: _LDR_DDAG_NODE__bindgen_ty_1,
   pub IncomingDependencies: LDRP_CSLIST,
   pub State: LDR_DDAG_STATE,
   pub CondenseLink: SINGLE_LIST_ENTRY,
   pub PreorderNumber: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DDAG_NODE__bindgen_ty_1 {
   pub Dependencies: LDRP_CSLIST,
   pub RemovalLink: SINGLE_LIST_ENTRY,
}
impl Default for _LDR_DDAG_NODE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_DDAG_NODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DDAG_NODE = _LDR_DDAG_NODE;
pub type PLDR_DDAG_NODE = *mut _LDR_DDAG_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DEPENDENCY_RECORD {
   pub DependencyLink: SINGLE_LIST_ENTRY,
   pub DependencyNode: PLDR_DDAG_NODE,
   pub IncomingDependencyLink: SINGLE_LIST_ENTRY,
   pub IncomingDependencyNode: PLDR_DDAG_NODE,
}
impl Default for _LDR_DEPENDENCY_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DEPENDENCY_RECORD = _LDR_DEPENDENCY_RECORD;
pub type PLDR_DEPENDENCY_RECORD = *mut _LDR_DEPENDENCY_RECORD;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LDR_DLL_LOAD_REASON {
   LoadReasonStaticDependency = 0,
   LoadReasonStaticForwarderDependency = 1,
   LoadReasonDynamicForwarderDependency = 2,
   LoadReasonDelayloadDependency = 3,
   LoadReasonDynamicLoad = 4,
   LoadReasonAsImageLoad = 5,
   LoadReasonAsDataLoad = 6,
   LoadReasonEnclavePrimary = 7,
   LoadReasonEnclaveDependency = 8,
   LoadReasonPatchImage = 9,
   LoadReasonUnknown = -1,
}
pub use self::_LDR_DLL_LOAD_REASON as LDR_DLL_LOAD_REASON;
pub type PLDR_DLL_LOAD_REASON = *mut _LDR_DLL_LOAD_REASON;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LDR_HOT_PATCH_STATE {
   LdrHotPatchBaseImage = 0,
   LdrHotPatchNotApplied = 1,
   LdrHotPatchAppliedReverse = 2,
   LdrHotPatchAppliedForward = 3,
   LdrHotPatchFailedToPatch = 4,
   LdrHotPatchStateMax = 5,
}
pub use self::_LDR_HOT_PATCH_STATE as LDR_HOT_PATCH_STATE;
pub type PLDR_HOT_PATCH_STATE = *mut _LDR_HOT_PATCH_STATE;
pub type PACTIVATION_CONTEXT = *mut _ACTIVATION_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDRP_LOAD_CONTEXT {
   _unused: [u8; 0],
}
pub type PLDRP_LOAD_CONTEXT = *mut _LDRP_LOAD_CONTEXT;
#[repr(C)]
pub struct _LDR_DATA_TABLE_ENTRY {
   pub InLoadOrderLinks: LIST_ENTRY,
   pub InMemoryOrderLinks: LIST_ENTRY,
   pub InInitializationOrderLinks: LIST_ENTRY,
   pub DllBase: PVOID,
   pub EntryPoint: PLDR_INIT_ROUTINE,
   pub SizeOfImage: ULONG,
   pub FullDllName: UNICODE_STRING,
   pub BaseDllName: UNICODE_STRING,
   pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1,
   pub ObsoleteLoadCount: USHORT,
   pub TlsIndex: USHORT,
   pub HashLinks: LIST_ENTRY,
   pub TimeDateStamp: ULONG,
   pub EntryPointActivationContext: PACTIVATION_CONTEXT,
   pub Lock: PVOID,
   pub DdagNode: PLDR_DDAG_NODE,
   pub NodeModuleLink: LIST_ENTRY,
   pub LoadContext: PLDRP_LOAD_CONTEXT,
   pub ParentDllBase: PVOID,
   pub SwitchBackContext: PVOID,
   pub BaseAddressIndexNode: RTL_BALANCED_NODE,
   pub MappingInfoIndexNode: RTL_BALANCED_NODE,
   pub OriginalBase: ULONG_PTR,
   pub LoadTime: LARGE_INTEGER,
   pub BaseNameHashValue: ULONG,
   pub LoadReason: LDR_DLL_LOAD_REASON,
   pub ImplicitPathOptions: ULONG,
   pub ReferenceCount: ULONG,
   pub DependentLoadFlags: ULONG,
   pub SigningLevel: UCHAR,
   pub CheckSum: ULONG,
   pub ActivePatchImageBase: PVOID,
   pub HotPatchState: LDR_HOT_PATCH_STATE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
   pub FlagGroup: [UCHAR; 4usize],
   pub Flags: ULONG,
   pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _LDR_DATA_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn PackagedBinary(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PackagedBinary(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PackagedBinary_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PackagedBinary_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MarkedForRemoval(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MarkedForRemoval(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MarkedForRemoval_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MarkedForRemoval_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageDll(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageDll(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageDll_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageDll_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoadNotificationsSent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadNotificationsSent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoadNotificationsSent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LoadNotificationsSent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TelemetryEntryProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_TelemetryEntryProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TelemetryEntryProcessed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TelemetryEntryProcessed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessStaticImport(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessStaticImport(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessStaticImport_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessStaticImport_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InLegacyLists(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InLegacyLists(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InLegacyLists_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InLegacyLists_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InIndexes(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InIndexes(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InIndexes_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InIndexes_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ShimDll(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ShimDll(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ShimDll_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ShimDll_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InExceptionTable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InExceptionTable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InExceptionTable_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InExceptionTable_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags1_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags1_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoadInProgress(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadInProgress(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoadInProgress_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LoadInProgress_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoadConfigProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadConfigProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoadConfigProcessed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LoadConfigProcessed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EntryProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EntryProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EntryProcessed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EntryProcessed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProtectDelayLoad(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProtectDelayLoad(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProtectDelayLoad_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProtectDelayLoad_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags3(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags3(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags3_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags3_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DontCallForThreads(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DontCallForThreads(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DontCallForThreads_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            18usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DontCallForThreads_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            18usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessAttachCalled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessAttachCalled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(19usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessAttachCalled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            19usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessAttachCalled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            19usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessAttachFailed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessAttachFailed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessAttachFailed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessAttachFailed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CorDeferredValidate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorDeferredValidate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CorDeferredValidate_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            21usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CorDeferredValidate_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            21usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CorImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CorImage_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            22usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CorImage_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            22usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DontRelocate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DontRelocate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DontRelocate_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            23usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DontRelocate_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            23usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CorILOnly(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorILOnly(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CorILOnly_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CorILOnly_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ChpeImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ChpeImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(25usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ChpeImage_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            25usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ChpeImage_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            25usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ChpeEmulatorImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ChpeEmulatorImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(26usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ChpeEmulatorImage_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            26usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ChpeEmulatorImage_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            26usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags5(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags5(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(27usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags5_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            27usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags5_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            27usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Redirected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Redirected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Redirected_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Redirected_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags6(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags6(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(29usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags6_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            29usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags6_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            29usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CompatDatabaseProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompatDatabaseProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CompatDatabaseProcessed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            31usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CompatDatabaseProcessed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            31usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PackagedBinary: ULONG,
      MarkedForRemoval: ULONG,
      ImageDll: ULONG,
      LoadNotificationsSent: ULONG,
      TelemetryEntryProcessed: ULONG,
      ProcessStaticImport: ULONG,
      InLegacyLists: ULONG,
      InIndexes: ULONG,
      ShimDll: ULONG,
      InExceptionTable: ULONG,
      ReservedFlags1: ULONG,
      LoadInProgress: ULONG,
      LoadConfigProcessed: ULONG,
      EntryProcessed: ULONG,
      ProtectDelayLoad: ULONG,
      ReservedFlags3: ULONG,
      DontCallForThreads: ULONG,
      ProcessAttachCalled: ULONG,
      ProcessAttachFailed: ULONG,
      CorDeferredValidate: ULONG,
      CorImage: ULONG,
      DontRelocate: ULONG,
      CorILOnly: ULONG,
      ChpeImage: ULONG,
      ChpeEmulatorImage: ULONG,
      ReservedFlags5: ULONG,
      Redirected: ULONG,
      ReservedFlags6: ULONG,
      CompatDatabaseProcessed: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let PackagedBinary: u32 = unsafe { ::core::mem::transmute(PackagedBinary) };
         PackagedBinary as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let MarkedForRemoval: u32 = unsafe { ::core::mem::transmute(MarkedForRemoval) };
         MarkedForRemoval as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ImageDll: u32 = unsafe { ::core::mem::transmute(ImageDll) };
         ImageDll as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let LoadNotificationsSent: u32 = unsafe { ::core::mem::transmute(LoadNotificationsSent) };
         LoadNotificationsSent as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let TelemetryEntryProcessed: u32 =
            unsafe { ::core::mem::transmute(TelemetryEntryProcessed) };
         TelemetryEntryProcessed as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ProcessStaticImport: u32 = unsafe { ::core::mem::transmute(ProcessStaticImport) };
         ProcessStaticImport as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let InLegacyLists: u32 = unsafe { ::core::mem::transmute(InLegacyLists) };
         InLegacyLists as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let InIndexes: u32 = unsafe { ::core::mem::transmute(InIndexes) };
         InIndexes as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let ShimDll: u32 = unsafe { ::core::mem::transmute(ShimDll) };
         ShimDll as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let InExceptionTable: u32 = unsafe { ::core::mem::transmute(InExceptionTable) };
         InExceptionTable as u64
      });
      __bindgen_bitfield_unit.set(10usize, 2u8, {
         let ReservedFlags1: u32 = unsafe { ::core::mem::transmute(ReservedFlags1) };
         ReservedFlags1 as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let LoadInProgress: u32 = unsafe { ::core::mem::transmute(LoadInProgress) };
         LoadInProgress as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let LoadConfigProcessed: u32 = unsafe { ::core::mem::transmute(LoadConfigProcessed) };
         LoadConfigProcessed as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let EntryProcessed: u32 = unsafe { ::core::mem::transmute(EntryProcessed) };
         EntryProcessed as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let ProtectDelayLoad: u32 = unsafe { ::core::mem::transmute(ProtectDelayLoad) };
         ProtectDelayLoad as u64
      });
      __bindgen_bitfield_unit.set(16usize, 2u8, {
         let ReservedFlags3: u32 = unsafe { ::core::mem::transmute(ReservedFlags3) };
         ReservedFlags3 as u64
      });
      __bindgen_bitfield_unit.set(18usize, 1u8, {
         let DontCallForThreads: u32 = unsafe { ::core::mem::transmute(DontCallForThreads) };
         DontCallForThreads as u64
      });
      __bindgen_bitfield_unit.set(19usize, 1u8, {
         let ProcessAttachCalled: u32 = unsafe { ::core::mem::transmute(ProcessAttachCalled) };
         ProcessAttachCalled as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let ProcessAttachFailed: u32 = unsafe { ::core::mem::transmute(ProcessAttachFailed) };
         ProcessAttachFailed as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let CorDeferredValidate: u32 = unsafe { ::core::mem::transmute(CorDeferredValidate) };
         CorDeferredValidate as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let CorImage: u32 = unsafe { ::core::mem::transmute(CorImage) };
         CorImage as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let DontRelocate: u32 = unsafe { ::core::mem::transmute(DontRelocate) };
         DontRelocate as u64
      });
      __bindgen_bitfield_unit.set(24usize, 1u8, {
         let CorILOnly: u32 = unsafe { ::core::mem::transmute(CorILOnly) };
         CorILOnly as u64
      });
      __bindgen_bitfield_unit.set(25usize, 1u8, {
         let ChpeImage: u32 = unsafe { ::core::mem::transmute(ChpeImage) };
         ChpeImage as u64
      });
      __bindgen_bitfield_unit.set(26usize, 1u8, {
         let ChpeEmulatorImage: u32 = unsafe { ::core::mem::transmute(ChpeEmulatorImage) };
         ChpeEmulatorImage as u64
      });
      __bindgen_bitfield_unit.set(27usize, 1u8, {
         let ReservedFlags5: u32 = unsafe { ::core::mem::transmute(ReservedFlags5) };
         ReservedFlags5 as u64
      });
      __bindgen_bitfield_unit.set(28usize, 1u8, {
         let Redirected: u32 = unsafe { ::core::mem::transmute(Redirected) };
         Redirected as u64
      });
      __bindgen_bitfield_unit.set(29usize, 2u8, {
         let ReservedFlags6: u32 = unsafe { ::core::mem::transmute(ReservedFlags6) };
         ReservedFlags6 as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let CompatDatabaseProcessed: u32 =
            unsafe { ::core::mem::transmute(CompatDatabaseProcessed) };
         CompatDatabaseProcessed as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_DATA_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DATA_TABLE_ENTRY = _LDR_DATA_TABLE_ENTRY;
pub type PLDR_DATA_TABLE_ENTRY = *mut _LDR_DATA_TABLE_ENTRY;
pub type PLDR_IMPORT_MODULE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(Parameter: PVOID, ModuleName: PSTR)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_IMPORT_CALLBACK_INFO {
   pub ImportCallbackRoutine: PLDR_IMPORT_MODULE_CALLBACK,
   pub ImportCallbackParameter: PVOID,
}
impl Default for _LDR_IMPORT_CALLBACK_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_IMPORT_CALLBACK_INFO = _LDR_IMPORT_CALLBACK_INFO;
pub type PLDR_IMPORT_CALLBACK_INFO = *mut _LDR_IMPORT_CALLBACK_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_SECTION_INFO {
   pub SectionHandle: HANDLE,
   pub DesiredAccess: ACCESS_MASK,
   pub ObjA: POBJECT_ATTRIBUTES,
   pub SectionPageProtection: ULONG,
   pub AllocationAttributes: ULONG,
}
impl Default for _LDR_SECTION_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_SECTION_INFO = _LDR_SECTION_INFO;
pub type PLDR_SECTION_INFO = *mut _LDR_SECTION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_VERIFY_IMAGE_INFO {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub CallbackInfo: LDR_IMPORT_CALLBACK_INFO,
   pub SectionInfo: LDR_SECTION_INFO,
   pub ImageCharacteristics: USHORT,
}
impl Default for _LDR_VERIFY_IMAGE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_VERIFY_IMAGE_INFO = _LDR_VERIFY_IMAGE_INFO;
pub type PLDR_VERIFY_IMAGE_INFO = *mut _LDR_VERIFY_IMAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
   pub Flags: ULONG,
   pub FullDllName: PUNICODE_STRING,
   pub BaseDllName: PUNICODE_STRING,
   pub DllBase: PVOID,
   pub SizeOfImage: ULONG,
}
impl Default for _LDR_DLL_LOADED_NOTIFICATION_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DLL_LOADED_NOTIFICATION_DATA = _LDR_DLL_LOADED_NOTIFICATION_DATA;
pub type PLDR_DLL_LOADED_NOTIFICATION_DATA = *mut _LDR_DLL_LOADED_NOTIFICATION_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
   pub Flags: ULONG,
   pub FullDllName: PCUNICODE_STRING,
   pub BaseDllName: PCUNICODE_STRING,
   pub DllBase: PVOID,
   pub SizeOfImage: ULONG,
}
impl Default for _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DLL_UNLOADED_NOTIFICATION_DATA = _LDR_DLL_UNLOADED_NOTIFICATION_DATA;
pub type PLDR_DLL_UNLOADED_NOTIFICATION_DATA = *mut _LDR_DLL_UNLOADED_NOTIFICATION_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DLL_NOTIFICATION_DATA {
   pub Loaded: LDR_DLL_LOADED_NOTIFICATION_DATA,
   pub Unloaded: LDR_DLL_UNLOADED_NOTIFICATION_DATA,
}
impl Default for _LDR_DLL_NOTIFICATION_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DLL_NOTIFICATION_DATA = _LDR_DLL_NOTIFICATION_DATA;
pub type PLDR_DLL_NOTIFICATION_DATA = *mut _LDR_DLL_NOTIFICATION_DATA;
pub type PLDR_DLL_NOTIFICATION_FUNCTION = ::core::option::Option<
   unsafe extern "C" fn(
      NotificationReason: ULONG,
      NotificationData: PLDR_DLL_NOTIFICATION_DATA,
      Context: PVOID,
   ),
>;
#[repr(C)]
pub struct _LDR_FAILURE_DATA {
   pub Status: NTSTATUS,
   pub DllName: [WCHAR; 32usize],
   pub AdditionalInfo: [WCHAR; 32usize],
}
impl Default for _LDR_FAILURE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_FAILURE_DATA = _LDR_FAILURE_DATA;
pub type PLDR_FAILURE_DATA = *mut _LDR_FAILURE_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_MITIGATION_OPTIONS_MAP {
   pub Map: [ULONG_PTR; 3usize],
}
pub type PS_MITIGATION_OPTIONS_MAP = _PS_MITIGATION_OPTIONS_MAP;
pub type PPS_MITIGATION_OPTIONS_MAP = *mut _PS_MITIGATION_OPTIONS_MAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_MITIGATION_AUDIT_OPTIONS_MAP {
   pub Map: [ULONG_PTR; 3usize],
}
pub type PS_MITIGATION_AUDIT_OPTIONS_MAP = _PS_MITIGATION_AUDIT_OPTIONS_MAP;
pub type PPS_MITIGATION_AUDIT_OPTIONS_MAP = *mut _PS_MITIGATION_AUDIT_OPTIONS_MAP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_SYSTEM_DLL_INIT_BLOCK {
   pub Size: ULONG,
   pub SystemDllWowRelocation: ULONG_PTR,
   pub SystemDllNativeRelocation: ULONG_PTR,
   pub Wow64SharedInformation: [ULONG_PTR; 16usize],
   pub RngData: ULONG,
   pub __bindgen_anon_1: _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1,
   pub MitigationOptionsMap: PS_MITIGATION_OPTIONS_MAP,
   pub CfgBitMap: ULONG_PTR,
   pub CfgBitMapSize: ULONG_PTR,
   pub Wow64CfgBitMap: ULONG_PTR,
   pub Wow64CfgBitMapSize: ULONG_PTR,
   pub MitigationAuditOptionsMap: PS_MITIGATION_AUDIT_OPTIONS_MAP,
   pub ScpCfgCheckFunction: ULONG_PTR,
   pub ScpCfgCheckESFunction: ULONG_PTR,
   pub ScpCfgDispatchFunction: ULONG_PTR,
   pub ScpCfgDispatchESFunction: ULONG_PTR,
   pub ScpArm64EcCallCheck: ULONG_PTR,
   pub ScpArm64EcCfgCheckFunction: ULONG_PTR,
   pub ScpArm64EcCfgCheckESFunction: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn CfgOverride(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CfgOverride(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CfgOverride_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CfgOverride_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      CfgOverride: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let CfgOverride: u32 = unsafe { ::core::mem::transmute(CfgOverride) };
         CfgOverride as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_SYSTEM_DLL_INIT_BLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_SYSTEM_DLL_INIT_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_SYSTEM_DLL_INIT_BLOCK = _PS_SYSTEM_DLL_INIT_BLOCK;
pub type PPS_SYSTEM_DLL_INIT_BLOCK = *mut _PS_SYSTEM_DLL_INIT_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SCPCFG_NTDLL_EXPORTS {
   pub ScpCfgHeader_Nop: PVOID,
   pub ScpCfgEnd_Nop: PVOID,
   pub ScpCfgHeader: PVOID,
   pub ScpCfgEnd: PVOID,
   pub ScpCfgHeader_ES: PVOID,
   pub ScpCfgEnd_ES: PVOID,
   pub ScpCfgHeader_Fptr: PVOID,
   pub ScpCfgEnd_Fptr: PVOID,
   pub LdrpGuardDispatchIcallNoESFptr: PVOID,
   pub __guard_dispatch_icall_fptr: PVOID,
   pub LdrpGuardCheckIcallNoESFptr: PVOID,
   pub __guard_check_icall_fptr: PVOID,
   pub LdrpHandleInvalidUserCallTarget: PVOID,
   pub LdrpCriticalLoaderFunctions: _RTL_SCPCFG_NTDLL_EXPORTS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SCPCFG_NTDLL_EXPORTS__bindgen_ty_1 {
   pub NtOpenFile: PVOID,
   pub NtCreateSection: PVOID,
   pub NtQueryAttributesFile: PVOID,
   pub NtOpenSection: PVOID,
   pub NtMapViewOfSection: PVOID,
}
impl Default for _RTL_SCPCFG_NTDLL_EXPORTS__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_SCPCFG_NTDLL_EXPORTS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SCPCFG_NTDLL_EXPORTS = _RTL_SCPCFG_NTDLL_EXPORTS;
pub type PRTL_SCPCFG_NTDLL_EXPORTS = *mut _RTL_SCPCFG_NTDLL_EXPORTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_RESOURCE_INFO {
   pub Type: ULONG_PTR,
   pub Name: ULONG_PTR,
   pub Language: ULONG_PTR,
}
pub type LDR_RESOURCE_INFO = _LDR_RESOURCE_INFO;
pub type PLDR_RESOURCE_INFO = *mut _LDR_RESOURCE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_ENUM_RESOURCE_ENTRY {
   pub Path: [_LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1; 3usize],
   pub Data: PVOID,
   pub Size: ULONG,
   pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1 {
   pub NameOrId: ULONG_PTR,
   pub Name: PIMAGE_RESOURCE_DIRECTORY_STRING,
   pub __bindgen_anon_1: _LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub Id: USHORT,
   pub NameIsPresent: USHORT,
}
impl Default for _LDR_ENUM_RESOURCE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_ENUM_RESOURCE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_ENUM_RESOURCE_ENTRY = _LDR_ENUM_RESOURCE_ENTRY;
pub type PLDR_ENUM_RESOURCE_ENTRY = *mut _LDR_ENUM_RESOURCE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_MODULE_INFORMATION {
   pub Section: PVOID,
   pub MappedBase: PVOID,
   pub ImageBase: PVOID,
   pub ImageSize: ULONG,
   pub Flags: ULONG,
   pub LoadOrderIndex: USHORT,
   pub InitOrderIndex: USHORT,
   pub LoadCount: USHORT,
   pub OffsetToFileName: USHORT,
   pub FullPathName: [UCHAR; 256usize],
}
impl Default for _RTL_PROCESS_MODULE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_MODULE_INFORMATION = _RTL_PROCESS_MODULE_INFORMATION;
pub type PRTL_PROCESS_MODULE_INFORMATION = *mut _RTL_PROCESS_MODULE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_MODULES {
   pub NumberOfModules: ULONG,
   pub Modules: [RTL_PROCESS_MODULE_INFORMATION; 1usize],
}
impl Default for _RTL_PROCESS_MODULES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_MODULES = _RTL_PROCESS_MODULES;
pub type PRTL_PROCESS_MODULES = *mut _RTL_PROCESS_MODULES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_PROCESS_MODULE_INFORMATION_EX {
   pub NextOffset: USHORT,
   pub __bindgen_anon_1: _RTL_PROCESS_MODULE_INFORMATION_EX__bindgen_ty_1,
   pub ImageChecksum: ULONG,
   pub TimeDateStamp: ULONG,
   pub DefaultBase: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_PROCESS_MODULE_INFORMATION_EX__bindgen_ty_1 {
   pub BaseInfo: RTL_PROCESS_MODULE_INFORMATION,
   pub __bindgen_anon_1: _RTL_PROCESS_MODULE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_MODULE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   pub Section: PVOID,
   pub MappedBase: PVOID,
   pub ImageBase: PVOID,
   pub ImageSize: ULONG,
   pub Flags: ULONG,
   pub LoadOrderIndex: USHORT,
   pub InitOrderIndex: USHORT,
   pub LoadCount: USHORT,
   pub OffsetToFileName: USHORT,
   pub FullPathName: [UCHAR; 256usize],
}
impl Default for _RTL_PROCESS_MODULE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_PROCESS_MODULE_INFORMATION_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_PROCESS_MODULE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_MODULE_INFORMATION_EX = _RTL_PROCESS_MODULE_INFORMATION_EX;
pub type PRTL_PROCESS_MODULE_INFORMATION_EX = *mut _RTL_PROCESS_MODULE_INFORMATION_EX;
pub type PLDR_ENUM_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      ModuleInformation: PLDR_DATA_TABLE_ENTRY,
      Parameter: PVOID,
      Stop: *mut BOOLEAN,
   ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DELAYLOAD_PROC_DESCRIPTOR {
   pub ImportDescribedByName: ULONG,
   pub Description: _DELAYLOAD_PROC_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DELAYLOAD_PROC_DESCRIPTOR__bindgen_ty_1 {
   pub Name: PCSTR,
   pub Ordinal: ULONG,
}
impl Default for _DELAYLOAD_PROC_DESCRIPTOR__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _DELAYLOAD_PROC_DESCRIPTOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DELAYLOAD_PROC_DESCRIPTOR = _DELAYLOAD_PROC_DESCRIPTOR;
pub type PDELAYLOAD_PROC_DESCRIPTOR = *mut _DELAYLOAD_PROC_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DELAYLOAD_INFO {
   pub Size: ULONG,
   pub DelayloadDescriptor: PCIMAGE_DELAYLOAD_DESCRIPTOR,
   pub ThunkAddress: PIMAGE_THUNK_DATA,
   pub TargetDllName: PCSTR,
   pub TargetApiDescriptor: DELAYLOAD_PROC_DESCRIPTOR,
   pub TargetModuleBase: PVOID,
   pub Unused: PVOID,
   pub LastError: ULONG,
}
impl Default for _DELAYLOAD_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DELAYLOAD_INFO = _DELAYLOAD_INFO;
pub type PDELAYLOAD_INFO = *mut _DELAYLOAD_INFO;
pub type PDELAYLOAD_FAILURE_DLL_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(NotificationReason: ULONG, DelayloadInfo: PDELAYLOAD_INFO) -> PVOID,
>;
pub type PDELAYLOAD_FAILURE_SYSTEM_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(DllName: PCSTR, ProcedureName: PCSTR) -> PVOID>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_SOFTWARE_ENCLAVE {
   pub Links: LIST_ENTRY,
   pub CriticalSection: RTL_CRITICAL_SECTION,
   pub EnclaveType: ULONG,
   pub ReferenceCount: LONG,
   pub EnclaveState: ULONG,
   pub BaseAddress: PVOID,
   pub Size: SIZE_T,
   pub PreviousBaseAddress: PVOID,
   pub Modules: LIST_ENTRY,
   pub PrimaryModule: PLDR_DATA_TABLE_ENTRY,
   pub BCryptModule: PLDR_DATA_TABLE_ENTRY,
   pub BCryptPrimitivesModule: PLDR_DATA_TABLE_ENTRY,
}
impl Default for _LDR_SOFTWARE_ENCLAVE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_SOFTWARE_ENCLAVE = _LDR_SOFTWARE_ENCLAVE;
pub type PLDR_SOFTWARE_ENCLAVE = *mut _LDR_SOFTWARE_ENCLAVE;
#[doc = "Thread Environment Block (TEB) structure.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb"]
pub type PTEB = *mut _TEB;
pub type PCOUNTED_REASON_CONTEXT = *mut _COUNTED_REASON_CONTEXT;
pub type PFILE_IO_COMPLETION_INFORMATION = *mut _FILE_IO_COMPLETION_INFORMATION;
pub type PPORT_MESSAGE = *mut _PORT_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECT {
   _unused: [u8; 0],
}
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT {
   _unused: [u8; 0],
}
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP {
   _unused: [u8; 0],
}
pub type PIRP = *mut _IRP;
pub type PRTL_BITMAP = *mut _RTL_BITMAP;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_ENVIRONMENT_INFORMATION_CLASS {
   SystemEnvironmentNameInformation = 1,
   SystemEnvironmentValueInformation = 2,
   MaxSystemEnvironmentInfoClass = 3,
}
pub use self::_SYSTEM_ENVIRONMENT_INFORMATION_CLASS as SYSTEM_ENVIRONMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VARIABLE_NAME {
   pub NextEntryOffset: ULONG,
   pub VendorGuid: GUID,
   pub Name: [WCHAR; 1usize],
}
pub type VARIABLE_NAME = _VARIABLE_NAME;
pub type PVARIABLE_NAME = *mut _VARIABLE_NAME;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VARIABLE_NAME_AND_VALUE {
   pub NextEntryOffset: ULONG,
   pub ValueOffset: ULONG,
   pub ValueLength: ULONG,
   pub Attributes: ULONG,
   pub VendorGuid: GUID,
   pub Name: [WCHAR; 1usize],
}
pub type VARIABLE_NAME_AND_VALUE = _VARIABLE_NAME_AND_VALUE;
pub type PVARIABLE_NAME_AND_VALUE = *mut _VARIABLE_NAME_AND_VALUE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BOOT_ENTRY {
   pub Version: ULONG,
   pub Length: ULONG,
   pub Id: ULONG,
   pub Attributes: ULONG,
   pub FriendlyNameOffset: ULONG,
   pub BootFilePathOffset: ULONG,
   pub OsOptionsLength: ULONG,
   pub OsOptions: [UCHAR; 1usize],
}
pub type BOOT_ENTRY = _BOOT_ENTRY;
pub type PBOOT_ENTRY = *mut _BOOT_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BOOT_ENTRY_LIST {
   pub NextEntryOffset: ULONG,
   pub BootEntry: BOOT_ENTRY,
}
pub type BOOT_ENTRY_LIST = _BOOT_ENTRY_LIST;
pub type PBOOT_ENTRY_LIST = *mut _BOOT_ENTRY_LIST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BOOT_OPTIONS {
   pub Version: ULONG,
   pub Length: ULONG,
   pub Timeout: ULONG,
   pub CurrentBootEntryId: ULONG,
   pub NextBootEntryId: ULONG,
   pub HeadlessRedirection: [WCHAR; 1usize],
}
pub type BOOT_OPTIONS = _BOOT_OPTIONS;
pub type PBOOT_OPTIONS = *mut _BOOT_OPTIONS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PATH {
   pub Version: ULONG,
   pub Length: ULONG,
   pub Type: ULONG,
   pub FilePath: [UCHAR; 1usize],
}
pub type FILE_PATH = _FILE_PATH;
pub type PFILE_PATH = *mut _FILE_PATH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EFI_DRIVER_ENTRY {
   pub Version: ULONG,
   pub Length: ULONG,
   pub Id: ULONG,
   pub FriendlyNameOffset: ULONG,
   pub DriverFilePathOffset: ULONG,
}
pub type EFI_DRIVER_ENTRY = _EFI_DRIVER_ENTRY;
pub type PEFI_DRIVER_ENTRY = *mut _EFI_DRIVER_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EFI_DRIVER_ENTRY_LIST {
   pub NextEntryOffset: ULONG,
   pub DriverEntry: EFI_DRIVER_ENTRY,
}
pub type EFI_DRIVER_ENTRY_LIST = _EFI_DRIVER_ENTRY_LIST;
pub type PEFI_DRIVER_ENTRY_LIST = *mut _EFI_DRIVER_ENTRY_LIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILTER_BOOT_OPTION_OPERATION {
   FilterBootOptionOperationOpenSystemStore = 0,
   FilterBootOptionOperationSetElement = 1,
   FilterBootOptionOperationDeleteElement = 2,
   FilterBootOptionOperationMax = 3,
}
pub use self::_FILTER_BOOT_OPTION_OPERATION as FILTER_BOOT_OPTION_OPERATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_INFORMATION_CLASS {
   EventBasicInformation = 0,
}
pub use self::_EVENT_INFORMATION_CLASS as EVENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_BASIC_INFORMATION {
   pub EventType: EVENT_TYPE,
   pub EventState: LONG,
}
impl Default for _EVENT_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_BASIC_INFORMATION = _EVENT_BASIC_INFORMATION;
pub type PEVENT_BASIC_INFORMATION = *mut _EVENT_BASIC_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MUTANT_INFORMATION_CLASS {
   MutantBasicInformation = 0,
   MutantOwnerInformation = 1,
}
pub use self::_MUTANT_INFORMATION_CLASS as MUTANT_INFORMATION_CLASS;
#[doc = "The MUTANT_BASIC_INFORMATION structure contains basic information about a mutant object."]
#[repr(C)]
pub struct _MUTANT_BASIC_INFORMATION {
   pub CurrentCount: LONG,
   pub OwnedByCaller: BOOLEAN,
   pub AbandonedState: BOOLEAN,
}
impl Default for _MUTANT_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The MUTANT_BASIC_INFORMATION structure contains basic information about a mutant object."]
pub type MUTANT_BASIC_INFORMATION = _MUTANT_BASIC_INFORMATION;
#[doc = "The MUTANT_BASIC_INFORMATION structure contains basic information about a mutant object."]
pub type PMUTANT_BASIC_INFORMATION = *mut _MUTANT_BASIC_INFORMATION;
#[doc = "The MUTANT_OWNER_INFORMATION structure contains information about the owner of a mutant object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MUTANT_OWNER_INFORMATION {
   pub ClientId: CLIENT_ID,
}
impl Default for _MUTANT_OWNER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The MUTANT_OWNER_INFORMATION structure contains information about the owner of a mutant object."]
pub type MUTANT_OWNER_INFORMATION = _MUTANT_OWNER_INFORMATION;
#[doc = "The MUTANT_OWNER_INFORMATION structure contains information about the owner of a mutant object."]
pub type PMUTANT_OWNER_INFORMATION = *mut _MUTANT_OWNER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SEMAPHORE_INFORMATION_CLASS {
   SemaphoreBasicInformation = 0,
}
pub use self::_SEMAPHORE_INFORMATION_CLASS as SEMAPHORE_INFORMATION_CLASS;
#[doc = "The SEMAPHORE_BASIC_INFORMATION structure contains basic information about a semaphore object."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEMAPHORE_BASIC_INFORMATION {
   pub CurrentCount: LONG,
   pub MaximumCount: LONG,
}
#[doc = "The SEMAPHORE_BASIC_INFORMATION structure contains basic information about a semaphore object."]
pub type SEMAPHORE_BASIC_INFORMATION = _SEMAPHORE_BASIC_INFORMATION;
#[doc = "The SEMAPHORE_BASIC_INFORMATION structure contains basic information about a semaphore object."]
pub type PSEMAPHORE_BASIC_INFORMATION = *mut _SEMAPHORE_BASIC_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TIMER_INFORMATION_CLASS {
   TimerBasicInformation = 0,
}
pub use self::_TIMER_INFORMATION_CLASS as TIMER_INFORMATION_CLASS;
#[repr(C)]
pub struct _TIMER_BASIC_INFORMATION {
   pub RemainingTime: LARGE_INTEGER,
   pub TimerState: BOOLEAN,
}
impl Default for _TIMER_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TIMER_BASIC_INFORMATION = _TIMER_BASIC_INFORMATION;
pub type PTIMER_BASIC_INFORMATION = *mut _TIMER_BASIC_INFORMATION;
pub type PTIMER_APC_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(TimerContext: PVOID, TimerLowValue: ULONG, TimerHighValue: LONG),
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TIMER_SET_INFORMATION_CLASS {
   TimerSetCoalescableTimer = 0,
   MaxTimerInfoClass = 1,
}
pub use self::_TIMER_SET_INFORMATION_CLASS as TIMER_SET_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TIMER_SET_COALESCABLE_TIMER_INFO {
   pub DueTime: LARGE_INTEGER,
   pub TimerApcRoutine: PTIMER_APC_ROUTINE,
   pub TimerContext: PVOID,
   pub WakeContext: PCOUNTED_REASON_CONTEXT,
   pub Period: ULONG,
   pub TolerableDelay: ULONG,
   pub PreviousState: PBOOLEAN,
}
impl Default for _TIMER_SET_COALESCABLE_TIMER_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TIMER_SET_COALESCABLE_TIMER_INFO = _TIMER_SET_COALESCABLE_TIMER_INFO;
pub type PTIMER_SET_COALESCABLE_TIMER_INFO = *mut _TIMER_SET_COALESCABLE_TIMER_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _T2_SET_PARAMETERS_V0 {
   pub Version: ULONG,
   pub Reserved: ULONG,
   pub NoWakeTolerance: LONGLONG,
}
pub type T2_SET_PARAMETERS = _T2_SET_PARAMETERS_V0;
pub type PT2_SET_PARAMETERS = *mut _T2_SET_PARAMETERS_V0;
pub type PT2_CANCEL_PARAMETERS = PVOID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNF_STATE_NAME {
   pub Data: [ULONG; 2usize],
}
pub type WNF_STATE_NAME = _WNF_STATE_NAME;
pub type PWNF_STATE_NAME = *mut _WNF_STATE_NAME;
pub type PCWNF_STATE_NAME = *const WNF_STATE_NAME;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WNF_STATE_NAME_LIFETIME {
   WnfWellKnownStateName = 0,
   WnfPermanentStateName = 1,
   WnfPersistentStateName = 2,
   WnfTemporaryStateName = 3,
}
pub use self::_WNF_STATE_NAME_LIFETIME as WNF_STATE_NAME_LIFETIME;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WNF_STATE_NAME_INFORMATION {
   WnfInfoStateNameExist = 0,
   WnfInfoSubscribersPresent = 1,
   WnfInfoIsQuiescent = 2,
}
pub use self::_WNF_STATE_NAME_INFORMATION as WNF_STATE_NAME_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WNF_DATA_SCOPE {
   WnfDataScopeSystem = 0,
   WnfDataScopeSession = 1,
   WnfDataScopeUser = 2,
   WnfDataScopeProcess = 3,
   WnfDataScopeMachine = 4,
   WnfDataScopePhysicalMachine = 5,
}
pub use self::_WNF_DATA_SCOPE as WNF_DATA_SCOPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNF_TYPE_ID {
   pub TypeId: GUID,
}
pub type WNF_TYPE_ID = _WNF_TYPE_ID;
pub type PWNF_TYPE_ID = *mut _WNF_TYPE_ID;
pub type PCWNF_TYPE_ID = *const WNF_TYPE_ID;
pub type WNF_CHANGE_STAMP = ULONG;
pub type PWNF_CHANGE_STAMP = *mut ULONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WNF_DELIVERY_DESCRIPTOR {
   pub SubscriptionId: ULONGLONG,
   pub StateName: WNF_STATE_NAME,
   pub ChangeStamp: WNF_CHANGE_STAMP,
   pub StateDataSize: ULONG,
   pub EventMask: ULONG,
   pub TypeId: WNF_TYPE_ID,
   pub StateDataOffset: ULONG,
}
pub type WNF_DELIVERY_DESCRIPTOR = _WNF_DELIVERY_DESCRIPTOR;
pub type PWNF_DELIVERY_DESCRIPTOR = *mut _WNF_DELIVERY_DESCRIPTOR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WORKERFACTORYINFOCLASS {
   WorkerFactoryTimeout = 0,
   WorkerFactoryRetryTimeout = 1,
   WorkerFactoryIdleTimeout = 2,
   WorkerFactoryBindingCount = 3,
   WorkerFactoryThreadMinimum = 4,
   WorkerFactoryThreadMaximum = 5,
   WorkerFactoryPaused = 6,
   WorkerFactoryBasicInformation = 7,
   WorkerFactoryAdjustThreadGoal = 8,
   WorkerFactoryCallbackType = 9,
   WorkerFactoryStackInformation = 10,
   WorkerFactoryThreadBasePriority = 11,
   WorkerFactoryTimeoutWaiters = 12,
   WorkerFactoryFlags = 13,
   WorkerFactoryThreadSoftMaximum = 14,
   WorkerFactoryThreadCpuSets = 15,
   MaxWorkerFactoryInfoClass = 16,
}
pub use self::_WORKERFACTORYINFOCLASS as WORKERFACTORYINFOCLASS;
pub type PWORKERFACTORYINFOCLASS = *mut _WORKERFACTORYINFOCLASS;
#[repr(C)]
pub struct _WORKER_FACTORY_BASIC_INFORMATION {
   pub Timeout: LARGE_INTEGER,
   pub RetryTimeout: LARGE_INTEGER,
   pub IdleTimeout: LARGE_INTEGER,
   pub Paused: BOOLEAN,
   pub TimerSet: BOOLEAN,
   pub QueuedToExWorker: BOOLEAN,
   pub MayCreate: BOOLEAN,
   pub CreateInProgress: BOOLEAN,
   pub InsertedIntoQueue: BOOLEAN,
   pub Shutdown: BOOLEAN,
   pub BindingCount: ULONG,
   pub ThreadMinimum: ULONG,
   pub ThreadMaximum: ULONG,
   pub PendingWorkerCount: ULONG,
   pub WaitingWorkerCount: ULONG,
   pub TotalWorkerCount: ULONG,
   pub ReleaseCount: ULONG,
   pub InfiniteWaitGoal: LONGLONG,
   pub StartRoutine: PVOID,
   pub StartParameter: PVOID,
   pub ProcessId: HANDLE,
   pub StackReserve: SIZE_T,
   pub StackCommit: SIZE_T,
   pub LastThreadCreationStatus: NTSTATUS,
}
impl Default for _WORKER_FACTORY_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WORKER_FACTORY_BASIC_INFORMATION = _WORKER_FACTORY_BASIC_INFORMATION;
pub type PWORKER_FACTORY_BASIC_INFORMATION = *mut _WORKER_FACTORY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORKER_FACTORY_DEFERRED_WORK {
   pub AlpcSendMessage: PPORT_MESSAGE,
   pub AlpcSendMessagePort: PVOID,
   pub AlpcSendMessageFlags: ULONG,
   pub Flags: ULONG,
}
impl Default for _WORKER_FACTORY_DEFERRED_WORK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WORKER_FACTORY_DEFERRED_WORK = _WORKER_FACTORY_DEFERRED_WORK;
pub type PWORKER_FACTORY_DEFERRED_WORK = *mut _WORKER_FACTORY_DEFERRED_WORK;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_INFORMATION_CLASS {
   SystemBasicInformation = 0,
   SystemProcessorInformation = 1,
   SystemPerformanceInformation = 2,
   SystemTimeOfDayInformation = 3,
   SystemPathInformation = 4,
   SystemProcessInformation = 5,
   SystemCallCountInformation = 6,
   SystemDeviceInformation = 7,
   SystemProcessorPerformanceInformation = 8,
   SystemFlagsInformation = 9,
   SystemCallTimeInformation = 10,
   SystemModuleInformation = 11,
   SystemLocksInformation = 12,
   SystemStackTraceInformation = 13,
   SystemPagedPoolInformation = 14,
   SystemNonPagedPoolInformation = 15,
   SystemHandleInformation = 16,
   SystemObjectInformation = 17,
   SystemPageFileInformation = 18,
   SystemVdmInstemulInformation = 19,
   SystemVdmBopInformation = 20,
   SystemFileCacheInformation = 21,
   SystemPoolTagInformation = 22,
   SystemInterruptInformation = 23,
   SystemDpcBehaviorInformation = 24,
   SystemFullMemoryInformation = 25,
   SystemLoadGdiDriverInformation = 26,
   SystemUnloadGdiDriverInformation = 27,
   SystemTimeAdjustmentInformation = 28,
   SystemSummaryMemoryInformation = 29,
   SystemMirrorMemoryInformation = 30,
   SystemPerformanceTraceInformation = 31,
   SystemObsolete0 = 32,
   SystemExceptionInformation = 33,
   SystemCrashDumpStateInformation = 34,
   SystemKernelDebuggerInformation = 35,
   SystemContextSwitchInformation = 36,
   SystemRegistryQuotaInformation = 37,
   SystemExtendServiceTableInformation = 38,
   SystemPrioritySeparation = 39,
   SystemVerifierAddDriverInformation = 40,
   SystemVerifierRemoveDriverInformation = 41,
   SystemProcessorIdleInformation = 42,
   SystemLegacyDriverInformation = 43,
   SystemCurrentTimeZoneInformation = 44,
   SystemLookasideInformation = 45,
   SystemTimeSlipNotification = 46,
   SystemSessionCreate = 47,
   SystemSessionDetach = 48,
   SystemSessionInformation = 49,
   SystemRangeStartInformation = 50,
   SystemVerifierInformation = 51,
   SystemVerifierThunkExtend = 52,
   SystemSessionProcessInformation = 53,
   SystemLoadGdiDriverInSystemSpace = 54,
   SystemNumaProcessorMap = 55,
   SystemPrefetcherInformation = 56,
   SystemExtendedProcessInformation = 57,
   SystemRecommendedSharedDataAlignment = 58,
   SystemComPlusPackage = 59,
   SystemNumaAvailableMemory = 60,
   SystemProcessorPowerInformation = 61,
   SystemEmulationBasicInformation = 62,
   SystemEmulationProcessorInformation = 63,
   SystemExtendedHandleInformation = 64,
   SystemLostDelayedWriteInformation = 65,
   SystemBigPoolInformation = 66,
   SystemSessionPoolTagInformation = 67,
   SystemSessionMappedViewInformation = 68,
   SystemHotpatchInformation = 69,
   SystemObjectSecurityMode = 70,
   SystemWatchdogTimerHandler = 71,
   SystemWatchdogTimerInformation = 72,
   SystemLogicalProcessorInformation = 73,
   SystemWow64SharedInformationObsolete = 74,
   SystemRegisterFirmwareTableInformationHandler = 75,
   SystemFirmwareTableInformation = 76,
   SystemModuleInformationEx = 77,
   SystemVerifierTriageInformation = 78,
   SystemSuperfetchInformation = 79,
   SystemMemoryListInformation = 80,
   SystemFileCacheInformationEx = 81,
   SystemThreadPriorityClientIdInformation = 82,
   SystemProcessorIdleCycleTimeInformation = 83,
   SystemVerifierCancellationInformation = 84,
   SystemProcessorPowerInformationEx = 85,
   SystemRefTraceInformation = 86,
   SystemSpecialPoolInformation = 87,
   SystemProcessIdInformation = 88,
   SystemErrorPortInformation = 89,
   SystemBootEnvironmentInformation = 90,
   SystemHypervisorInformation = 91,
   SystemVerifierInformationEx = 92,
   SystemTimeZoneInformation = 93,
   SystemImageFileExecutionOptionsInformation = 94,
   SystemCoverageInformation = 95,
   SystemPrefetchPatchInformation = 96,
   SystemVerifierFaultsInformation = 97,
   SystemSystemPartitionInformation = 98,
   SystemSystemDiskInformation = 99,
   SystemProcessorPerformanceDistribution = 100,
   SystemNumaProximityNodeInformation = 101,
   SystemDynamicTimeZoneInformation = 102,
   SystemCodeIntegrityInformation = 103,
   SystemProcessorMicrocodeUpdateInformation = 104,
   SystemProcessorBrandString = 105,
   SystemVirtualAddressInformation = 106,
   SystemLogicalProcessorAndGroupInformation = 107,
   SystemProcessorCycleTimeInformation = 108,
   SystemStoreInformation = 109,
   SystemRegistryAppendString = 110,
   SystemAitSamplingValue = 111,
   SystemVhdBootInformation = 112,
   SystemCpuQuotaInformation = 113,
   SystemNativeBasicInformation = 114,
   SystemErrorPortTimeouts = 115,
   SystemLowPriorityIoInformation = 116,
   SystemTpmBootEntropyInformation = 117,
   SystemVerifierCountersInformation = 118,
   SystemPagedPoolInformationEx = 119,
   SystemSystemPtesInformationEx = 120,
   SystemNodeDistanceInformation = 121,
   SystemAcpiAuditInformation = 122,
   SystemBasicPerformanceInformation = 123,
   SystemQueryPerformanceCounterInformation = 124,
   SystemSessionBigPoolInformation = 125,
   SystemBootGraphicsInformation = 126,
   SystemScrubPhysicalMemoryInformation = 127,
   SystemBadPageInformation = 128,
   SystemProcessorProfileControlArea = 129,
   SystemCombinePhysicalMemoryInformation = 130,
   SystemEntropyInterruptTimingInformation = 131,
   SystemConsoleInformation = 132,
   SystemPlatformBinaryInformation = 133,
   SystemPolicyInformation = 134,
   SystemHypervisorProcessorCountInformation = 135,
   SystemDeviceDataInformation = 136,
   SystemDeviceDataEnumerationInformation = 137,
   SystemMemoryTopologyInformation = 138,
   SystemMemoryChannelInformation = 139,
   SystemBootLogoInformation = 140,
   SystemProcessorPerformanceInformationEx = 141,
   SystemCriticalProcessErrorLogInformation = 142,
   SystemSecureBootPolicyInformation = 143,
   SystemPageFileInformationEx = 144,
   SystemSecureBootInformation = 145,
   SystemEntropyInterruptTimingRawInformation = 146,
   SystemPortableWorkspaceEfiLauncherInformation = 147,
   SystemFullProcessInformation = 148,
   SystemKernelDebuggerInformationEx = 149,
   SystemBootMetadataInformation = 150,
   SystemSoftRebootInformation = 151,
   SystemElamCertificateInformation = 152,
   SystemOfflineDumpConfigInformation = 153,
   SystemProcessorFeaturesInformation = 154,
   SystemRegistryReconciliationInformation = 155,
   SystemEdidInformation = 156,
   SystemManufacturingInformation = 157,
   SystemEnergyEstimationConfigInformation = 158,
   SystemHypervisorDetailInformation = 159,
   SystemProcessorCycleStatsInformation = 160,
   SystemVmGenerationCountInformation = 161,
   SystemTrustedPlatformModuleInformation = 162,
   SystemKernelDebuggerFlags = 163,
   SystemCodeIntegrityPolicyInformation = 164,
   SystemIsolatedUserModeInformation = 165,
   SystemHardwareSecurityTestInterfaceResultsInformation = 166,
   SystemSingleModuleInformation = 167,
   SystemAllowedCpuSetsInformation = 168,
   SystemVsmProtectionInformation = 169,
   SystemInterruptCpuSetsInformation = 170,
   SystemSecureBootPolicyFullInformation = 171,
   SystemCodeIntegrityPolicyFullInformation = 172,
   SystemAffinitizedInterruptProcessorInformation = 173,
   SystemRootSiloInformation = 174,
   SystemCpuSetInformation = 175,
   SystemCpuSetTagInformation = 176,
   SystemWin32WerStartCallout = 177,
   SystemSecureKernelProfileInformation = 178,
   SystemCodeIntegrityPlatformManifestInformation = 179,
   SystemInterruptSteeringInformation = 180,
   SystemSupportedProcessorArchitectures = 181,
   SystemMemoryUsageInformation = 182,
   SystemCodeIntegrityCertificateInformation = 183,
   SystemPhysicalMemoryInformation = 184,
   SystemControlFlowTransition = 185,
   SystemKernelDebuggingAllowed = 186,
   SystemActivityModerationExeState = 187,
   SystemActivityModerationUserSettings = 188,
   SystemCodeIntegrityPoliciesFullInformation = 189,
   SystemCodeIntegrityUnlockInformation = 190,
   SystemIntegrityQuotaInformation = 191,
   SystemFlushInformation = 192,
   SystemProcessorIdleMaskInformation = 193,
   SystemSecureDumpEncryptionInformation = 194,
   SystemWriteConstraintInformation = 195,
   SystemKernelVaShadowInformation = 196,
   SystemHypervisorSharedPageInformation = 197,
   SystemFirmwareBootPerformanceInformation = 198,
   SystemCodeIntegrityVerificationInformation = 199,
   SystemFirmwarePartitionInformation = 200,
   SystemSpeculationControlInformation = 201,
   SystemDmaGuardPolicyInformation = 202,
   SystemEnclaveLaunchControlInformation = 203,
   SystemWorkloadAllowedCpuSetsInformation = 204,
   SystemCodeIntegrityUnlockModeInformation = 205,
   SystemLeapSecondInformation = 206,
   SystemFlags2Information = 207,
   SystemSecurityModelInformation = 208,
   SystemCodeIntegritySyntheticCacheInformation = 209,
   SystemFeatureConfigurationInformation = 210,
   SystemFeatureConfigurationSectionInformation = 211,
   SystemFeatureUsageSubscriptionInformation = 212,
   SystemSecureSpeculationControlInformation = 213,
   SystemSpacesBootInformation = 214,
   SystemFwRamdiskInformation = 215,
   SystemWheaIpmiHardwareInformation = 216,
   SystemDifSetRuleClassInformation = 217,
   SystemDifClearRuleClassInformation = 218,
   SystemDifApplyPluginVerificationOnDriver = 219,
   SystemDifRemovePluginVerificationOnDriver = 220,
   SystemShadowStackInformation = 221,
   SystemBuildVersionInformation = 222,
   SystemPoolLimitInformation = 223,
   SystemCodeIntegrityAddDynamicStore = 224,
   SystemCodeIntegrityClearDynamicStores = 225,
   SystemDifPoolTrackingInformation = 226,
   SystemPoolZeroingInformation = 227,
   SystemDpcWatchdogInformation = 228,
   SystemDpcWatchdogInformation2 = 229,
   SystemSupportedProcessorArchitectures2 = 230,
   SystemSingleProcessorRelationshipInformation = 231,
   SystemXfgCheckFailureInformation = 232,
   SystemIommuStateInformation = 233,
   SystemHypervisorMinrootInformation = 234,
   SystemHypervisorBootPagesInformation = 235,
   SystemPointerAuthInformation = 236,
   SystemSecureKernelDebuggerInformation = 237,
   SystemOriginalImageFeatureInformation = 238,
   SystemMemoryNumaInformation = 239,
   SystemMemoryNumaPerformanceInformation = 240,
   SystemCodeIntegritySignedPoliciesFullInformation = 241,
   SystemSecureCoreInformation = 242,
   SystemTrustedAppsRuntimeInformation = 243,
   SystemBadPageInformationEx = 244,
   SystemResourceDeadlockTimeout = 245,
   SystemBreakOnContextUnwindFailureInformation = 246,
   SystemOslRamdiskInformation = 247,
   MaxSystemInfoClass = 248,
}
pub use self::_SYSTEM_INFORMATION_CLASS as SYSTEM_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BASIC_INFORMATION {
   pub Reserved: ULONG,
   pub TimerResolution: ULONG,
   pub PageSize: ULONG,
   pub NumberOfPhysicalPages: ULONG,
   pub LowestPhysicalPageNumber: ULONG,
   pub HighestPhysicalPageNumber: ULONG,
   pub AllocationGranularity: ULONG,
   pub MinimumUserModeAddress: ULONG_PTR,
   pub MaximumUserModeAddress: ULONG_PTR,
   pub ActiveProcessorsAffinityMask: KAFFINITY,
   pub NumberOfProcessors: CCHAR,
}
pub type SYSTEM_BASIC_INFORMATION = _SYSTEM_BASIC_INFORMATION;
pub type PSYSTEM_BASIC_INFORMATION = *mut _SYSTEM_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_INFORMATION {
   pub ProcessorArchitecture: USHORT,
   pub ProcessorLevel: USHORT,
   pub ProcessorRevision: USHORT,
   pub MaximumProcessors: USHORT,
   pub ProcessorFeatureBits: ULONG,
}
pub type SYSTEM_PROCESSOR_INFORMATION = _SYSTEM_PROCESSOR_INFORMATION;
pub type PSYSTEM_PROCESSOR_INFORMATION = *mut _SYSTEM_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PERFORMANCE_INFORMATION {
   pub IdleProcessTime: LARGE_INTEGER,
   pub IoReadTransferCount: LARGE_INTEGER,
   pub IoWriteTransferCount: LARGE_INTEGER,
   pub IoOtherTransferCount: LARGE_INTEGER,
   pub IoReadOperationCount: ULONG,
   pub IoWriteOperationCount: ULONG,
   pub IoOtherOperationCount: ULONG,
   pub AvailablePages: ULONG,
   pub CommittedPages: ULONG,
   pub CommitLimit: ULONG,
   pub PeakCommitment: ULONG,
   pub PageFaultCount: ULONG,
   pub CopyOnWriteCount: ULONG,
   pub TransitionCount: ULONG,
   pub CacheTransitionCount: ULONG,
   pub DemandZeroCount: ULONG,
   pub PageReadCount: ULONG,
   pub PageReadIoCount: ULONG,
   pub CacheReadCount: ULONG,
   pub CacheIoCount: ULONG,
   pub DirtyPagesWriteCount: ULONG,
   pub DirtyWriteIoCount: ULONG,
   pub MappedPagesWriteCount: ULONG,
   pub MappedWriteIoCount: ULONG,
   pub PagedPoolPages: ULONG,
   pub NonPagedPoolPages: ULONG,
   pub PagedPoolAllocs: ULONG,
   pub PagedPoolFrees: ULONG,
   pub NonPagedPoolAllocs: ULONG,
   pub NonPagedPoolFrees: ULONG,
   pub FreeSystemPtes: ULONG,
   pub ResidentSystemCodePage: ULONG,
   pub TotalSystemDriverPages: ULONG,
   pub TotalSystemCodePages: ULONG,
   pub NonPagedPoolLookasideHits: ULONG,
   pub PagedPoolLookasideHits: ULONG,
   pub AvailablePagedPoolPages: ULONG,
   pub ResidentSystemCachePage: ULONG,
   pub ResidentPagedPoolPage: ULONG,
   pub ResidentSystemDriverPage: ULONG,
   pub CcFastReadNoWait: ULONG,
   pub CcFastReadWait: ULONG,
   pub CcFastReadResourceMiss: ULONG,
   pub CcFastReadNotPossible: ULONG,
   pub CcFastMdlReadNoWait: ULONG,
   pub CcFastMdlReadWait: ULONG,
   pub CcFastMdlReadResourceMiss: ULONG,
   pub CcFastMdlReadNotPossible: ULONG,
   pub CcMapDataNoWait: ULONG,
   pub CcMapDataWait: ULONG,
   pub CcMapDataNoWaitMiss: ULONG,
   pub CcMapDataWaitMiss: ULONG,
   pub CcPinMappedDataCount: ULONG,
   pub CcPinReadNoWait: ULONG,
   pub CcPinReadWait: ULONG,
   pub CcPinReadNoWaitMiss: ULONG,
   pub CcPinReadWaitMiss: ULONG,
   pub CcCopyReadNoWait: ULONG,
   pub CcCopyReadWait: ULONG,
   pub CcCopyReadNoWaitMiss: ULONG,
   pub CcCopyReadWaitMiss: ULONG,
   pub CcMdlReadNoWait: ULONG,
   pub CcMdlReadWait: ULONG,
   pub CcMdlReadNoWaitMiss: ULONG,
   pub CcMdlReadWaitMiss: ULONG,
   pub CcReadAheadIos: ULONG,
   pub CcLazyWriteIos: ULONG,
   pub CcLazyWritePages: ULONG,
   pub CcDataFlushes: ULONG,
   pub CcDataPages: ULONG,
   pub ContextSwitches: ULONG,
   pub FirstLevelTbFills: ULONG,
   pub SecondLevelTbFills: ULONG,
   pub SystemCalls: ULONG,
   pub CcTotalDirtyPages: ULONGLONG,
   pub CcDirtyPageThreshold: ULONGLONG,
   pub ResidentAvailablePages: LONGLONG,
   pub SharedCommittedPages: ULONGLONG,
   pub MdlPagesAllocated: ULONGLONG,
   pub PfnDatabaseCommittedPages: ULONGLONG,
   pub SystemPageTableCommittedPages: ULONGLONG,
   pub ContiguousPagesAllocated: ULONGLONG,
}
impl Default for _SYSTEM_PERFORMANCE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PERFORMANCE_INFORMATION = _SYSTEM_PERFORMANCE_INFORMATION;
pub type PSYSTEM_PERFORMANCE_INFORMATION = *mut _SYSTEM_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_TIMEOFDAY_INFORMATION {
   pub BootTime: LARGE_INTEGER,
   pub CurrentTime: LARGE_INTEGER,
   pub TimeZoneBias: LARGE_INTEGER,
   pub TimeZoneId: ULONG,
   pub Reserved: ULONG,
   pub BootTimeBias: ULONGLONG,
   pub SleepTimeBias: ULONGLONG,
}
impl Default for _SYSTEM_TIMEOFDAY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_TIMEOFDAY_INFORMATION = _SYSTEM_TIMEOFDAY_INFORMATION;
pub type PSYSTEM_TIMEOFDAY_INFORMATION = *mut _SYSTEM_TIMEOFDAY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_THREAD_INFORMATION {
   pub KernelTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
   pub CreateTime: LARGE_INTEGER,
   pub WaitTime: ULONG,
   pub StartAddress: PVOID,
   pub ClientId: CLIENT_ID,
   pub Priority: KPRIORITY,
   pub BasePriority: KPRIORITY,
   pub ContextSwitches: ULONG,
   pub ThreadState: KTHREAD_STATE,
   pub WaitReason: KWAIT_REASON,
}
impl Default for _SYSTEM_THREAD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_THREAD_INFORMATION = _SYSTEM_THREAD_INFORMATION;
pub type PSYSTEM_THREAD_INFORMATION = *mut _SYSTEM_THREAD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
   pub ThreadInfo: SYSTEM_THREAD_INFORMATION,
   pub StackBase: ULONG_PTR,
   pub StackLimit: ULONG_PTR,
   pub Win32StartAddress: PVOID,
   pub TebBase: PVOID,
   pub Reserved2: ULONG_PTR,
   pub Reserved3: ULONG_PTR,
   pub Reserved4: ULONG_PTR,
}
impl Default for _SYSTEM_EXTENDED_THREAD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_EXTENDED_THREAD_INFORMATION = _SYSTEM_EXTENDED_THREAD_INFORMATION;
pub type PSYSTEM_EXTENDED_THREAD_INFORMATION = *mut _SYSTEM_EXTENDED_THREAD_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_PROCESS_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub NumberOfThreads: ULONG,
   pub WorkingSetPrivateSize: LARGE_INTEGER,
   pub HardFaultCount: ULONG,
   pub NumberOfThreadsHighWatermark: ULONG,
   pub CycleTime: ULONGLONG,
   pub CreateTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
   pub KernelTime: LARGE_INTEGER,
   pub ImageName: UNICODE_STRING,
   pub BasePriority: KPRIORITY,
   pub UniqueProcessId: HANDLE,
   pub InheritedFromUniqueProcessId: HANDLE,
   pub HandleCount: ULONG,
   pub SessionId: ULONG,
   pub UniqueProcessKey: ULONG_PTR,
   pub PeakVirtualSize: SIZE_T,
   pub VirtualSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub PeakWorkingSetSize: SIZE_T,
   pub WorkingSetSize: SIZE_T,
   pub QuotaPeakPagedPoolUsage: SIZE_T,
   pub QuotaPagedPoolUsage: SIZE_T,
   pub QuotaPeakNonPagedPoolUsage: SIZE_T,
   pub QuotaNonPagedPoolUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
   pub PrivatePageCount: SIZE_T,
   pub ReadOperationCount: LARGE_INTEGER,
   pub WriteOperationCount: LARGE_INTEGER,
   pub OtherOperationCount: LARGE_INTEGER,
   pub ReadTransferCount: LARGE_INTEGER,
   pub WriteTransferCount: LARGE_INTEGER,
   pub OtherTransferCount: LARGE_INTEGER,
   pub Threads: [SYSTEM_THREAD_INFORMATION; 1usize],
}
impl Default for _SYSTEM_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESS_INFORMATION = _SYSTEM_PROCESS_INFORMATION;
pub type PSYSTEM_PROCESS_INFORMATION = *mut _SYSTEM_PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CALL_COUNT_INFORMATION {
   pub Length: ULONG,
   pub NumberOfTables: ULONG,
}
pub type SYSTEM_CALL_COUNT_INFORMATION = _SYSTEM_CALL_COUNT_INFORMATION;
pub type PSYSTEM_CALL_COUNT_INFORMATION = *mut _SYSTEM_CALL_COUNT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_DEVICE_INFORMATION {
   pub NumberOfDisks: ULONG,
   pub NumberOfFloppies: ULONG,
   pub NumberOfCdRoms: ULONG,
   pub NumberOfTapes: ULONG,
   pub NumberOfSerialPorts: ULONG,
   pub NumberOfParallelPorts: ULONG,
}
pub type SYSTEM_DEVICE_INFORMATION = _SYSTEM_DEVICE_INFORMATION;
pub type PSYSTEM_DEVICE_INFORMATION = *mut _SYSTEM_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
   pub IdleTime: LARGE_INTEGER,
   pub KernelTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
   pub DpcTime: LARGE_INTEGER,
   pub InterruptTime: LARGE_INTEGER,
   pub InterruptCount: ULONG,
}
impl Default for _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = *mut _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FLAGS_INFORMATION {
   pub Flags: ULONG,
}
pub type SYSTEM_FLAGS_INFORMATION = _SYSTEM_FLAGS_INFORMATION;
pub type PSYSTEM_FLAGS_INFORMATION = *mut _SYSTEM_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CALL_TIME_INFORMATION {
   pub Length: ULONG,
   pub TotalCalls: ULONG,
   pub TimeOfCalls: [LARGE_INTEGER; 1usize],
}
impl Default for _SYSTEM_CALL_TIME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CALL_TIME_INFORMATION = _SYSTEM_CALL_TIME_INFORMATION;
pub type PSYSTEM_CALL_TIME_INFORMATION = *mut _SYSTEM_CALL_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_LOCK_INFORMATION {
   pub Address: PVOID,
   pub Type: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub OwningThread: HANDLE,
   pub LockCount: LONG,
   pub ContentionCount: ULONG,
   pub EntryCount: ULONG,
   pub RecursionCount: LONG,
   pub NumberOfWaitingShared: ULONG,
   pub NumberOfWaitingExclusive: ULONG,
}
impl Default for _RTL_PROCESS_LOCK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_LOCK_INFORMATION = _RTL_PROCESS_LOCK_INFORMATION;
pub type PRTL_PROCESS_LOCK_INFORMATION = *mut _RTL_PROCESS_LOCK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_LOCKS {
   pub NumberOfLocks: ULONG,
   pub Locks: [RTL_PROCESS_LOCK_INFORMATION; 1usize],
}
impl Default for _RTL_PROCESS_LOCKS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_LOCKS = _RTL_PROCESS_LOCKS;
pub type PRTL_PROCESS_LOCKS = *mut _RTL_PROCESS_LOCKS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_BACKTRACE_INFORMATION {
   pub SymbolicBackTrace: PCHAR,
   pub TraceCount: ULONG,
   pub Index: USHORT,
   pub Depth: USHORT,
   pub BackTrace: [PVOID; 32usize],
}
impl Default for _RTL_PROCESS_BACKTRACE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_BACKTRACE_INFORMATION = _RTL_PROCESS_BACKTRACE_INFORMATION;
pub type PRTL_PROCESS_BACKTRACE_INFORMATION = *mut _RTL_PROCESS_BACKTRACE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_BACKTRACES {
   pub CommittedMemory: ULONG,
   pub ReservedMemory: ULONG,
   pub NumberOfBackTraceLookups: ULONG,
   pub NumberOfBackTraces: ULONG,
   pub BackTraces: [RTL_PROCESS_BACKTRACE_INFORMATION; 1usize],
}
impl Default for _RTL_PROCESS_BACKTRACES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_BACKTRACES = _RTL_PROCESS_BACKTRACES;
pub type PRTL_PROCESS_BACKTRACES = *mut _RTL_PROCESS_BACKTRACES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
   pub UniqueProcessId: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub ObjectTypeIndex: UCHAR,
   pub HandleAttributes: UCHAR,
   pub HandleValue: USHORT,
   pub Object: PVOID,
   pub GrantedAccess: ACCESS_MASK,
}
impl Default for _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HANDLE_TABLE_ENTRY_INFO = _SYSTEM_HANDLE_TABLE_ENTRY_INFO;
pub type PSYSTEM_HANDLE_TABLE_ENTRY_INFO = *mut _SYSTEM_HANDLE_TABLE_ENTRY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_INFORMATION {
   pub NumberOfHandles: ULONG,
   pub Handles: [SYSTEM_HANDLE_TABLE_ENTRY_INFO; 1usize],
}
impl Default for _SYSTEM_HANDLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HANDLE_INFORMATION = _SYSTEM_HANDLE_INFORMATION;
pub type PSYSTEM_HANDLE_INFORMATION = *mut _SYSTEM_HANDLE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_OBJECTTYPE_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub NumberOfObjects: ULONG,
   pub NumberOfHandles: ULONG,
   pub TypeIndex: ULONG,
   pub InvalidAttributes: ULONG,
   pub GenericMapping: GENERIC_MAPPING,
   pub ValidAccessMask: ACCESS_MASK,
   pub PoolType: ULONG,
   pub SecurityRequired: BOOLEAN,
   pub WaitableObject: BOOLEAN,
   pub TypeName: UNICODE_STRING,
}
impl Default for _SYSTEM_OBJECTTYPE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_OBJECTTYPE_INFORMATION = _SYSTEM_OBJECTTYPE_INFORMATION;
pub type PSYSTEM_OBJECTTYPE_INFORMATION = *mut _SYSTEM_OBJECTTYPE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_OBJECT_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub Object: PVOID,
   pub CreatorUniqueProcess: HANDLE,
   pub CreatorBackTraceIndex: USHORT,
   pub Flags: USHORT,
   pub PointerCount: LONG,
   pub HandleCount: LONG,
   pub PagedPoolCharge: ULONG,
   pub NonPagedPoolCharge: ULONG,
   pub ExclusiveProcessId: HANDLE,
   pub SecurityDescriptor: PVOID,
   pub NameInfo: UNICODE_STRING,
}
impl Default for _SYSTEM_OBJECT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_OBJECT_INFORMATION = _SYSTEM_OBJECT_INFORMATION;
pub type PSYSTEM_OBJECT_INFORMATION = *mut _SYSTEM_OBJECT_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_PAGEFILE_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub TotalSize: ULONG,
   pub TotalInUse: ULONG,
   pub PeakUsage: ULONG,
   pub PageFileName: UNICODE_STRING,
}
impl Default for _SYSTEM_PAGEFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PAGEFILE_INFORMATION = _SYSTEM_PAGEFILE_INFORMATION;
pub type PSYSTEM_PAGEFILE_INFORMATION = *mut _SYSTEM_PAGEFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_VDM_INSTEMUL_INFO {
   pub SegmentNotPresent: ULONG,
   pub VdmOpcode0F: ULONG,
   pub OpcodeESPrefix: ULONG,
   pub OpcodeCSPrefix: ULONG,
   pub OpcodeSSPrefix: ULONG,
   pub OpcodeDSPrefix: ULONG,
   pub OpcodeFSPrefix: ULONG,
   pub OpcodeGSPrefix: ULONG,
   pub OpcodeOPER32Prefix: ULONG,
   pub OpcodeADDR32Prefix: ULONG,
   pub OpcodeINSB: ULONG,
   pub OpcodeINSW: ULONG,
   pub OpcodeOUTSB: ULONG,
   pub OpcodeOUTSW: ULONG,
   pub OpcodePUSHF: ULONG,
   pub OpcodePOPF: ULONG,
   pub OpcodeINTnn: ULONG,
   pub OpcodeINTO: ULONG,
   pub OpcodeIRET: ULONG,
   pub OpcodeINBimm: ULONG,
   pub OpcodeINWimm: ULONG,
   pub OpcodeOUTBimm: ULONG,
   pub OpcodeOUTWimm: ULONG,
   pub OpcodeINB: ULONG,
   pub OpcodeINW: ULONG,
   pub OpcodeOUTB: ULONG,
   pub OpcodeOUTW: ULONG,
   pub OpcodeLOCKPrefix: ULONG,
   pub OpcodeREPNEPrefix: ULONG,
   pub OpcodeREPPrefix: ULONG,
   pub OpcodeHLT: ULONG,
   pub OpcodeCLI: ULONG,
   pub OpcodeSTI: ULONG,
   pub BopCount: ULONG,
}
pub type SYSTEM_VDM_INSTEMUL_INFO = _SYSTEM_VDM_INSTEMUL_INFO;
pub type PSYSTEM_VDM_INSTEMUL_INFO = *mut _SYSTEM_VDM_INSTEMUL_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FILECACHE_INFORMATION {
   pub CurrentSize: SIZE_T,
   pub PeakSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub MinimumWorkingSet: SIZE_T,
   pub MaximumWorkingSet: SIZE_T,
   pub CurrentSizeIncludingTransitionInPages: SIZE_T,
   pub PeakSizeIncludingTransitionInPages: SIZE_T,
   pub TransitionRePurposeCount: ULONG,
   pub Flags: ULONG,
}
pub type SYSTEM_FILECACHE_INFORMATION = _SYSTEM_FILECACHE_INFORMATION;
pub type PSYSTEM_FILECACHE_INFORMATION = *mut _SYSTEM_FILECACHE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BASIC_WORKING_SET_INFORMATION {
   pub CurrentSize: SIZE_T,
   pub PeakSize: SIZE_T,
   pub PageFaultCount: ULONG,
}
pub type SYSTEM_BASIC_WORKING_SET_INFORMATION = _SYSTEM_BASIC_WORKING_SET_INFORMATION;
pub type PSYSTEM_BASIC_WORKING_SET_INFORMATION = *mut _SYSTEM_BASIC_WORKING_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POOLTAG {
   pub __bindgen_anon_1: _SYSTEM_POOLTAG__bindgen_ty_1,
   pub PagedAllocs: ULONG,
   pub PagedFrees: ULONG,
   pub PagedUsed: SIZE_T,
   pub NonPagedAllocs: ULONG,
   pub NonPagedFrees: ULONG,
   pub NonPagedUsed: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POOLTAG__bindgen_ty_1 {
   pub Tag: [UCHAR; 4usize],
   pub TagUlong: ULONG,
}
impl Default for _SYSTEM_POOLTAG__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_POOLTAG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POOLTAG = _SYSTEM_POOLTAG;
pub type PSYSTEM_POOLTAG = *mut _SYSTEM_POOLTAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POOLTAG_INFORMATION {
   pub Count: ULONG,
   pub TagInfo: [SYSTEM_POOLTAG; 1usize],
}
impl Default for _SYSTEM_POOLTAG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POOLTAG_INFORMATION = _SYSTEM_POOLTAG_INFORMATION;
pub type PSYSTEM_POOLTAG_INFORMATION = *mut _SYSTEM_POOLTAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_INFORMATION {
   pub ContextSwitches: ULONG,
   pub DpcCount: ULONG,
   pub DpcRate: ULONG,
   pub TimeIncrement: ULONG,
   pub DpcBypassCount: ULONG,
   pub ApcBypassCount: ULONG,
}
pub type SYSTEM_INTERRUPT_INFORMATION = _SYSTEM_INTERRUPT_INFORMATION;
pub type PSYSTEM_INTERRUPT_INFORMATION = *mut _SYSTEM_INTERRUPT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_DPC_BEHAVIOR_INFORMATION {
   pub Spare: ULONG,
   pub DpcQueueDepth: ULONG,
   pub MinimumDpcRate: ULONG,
   pub AdjustDpcThreshold: ULONG,
   pub IdealDpcRate: ULONG,
}
pub type SYSTEM_DPC_BEHAVIOR_INFORMATION = _SYSTEM_DPC_BEHAVIOR_INFORMATION;
pub type PSYSTEM_DPC_BEHAVIOR_INFORMATION = *mut _SYSTEM_DPC_BEHAVIOR_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
   pub TimeAdjustment: ULONG,
   pub TimeIncrement: ULONG,
   pub Enable: BOOLEAN,
}
impl Default for _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_QUERY_TIME_ADJUST_INFORMATION = _SYSTEM_QUERY_TIME_ADJUST_INFORMATION;
pub type PSYSTEM_QUERY_TIME_ADJUST_INFORMATION = *mut _SYSTEM_QUERY_TIME_ADJUST_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE {
   pub TimeAdjustment: ULONGLONG,
   pub TimeIncrement: ULONGLONG,
   pub Enable: BOOLEAN,
}
impl Default for _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE =
   _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE;
pub type PSYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE =
   *mut _SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE;
#[repr(C)]
pub struct _SYSTEM_SET_TIME_ADJUST_INFORMATION {
   pub TimeAdjustment: ULONG,
   pub Enable: BOOLEAN,
}
impl Default for _SYSTEM_SET_TIME_ADJUST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SET_TIME_ADJUST_INFORMATION = _SYSTEM_SET_TIME_ADJUST_INFORMATION;
pub type PSYSTEM_SET_TIME_ADJUST_INFORMATION = *mut _SYSTEM_SET_TIME_ADJUST_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE {
   pub TimeAdjustment: ULONGLONG,
   pub Enable: BOOLEAN,
}
impl Default for _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE = _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE;
pub type PSYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE =
   *mut _SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_TRACE_INFORMATION_CLASS {
   EventTraceKernelVersionInformation = 0,
   EventTraceGroupMaskInformation = 1,
   EventTracePerformanceInformation = 2,
   EventTraceTimeProfileInformation = 3,
   EventTraceSessionSecurityInformation = 4,
   EventTraceSpinlockInformation = 5,
   EventTraceStackTracingInformation = 6,
   EventTraceExecutiveResourceInformation = 7,
   EventTraceHeapTracingInformation = 8,
   EventTraceHeapSummaryTracingInformation = 9,
   EventTracePoolTagFilterInformation = 10,
   EventTracePebsTracingInformation = 11,
   EventTraceProfileConfigInformation = 12,
   EventTraceProfileSourceListInformation = 13,
   EventTraceProfileEventListInformation = 14,
   EventTraceProfileCounterListInformation = 15,
   EventTraceStackCachingInformation = 16,
   EventTraceObjectTypeFilterInformation = 17,
   EventTraceSoftRestartInformation = 18,
   EventTraceLastBranchConfigurationInformation = 19,
   EventTraceLastBranchEventListInformation = 20,
   EventTraceProfileSourceAddInformation = 21,
   EventTraceProfileSourceRemoveInformation = 22,
   EventTraceProcessorTraceConfigurationInformation = 23,
   EventTraceProcessorTraceEventListInformation = 24,
   EventTraceCoverageSamplerInformation = 25,
   EventTraceUnifiedStackCachingInformation = 26,
   EventTraceContextRegisterTraceInformation = 27,
   MaxEventTraceInfoClass = 28,
}
pub use self::_EVENT_TRACE_INFORMATION_CLASS as EVENT_TRACE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_VERSION_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub EventTraceKernelVersion: ULONG,
}
impl Default for _EVENT_TRACE_VERSION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_VERSION_INFORMATION = _EVENT_TRACE_VERSION_INFORMATION;
pub type PEVENT_TRACE_VERSION_INFORMATION = *mut _EVENT_TRACE_VERSION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_GROUPMASK_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub EventTraceGroupMasks: [ULONG; 8usize],
}
impl Default for _EVENT_TRACE_GROUPMASK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_GROUPMASK_INFORMATION = _EVENT_TRACE_GROUPMASK_INFORMATION;
pub type PEVENT_TRACE_GROUPMASK_INFORMATION = *mut _EVENT_TRACE_GROUPMASK_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_TRACE_PERFORMANCE_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub LogfileBytesWritten: LARGE_INTEGER,
}
impl Default for _EVENT_TRACE_PERFORMANCE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PERFORMANCE_INFORMATION = _EVENT_TRACE_PERFORMANCE_INFORMATION;
pub type PEVENT_TRACE_PERFORMANCE_INFORMATION = *mut _EVENT_TRACE_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_TIME_PROFILE_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub ProfileInterval: ULONG,
}
impl Default for _EVENT_TRACE_TIME_PROFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_TIME_PROFILE_INFORMATION = _EVENT_TRACE_TIME_PROFILE_INFORMATION;
pub type PEVENT_TRACE_TIME_PROFILE_INFORMATION = *mut _EVENT_TRACE_TIME_PROFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_SESSION_SECURITY_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub SecurityInformation: ULONG,
   pub TraceHandle: TRACEHANDLE,
   pub SecurityDescriptor: [UCHAR; 1usize],
}
impl Default for _EVENT_TRACE_SESSION_SECURITY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_SESSION_SECURITY_INFORMATION = _EVENT_TRACE_SESSION_SECURITY_INFORMATION;
pub type PEVENT_TRACE_SESSION_SECURITY_INFORMATION = *mut _EVENT_TRACE_SESSION_SECURITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_SPINLOCK_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub SpinLockSpinThreshold: ULONG,
   pub SpinLockAcquireSampleRate: ULONG,
   pub SpinLockContentionSampleRate: ULONG,
   pub SpinLockHoldThreshold: ULONG,
}
impl Default for _EVENT_TRACE_SPINLOCK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_SPINLOCK_INFORMATION = _EVENT_TRACE_SPINLOCK_INFORMATION;
pub type PEVENT_TRACE_SPINLOCK_INFORMATION = *mut _EVENT_TRACE_SPINLOCK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_SYSTEM_EVENT_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub HookId: [ULONG; 1usize],
}
impl Default for _EVENT_TRACE_SYSTEM_EVENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_SYSTEM_EVENT_INFORMATION = _EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type PEVENT_TRACE_SYSTEM_EVENT_INFORMATION = *mut _EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type EVENT_TRACE_STACK_TRACING_INFORMATION = EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type PEVENT_TRACE_STACK_TRACING_INFORMATION = *mut EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type EVENT_TRACE_PEBS_TRACING_INFORMATION = EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type PEVENT_TRACE_PEBS_TRACING_INFORMATION = *mut EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type EVENT_TRACE_PROFILE_EVENT_INFORMATION = EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
pub type PEVENT_TRACE_PROFILE_EVENT_INFORMATION = *mut EVENT_TRACE_SYSTEM_EVENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub ReleaseSamplingRate: ULONG,
   pub ContentionSamplingRate: ULONG,
   pub NumberOfExcessiveTimeouts: ULONG,
}
impl Default for _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION = _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION;
pub type PEVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION =
   *mut _EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_HEAP_TRACING_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub ProcessId: [ULONG; 1usize],
}
impl Default for _EVENT_TRACE_HEAP_TRACING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_HEAP_TRACING_INFORMATION = _EVENT_TRACE_HEAP_TRACING_INFORMATION;
pub type PEVENT_TRACE_HEAP_TRACING_INFORMATION = *mut _EVENT_TRACE_HEAP_TRACING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_TAG_FILTER_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub Filter: [ULONG; 1usize],
}
impl Default for _EVENT_TRACE_TAG_FILTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_TAG_FILTER_INFORMATION = _EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type PEVENT_TRACE_TAG_FILTER_INFORMATION = *mut _EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type EVENT_TRACE_POOLTAG_FILTER_INFORMATION = EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type PEVENT_TRACE_POOLTAG_FILTER_INFORMATION = *mut EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type EVENT_TRACE_OBJECT_TYPE_FILTER_INFORMATION = EVENT_TRACE_TAG_FILTER_INFORMATION;
pub type PEVENT_TRACE_OBJECT_TYPE_FILTER_INFORMATION = *mut EVENT_TRACE_TAG_FILTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_COUNTER_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub ProfileSource: [ULONG; 1usize],
}
impl Default for _EVENT_TRACE_PROFILE_COUNTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_COUNTER_INFORMATION = _EVENT_TRACE_PROFILE_COUNTER_INFORMATION;
pub type PEVENT_TRACE_PROFILE_COUNTER_INFORMATION = *mut _EVENT_TRACE_PROFILE_COUNTER_INFORMATION;
pub type EVENT_TRACE_PROFILE_CONFIG_INFORMATION = EVENT_TRACE_PROFILE_COUNTER_INFORMATION;
pub type PEVENT_TRACE_PROFILE_CONFIG_INFORMATION = *mut EVENT_TRACE_PROFILE_COUNTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_LIST_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub Spare: ULONG,
   pub Profile: [PPROFILE_SOURCE_INFO; 1usize],
}
impl Default for _EVENT_TRACE_PROFILE_LIST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_LIST_INFORMATION = _EVENT_TRACE_PROFILE_LIST_INFORMATION;
pub type PEVENT_TRACE_PROFILE_LIST_INFORMATION = *mut _EVENT_TRACE_PROFILE_LIST_INFORMATION;
#[repr(C)]
pub struct _EVENT_TRACE_STACK_CACHING_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub Enabled: BOOLEAN,
   pub Reserved: [UCHAR; 3usize],
   pub CacheSize: ULONG,
   pub BucketCount: ULONG,
}
impl Default for _EVENT_TRACE_STACK_CACHING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_STACK_CACHING_INFORMATION = _EVENT_TRACE_STACK_CACHING_INFORMATION;
pub type PEVENT_TRACE_STACK_CACHING_INFORMATION = *mut _EVENT_TRACE_STACK_CACHING_INFORMATION;
#[repr(C)]
pub struct _EVENT_TRACE_SOFT_RESTART_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub TraceHandle: TRACEHANDLE,
   pub PersistTraceBuffers: BOOLEAN,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _EVENT_TRACE_SOFT_RESTART_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_SOFT_RESTART_INFORMATION = _EVENT_TRACE_SOFT_RESTART_INFORMATION;
pub type PEVENT_TRACE_SOFT_RESTART_INFORMATION = *mut _EVENT_TRACE_SOFT_RESTART_INFORMATION;
impl _EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS {
   pub const EventTraceProfileAddInformationV2: _EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS =
      _EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS::EventTraceProfileAddInformationMinVersion;
}
impl _EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS {
   pub const EventTraceProfileAddInformationMaxVersion:
      _EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS =
      _EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS::EventTraceProfileAddInformationV3;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS {
   EventTraceProfileAddInformationMinVersion = 2,
   EventTraceProfileAddInformationV3 = 3,
}
pub use self::_EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS as EVENT_TRACE_PROFILE_ADD_INFORMATION_VERSIONS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2 {
   pub Intel: _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2__bindgen_ty_1,
   pub Amd: _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2__bindgen_ty_2,
   pub Arm: _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2__bindgen_ty_1 {
   pub PerfEvtEventSelect: UCHAR,
   pub PerfEvtUnitSelect: UCHAR,
   pub PerfEvtCMask: UCHAR,
   pub PerfEvtCInv: UCHAR,
   pub PerfEvtAnyThread: UCHAR,
   pub PerfEvtEdgeDetect: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2__bindgen_ty_2 {
   pub PerfEvtEventSelect: UCHAR,
   pub PerfEvtUnitSelect: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2__bindgen_ty_3 {
   pub PerfEvtType: ULONG,
   pub AllowsHalt: UCHAR,
}
impl Default for _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_ADD_INFORMATION_V2 = _EVENT_TRACE_PROFILE_ADD_INFORMATION_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3 {
   pub Intel: _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3__bindgen_ty_1,
   pub Amd: _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3__bindgen_ty_2,
   pub Arm: _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3__bindgen_ty_1 {
   pub PerfEvtEventSelect: UCHAR,
   pub PerfEvtUnitSelect: UCHAR,
   pub PerfEvtCMask: UCHAR,
   pub PerfEvtCInv: UCHAR,
   pub PerfEvtAnyThread: UCHAR,
   pub PerfEvtEdgeDetect: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3__bindgen_ty_2 {
   pub PerfEvtEventSelect: USHORT,
   pub PerfEvtUnitSelect: UCHAR,
   pub PerfEvtCMask: UCHAR,
   pub PerfEvtCInv: UCHAR,
   pub PerfEvtEdgeDetect: UCHAR,
   pub PerfEvtHostGuest: UCHAR,
   pub PerfPmuType: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3__bindgen_ty_3 {
   pub PerfEvtType: ULONG,
   pub AllowsHalt: UCHAR,
}
impl Default for _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_ADD_INFORMATION_V3 = _EVENT_TRACE_PROFILE_ADD_INFORMATION_V3;
#[repr(C)]
pub struct _EVENT_TRACE_PROFILE_ADD_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub Version: UCHAR,
   pub __bindgen_anon_1: _EVENT_TRACE_PROFILE_ADD_INFORMATION__bindgen_ty_1,
   pub CpuInfoHierarchy: [ULONG; 3usize],
   pub InitialInterval: ULONG,
   pub Persist: BOOLEAN,
   pub ProfileSourceDescription: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_TRACE_PROFILE_ADD_INFORMATION__bindgen_ty_1 {
   pub V2: EVENT_TRACE_PROFILE_ADD_INFORMATION_V2,
   pub V3: EVENT_TRACE_PROFILE_ADD_INFORMATION_V3,
}
impl Default for _EVENT_TRACE_PROFILE_ADD_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _EVENT_TRACE_PROFILE_ADD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_ADD_INFORMATION = _EVENT_TRACE_PROFILE_ADD_INFORMATION;
pub type PEVENT_TRACE_PROFILE_ADD_INFORMATION = *mut _EVENT_TRACE_PROFILE_ADD_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_PROFILE_REMOVE_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub ProfileSource: KPROFILE_SOURCE,
   pub CpuInfoHierarchy: [ULONG; 3usize],
}
impl Default for _EVENT_TRACE_PROFILE_REMOVE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_PROFILE_REMOVE_INFORMATION = _EVENT_TRACE_PROFILE_REMOVE_INFORMATION;
pub type PEVENT_TRACE_PROFILE_REMOVE_INFORMATION = *mut _EVENT_TRACE_PROFILE_REMOVE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION {
   pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
   pub CoverageSamplerInformationClass: UCHAR,
   pub MajorVersion: UCHAR,
   pub MinorVersion: UCHAR,
   pub Reserved: UCHAR,
   pub SamplerHandle: HANDLE,
}
impl Default for _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION = _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION;
pub type PEVENT_TRACE_COVERAGE_SAMPLER_INFORMATION = *mut _EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_EXCEPTION_INFORMATION {
   pub AlignmentFixupCount: ULONG,
   pub ExceptionDispatchCount: ULONG,
   pub FloatingEmulationCount: ULONG,
   pub ByteWordEmulationCount: ULONG,
}
pub type SYSTEM_EXCEPTION_INFORMATION = _SYSTEM_EXCEPTION_INFORMATION;
pub type PSYSTEM_EXCEPTION_INFORMATION = *mut _SYSTEM_EXCEPTION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS {
   SystemCrashDumpDisable = 0,
   SystemCrashDumpReconfigure = 1,
   SystemCrashDumpInitializationComplete = 2,
}
pub use self::_SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS as SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS;
pub type PSYSTEM_CRASH_DUMP_CONFIGURATION_CLASS = *mut _SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CRASH_DUMP_STATE_INFORMATION {
   pub CrashDumpConfigurationClass: SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS,
}
impl Default for _SYSTEM_CRASH_DUMP_STATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CRASH_DUMP_STATE_INFORMATION = _SYSTEM_CRASH_DUMP_STATE_INFORMATION;
pub type PSYSTEM_CRASH_DUMP_STATE_INFORMATION = *mut _SYSTEM_CRASH_DUMP_STATE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
   pub KernelDebuggerEnabled: BOOLEAN,
   pub KernelDebuggerNotPresent: BOOLEAN,
}
impl Default for _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_KERNEL_DEBUGGER_INFORMATION = _SYSTEM_KERNEL_DEBUGGER_INFORMATION;
pub type PSYSTEM_KERNEL_DEBUGGER_INFORMATION = *mut _SYSTEM_KERNEL_DEBUGGER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CONTEXT_SWITCH_INFORMATION {
   pub ContextSwitches: ULONG,
   pub FindAny: ULONG,
   pub FindLast: ULONG,
   pub FindIdeal: ULONG,
   pub IdleAny: ULONG,
   pub IdleCurrent: ULONG,
   pub IdleLast: ULONG,
   pub IdleIdeal: ULONG,
   pub PreemptAny: ULONG,
   pub PreemptCurrent: ULONG,
   pub PreemptLast: ULONG,
   pub SwitchToIdle: ULONG,
}
pub type SYSTEM_CONTEXT_SWITCH_INFORMATION = _SYSTEM_CONTEXT_SWITCH_INFORMATION;
pub type PSYSTEM_CONTEXT_SWITCH_INFORMATION = *mut _SYSTEM_CONTEXT_SWITCH_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
   pub RegistryQuotaAllowed: ULONG,
   pub RegistryQuotaUsed: ULONG,
   pub PagedPoolSize: SIZE_T,
}
pub type SYSTEM_REGISTRY_QUOTA_INFORMATION = _SYSTEM_REGISTRY_QUOTA_INFORMATION;
pub type PSYSTEM_REGISTRY_QUOTA_INFORMATION = *mut _SYSTEM_REGISTRY_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_IDLE_INFORMATION {
   pub IdleTime: ULONGLONG,
   pub C1Time: ULONGLONG,
   pub C2Time: ULONGLONG,
   pub C3Time: ULONGLONG,
   pub C1Transitions: ULONG,
   pub C2Transitions: ULONG,
   pub C3Transitions: ULONG,
   pub Padding: ULONG,
}
pub type SYSTEM_PROCESSOR_IDLE_INFORMATION = _SYSTEM_PROCESSOR_IDLE_INFORMATION;
pub type PSYSTEM_PROCESSOR_IDLE_INFORMATION = *mut _SYSTEM_PROCESSOR_IDLE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_LEGACY_DRIVER_INFORMATION {
   pub VetoType: ULONG,
   pub VetoList: UNICODE_STRING,
}
impl Default for _SYSTEM_LEGACY_DRIVER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_LEGACY_DRIVER_INFORMATION = _SYSTEM_LEGACY_DRIVER_INFORMATION;
pub type PSYSTEM_LEGACY_DRIVER_INFORMATION = *mut _SYSTEM_LEGACY_DRIVER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_LOOKASIDE_INFORMATION {
   pub CurrentDepth: USHORT,
   pub MaximumDepth: USHORT,
   pub TotalAllocates: ULONG,
   pub AllocateMisses: ULONG,
   pub TotalFrees: ULONG,
   pub FreeMisses: ULONG,
   pub Type: ULONG,
   pub Tag: ULONG,
   pub Size: ULONG,
}
pub type SYSTEM_LOOKASIDE_INFORMATION = _SYSTEM_LOOKASIDE_INFORMATION;
pub type PSYSTEM_LOOKASIDE_INFORMATION = *mut _SYSTEM_LOOKASIDE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_RANGE_START_INFORMATION {
   pub SystemRangeStart: ULONG_PTR,
}
pub type SYSTEM_RANGE_START_INFORMATION = _SYSTEM_RANGE_START_INFORMATION;
pub type PSYSTEM_RANGE_START_INFORMATION = *mut _SYSTEM_RANGE_START_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_INFORMATION_LEGACY {
   pub NextEntryOffset: ULONG,
   pub Level: ULONG,
   pub DriverName: UNICODE_STRING,
   pub RaiseIrqls: ULONG,
   pub AcquireSpinLocks: ULONG,
   pub SynchronizeExecutions: ULONG,
   pub AllocationsAttempted: ULONG,
   pub AllocationsSucceeded: ULONG,
   pub AllocationsSucceededSpecialPool: ULONG,
   pub AllocationsWithNoTag: ULONG,
   pub TrimRequests: ULONG,
   pub Trims: ULONG,
   pub AllocationsFailed: ULONG,
   pub AllocationsFailedDeliberately: ULONG,
   pub Loads: ULONG,
   pub Unloads: ULONG,
   pub UnTrackedPool: ULONG,
   pub CurrentPagedPoolAllocations: ULONG,
   pub CurrentNonPagedPoolAllocations: ULONG,
   pub PeakPagedPoolAllocations: ULONG,
   pub PeakNonPagedPoolAllocations: ULONG,
   pub PagedPoolUsageInBytes: SIZE_T,
   pub NonPagedPoolUsageInBytes: SIZE_T,
   pub PeakPagedPoolUsageInBytes: SIZE_T,
   pub PeakNonPagedPoolUsageInBytes: SIZE_T,
}
impl Default for _SYSTEM_VERIFIER_INFORMATION_LEGACY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_INFORMATION_LEGACY = _SYSTEM_VERIFIER_INFORMATION_LEGACY;
pub type PSYSTEM_VERIFIER_INFORMATION_LEGACY = *mut _SYSTEM_VERIFIER_INFORMATION_LEGACY;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub Level: ULONG,
   pub RuleClasses: [ULONG; 2usize],
   pub TriageContext: ULONG,
   pub AreAllDriversBeingVerified: ULONG,
   pub DriverName: UNICODE_STRING,
   pub RaiseIrqls: ULONG,
   pub AcquireSpinLocks: ULONG,
   pub SynchronizeExecutions: ULONG,
   pub AllocationsAttempted: ULONG,
   pub AllocationsSucceeded: ULONG,
   pub AllocationsSucceededSpecialPool: ULONG,
   pub AllocationsWithNoTag: ULONG,
   pub TrimRequests: ULONG,
   pub Trims: ULONG,
   pub AllocationsFailed: ULONG,
   pub AllocationsFailedDeliberately: ULONG,
   pub Loads: ULONG,
   pub Unloads: ULONG,
   pub UnTrackedPool: ULONG,
   pub CurrentPagedPoolAllocations: ULONG,
   pub CurrentNonPagedPoolAllocations: ULONG,
   pub PeakPagedPoolAllocations: ULONG,
   pub PeakNonPagedPoolAllocations: ULONG,
   pub PagedPoolUsageInBytes: SIZE_T,
   pub NonPagedPoolUsageInBytes: SIZE_T,
   pub PeakPagedPoolUsageInBytes: SIZE_T,
   pub PeakNonPagedPoolUsageInBytes: SIZE_T,
}
impl Default for _SYSTEM_VERIFIER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_INFORMATION = _SYSTEM_VERIFIER_INFORMATION;
pub type PSYSTEM_VERIFIER_INFORMATION = *mut _SYSTEM_VERIFIER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SESSION_PROCESS_INFORMATION {
   pub SessionId: ULONG,
   pub SizeOfBuf: ULONG,
   pub Buffer: PVOID,
}
impl Default for _SYSTEM_SESSION_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SESSION_PROCESS_INFORMATION = _SYSTEM_SESSION_PROCESS_INFORMATION;
pub type PSYSTEM_SESSION_PROCESS_INFORMATION = *mut _SYSTEM_SESSION_PROCESS_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_GDI_DRIVER_INFORMATION {
   pub DriverName: UNICODE_STRING,
   pub ImageAddress: PVOID,
   pub SectionPointer: PVOID,
   pub EntryPoint: PVOID,
   pub ExportSectionPointer: PIMAGE_EXPORT_DIRECTORY,
   pub ImageLength: ULONG,
}
impl Default for _SYSTEM_GDI_DRIVER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_GDI_DRIVER_INFORMATION = _SYSTEM_GDI_DRIVER_INFORMATION;
pub type PSYSTEM_GDI_DRIVER_INFORMATION = *mut _SYSTEM_GDI_DRIVER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_NUMA_INFORMATION {
   pub HighestNodeNumber: ULONG,
   pub Reserved: ULONG,
   pub __bindgen_anon_1: _SYSTEM_NUMA_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_NUMA_INFORMATION__bindgen_ty_1 {
   pub ActiveProcessorsGroupAffinity: [GROUP_AFFINITY; 64usize],
   pub AvailableMemory: [ULONGLONG; 64usize],
   pub Pad: [ULONGLONG; 128usize],
}
impl Default for _SYSTEM_NUMA_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_NUMA_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_NUMA_INFORMATION = _SYSTEM_NUMA_INFORMATION;
pub type PSYSTEM_NUMA_INFORMATION = *mut _SYSTEM_NUMA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_POWER_INFORMATION {
   pub CurrentFrequency: UCHAR,
   pub ThermalLimitFrequency: UCHAR,
   pub ConstantThrottleFrequency: UCHAR,
   pub DegradedThrottleFrequency: UCHAR,
   pub LastBusyFrequency: UCHAR,
   pub LastC3Frequency: UCHAR,
   pub LastAdjustedBusyFrequency: UCHAR,
   pub ProcessorMinThrottle: UCHAR,
   pub ProcessorMaxThrottle: UCHAR,
   pub NumberOfFrequencies: ULONG,
   pub PromotionCount: ULONG,
   pub DemotionCount: ULONG,
   pub ErrorCount: ULONG,
   pub RetryCount: ULONG,
   pub CurrentFrequencyTime: ULONGLONG,
   pub CurrentProcessorTime: ULONGLONG,
   pub CurrentProcessorIdleTime: ULONGLONG,
   pub LastProcessorTime: ULONGLONG,
   pub LastProcessorIdleTime: ULONGLONG,
   pub Energy: ULONGLONG,
}
pub type SYSTEM_PROCESSOR_POWER_INFORMATION = _SYSTEM_PROCESSOR_POWER_INFORMATION;
pub type PSYSTEM_PROCESSOR_POWER_INFORMATION = *mut _SYSTEM_PROCESSOR_POWER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
   pub Object: PVOID,
   pub UniqueProcessId: HANDLE,
   pub HandleValue: HANDLE,
   pub GrantedAccess: ACCESS_MASK,
   pub CreatorBackTraceIndex: USHORT,
   pub ObjectTypeIndex: USHORT,
   pub HandleAttributes: ULONG,
   pub Reserved: ULONG,
}
impl Default for _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX = _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
pub type PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX = *mut _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_INFORMATION_EX {
   pub NumberOfHandles: ULONG_PTR,
   pub Reserved: ULONG_PTR,
   pub Handles: [SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX; 1usize],
}
impl Default for _SYSTEM_HANDLE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HANDLE_INFORMATION_EX = _SYSTEM_HANDLE_INFORMATION_EX;
pub type PSYSTEM_HANDLE_INFORMATION_EX = *mut _SYSTEM_HANDLE_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BIGPOOL_ENTRY {
   pub __bindgen_anon_1: _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_1,
   pub SizeInBytes: SIZE_T,
   pub __bindgen_anon_2: _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_1 {
   pub VirtualAddress: PVOID,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_1 {
   #[inline]
   pub fn NonPaged(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_NonPaged(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NonPaged_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_NonPaged_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(NonPaged: ULONG_PTR) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let NonPaged: u64 = unsafe { ::core::mem::transmute(NonPaged) };
         NonPaged as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_2 {
   pub Tag: [UCHAR; 4usize],
   pub TagUlong: ULONG,
}
impl Default for _SYSTEM_BIGPOOL_ENTRY__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_BIGPOOL_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BIGPOOL_ENTRY = _SYSTEM_BIGPOOL_ENTRY;
pub type PSYSTEM_BIGPOOL_ENTRY = *mut _SYSTEM_BIGPOOL_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BIGPOOL_INFORMATION {
   pub Count: ULONG,
   pub AllocatedInfo: [SYSTEM_BIGPOOL_ENTRY; 1usize],
}
impl Default for _SYSTEM_BIGPOOL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BIGPOOL_INFORMATION = _SYSTEM_BIGPOOL_INFORMATION;
pub type PSYSTEM_BIGPOOL_INFORMATION = *mut _SYSTEM_BIGPOOL_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_POOL_ENTRY {
   pub Allocated: BOOLEAN,
   pub Spare0: BOOLEAN,
   pub AllocatorBackTraceIndex: USHORT,
   pub Size: ULONG,
   pub __bindgen_anon_1: _SYSTEM_POOL_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POOL_ENTRY__bindgen_ty_1 {
   pub Tag: [UCHAR; 4usize],
   pub TagUlong: ULONG,
   pub ProcessChargedQuota: PVOID,
}
impl Default for _SYSTEM_POOL_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_POOL_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POOL_ENTRY = _SYSTEM_POOL_ENTRY;
pub type PSYSTEM_POOL_ENTRY = *mut _SYSTEM_POOL_ENTRY;
#[repr(C)]
pub struct _SYSTEM_POOL_INFORMATION {
   pub TotalSize: SIZE_T,
   pub FirstEntry: PVOID,
   pub EntryOverhead: USHORT,
   pub PoolTagPresent: BOOLEAN,
   pub Spare0: BOOLEAN,
   pub NumberOfEntries: ULONG,
   pub Entries: [SYSTEM_POOL_ENTRY; 1usize],
}
impl Default for _SYSTEM_POOL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POOL_INFORMATION = _SYSTEM_POOL_INFORMATION;
pub type PSYSTEM_POOL_INFORMATION = *mut _SYSTEM_POOL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SESSION_POOLTAG_INFORMATION {
   pub NextEntryOffset: SIZE_T,
   pub SessionId: ULONG,
   pub Count: ULONG,
   pub TagInfo: [SYSTEM_POOLTAG; 1usize],
}
impl Default for _SYSTEM_SESSION_POOLTAG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SESSION_POOLTAG_INFORMATION = _SYSTEM_SESSION_POOLTAG_INFORMATION;
pub type PSYSTEM_SESSION_POOLTAG_INFORMATION = *mut _SYSTEM_SESSION_POOLTAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {
   pub NextEntryOffset: SIZE_T,
   pub SessionId: ULONG,
   pub ViewFailures: ULONG,
   pub NumberOfBytesAvailable: SIZE_T,
   pub NumberOfBytesAvailableContiguous: SIZE_T,
}
pub type SYSTEM_SESSION_MAPPED_VIEW_INFORMATION = _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION;
pub type PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION = *mut _SYSTEM_SESSION_MAPPED_VIEW_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WATCHDOG_HANDLER_ACTION {
   WdActionSetTimeoutValue = 0,
   WdActionQueryTimeoutValue = 1,
   WdActionResetTimer = 2,
   WdActionStopTimer = 3,
   WdActionStartTimer = 4,
   WdActionSetTriggerAction = 5,
   WdActionQueryTriggerAction = 6,
   WdActionQueryState = 7,
}
pub use self::_WATCHDOG_HANDLER_ACTION as WATCHDOG_HANDLER_ACTION;
pub type PSYSTEM_WATCHDOG_HANDLER = ::core::option::Option<
   unsafe extern "C" fn(
      Action: WATCHDOG_HANDLER_ACTION,
      Context: PVOID,
      DataValue: PULONG,
      NoLocks: BOOLEAN,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_WATCHDOG_HANDLER_INFORMATION {
   pub WdHandler: PSYSTEM_WATCHDOG_HANDLER,
   pub Context: PVOID,
}
impl Default for _SYSTEM_WATCHDOG_HANDLER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_WATCHDOG_HANDLER_INFORMATION = _SYSTEM_WATCHDOG_HANDLER_INFORMATION;
pub type PSYSTEM_WATCHDOG_HANDLER_INFORMATION = *mut _SYSTEM_WATCHDOG_HANDLER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WATCHDOG_INFORMATION_CLASS {
   WdInfoTimeoutValue = 0,
   WdInfoResetTimer = 1,
   WdInfoStopTimer = 2,
   WdInfoStartTimer = 3,
   WdInfoTriggerAction = 4,
   WdInfoState = 5,
   WdInfoTriggerReset = 6,
   WdInfoNop = 7,
   WdInfoGeneratedLastReset = 8,
   WdInfoInvalid = 9,
}
pub use self::_WATCHDOG_INFORMATION_CLASS as WATCHDOG_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_WATCHDOG_TIMER_INFORMATION {
   pub WdInfoClass: WATCHDOG_INFORMATION_CLASS,
   pub DataValue: ULONG,
}
impl Default for _SYSTEM_WATCHDOG_TIMER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_WATCHDOG_TIMER_INFORMATION = _SYSTEM_WATCHDOG_TIMER_INFORMATION;
pub type PSYSTEM_WATCHDOG_TIMER_INFORMATION = *mut _SYSTEM_WATCHDOG_TIMER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_FIRMWARE_TABLE_ACTION {
   SystemFirmwareTableEnumerate = 0,
   SystemFirmwareTableGet = 1,
   SystemFirmwareTableMax = 2,
}
pub use self::_SYSTEM_FIRMWARE_TABLE_ACTION as SYSTEM_FIRMWARE_TABLE_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
   pub ProviderSignature: ULONG,
   pub Action: SYSTEM_FIRMWARE_TABLE_ACTION,
   pub TableID: ULONG,
   pub TableBufferLength: ULONG,
   pub TableBuffer: [UCHAR; 1usize],
}
impl Default for _SYSTEM_FIRMWARE_TABLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FIRMWARE_TABLE_INFORMATION = _SYSTEM_FIRMWARE_TABLE_INFORMATION;
pub type PSYSTEM_FIRMWARE_TABLE_INFORMATION = *mut _SYSTEM_FIRMWARE_TABLE_INFORMATION;
pub type PFNFTH = ::core::option::Option<
   unsafe extern "C" fn(SystemFirmwareTableInfo: PSYSTEM_FIRMWARE_TABLE_INFORMATION) -> NTSTATUS,
>;
#[repr(C)]
pub struct _SYSTEM_FIRMWARE_TABLE_HANDLER {
   pub ProviderSignature: ULONG,
   pub Register: BOOLEAN,
   pub FirmwareTableHandler: PFNFTH,
   pub DriverObject: PVOID,
}
impl Default for _SYSTEM_FIRMWARE_TABLE_HANDLER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FIRMWARE_TABLE_HANDLER = _SYSTEM_FIRMWARE_TABLE_HANDLER;
pub type PSYSTEM_FIRMWARE_TABLE_HANDLER = *mut _SYSTEM_FIRMWARE_TABLE_HANDLER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_LIST_INFORMATION {
   pub ZeroPageCount: SIZE_T,
   pub FreePageCount: SIZE_T,
   pub ModifiedPageCount: SIZE_T,
   pub ModifiedNoWritePageCount: SIZE_T,
   pub BadPageCount: SIZE_T,
   pub PageCountByPriority: [SIZE_T; 8usize],
   pub RepurposedPagesByPriority: [SIZE_T; 8usize],
   pub ModifiedPageCountPageFile: SIZE_T,
}
pub type SYSTEM_MEMORY_LIST_INFORMATION = _SYSTEM_MEMORY_LIST_INFORMATION;
pub type PSYSTEM_MEMORY_LIST_INFORMATION = *mut _SYSTEM_MEMORY_LIST_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_MEMORY_LIST_COMMAND {
   MemoryCaptureAccessedBits = 0,
   MemoryCaptureAndResetAccessedBits = 1,
   MemoryEmptyWorkingSets = 2,
   MemoryFlushModifiedList = 3,
   MemoryPurgeStandbyList = 4,
   MemoryPurgeLowPriorityStandbyList = 5,
   MemoryCommandMax = 6,
}
pub use self::_SYSTEM_MEMORY_LIST_COMMAND as SYSTEM_MEMORY_LIST_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_THREAD_CID_PRIORITY_INFORMATION {
   pub ClientId: CLIENT_ID,
   pub Priority: KPRIORITY,
}
impl Default for _SYSTEM_THREAD_CID_PRIORITY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_THREAD_CID_PRIORITY_INFORMATION = _SYSTEM_THREAD_CID_PRIORITY_INFORMATION;
pub type PSYSTEM_THREAD_CID_PRIORITY_INFORMATION = *mut _SYSTEM_THREAD_CID_PRIORITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION {
   pub CycleTime: ULONGLONG,
}
pub type SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION =
   _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION;
pub type PSYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION =
   *mut _SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_VERIFIER_ISSUE {
   pub IssueType: ULONGLONG,
   pub Address: PVOID,
   pub Parameters: [ULONGLONG; 2usize],
}
impl Default for _SYSTEM_VERIFIER_ISSUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_ISSUE = _SYSTEM_VERIFIER_ISSUE;
pub type PSYSTEM_VERIFIER_ISSUE = *mut _SYSTEM_VERIFIER_ISSUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_VERIFIER_CANCELLATION_INFORMATION {
   pub CancelProbability: ULONG,
   pub CancelThreshold: ULONG,
   pub CompletionThreshold: ULONG,
   pub CancellationVerifierDisabled: ULONG,
   pub AvailableIssues: ULONG,
   pub Issues: [SYSTEM_VERIFIER_ISSUE; 128usize],
}
impl Default for _SYSTEM_VERIFIER_CANCELLATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_CANCELLATION_INFORMATION = _SYSTEM_VERIFIER_CANCELLATION_INFORMATION;
pub type PSYSTEM_VERIFIER_CANCELLATION_INFORMATION = *mut _SYSTEM_VERIFIER_CANCELLATION_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_REF_TRACE_INFORMATION {
   pub TraceEnable: BOOLEAN,
   pub TracePermanent: BOOLEAN,
   pub TraceProcessName: UNICODE_STRING,
   pub TracePoolTags: UNICODE_STRING,
}
impl Default for _SYSTEM_REF_TRACE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_REF_TRACE_INFORMATION = _SYSTEM_REF_TRACE_INFORMATION;
pub type PSYSTEM_REF_TRACE_INFORMATION = *mut _SYSTEM_REF_TRACE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SPECIAL_POOL_INFORMATION {
   pub PoolTag: ULONG,
   pub Flags: ULONG,
}
pub type SYSTEM_SPECIAL_POOL_INFORMATION = _SYSTEM_SPECIAL_POOL_INFORMATION;
pub type PSYSTEM_SPECIAL_POOL_INFORMATION = *mut _SYSTEM_SPECIAL_POOL_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_PROCESS_ID_INFORMATION {
   pub ProcessId: HANDLE,
   pub ImageName: UNICODE_STRING,
}
impl Default for _SYSTEM_PROCESS_ID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESS_ID_INFORMATION = _SYSTEM_PROCESS_ID_INFORMATION;
pub type PSYSTEM_PROCESS_ID_INFORMATION = *mut _SYSTEM_PROCESS_ID_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_HYPERVISOR_QUERY_INFORMATION {
   pub HypervisorConnected: BOOLEAN,
   pub HypervisorDebuggingEnabled: BOOLEAN,
   pub HypervisorPresent: BOOLEAN,
   pub Spare0: [BOOLEAN; 5usize],
   pub EnabledEnlightenments: ULONGLONG,
}
impl Default for _SYSTEM_HYPERVISOR_QUERY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HYPERVISOR_QUERY_INFORMATION = _SYSTEM_HYPERVISOR_QUERY_INFORMATION;
pub type PSYSTEM_HYPERVISOR_QUERY_INFORMATION = *mut _SYSTEM_HYPERVISOR_QUERY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
   pub BootIdentifier: GUID,
   pub FirmwareType: FIRMWARE_TYPE,
   pub __bindgen_anon_1: _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1 {
   pub BootFlags: ULONGLONG,
   pub __bindgen_anon_1: _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
   pub __bindgen_padding_0: [u8; 5usize],
}
impl _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn DbgMenuOsSelection(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMenuOsSelection(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgMenuOsSelection_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgMenuOsSelection_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgHiberBoot(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgHiberBoot(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgHiberBoot_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgHiberBoot_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgSoftBoot(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgSoftBoot(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgSoftBoot_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgSoftBoot_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgMeasuredLaunch(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMeasuredLaunch(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgMeasuredLaunch_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgMeasuredLaunch_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgMeasuredLaunchCapable(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMeasuredLaunchCapable(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgMeasuredLaunchCapable_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgMeasuredLaunchCapable_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgSystemHiveReplace(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgSystemHiveReplace(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgSystemHiveReplace_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgSystemHiveReplace_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgMeasuredLaunchSmmProtections(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMeasuredLaunchSmmProtections(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgMeasuredLaunchSmmProtections_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgMeasuredLaunchSmmProtections_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgMeasuredLaunchSmmLevel(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 7u8) as u64) }
   }
   #[inline]
   pub fn set_DbgMeasuredLaunchSmmLevel(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgMeasuredLaunchSmmLevel_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            7u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgMeasuredLaunchSmmLevel_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            7u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgBugCheckRecovery(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgBugCheckRecovery(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgBugCheckRecovery_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgBugCheckRecovery_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgFASR(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgFASR(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgFASR_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgFASR_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgUseCachedBcd(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_DbgUseCachedBcd(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgUseCachedBcd_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DbgUseCachedBcd_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DbgMenuOsSelection: ULONGLONG,
      DbgHiberBoot: ULONGLONG,
      DbgSoftBoot: ULONGLONG,
      DbgMeasuredLaunch: ULONGLONG,
      DbgMeasuredLaunchCapable: ULONGLONG,
      DbgSystemHiveReplace: ULONGLONG,
      DbgMeasuredLaunchSmmProtections: ULONGLONG,
      DbgMeasuredLaunchSmmLevel: ULONGLONG,
      DbgBugCheckRecovery: ULONGLONG,
      DbgFASR: ULONGLONG,
      DbgUseCachedBcd: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DbgMenuOsSelection: u64 = unsafe { ::core::mem::transmute(DbgMenuOsSelection) };
         DbgMenuOsSelection as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DbgHiberBoot: u64 = unsafe { ::core::mem::transmute(DbgHiberBoot) };
         DbgHiberBoot as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DbgSoftBoot: u64 = unsafe { ::core::mem::transmute(DbgSoftBoot) };
         DbgSoftBoot as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DbgMeasuredLaunch: u64 = unsafe { ::core::mem::transmute(DbgMeasuredLaunch) };
         DbgMeasuredLaunch as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let DbgMeasuredLaunchCapable: u64 =
            unsafe { ::core::mem::transmute(DbgMeasuredLaunchCapable) };
         DbgMeasuredLaunchCapable as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let DbgSystemHiveReplace: u64 = unsafe { ::core::mem::transmute(DbgSystemHiveReplace) };
         DbgSystemHiveReplace as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let DbgMeasuredLaunchSmmProtections: u64 =
            unsafe { ::core::mem::transmute(DbgMeasuredLaunchSmmProtections) };
         DbgMeasuredLaunchSmmProtections as u64
      });
      __bindgen_bitfield_unit.set(7usize, 7u8, {
         let DbgMeasuredLaunchSmmLevel: u64 =
            unsafe { ::core::mem::transmute(DbgMeasuredLaunchSmmLevel) };
         DbgMeasuredLaunchSmmLevel as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let DbgBugCheckRecovery: u64 = unsafe { ::core::mem::transmute(DbgBugCheckRecovery) };
         DbgBugCheckRecovery as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let DbgFASR: u64 = unsafe { ::core::mem::transmute(DbgFASR) };
         DbgFASR as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let DbgUseCachedBcd: u64 = unsafe { ::core::mem::transmute(DbgUseCachedBcd) };
         DbgUseCachedBcd as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_BOOT_ENVIRONMENT_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BOOT_ENVIRONMENT_INFORMATION = _SYSTEM_BOOT_ENVIRONMENT_INFORMATION;
pub type PSYSTEM_BOOT_ENVIRONMENT_INFORMATION = *mut _SYSTEM_BOOT_ENVIRONMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION {
   pub FlagsToEnable: ULONG,
   pub FlagsToDisable: ULONG,
}
pub type SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION =
   _SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION;
pub type PSYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION =
   *mut _SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _COVERAGE_REQUEST_CODES {
   CoverageAllModules = 0,
   CoverageSearchByHash = 1,
   CoverageSearchByName = 2,
}
pub use self::_COVERAGE_REQUEST_CODES as COVERAGE_REQUEST_CODES;
#[repr(C)]
pub struct _COVERAGE_MODULE_REQUEST {
   pub RequestType: COVERAGE_REQUEST_CODES,
   pub SearchInfo: _COVERAGE_MODULE_REQUEST__bindgen_ty_1,
}
#[repr(C)]
pub union _COVERAGE_MODULE_REQUEST__bindgen_ty_1 {
   pub MD5Hash: ::core::mem::ManuallyDrop<[UCHAR; 16usize]>,
   pub ModuleName: ::core::mem::ManuallyDrop<UNICODE_STRING>,
}
impl Default for _COVERAGE_MODULE_REQUEST__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _COVERAGE_MODULE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COVERAGE_MODULE_REQUEST = _COVERAGE_MODULE_REQUEST;
pub type PCOVERAGE_MODULE_REQUEST = *mut _COVERAGE_MODULE_REQUEST;
#[repr(C)]
pub struct _COVERAGE_MODULE_INFO {
   pub ModuleInfoSize: ULONG,
   pub IsBinaryLoaded: ULONG,
   pub ModulePathName: UNICODE_STRING,
   pub CoverageSectionSize: ULONG,
   pub CoverageSection: [UCHAR; 1usize],
}
impl Default for _COVERAGE_MODULE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COVERAGE_MODULE_INFO = _COVERAGE_MODULE_INFO;
pub type PCOVERAGE_MODULE_INFO = *mut _COVERAGE_MODULE_INFO;
#[repr(C)]
pub struct _COVERAGE_MODULES {
   pub ListAndReset: ULONG,
   pub NumberOfModules: ULONG,
   pub ModuleRequestInfo: COVERAGE_MODULE_REQUEST,
   pub Modules: [COVERAGE_MODULE_INFO; 1usize],
}
impl Default for _COVERAGE_MODULES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COVERAGE_MODULES = _COVERAGE_MODULES;
pub type PCOVERAGE_MODULES = *mut _COVERAGE_MODULES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PREFETCH_PATCH_INFORMATION {
   pub PrefetchPatchCount: ULONG,
}
pub type SYSTEM_PREFETCH_PATCH_INFORMATION = _SYSTEM_PREFETCH_PATCH_INFORMATION;
pub type PSYSTEM_PREFETCH_PATCH_INFORMATION = *mut _SYSTEM_PREFETCH_PATCH_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_FAULTS_INFORMATION {
   pub Probability: ULONG,
   pub MaxProbability: ULONG,
   pub PoolTags: UNICODE_STRING,
   pub Applications: UNICODE_STRING,
}
impl Default for _SYSTEM_VERIFIER_FAULTS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_FAULTS_INFORMATION = _SYSTEM_VERIFIER_FAULTS_INFORMATION;
pub type PSYSTEM_VERIFIER_FAULTS_INFORMATION = *mut _SYSTEM_VERIFIER_FAULTS_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_INFORMATION_EX {
   pub VerifyMode: ULONG,
   pub OptionChanges: ULONG,
   pub PreviousBucketName: UNICODE_STRING,
   pub IrpCancelTimeoutMsec: ULONG,
   pub VerifierExtensionEnabled: ULONG,
   pub Reserved: [ULONG; 1usize],
}
impl Default for _SYSTEM_VERIFIER_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_INFORMATION_EX = _SYSTEM_VERIFIER_INFORMATION_EX;
pub type PSYSTEM_VERIFIER_INFORMATION_EX = *mut _SYSTEM_VERIFIER_INFORMATION_EX;
#[repr(C)]
pub struct _SYSTEM_SYSTEM_PARTITION_INFORMATION {
   pub SystemPartition: UNICODE_STRING,
}
impl Default for _SYSTEM_SYSTEM_PARTITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SYSTEM_PARTITION_INFORMATION = _SYSTEM_SYSTEM_PARTITION_INFORMATION;
pub type PSYSTEM_SYSTEM_PARTITION_INFORMATION = *mut _SYSTEM_SYSTEM_PARTITION_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_SYSTEM_DISK_INFORMATION {
   pub SystemDisk: UNICODE_STRING,
}
impl Default for _SYSTEM_SYSTEM_DISK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SYSTEM_DISK_INFORMATION = _SYSTEM_SYSTEM_DISK_INFORMATION;
pub type PSYSTEM_SYSTEM_DISK_INFORMATION = *mut _SYSTEM_SYSTEM_DISK_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_NUMA_PROXIMITY_MAP {
   pub NodeProximityId: ULONG,
   pub NodeNumber: USHORT,
}
pub type SYSTEM_NUMA_PROXIMITY_MAP = _SYSTEM_NUMA_PROXIMITY_MAP;
pub type PSYSTEM_NUMA_PROXIMITY_MAP = *mut _SYSTEM_NUMA_PROXIMITY_MAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT {
   pub Hits: ULONGLONG,
   pub PercentFrequency: UCHAR,
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT = _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT = *mut _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION {
   pub ProcessorNumber: ULONG,
   pub StateCount: ULONG,
   pub States: [SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT; 1usize],
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION =
   _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 {
   pub Hits: ULONG,
   pub PercentFrequency: UCHAR,
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 = _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION_WIN8 {
   pub ProcessorNumber: ULONG,
   pub StateCount: ULONG,
   pub States: [SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8; 1usize],
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION_WIN8 =
   _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION_WIN8;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION_WIN8 =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION_WIN8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION {
   pub ProcessorCount: ULONG,
   pub Offsets: [ULONG; 1usize],
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION = _SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_INFORMATION {
   pub Length: ULONG,
   pub CodeIntegrityOptions: ULONG,
}
pub type SYSTEM_CODEINTEGRITY_INFORMATION = _SYSTEM_CODEINTEGRITY_INFORMATION;
pub type PSYSTEM_CODEINTEGRITY_INFORMATION = *mut _SYSTEM_CODEINTEGRITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION {
   pub Operation: ULONG,
}
pub type SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION =
   _SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION;
pub type PSYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION =
   *mut _SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_VA_TYPE {
   SystemVaTypeAll = 0,
   SystemVaTypeNonPagedPool = 1,
   SystemVaTypePagedPool = 2,
   SystemVaTypeSystemCache = 3,
   SystemVaTypeSystemPtes = 4,
   SystemVaTypeSessionSpace = 5,
   SystemVaTypeMax = 6,
}
pub use self::_SYSTEM_VA_TYPE as SYSTEM_VA_TYPE;
pub type PSYSTEM_VA_TYPE = *mut _SYSTEM_VA_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_VA_LIST_INFORMATION {
   pub VirtualSize: SIZE_T,
   pub VirtualPeak: SIZE_T,
   pub VirtualLimit: SIZE_T,
   pub AllocationFailures: SIZE_T,
}
pub type SYSTEM_VA_LIST_INFORMATION = _SYSTEM_VA_LIST_INFORMATION;
pub type PSYSTEM_VA_LIST_INFORMATION = *mut _SYSTEM_VA_LIST_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORE_INFORMATION_CLASS {
   StorePageRequest = 1,
   StoreStatsRequest = 2,
   StoreCreateRequest = 3,
   StoreDeleteRequest = 4,
   StoreListRequest = 5,
   Available1 = 6,
   StoreEmptyRequest = 7,
   CacheListRequest = 8,
   CacheCreateRequest = 9,
   CacheDeleteRequest = 10,
   CacheStoreCreateRequest = 11,
   CacheStoreDeleteRequest = 12,
   CacheStatsRequest = 13,
   Available2 = 14,
   RegistrationRequest = 15,
   GlobalCacheStatsRequest = 16,
   StoreResizeRequest = 17,
   CacheStoreResizeRequest = 18,
   SmConfigRequest = 19,
   StoreHighMemoryPriorityRequest = 20,
   SystemStoreTrimRequest = 21,
   MemCompressionInfoRequest = 22,
   ProcessStoreInfoRequest = 23,
   StoreInformationMax = 24,
}
pub use self::_STORE_INFORMATION_CLASS as STORE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_STORE_INFORMATION {
   pub Version: ULONG,
   pub StoreInformationClass: STORE_INFORMATION_CLASS,
   pub Data: PVOID,
   pub Length: ULONG,
}
impl Default for _SYSTEM_STORE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_STORE_INFORMATION = _SYSTEM_STORE_INFORMATION;
pub type PSYSTEM_STORE_INFORMATION = *mut _SYSTEM_STORE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ST_STATS_LEVEL {
   StStatsLevelBasic = 0,
   StStatsLevelIoStats = 1,
   StStatsLevelRegionSpace = 2,
   StStatsLevelSpaceBitmap = 3,
   StStatsLevelMax = 4,
}
pub use self::_ST_STATS_LEVEL as ST_STATS_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STATS_REQUEST {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub BufferSize: ULONG,
   pub Buffer: PVOID,
}
impl Default for _SM_STATS_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_STATS_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DetailLevel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_DetailLevel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DetailLevel_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DetailLevel_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn StoreId(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_StoreId(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StoreId_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            16u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StoreId_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      DetailLevel: ULONG,
      StoreId: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let DetailLevel: u32 = unsafe { ::core::mem::transmute(DetailLevel) };
         DetailLevel as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let StoreId: u32 = unsafe { ::core::mem::transmute(StoreId) };
         StoreId as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_STATS_REQUEST = _SM_STATS_REQUEST;
pub type PSM_STATS_REQUEST = *mut _SM_STATS_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_DATA_MGR_STATS {
   pub RegionCount: ULONG,
   pub PagesStored: ULONG,
   pub UniquePagesStored: ULONG,
   pub LazyCleanupRegionCount: ULONG,
   pub Space: [_ST_DATA_MGR_STATS__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_DATA_MGR_STATS__bindgen_ty_1 {
   pub RegionsInUse: ULONG,
   pub SpaceUsed: ULONG,
}
pub type ST_DATA_MGR_STATS = _ST_DATA_MGR_STATS;
pub type PST_DATA_MGR_STATS = *mut _ST_DATA_MGR_STATS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_IO_STATS_PERIOD {
   pub PageCounts: [ULONG; 5usize],
}
pub type ST_IO_STATS_PERIOD = _ST_IO_STATS_PERIOD;
pub type PST_IO_STATS_PERIOD = *mut _ST_IO_STATS_PERIOD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_IO_STATS {
   pub PeriodCount: ULONG,
   pub Periods: [ST_IO_STATS_PERIOD; 64usize],
}
impl Default for _ST_IO_STATS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ST_IO_STATS = _ST_IO_STATS;
pub type PST_IO_STATS = *mut _ST_IO_STATS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_READ_LATENCY_BUCKET {
   pub LatencyUs: ULONG,
   pub Count: ULONG,
}
pub type ST_READ_LATENCY_BUCKET = _ST_READ_LATENCY_BUCKET;
pub type PST_READ_LATENCY_BUCKET = *mut _ST_READ_LATENCY_BUCKET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_READ_LATENCY_STATS {
   pub Buckets: [ST_READ_LATENCY_BUCKET; 8usize],
}
pub type ST_READ_LATENCY_STATS = _ST_READ_LATENCY_STATS;
pub type PST_READ_LATENCY_STATS = *mut _ST_READ_LATENCY_STATS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_STATS_REGION_INFO {
   pub SpaceUsed: USHORT,
   pub Priority: UCHAR,
   pub Spare: UCHAR,
}
pub type ST_STATS_REGION_INFO = _ST_STATS_REGION_INFO;
pub type PST_STATS_REGION_INFO = *mut _ST_STATS_REGION_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_STATS_SPACE_BITMAP {
   pub CompressedBytes: SIZE_T,
   pub BytesPerBit: ULONG,
   pub StoreBitmap: [UCHAR; 1usize],
}
pub type ST_STATS_SPACE_BITMAP = _ST_STATS_SPACE_BITMAP;
pub type PST_STATS_SPACE_BITMAP = *mut _ST_STATS_SPACE_BITMAP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_STATS {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub Size: ULONG,
   pub CompressionFormat: USHORT,
   pub Spare: USHORT,
   pub Basic: _ST_STATS__bindgen_ty_1,
   pub Io: _ST_STATS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ST_STATS__bindgen_ty_1 {
   pub RegionSize: ULONG,
   pub RegionCount: ULONG,
   pub RegionCountMax: ULONG,
   pub Granularity: ULONG,
   pub UserData: ST_DATA_MGR_STATS,
   pub Metadata: ST_DATA_MGR_STATS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ST_STATS__bindgen_ty_2 {
   pub IoStats: ST_IO_STATS,
   pub ReadLatencyStats: ST_READ_LATENCY_STATS,
}
impl Default for _ST_STATS__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ST_STATS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _ST_STATS {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Level(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Level(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Level_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Level_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn StoreType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_StoreType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StoreType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StoreType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoDuplication(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoDuplication(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoDuplication_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoDuplication_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoCompression(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoCompression(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoCompression_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            17usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoCompression_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            17usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EncryptionStrength(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 12u8) as u32) }
   }
   #[inline]
   pub fn set_EncryptionStrength(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EncryptionStrength_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            18usize,
            12u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EncryptionStrength_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            18usize,
            12u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(30usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualRegions_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            30usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualRegions_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            30usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Spare0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare0_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            31usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare0_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            31usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      Level: ULONG,
      StoreType: ULONG,
      NoDuplication: ULONG,
      NoCompression: ULONG,
      EncryptionStrength: ULONG,
      VirtualRegions: ULONG,
      Spare0: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 4u8, {
         let Level: u32 = unsafe { ::core::mem::transmute(Level) };
         Level as u64
      });
      __bindgen_bitfield_unit.set(12usize, 4u8, {
         let StoreType: u32 = unsafe { ::core::mem::transmute(StoreType) };
         StoreType as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let NoDuplication: u32 = unsafe { ::core::mem::transmute(NoDuplication) };
         NoDuplication as u64
      });
      __bindgen_bitfield_unit.set(17usize, 1u8, {
         let NoCompression: u32 = unsafe { ::core::mem::transmute(NoCompression) };
         NoCompression as u64
      });
      __bindgen_bitfield_unit.set(18usize, 12u8, {
         let EncryptionStrength: u32 = unsafe { ::core::mem::transmute(EncryptionStrength) };
         EncryptionStrength as u64
      });
      __bindgen_bitfield_unit.set(30usize, 1u8, {
         let VirtualRegions: u32 = unsafe { ::core::mem::transmute(VirtualRegions) };
         VirtualRegions as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Spare0: u32 = unsafe { ::core::mem::transmute(Spare0) };
         Spare0 as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type ST_STATS = _ST_STATS;
pub type PST_STATS = *mut _ST_STATS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SM_STORE_TYPE {
   StoreTypeInMemory = 0,
   StoreTypeFile = 1,
   StoreTypeMax = 2,
}
pub use self::_SM_STORE_TYPE as SM_STORE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SM_STORE_BASIC_PARAMS {
   pub __bindgen_anon_1: _SM_STORE_BASIC_PARAMS__bindgen_ty_1,
   pub Granularity: ULONG,
   pub RegionSize: ULONG,
   pub RegionCountMax: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SM_STORE_BASIC_PARAMS__bindgen_ty_1 {
   pub __bindgen_anon_1: _SM_STORE_BASIC_PARAMS__bindgen_ty_1__bindgen_ty_1,
   pub StoreFlags: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_STORE_BASIC_PARAMS__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SM_STORE_BASIC_PARAMS__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn StoreType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_StoreType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StoreType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StoreType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoDuplication(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoDuplication(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoDuplication_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoDuplication_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FailNoCompression(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FailNoCompression(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FailNoCompression_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FailNoCompression_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoCompression(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoCompression(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoCompression_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoCompression_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoEncryption(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoEncryption(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoEncryption_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoEncryption_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoEvictOnAdd(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoEvictOnAdd(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoEvictOnAdd_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoEvictOnAdd_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PerformsFileIo(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PerformsFileIo(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PerformsFileIo_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PerformsFileIo_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VdlNotSet(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VdlNotSet(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VdlNotSet_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VdlNotSet_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UseIntermediateAddBuffer(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UseIntermediateAddBuffer(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UseIntermediateAddBuffer_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_UseIntermediateAddBuffer_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CompressNoHuff(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompressNoHuff(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CompressNoHuff_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CompressNoHuff_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LockActiveRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LockActiveRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LockActiveRegions_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            17usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LockActiveRegions_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            17usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualRegions_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            18usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualRegions_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            18usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(19usize, 13u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            19usize,
            13u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            19usize,
            13u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      StoreType: ULONG,
      NoDuplication: ULONG,
      FailNoCompression: ULONG,
      NoCompression: ULONG,
      NoEncryption: ULONG,
      NoEvictOnAdd: ULONG,
      PerformsFileIo: ULONG,
      VdlNotSet: ULONG,
      UseIntermediateAddBuffer: ULONG,
      CompressNoHuff: ULONG,
      LockActiveRegions: ULONG,
      VirtualRegions: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let StoreType: u32 = unsafe { ::core::mem::transmute(StoreType) };
         StoreType as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let NoDuplication: u32 = unsafe { ::core::mem::transmute(NoDuplication) };
         NoDuplication as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let FailNoCompression: u32 = unsafe { ::core::mem::transmute(FailNoCompression) };
         FailNoCompression as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let NoCompression: u32 = unsafe { ::core::mem::transmute(NoCompression) };
         NoCompression as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let NoEncryption: u32 = unsafe { ::core::mem::transmute(NoEncryption) };
         NoEncryption as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let NoEvictOnAdd: u32 = unsafe { ::core::mem::transmute(NoEvictOnAdd) };
         NoEvictOnAdd as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let PerformsFileIo: u32 = unsafe { ::core::mem::transmute(PerformsFileIo) };
         PerformsFileIo as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let VdlNotSet: u32 = unsafe { ::core::mem::transmute(VdlNotSet) };
         VdlNotSet as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let UseIntermediateAddBuffer: u32 =
            unsafe { ::core::mem::transmute(UseIntermediateAddBuffer) };
         UseIntermediateAddBuffer as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let CompressNoHuff: u32 = unsafe { ::core::mem::transmute(CompressNoHuff) };
         CompressNoHuff as u64
      });
      __bindgen_bitfield_unit.set(17usize, 1u8, {
         let LockActiveRegions: u32 = unsafe { ::core::mem::transmute(LockActiveRegions) };
         LockActiveRegions as u64
      });
      __bindgen_bitfield_unit.set(18usize, 1u8, {
         let VirtualRegions: u32 = unsafe { ::core::mem::transmute(VirtualRegions) };
         VirtualRegions as u64
      });
      __bindgen_bitfield_unit.set(19usize, 13u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SM_STORE_BASIC_PARAMS__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SM_STORE_BASIC_PARAMS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_STORE_BASIC_PARAMS = _SM_STORE_BASIC_PARAMS;
pub type PSM_STORE_BASIC_PARAMS = *mut _SM_STORE_BASIC_PARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SMKM_REGION_EXTENT {
   pub RegionCount: ULONG,
   pub ByteOffset: SIZE_T,
}
pub type SMKM_REGION_EXTENT = _SMKM_REGION_EXTENT;
pub type PSMKM_REGION_EXTENT = *mut _SMKM_REGION_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMKM_FILE_INFO {
   pub FileHandle: HANDLE,
   pub FileObject: PFILE_OBJECT,
   pub VolumeFileObject: PFILE_OBJECT,
   pub VolumeDeviceObject: PDEVICE_OBJECT,
   pub VolumePnpHandle: HANDLE,
   pub UsageNotificationIrp: PIRP,
   pub Extents: PSMKM_REGION_EXTENT,
   pub ExtentCount: ULONG,
}
impl Default for _SMKM_FILE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SMKM_FILE_INFO = _SMKM_FILE_INFO;
pub type PSMKM_FILE_INFO = *mut _SMKM_FILE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STORE_CACHE_BACKED_PARAMS {
   pub SectorSize: ULONG,
   pub EncryptionKey: PCHAR,
   pub EncryptionKeySize: ULONG,
   pub FileInfo: PSMKM_FILE_INFO,
   pub EtaContext: PVOID,
   pub StoreRegionBitmap: PRTL_BITMAP,
}
impl Default for _SM_STORE_CACHE_BACKED_PARAMS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_STORE_CACHE_BACKED_PARAMS = _SM_STORE_CACHE_BACKED_PARAMS;
pub type PSM_STORE_CACHE_BACKED_PARAMS = *mut _SM_STORE_CACHE_BACKED_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SM_STORE_PARAMETERS {
   pub Store: SM_STORE_BASIC_PARAMS,
   pub Priority: ULONG,
   pub Flags: ULONG,
   pub CacheBacked: SM_STORE_CACHE_BACKED_PARAMS,
}
impl Default for _SM_STORE_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_STORE_PARAMETERS = _SM_STORE_PARAMETERS;
pub type PSM_STORE_PARAMETERS = *mut _SM_STORE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SM_CREATE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub Params: SM_STORE_PARAMETERS,
   pub StoreId: ULONG,
}
impl Default for _SM_CREATE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_CREATE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AcquireReference(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AcquireReference(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AcquireReference_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AcquireReference_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KeyedStore(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KeyedStore(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KeyedStore_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KeyedStore_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 22u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            22u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            22u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      AcquireReference: ULONG,
      KeyedStore: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let AcquireReference: u32 = unsafe { ::core::mem::transmute(AcquireReference) };
         AcquireReference as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let KeyedStore: u32 = unsafe { ::core::mem::transmute(KeyedStore) };
         KeyedStore as u64
      });
      __bindgen_bitfield_unit.set(10usize, 22u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_CREATE_REQUEST = _SM_CREATE_REQUEST;
pub type PSM_CREATE_REQUEST = *mut _SM_CREATE_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_DELETE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreId: ULONG,
}
impl _SM_DELETE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_DELETE_REQUEST = _SM_DELETE_REQUEST;
pub type PSM_DELETE_REQUEST = *mut _SM_DELETE_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_STORE_LIST_REQUEST {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreId: [ULONG; 32usize],
}
impl _SM_STORE_LIST_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn StoreCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_StoreCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StoreCount_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StoreCount_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ExtendedRequest(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ExtendedRequest(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ExtendedRequest_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ExtendedRequest_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 15u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            17usize,
            15u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            17usize,
            15u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      StoreCount: ULONG,
      ExtendedRequest: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let StoreCount: u32 = unsafe { ::core::mem::transmute(StoreCount) };
         StoreCount as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let ExtendedRequest: u32 = unsafe { ::core::mem::transmute(ExtendedRequest) };
         ExtendedRequest as u64
      });
      __bindgen_bitfield_unit.set(17usize, 15u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_STORE_LIST_REQUEST = _SM_STORE_LIST_REQUEST;
pub type PSM_STORE_LIST_REQUEST = *mut _SM_STORE_LIST_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STORE_LIST_REQUEST_EX {
   pub Request: SM_STORE_LIST_REQUEST,
   pub NameBuffer: [[WCHAR; 64usize]; 32usize],
}
impl Default for _SM_STORE_LIST_REQUEST_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_STORE_LIST_REQUEST_EX = _SM_STORE_LIST_REQUEST_EX;
pub type PSM_STORE_LIST_REQUEST_EX = *mut _SM_STORE_LIST_REQUEST_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SMC_CACHE_LIST_REQUEST {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: [ULONG; 16usize],
}
impl _SMC_CACHE_LIST_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CacheCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_CacheCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CacheCount_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CacheCount_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            16u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      CacheCount: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let CacheCount: u32 = unsafe { ::core::mem::transmute(CacheCount) };
         CacheCount as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_LIST_REQUEST = _SMC_CACHE_LIST_REQUEST;
pub type PSMC_CACHE_LIST_REQUEST = *mut _SMC_CACHE_LIST_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SMC_CACHE_PARAMETERS {
   pub CacheFileSize: SIZE_T,
   pub StoreAlignment: ULONG,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheFlags: ULONG,
   pub Priority: ULONG,
}
impl _SMC_CACHE_PARAMETERS {
   #[inline]
   pub fn PerformsFileIo(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PerformsFileIo(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PerformsFileIo_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PerformsFileIo_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VdlNotSet(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VdlNotSet(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VdlNotSet_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VdlNotSet_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PerformsFileIo: ULONG,
      VdlNotSet: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let PerformsFileIo: u32 = unsafe { ::core::mem::transmute(PerformsFileIo) };
         PerformsFileIo as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let VdlNotSet: u32 = unsafe { ::core::mem::transmute(VdlNotSet) };
         VdlNotSet as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_PARAMETERS = _SMC_CACHE_PARAMETERS;
pub type PSMC_CACHE_PARAMETERS = *mut _SMC_CACHE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_CACHE_CREATE_PARAMETERS {
   pub CacheParameters: SMC_CACHE_PARAMETERS,
   pub TemplateFilePath: [WCHAR; 512usize],
}
impl Default for _SMC_CACHE_CREATE_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SMC_CACHE_CREATE_PARAMETERS = _SMC_CACHE_CREATE_PARAMETERS;
pub type PSMC_CACHE_CREATE_PARAMETERS = *mut _SMC_CACHE_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_CACHE_CREATE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
   pub CacheCreateParams: SMC_CACHE_CREATE_PARAMETERS,
}
impl Default for _SMC_CACHE_CREATE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_CACHE_CREATE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_CREATE_REQUEST = _SMC_CACHE_CREATE_REQUEST;
pub type PSMC_CACHE_CREATE_REQUEST = *mut _SMC_CACHE_CREATE_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SMC_CACHE_DELETE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
}
impl _SMC_CACHE_DELETE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_DELETE_REQUEST = _SMC_CACHE_DELETE_REQUEST;
pub type PSMC_CACHE_DELETE_REQUEST = *mut _SMC_CACHE_DELETE_REQUEST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SM_STORE_MANAGER_TYPE {
   SmStoreManagerTypePhysical = 0,
   SmStoreManagerTypeVirtual = 1,
   SmStoreManagerTypeMax = 2,
}
pub use self::_SM_STORE_MANAGER_TYPE as SM_STORE_MANAGER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SMC_STORE_CREATE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreParams: SM_STORE_BASIC_PARAMS,
   pub CacheId: ULONG,
   pub StoreManagerType: SM_STORE_MANAGER_TYPE,
   pub StoreId: ULONG,
}
impl Default for _SMC_STORE_CREATE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_STORE_CREATE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_STORE_CREATE_REQUEST = _SMC_STORE_CREATE_REQUEST;
pub type PSMC_STORE_CREATE_REQUEST = *mut _SMC_STORE_CREATE_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_STORE_DELETE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
   pub StoreManagerType: SM_STORE_MANAGER_TYPE,
   pub StoreId: ULONG,
}
impl Default for _SMC_STORE_DELETE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_STORE_DELETE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_STORE_DELETE_REQUEST = _SMC_STORE_DELETE_REQUEST;
pub type PSMC_STORE_DELETE_REQUEST = *mut _SMC_STORE_DELETE_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_CACHE_STATS {
   pub TotalFileSize: SIZE_T,
   pub StoreCount: ULONG,
   pub RegionCount: ULONG,
   pub RegionSizeBytes: ULONG,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreIds: [ULONG; 16usize],
   pub PhysicalStoreBitmap: ULONG,
   pub Priority: ULONG,
   pub TemplateFilePath: [WCHAR; 512usize],
}
impl Default for _SMC_CACHE_STATS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_CACHE_STATS {
   #[inline]
   pub fn FileCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_FileCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FileCount_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FileCount_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PerformsFileIo(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PerformsFileIo(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PerformsFileIo_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PerformsFileIo_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 25u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            25u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            25u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FileCount: ULONG,
      PerformsFileIo: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 6u8, {
         let FileCount: u32 = unsafe { ::core::mem::transmute(FileCount) };
         FileCount as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let PerformsFileIo: u32 = unsafe { ::core::mem::transmute(PerformsFileIo) };
         PerformsFileIo as u64
      });
      __bindgen_bitfield_unit.set(7usize, 25u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_STATS = _SMC_CACHE_STATS;
pub type PSMC_CACHE_STATS = *mut _SMC_CACHE_STATS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_CACHE_STATS_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
   pub CacheStats: SMC_CACHE_STATS,
}
impl Default for _SMC_CACHE_STATS_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_CACHE_STATS_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoFilePath(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NoFilePath(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoFilePath_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NoFilePath_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            23u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            23u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      NoFilePath: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let NoFilePath: u32 = unsafe { ::core::mem::transmute(NoFilePath) };
         NoFilePath as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_CACHE_STATS_REQUEST = _SMC_CACHE_STATS_REQUEST;
pub type PSMC_CACHE_STATS_REQUEST = *mut _SMC_CACHE_STATS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_REGISTRATION_INFO {
   pub CachesUpdatedEvent: HANDLE,
}
impl Default for _SM_REGISTRATION_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SM_REGISTRATION_INFO = _SM_REGISTRATION_INFO;
pub type PSM_REGISTRATION_INFO = *mut _SM_REGISTRATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_REGISTRATION_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub RegInfo: SM_REGISTRATION_INFO,
}
impl Default for _SM_REGISTRATION_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_REGISTRATION_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_REGISTRATION_REQUEST = _SM_REGISTRATION_REQUEST;
pub type PSM_REGISTRATION_REQUEST = *mut _SM_REGISTRATION_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STORE_RESIZE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub StoreId: ULONG,
   pub NumberOfRegions: ULONG,
   pub RegionBitmap: PRTL_BITMAP,
}
impl Default for _SM_STORE_RESIZE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_STORE_RESIZE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AddRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AddRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddRegions_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AddRegions_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            23u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            23u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      AddRegions: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let AddRegions: u32 = unsafe { ::core::mem::transmute(AddRegions) };
         AddRegions as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_STORE_RESIZE_REQUEST = _SM_STORE_RESIZE_REQUEST;
pub type PSM_STORE_RESIZE_REQUEST = *mut _SM_STORE_RESIZE_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMC_STORE_RESIZE_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CacheId: ULONG,
   pub StoreId: ULONG,
   pub StoreManagerType: SM_STORE_MANAGER_TYPE,
   pub RegionCount: ULONG,
}
impl Default for _SMC_STORE_RESIZE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SMC_STORE_RESIZE_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AddRegions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AddRegions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddRegions_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AddRegions_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            23u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            23u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      AddRegions: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let AddRegions: u32 = unsafe { ::core::mem::transmute(AddRegions) };
         AddRegions as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SMC_STORE_RESIZE_REQUEST = _SMC_STORE_RESIZE_REQUEST;
pub type PSMC_STORE_RESIZE_REQUEST = *mut _SMC_STORE_RESIZE_REQUEST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SM_CONFIG_TYPE {
   SmConfigDirtyPageCompression = 0,
   SmConfigAsyncInswap = 1,
   SmConfigPrefetchSeekThreshold = 2,
   SmConfigTypeMax = 3,
}
pub use self::_SM_CONFIG_TYPE as SM_CONFIG_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_CONFIG_REQUEST {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub ConfigValue: ULONG,
}
impl _SM_CONFIG_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            16u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ConfigType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_ConfigType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ConfigType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ConfigType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      Spare: ULONG,
      ConfigType: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 16u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit.set(24usize, 8u8, {
         let ConfigType: u32 = unsafe { ::core::mem::transmute(ConfigType) };
         ConfigType as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_CONFIG_REQUEST = _SM_CONFIG_REQUEST;
pub type PSM_CONFIG_REQUEST = *mut _SM_CONFIG_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub ProcessHandle: HANDLE,
}
impl Default for _SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SetHighMemoryPriority(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SetHighMemoryPriority(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SetHighMemoryPriority_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SetHighMemoryPriority_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 23u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            23u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            23u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      SetHighMemoryPriority: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let SetHighMemoryPriority: u32 = unsafe { ::core::mem::transmute(SetHighMemoryPriority) };
         SetHighMemoryPriority as u64
      });
      __bindgen_bitfield_unit.set(9usize, 23u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_STORE_HIGH_MEM_PRIORITY_REQUEST = _SM_STORE_HIGH_MEM_PRIORITY_REQUEST;
pub type PSM_STORE_HIGH_MEM_PRIORITY_REQUEST = *mut _SM_STORE_HIGH_MEM_PRIORITY_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_SYSTEM_STORE_TRIM_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub PagesToTrim: SIZE_T,
}
impl _SM_SYSTEM_STORE_TRIM_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_SYSTEM_STORE_TRIM_REQUEST = _SM_SYSTEM_STORE_TRIM_REQUEST;
pub type PSM_SYSTEM_STORE_TRIM_REQUEST = *mut _SM_SYSTEM_STORE_TRIM_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SM_MEM_COMPRESSION_INFO_REQUEST {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CompressionPid: ULONG,
   pub WorkingSetSize: ULONG,
   pub TotalDataCompressed: SIZE_T,
   pub TotalCompressedSize: SIZE_T,
   pub TotalUniqueDataCompressed: SIZE_T,
}
impl _SM_MEM_COMPRESSION_INFO_REQUEST {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Version: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SM_MEM_COMPRESSION_INFO_REQUEST = _SM_MEM_COMPRESSION_INFO_REQUEST;
pub type PSM_MEM_COMPRESSION_INFO_REQUEST = *mut _SM_MEM_COMPRESSION_INFO_REQUEST;
#[repr(C)]
pub struct _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {
   pub KeyHandle: HANDLE,
   pub ValueNamePointer: PUNICODE_STRING,
   pub RequiredLengthPointer: PULONG,
   pub Buffer: PUCHAR,
   pub BufferLength: ULONG,
   pub Type: ULONG,
   pub AppendBuffer: PUCHAR,
   pub AppendBufferLength: ULONG,
   pub CreateIfDoesntExist: BOOLEAN,
   pub TruncateExistingValue: BOOLEAN,
}
impl Default for _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS = _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS;
pub type PSYSTEM_REGISTRY_APPEND_STRING_PARAMETERS = *mut _SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS;
#[repr(C)]
pub struct _SYSTEM_VHD_BOOT_INFORMATION {
   pub OsDiskIsVhd: BOOLEAN,
   pub OsVhdFilePathOffset: ULONG,
   pub OsVhdParentVolume: [WCHAR; 1usize],
}
impl Default for _SYSTEM_VHD_BOOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VHD_BOOT_INFORMATION = _SYSTEM_VHD_BOOT_INFORMATION;
pub type PSYSTEM_VHD_BOOT_INFORMATION = *mut _SYSTEM_VHD_BOOT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CPU_QUOTA_QUERY_ENTRY {
   pub SessionId: ULONG,
   pub Weight: ULONG,
}
pub type PS_CPU_QUOTA_QUERY_ENTRY = _PS_CPU_QUOTA_QUERY_ENTRY;
pub type PPS_CPU_QUOTA_QUERY_ENTRY = *mut _PS_CPU_QUOTA_QUERY_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CPU_QUOTA_QUERY_INFORMATION {
   pub SessionCount: ULONG,
   pub SessionInformation: [PS_CPU_QUOTA_QUERY_ENTRY; 1usize],
}
pub type PS_CPU_QUOTA_QUERY_INFORMATION = _PS_CPU_QUOTA_QUERY_INFORMATION;
pub type PPS_CPU_QUOTA_QUERY_INFORMATION = *mut _PS_CPU_QUOTA_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_ERROR_PORT_TIMEOUTS {
   pub StartTimeout: ULONG,
   pub CommTimeout: ULONG,
}
pub type SYSTEM_ERROR_PORT_TIMEOUTS = _SYSTEM_ERROR_PORT_TIMEOUTS;
pub type PSYSTEM_ERROR_PORT_TIMEOUTS = *mut _SYSTEM_ERROR_PORT_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_LOW_PRIORITY_IO_INFORMATION {
   pub LowPriReadOperations: ULONG,
   pub LowPriWriteOperations: ULONG,
   pub KernelBumpedToNormalOperations: ULONG,
   pub LowPriPagingReadOperations: ULONG,
   pub KernelPagingReadsBumpedToNormal: ULONG,
   pub LowPriPagingWriteOperations: ULONG,
   pub KernelPagingWritesBumpedToNormal: ULONG,
   pub BoostedIrpCount: ULONG,
   pub BoostedPagingIrpCount: ULONG,
   pub BlanketBoostCount: ULONG,
}
pub type SYSTEM_LOW_PRIORITY_IO_INFORMATION = _SYSTEM_LOW_PRIORITY_IO_INFORMATION;
pub type PSYSTEM_LOW_PRIORITY_IO_INFORMATION = *mut _SYSTEM_LOW_PRIORITY_IO_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BOOT_ENTROPY_SOURCE_RESULT_CODE {
   BootEntropySourceStructureUninitialized = 0,
   BootEntropySourceDisabledByPolicy = 1,
   BootEntropySourceNotPresent = 2,
   BootEntropySourceError = 3,
   BootEntropySourceSuccess = 4,
}
pub use self::_BOOT_ENTROPY_SOURCE_RESULT_CODE as BOOT_ENTROPY_SOURCE_RESULT_CODE;
impl _BOOT_ENTROPY_SOURCE_ID {
   pub const BootMaxEntropySources: _BOOT_ENTROPY_SOURCE_ID =
      _BOOT_ENTROPY_SOURCE_ID::BootEntropySourceTcbRdrand;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BOOT_ENTROPY_SOURCE_ID {
   BootEntropySourceNone = 0,
   BootEntropySourceSeedfile = 1,
   BootEntropySourceExternal = 2,
   BootEntropySourceTpm = 3,
   BootEntropySourceRdrand = 4,
   BootEntropySourceTime = 5,
   BootEntropySourceAcpiOem0 = 6,
   BootEntropySourceUefi = 7,
   BootEntropySourceCng = 8,
   BootEntropySourceTcbTpm = 9,
   BootEntropySourceTcbRdrand = 10,
}
pub use self::_BOOT_ENTROPY_SOURCE_ID as BOOT_ENTROPY_SOURCE_ID;
pub type PBOOT_ENTROPY_SOURCE_ID = *mut _BOOT_ENTROPY_SOURCE_ID;
#[repr(C)]
pub struct _TPM_BOOT_ENTROPY_NT_RESULT {
   pub Policy: ULONGLONG,
   pub ResultCode: BOOT_ENTROPY_SOURCE_RESULT_CODE,
   pub ResultStatus: NTSTATUS,
   pub Time: ULONGLONG,
   pub EntropyLength: ULONG,
   pub EntropyData: [UCHAR; 40usize],
}
impl Default for _TPM_BOOT_ENTROPY_NT_RESULT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TPM_BOOT_ENTROPY_NT_RESULT = _TPM_BOOT_ENTROPY_NT_RESULT;
pub type PTPM_BOOT_ENTROPY_NT_RESULT = *mut _TPM_BOOT_ENTROPY_NT_RESULT;
#[repr(C)]
pub struct _BOOT_ENTROPY_SOURCE_NT_RESULT {
   pub SourceId: BOOT_ENTROPY_SOURCE_ID,
   pub Policy: ULONG64,
   pub ResultCode: BOOT_ENTROPY_SOURCE_RESULT_CODE,
   pub ResultStatus: NTSTATUS,
   pub Time: ULONGLONG,
   pub EntropyLength: ULONG,
   pub EntropyData: [UCHAR; 64usize],
}
impl Default for _BOOT_ENTROPY_SOURCE_NT_RESULT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BOOT_ENTROPY_SOURCE_NT_RESULT = _BOOT_ENTROPY_SOURCE_NT_RESULT;
pub type PBOOT_ENTROPY_SOURCE_NT_RESULT = *mut _BOOT_ENTROPY_SOURCE_NT_RESULT;
#[repr(C)]
pub struct _BOOT_ENTROPY_NT_RESULT {
   pub maxEntropySources: ULONG,
   pub EntropySourceResult: [BOOT_ENTROPY_SOURCE_NT_RESULT; 10usize],
   pub SeedBytesForCng: [UCHAR; 48usize],
}
impl Default for _BOOT_ENTROPY_NT_RESULT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BOOT_ENTROPY_NT_RESULT = _BOOT_ENTROPY_NT_RESULT;
pub type PBOOT_ENTROPY_NT_RESULT = *mut _BOOT_ENTROPY_NT_RESULT;
#[repr(C)]
pub struct _SYSTEM_VERIFIER_COUNTERS_INFORMATION {
   pub Legacy: SYSTEM_VERIFIER_INFORMATION,
   pub RaiseIrqls: ULONG,
   pub AcquireSpinLocks: ULONG,
   pub SynchronizeExecutions: ULONG,
   pub AllocationsWithNoTag: ULONG,
   pub AllocationsFailed: ULONG,
   pub AllocationsFailedDeliberately: ULONG,
   pub LockedBytes: SIZE_T,
   pub PeakLockedBytes: SIZE_T,
   pub MappedLockedBytes: SIZE_T,
   pub PeakMappedLockedBytes: SIZE_T,
   pub MappedIoSpaceBytes: SIZE_T,
   pub PeakMappedIoSpaceBytes: SIZE_T,
   pub PagesForMdlBytes: SIZE_T,
   pub PeakPagesForMdlBytes: SIZE_T,
   pub ContiguousMemoryBytes: SIZE_T,
   pub PeakContiguousMemoryBytes: SIZE_T,
   pub ExecutePoolTypes: ULONG,
   pub ExecutePageProtections: ULONG,
   pub ExecutePageMappings: ULONG,
   pub ExecuteWriteSections: ULONG,
   pub SectionAlignmentFailures: ULONG,
   pub UnsupportedRelocs: ULONG,
   pub IATInExecutableSection: ULONG,
}
impl Default for _SYSTEM_VERIFIER_COUNTERS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VERIFIER_COUNTERS_INFORMATION = _SYSTEM_VERIFIER_COUNTERS_INFORMATION;
pub type PSYSTEM_VERIFIER_COUNTERS_INFORMATION = *mut _SYSTEM_VERIFIER_COUNTERS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_ACPI_AUDIT_INFORMATION {
   pub RsdpCount: ULONG,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _SYSTEM_ACPI_AUDIT_INFORMATION {
   #[inline]
   pub fn SameRsdt(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SameRsdt(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SameRsdt_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SameRsdt_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SlicPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SlicPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SlicPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SlicPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SlicDifferent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SlicDifferent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SlicDifferent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SlicDifferent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SameRsdt: ULONG,
      SlicPresent: ULONG,
      SlicDifferent: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SameRsdt: u32 = unsafe { ::core::mem::transmute(SameRsdt) };
         SameRsdt as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let SlicPresent: u32 = unsafe { ::core::mem::transmute(SlicPresent) };
         SlicPresent as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let SlicDifferent: u32 = unsafe { ::core::mem::transmute(SlicDifferent) };
         SlicDifferent as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SYSTEM_ACPI_AUDIT_INFORMATION = _SYSTEM_ACPI_AUDIT_INFORMATION;
pub type PSYSTEM_ACPI_AUDIT_INFORMATION = *mut _SYSTEM_ACPI_AUDIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BASIC_PERFORMANCE_INFORMATION {
   pub AvailablePages: SIZE_T,
   pub CommittedPages: SIZE_T,
   pub CommitLimit: SIZE_T,
   pub PeakCommitment: SIZE_T,
}
pub type SYSTEM_BASIC_PERFORMANCE_INFORMATION = _SYSTEM_BASIC_PERFORMANCE_INFORMATION;
pub type PSYSTEM_BASIC_PERFORMANCE_INFORMATION = *mut _SYSTEM_BASIC_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUERY_PERFORMANCE_COUNTER_FLAGS {
   pub __bindgen_anon_1: _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1 {
   pub __bindgen_anon_1: _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1__bindgen_ty_1,
   pub ul: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn KernelTransition(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KernelTransition(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KernelTransition_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KernelTransition_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      KernelTransition: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let KernelTransition: u32 = unsafe { ::core::mem::transmute(KernelTransition) };
         KernelTransition as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _QUERY_PERFORMANCE_COUNTER_FLAGS__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _QUERY_PERFORMANCE_COUNTER_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type QUERY_PERFORMANCE_COUNTER_FLAGS = _QUERY_PERFORMANCE_COUNTER_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION {
   pub Version: ULONG,
   pub Flags: QUERY_PERFORMANCE_COUNTER_FLAGS,
   pub ValidFlags: QUERY_PERFORMANCE_COUNTER_FLAGS,
}
impl Default for _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION =
   _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION;
pub type PSYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION =
   *mut _SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_PIXEL_FORMAT {
   SystemPixelFormatUnknown = 0,
   SystemPixelFormatR8G8B8 = 1,
   SystemPixelFormatR8G8B8X8 = 2,
   SystemPixelFormatB8G8R8 = 3,
   SystemPixelFormatB8G8R8X8 = 4,
}
pub use self::_SYSTEM_PIXEL_FORMAT as SYSTEM_PIXEL_FORMAT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BOOT_GRAPHICS_INFORMATION {
   pub FrameBuffer: LARGE_INTEGER,
   pub Width: ULONG,
   pub Height: ULONG,
   pub PixelStride: ULONG,
   pub Flags: ULONG,
   pub Format: SYSTEM_PIXEL_FORMAT,
   pub DisplayRotation: ULONG,
}
impl Default for _SYSTEM_BOOT_GRAPHICS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BOOT_GRAPHICS_INFORMATION = _SYSTEM_BOOT_GRAPHICS_INFORMATION;
pub type PSYSTEM_BOOT_GRAPHICS_INFORMATION = *mut _SYSTEM_BOOT_GRAPHICS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_SCRUB_INFORMATION {
   pub Handle: HANDLE,
   pub PagesScrubbed: SIZE_T,
}
impl Default for _MEMORY_SCRUB_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_SCRUB_INFORMATION = _MEMORY_SCRUB_INFORMATION;
pub type PMEMORY_SCRUB_INFORMATION = *mut _MEMORY_SCRUB_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BAD_PAGE_INFORMATION {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl Default for _SYSTEM_BAD_PAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SYSTEM_BAD_PAGE_INFORMATION {
   #[inline]
   pub fn PhysicalPageNumber(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 52u8) as u64) }
   }
   #[inline]
   pub fn set_PhysicalPageNumber(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 52u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PhysicalPageNumber_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            52u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_PhysicalPageNumber_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            52u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 10u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(52usize, 10u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            52usize,
            10u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            52usize,
            10u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Pending(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Pending(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(62usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Pending_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            62usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Pending_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            62usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Poisoned(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Poisoned(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(63usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Poisoned_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            63usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Poisoned_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            63usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PhysicalPageNumber: ULONG_PTR,
      Reserved: ULONG_PTR,
      Pending: ULONG_PTR,
      Poisoned: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 52u8, {
         let PhysicalPageNumber: u64 = unsafe { ::core::mem::transmute(PhysicalPageNumber) };
         PhysicalPageNumber as u64
      });
      __bindgen_bitfield_unit.set(52usize, 10u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(62usize, 1u8, {
         let Pending: u64 = unsafe { ::core::mem::transmute(Pending) };
         Pending as u64
      });
      __bindgen_bitfield_unit.set(63usize, 1u8, {
         let Poisoned: u64 = unsafe { ::core::mem::transmute(Poisoned) };
         Poisoned as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SYSTEM_BAD_PAGE_INFORMATION = _SYSTEM_BAD_PAGE_INFORMATION;
pub type PSYSTEM_BAD_PAGE_INFORMATION = *mut _SYSTEM_BAD_PAGE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEBS_DS_SAVE_AREA32 {
   pub BtsBufferBase: ULONG,
   pub BtsIndex: ULONG,
   pub BtsAbsoluteMaximum: ULONG,
   pub BtsInterruptThreshold: ULONG,
   pub PebsBufferBase: ULONG,
   pub PebsIndex: ULONG,
   pub PebsAbsoluteMaximum: ULONG,
   pub PebsInterruptThreshold: ULONG,
   pub PebsGpCounterReset: [ULONG; 8usize],
   pub PebsFixedCounterReset: [ULONG; 4usize],
}
pub type PEBS_DS_SAVE_AREA32 = _PEBS_DS_SAVE_AREA32;
pub type PPEBS_DS_SAVE_AREA32 = *mut _PEBS_DS_SAVE_AREA32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEBS_DS_SAVE_AREA64 {
   pub BtsBufferBase: ULONGLONG,
   pub BtsIndex: ULONGLONG,
   pub BtsAbsoluteMaximum: ULONGLONG,
   pub BtsInterruptThreshold: ULONGLONG,
   pub PebsBufferBase: ULONGLONG,
   pub PebsIndex: ULONGLONG,
   pub PebsAbsoluteMaximum: ULONGLONG,
   pub PebsInterruptThreshold: ULONGLONG,
   pub PebsGpCounterReset: [ULONGLONG; 8usize],
   pub PebsFixedCounterReset: [ULONGLONG; 4usize],
}
pub type PEBS_DS_SAVE_AREA64 = _PEBS_DS_SAVE_AREA64;
pub type PPEBS_DS_SAVE_AREA64 = *mut _PEBS_DS_SAVE_AREA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEBS_DS_SAVE_AREA {
   pub As32Bit: PEBS_DS_SAVE_AREA32,
   pub As64Bit: PEBS_DS_SAVE_AREA64,
}
impl Default for _PEBS_DS_SAVE_AREA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEBS_DS_SAVE_AREA = _PEBS_DS_SAVE_AREA;
pub type PPEBS_DS_SAVE_AREA = *mut _PEBS_DS_SAVE_AREA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESSOR_PROFILE_CONTROL_AREA {
   pub PebsDsSaveArea: PEBS_DS_SAVE_AREA,
}
impl Default for _PROCESSOR_PROFILE_CONTROL_AREA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESSOR_PROFILE_CONTROL_AREA = _PROCESSOR_PROFILE_CONTROL_AREA;
pub type PPROCESSOR_PROFILE_CONTROL_AREA = *mut _PROCESSOR_PROFILE_CONTROL_AREA;
#[repr(C)]
pub struct _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA {
   pub ProcessorProfileControlArea: PROCESSOR_PROFILE_CONTROL_AREA,
   pub Allocate: BOOLEAN,
}
impl Default for _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA = _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA;
pub type PSYSTEM_PROCESSOR_PROFILE_CONTROL_AREA = *mut _SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_COMBINE_INFORMATION {
   pub Handle: HANDLE,
   pub PagesCombined: SIZE_T,
}
impl Default for _MEMORY_COMBINE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_COMBINE_INFORMATION = _MEMORY_COMBINE_INFORMATION;
pub type PMEMORY_COMBINE_INFORMATION = *mut _MEMORY_COMBINE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_COMBINE_INFORMATION_EX {
   pub Handle: HANDLE,
   pub PagesCombined: SIZE_T,
   pub Flags: ULONG,
}
impl Default for _MEMORY_COMBINE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_COMBINE_INFORMATION_EX = _MEMORY_COMBINE_INFORMATION_EX;
pub type PMEMORY_COMBINE_INFORMATION_EX = *mut _MEMORY_COMBINE_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_COMBINE_INFORMATION_EX2 {
   pub Handle: HANDLE,
   pub PagesCombined: SIZE_T,
   pub Flags: ULONG,
   pub ProcessHandle: HANDLE,
}
impl Default for _MEMORY_COMBINE_INFORMATION_EX2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_COMBINE_INFORMATION_EX2 = _MEMORY_COMBINE_INFORMATION_EX2;
pub type PMEMORY_COMBINE_INFORMATION_EX2 = *mut _MEMORY_COMBINE_INFORMATION_EX2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ENTROPY_TIMING_INFORMATION {
   pub EntropyRoutine: ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: ULONG)>,
   pub InitializationRoutine:
      ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: ULONG, arg3: PVOID)>,
   pub InitializationContext: PVOID,
}
impl Default for _SYSTEM_ENTROPY_TIMING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ENTROPY_TIMING_INFORMATION = _SYSTEM_ENTROPY_TIMING_INFORMATION;
pub type PSYSTEM_ENTROPY_TIMING_INFORMATION = *mut _SYSTEM_ENTROPY_TIMING_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CONSOLE_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_CONSOLE_INFORMATION {
   #[inline]
   pub fn DriverLoaded(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DriverLoaded(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DriverLoaded_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DriverLoaded_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(DriverLoaded: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DriverLoaded: u32 = unsafe { ::core::mem::transmute(DriverLoaded) };
         DriverLoaded as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SYSTEM_CONSOLE_INFORMATION = _SYSTEM_CONSOLE_INFORMATION;
pub type PSYSTEM_CONSOLE_INFORMATION = *mut _SYSTEM_CONSOLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PLATFORM_BINARY_INFORMATION {
   pub PhysicalAddress: ULONG64,
   pub HandoffBuffer: PVOID,
   pub CommandLineBuffer: PVOID,
   pub HandoffBufferSize: ULONG,
   pub CommandLineBufferSize: ULONG,
}
impl Default for _SYSTEM_PLATFORM_BINARY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PLATFORM_BINARY_INFORMATION = _SYSTEM_PLATFORM_BINARY_INFORMATION;
pub type PSYSTEM_PLATFORM_BINARY_INFORMATION = *mut _SYSTEM_PLATFORM_BINARY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POLICY_INFORMATION {
   pub InputData: PVOID,
   pub OutputData: PVOID,
   pub InputDataSize: ULONG,
   pub OutputDataSize: ULONG,
   pub Version: ULONG,
}
impl Default for _SYSTEM_POLICY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POLICY_INFORMATION = _SYSTEM_POLICY_INFORMATION;
pub type PSYSTEM_POLICY_INFORMATION = *mut _SYSTEM_POLICY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION {
   pub NumberOfLogicalProcessors: ULONG,
   pub NumberOfCores: ULONG,
}
pub type SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION =
   _SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION;
pub type PSYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION =
   *mut _SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_DEVICE_DATA_INFORMATION {
   pub DeviceId: UNICODE_STRING,
   pub DataName: UNICODE_STRING,
   pub DataType: ULONG,
   pub DataBufferLength: ULONG,
   pub DataBuffer: PVOID,
}
impl Default for _SYSTEM_DEVICE_DATA_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_DEVICE_DATA_INFORMATION = _SYSTEM_DEVICE_DATA_INFORMATION;
pub type PSYSTEM_DEVICE_DATA_INFORMATION = *mut _SYSTEM_DEVICE_DATA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PHYSICAL_CHANNEL_RUN {
   pub NodeNumber: ULONG,
   pub ChannelNumber: ULONG,
   pub BasePage: ULONGLONG,
   pub PageCount: ULONGLONG,
   pub Flags: ULONG,
}
pub type PHYSICAL_CHANNEL_RUN = _PHYSICAL_CHANNEL_RUN;
pub type PPHYSICAL_CHANNEL_RUN = *mut _PHYSICAL_CHANNEL_RUN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_TOPOLOGY_INFORMATION {
   pub NumberOfRuns: ULONGLONG,
   pub NumberOfNodes: ULONG,
   pub NumberOfChannels: ULONG,
   pub Run: [PHYSICAL_CHANNEL_RUN; 1usize],
}
pub type SYSTEM_MEMORY_TOPOLOGY_INFORMATION = _SYSTEM_MEMORY_TOPOLOGY_INFORMATION;
pub type PSYSTEM_MEMORY_TOPOLOGY_INFORMATION = *mut _SYSTEM_MEMORY_TOPOLOGY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_CHANNEL_INFORMATION {
   pub ChannelNumber: ULONG,
   pub ChannelHeatIndex: ULONG,
   pub TotalPageCount: ULONGLONG,
   pub ZeroPageCount: ULONGLONG,
   pub FreePageCount: ULONGLONG,
   pub StandbyPageCount: ULONGLONG,
}
pub type SYSTEM_MEMORY_CHANNEL_INFORMATION = _SYSTEM_MEMORY_CHANNEL_INFORMATION;
pub type PSYSTEM_MEMORY_CHANNEL_INFORMATION = *mut _SYSTEM_MEMORY_CHANNEL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BOOT_LOGO_INFORMATION {
   pub Flags: ULONG,
   pub BitmapOffset: ULONG,
}
pub type SYSTEM_BOOT_LOGO_INFORMATION = _SYSTEM_BOOT_LOGO_INFORMATION;
pub type PSYSTEM_BOOT_LOGO_INFORMATION = *mut _SYSTEM_BOOT_LOGO_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX {
   pub IdleTime: LARGE_INTEGER,
   pub KernelTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
   pub DpcTime: LARGE_INTEGER,
   pub InterruptTime: LARGE_INTEGER,
   pub InterruptCount: ULONG,
   pub Spare0: ULONG,
   pub AvailableTime: LARGE_INTEGER,
   pub Spare1: LARGE_INTEGER,
   pub Spare2: LARGE_INTEGER,
}
impl Default for _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX = _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX =
   *mut _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX;
#[repr(C)]
pub struct _CRITICAL_PROCESS_EXCEPTION_DATA {
   pub ReportId: GUID,
   pub ModuleName: UNICODE_STRING,
   pub ModuleTimestamp: ULONG,
   pub ModuleSize: ULONG,
   pub Offset: ULONG_PTR,
}
impl Default for _CRITICAL_PROCESS_EXCEPTION_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CRITICAL_PROCESS_EXCEPTION_DATA = _CRITICAL_PROCESS_EXCEPTION_DATA;
pub type PCRITICAL_PROCESS_EXCEPTION_DATA = *mut _CRITICAL_PROCESS_EXCEPTION_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION {
   pub PolicyPublisher: GUID,
   pub PolicyVersion: ULONG,
   pub PolicyOptions: ULONG,
}
pub type SYSTEM_SECUREBOOT_POLICY_INFORMATION = _SYSTEM_SECUREBOOT_POLICY_INFORMATION;
pub type PSYSTEM_SECUREBOOT_POLICY_INFORMATION = *mut _SYSTEM_SECUREBOOT_POLICY_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_PAGEFILE_INFORMATION_EX {
   pub __bindgen_anon_1: _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1,
   pub MinimumSize: ULONG,
   pub MaximumSize: ULONG,
}
#[repr(C)]
pub union _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1 {
   pub Info: ::core::mem::ManuallyDrop<SYSTEM_PAGEFILE_INFORMATION>,
   pub __bindgen_anon_1:
      ::core::mem::ManuallyDrop<_SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   pub NextEntryOffset: ULONG,
   pub TotalSize: ULONG,
   pub TotalInUse: ULONG,
   pub PeakUsage: ULONG,
   pub PageFileName: UNICODE_STRING,
}
impl Default for _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_PAGEFILE_INFORMATION_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_PAGEFILE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PAGEFILE_INFORMATION_EX = _SYSTEM_PAGEFILE_INFORMATION_EX;
pub type PSYSTEM_PAGEFILE_INFORMATION_EX = *mut _SYSTEM_PAGEFILE_INFORMATION_EX;
#[repr(C)]
pub struct _SYSTEM_SECUREBOOT_INFORMATION {
   pub SecureBootEnabled: BOOLEAN,
   pub SecureBootCapable: BOOLEAN,
}
impl Default for _SYSTEM_SECUREBOOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SECUREBOOT_INFORMATION = _SYSTEM_SECUREBOOT_INFORMATION;
pub type PSYSTEM_SECUREBOOT_INFORMATION = *mut _SYSTEM_SECUREBOOT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_DISK_COUNTERS {
   pub BytesRead: ULONGLONG,
   pub BytesWritten: ULONGLONG,
   pub ReadOperationCount: ULONGLONG,
   pub WriteOperationCount: ULONGLONG,
   pub FlushOperationCount: ULONGLONG,
}
pub type PROCESS_DISK_COUNTERS = _PROCESS_DISK_COUNTERS;
pub type PPROCESS_DISK_COUNTERS = *mut _PROCESS_DISK_COUNTERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ENERGY_STATE_DURATION {
   pub Value: ULONGLONG,
   pub __bindgen_anon_1: _ENERGY_STATE_DURATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ENERGY_STATE_DURATION__bindgen_ty_1 {
   pub LastChangeTime: ULONG,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _ENERGY_STATE_DURATION__bindgen_ty_1 {
   #[inline]
   pub fn Duration(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Duration(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Duration_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Duration_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsInState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsInState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsInState_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            31usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsInState_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            31usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Duration: ULONG, IsInState: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 31u8, {
         let Duration: u32 = unsafe { ::core::mem::transmute(Duration) };
         Duration as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let IsInState: u32 = unsafe { ::core::mem::transmute(IsInState) };
         IsInState as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _ENERGY_STATE_DURATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ENERGY_STATE_DURATION = _ENERGY_STATE_DURATION;
pub type PENERGY_STATE_DURATION = *mut _ENERGY_STATE_DURATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES {
   pub Cycles: [[ULONGLONG; 2usize]; 4usize],
   pub DiskEnergy: ULONGLONG,
   pub NetworkTailEnergy: ULONGLONG,
   pub MBBTailEnergy: ULONGLONG,
   pub NetworkTxRxBytes: ULONGLONG,
   pub MBBTxRxBytes: ULONGLONG,
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES__bindgen_ty_1,
   pub CompositionRendered: ULONG,
   pub CompositionDirtyGenerated: ULONG,
   pub CompositionDirtyPropagated: ULONG,
   pub Reserved1: ULONG,
   pub AttributedCycles: [[ULONGLONG; 2usize]; 4usize],
   pub WorkOnBehalfCycles: [[ULONGLONG; 2usize]; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES__bindgen_ty_1 {
   pub Durations: [ENERGY_STATE_DURATION; 3usize],
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1 {
   pub ForegroundDuration: ENERGY_STATE_DURATION,
   pub DesktopVisibleDuration: ENERGY_STATE_DURATION,
   pub PSMForegroundDuration: ENERGY_STATE_DURATION,
}
impl Default for _PROCESS_ENERGY_VALUES__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_ENERGY_VALUES = _PROCESS_ENERGY_VALUES;
pub type PPROCESS_ENERGY_VALUES = *mut _PROCESS_ENERGY_VALUES;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TIMELINE_BITMAP {
   pub Value: ULONGLONG,
   pub __bindgen_anon_1: _TIMELINE_BITMAP__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TIMELINE_BITMAP__bindgen_ty_1 {
   pub EndTime: ULONG,
   pub Bitmap: ULONG,
}
impl Default for _TIMELINE_BITMAP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TIMELINE_BITMAP = _TIMELINE_BITMAP;
pub type PTIMELINE_BITMAP = *mut _TIMELINE_BITMAP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION {
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1,
   pub __bindgen_anon_2: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2,
   pub KeyboardInput: ULONG,
   pub MouseInput: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1 {
   pub Timelines: [TIMELINE_BITMAP; 14usize],
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
   pub CpuTimeline: TIMELINE_BITMAP,
   pub DiskTimeline: TIMELINE_BITMAP,
   pub NetworkTimeline: TIMELINE_BITMAP,
   pub MBBTimeline: TIMELINE_BITMAP,
   pub ForegroundTimeline: TIMELINE_BITMAP,
   pub DesktopVisibleTimeline: TIMELINE_BITMAP,
   pub CompositionRenderedTimeline: TIMELINE_BITMAP,
   pub CompositionDirtyGeneratedTimeline: TIMELINE_BITMAP,
   pub CompositionDirtyPropagatedTimeline: TIMELINE_BITMAP,
   pub InputTimeline: TIMELINE_BITMAP,
   pub AudioInTimeline: TIMELINE_BITMAP,
   pub AudioOutTimeline: TIMELINE_BITMAP,
   pub DisplayRequiredTimeline: TIMELINE_BITMAP,
   pub KeyboardInputTimeline: TIMELINE_BITMAP,
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2 {
   pub Durations: [ENERGY_STATE_DURATION; 5usize],
   pub __bindgen_anon_1: _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1 {
   pub InputDuration: ENERGY_STATE_DURATION,
   pub AudioInDuration: ENERGY_STATE_DURATION,
   pub AudioOutDuration: ENERGY_STATE_DURATION,
   pub DisplayRequiredDuration: ENERGY_STATE_DURATION,
   pub PSMBackgroundDuration: ENERGY_STATE_DURATION,
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_ENERGY_VALUES_EXTENSION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_ENERGY_VALUES_EXTENSION = _PROCESS_ENERGY_VALUES_EXTENSION;
pub type PPROCESS_ENERGY_VALUES_EXTENSION = *mut _PROCESS_ENERGY_VALUES_EXTENSION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_EXTENDED_ENERGY_VALUES {
   pub Base: PROCESS_ENERGY_VALUES,
   pub Extension: PROCESS_ENERGY_VALUES_EXTENSION,
}
impl Default for _PROCESS_EXTENDED_ENERGY_VALUES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_EXTENDED_ENERGY_VALUES = _PROCESS_EXTENDED_ENERGY_VALUES;
pub type PPROCESS_EXTENDED_ENERGY_VALUES = *mut _PROCESS_EXTENDED_ENERGY_VALUES;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_PROCESS_CLASSIFICATION {
   SystemProcessClassificationNormal = 0,
   SystemProcessClassificationSystem = 1,
   SystemProcessClassificationSecureSystem = 2,
   SystemProcessClassificationMemCompression = 3,
   SystemProcessClassificationRegistry = 4,
   SystemProcessClassificationMaximum = 5,
}
pub use self::_SYSTEM_PROCESS_CLASSIFICATION as SYSTEM_PROCESS_CLASSIFICATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESS_INFORMATION_EXTENSION {
   pub DiskCounters: PROCESS_DISK_COUNTERS,
   pub ContextSwitches: ULONGLONG,
   pub __bindgen_anon_1: _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1,
   pub UserSidOffset: ULONG,
   pub PackageFullNameOffset: ULONG,
   pub EnergyValues: PROCESS_ENERGY_VALUES,
   pub AppIdOffset: ULONG,
   pub SharedCommitCharge: SIZE_T,
   pub JobObjectId: ULONG,
   pub SpareUlong: ULONG,
   pub ProcessSequenceNumber: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn HasStrongId(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HasStrongId(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HasStrongId_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HasStrongId_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Classification(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Classification(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Classification_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Classification_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BackgroundActivityModerated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BackgroundActivityModerated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BackgroundActivityModerated_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BackgroundActivityModerated_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 26u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            26u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            26u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HasStrongId: ULONG,
      Classification: ULONG,
      BackgroundActivityModerated: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let HasStrongId: u32 = unsafe { ::core::mem::transmute(HasStrongId) };
         HasStrongId as u64
      });
      __bindgen_bitfield_unit.set(1usize, 4u8, {
         let Classification: u32 = unsafe { ::core::mem::transmute(Classification) };
         Classification as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let BackgroundActivityModerated: u32 =
            unsafe { ::core::mem::transmute(BackgroundActivityModerated) };
         BackgroundActivityModerated as u64
      });
      __bindgen_bitfield_unit.set(6usize, 26u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_PROCESS_INFORMATION_EXTENSION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_PROCESS_INFORMATION_EXTENSION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PROCESS_INFORMATION_EXTENSION = _SYSTEM_PROCESS_INFORMATION_EXTENSION;
pub type PSYSTEM_PROCESS_INFORMATION_EXTENSION = *mut _SYSTEM_PROCESS_INFORMATION_EXTENSION;
#[repr(C)]
pub struct _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION {
   pub EfiLauncherEnabled: BOOLEAN,
}
impl Default for _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION =
   _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION;
pub type PSYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION =
   *mut _SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
   pub DebuggerAllowed: BOOLEAN,
   pub DebuggerEnabled: BOOLEAN,
   pub DebuggerPresent: BOOLEAN,
}
impl Default for _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX = _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;
pub type PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX = *mut _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ELAM_CERTIFICATE_INFORMATION {
   pub ElamDriverFile: HANDLE,
}
impl Default for _SYSTEM_ELAM_CERTIFICATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ELAM_CERTIFICATE_INFORMATION = _SYSTEM_ELAM_CERTIFICATE_INFORMATION;
pub type PSYSTEM_ELAM_CERTIFICATE_INFORMATION = *mut _SYSTEM_ELAM_CERTIFICATE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
   pub Version: ULONG,
   pub AbnormalResetOccurred: ULONG,
   pub OfflineMemoryDumpCapable: ULONG,
   pub ResetDataAddress: LARGE_INTEGER,
   pub ResetDataSize: ULONG,
}
impl Default for _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 = _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2;
pub type POFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 = *mut _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 {
   pub Version: ULONG,
   pub AbnormalResetOccurred: ULONG,
   pub OfflineMemoryDumpCapable: ULONG,
}
pub type OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 = _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1;
pub type POFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 = *mut _OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_FEATURES_INFORMATION {
   pub ProcessorFeatureBits: ULONGLONG,
   pub Reserved: [ULONGLONG; 3usize],
}
pub type SYSTEM_PROCESSOR_FEATURES_INFORMATION = _SYSTEM_PROCESSOR_FEATURES_INFORMATION;
pub type PSYSTEM_PROCESSOR_FEATURES_INFORMATION = *mut _SYSTEM_PROCESSOR_FEATURES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_EDID_INFORMATION {
   pub Edid: [UCHAR; 128usize],
}
impl Default for _SYSTEM_EDID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_EDID_INFORMATION = _SYSTEM_EDID_INFORMATION;
pub type PSYSTEM_EDID_INFORMATION = *mut _SYSTEM_EDID_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_MANUFACTURING_INFORMATION {
   pub Options: ULONG,
   pub ProfileName: UNICODE_STRING,
}
impl Default for _SYSTEM_MANUFACTURING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_MANUFACTURING_INFORMATION = _SYSTEM_MANUFACTURING_INFORMATION;
pub type PSYSTEM_MANUFACTURING_INFORMATION = *mut _SYSTEM_MANUFACTURING_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION {
   pub Enabled: BOOLEAN,
}
impl Default for _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION = _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION;
pub type PSYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION =
   *mut _SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HV_DETAILS {
   pub Data: [ULONG; 4usize],
}
pub type HV_DETAILS = _HV_DETAILS;
pub type PHV_DETAILS = *mut _HV_DETAILS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
   pub HvVendorAndMaxFunction: HV_DETAILS,
   pub HypervisorInterface: HV_DETAILS,
   pub HypervisorVersion: HV_DETAILS,
   pub HvFeatures: HV_DETAILS,
   pub HwFeatures: HV_DETAILS,
   pub EnlightenmentInfo: HV_DETAILS,
   pub ImplementationLimits: HV_DETAILS,
}
pub type SYSTEM_HYPERVISOR_DETAIL_INFORMATION = _SYSTEM_HYPERVISOR_DETAIL_INFORMATION;
pub type PSYSTEM_HYPERVISOR_DETAIL_INFORMATION = *mut _SYSTEM_HYPERVISOR_DETAIL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION {
   pub Cycles: [[ULONGLONG; 2usize]; 4usize],
}
pub type SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION;
pub type PSYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION = *mut _SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_TPM_INFORMATION {
   pub Flags: ULONG,
}
pub type SYSTEM_TPM_INFORMATION = _SYSTEM_TPM_INFORMATION;
pub type PSYSTEM_TPM_INFORMATION = *mut _SYSTEM_TPM_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_VSM_PROTECTION_INFORMATION {
   pub DmaProtectionsAvailable: BOOLEAN,
   pub DmaProtectionsInUse: BOOLEAN,
   pub HardwareMbecAvailable: BOOLEAN,
   pub ApicVirtualizationAvailable: BOOLEAN,
}
impl Default for _SYSTEM_VSM_PROTECTION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_VSM_PROTECTION_INFORMATION = _SYSTEM_VSM_PROTECTION_INFORMATION;
pub type PSYSTEM_VSM_PROTECTION_INFORMATION = *mut _SYSTEM_VSM_PROTECTION_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_KERNEL_DEBUGGER_FLAGS {
   pub KernelDebuggerIgnoreUmExceptions: BOOLEAN,
}
impl Default for _SYSTEM_KERNEL_DEBUGGER_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_KERNEL_DEBUGGER_FLAGS = _SYSTEM_KERNEL_DEBUGGER_FLAGS;
pub type PSYSTEM_KERNEL_DEBUGGER_FLAGS = *mut _SYSTEM_KERNEL_DEBUGGER_FLAGS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION {
   pub Options: ULONG,
   pub HVCIOptions: ULONG,
   pub Version: ULONGLONG,
   pub PolicyGuid: GUID,
}
pub type SYSTEM_CODEINTEGRITYPOLICY_INFORMATION = _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION;
pub type PSYSTEM_CODEINTEGRITYPOLICY_INFORMATION = *mut _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
   pub Spare0: [BOOLEAN; 6usize],
   pub Spare1: ULONGLONG,
}
impl Default for _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
   #[inline]
   pub fn SecureKernelRunning(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SecureKernelRunning(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SecureKernelRunning_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SecureKernelRunning_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvciEnabled(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HvciEnabled(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvciEnabled_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_HvciEnabled_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvciStrictMode(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HvciStrictMode(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvciStrictMode_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_HvciStrictMode_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DebugEnabled(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DebugEnabled(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DebugEnabled_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_DebugEnabled_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FirmwarePageProtection(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_FirmwarePageProtection(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FirmwarePageProtection_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_FirmwarePageProtection_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EncryptionKeyAvailable(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EncryptionKeyAvailable(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EncryptionKeyAvailable_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_EncryptionKeyAvailable_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareFlags(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_SpareFlags(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareFlags_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            2u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SpareFlags_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TrustletRunning(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_TrustletRunning(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TrustletRunning_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_TrustletRunning_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvciDisableAllowed(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HvciDisableAllowed(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvciDisableAllowed_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_HvciDisableAllowed_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HardwareEnforcedVbs(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HardwareEnforcedVbs(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HardwareEnforcedVbs_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_HardwareEnforcedVbs_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NoSecrets(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_NoSecrets(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NoSecrets_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_NoSecrets_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EncryptionKeyPersistent(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EncryptionKeyPersistent(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EncryptionKeyPersistent_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_EncryptionKeyPersistent_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HardwareEnforcedHvpt(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HardwareEnforcedHvpt(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HardwareEnforcedHvpt_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_HardwareEnforcedHvpt_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HardwareHvptAvailable(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_HardwareHvptAvailable(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HardwareHvptAvailable_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_HardwareHvptAvailable_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareFlags2(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SpareFlags2(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareFlags2_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SpareFlags2_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SecureKernelRunning: BOOLEAN,
      HvciEnabled: BOOLEAN,
      HvciStrictMode: BOOLEAN,
      DebugEnabled: BOOLEAN,
      FirmwarePageProtection: BOOLEAN,
      EncryptionKeyAvailable: BOOLEAN,
      SpareFlags: BOOLEAN,
      TrustletRunning: BOOLEAN,
      HvciDisableAllowed: BOOLEAN,
      HardwareEnforcedVbs: BOOLEAN,
      NoSecrets: BOOLEAN,
      EncryptionKeyPersistent: BOOLEAN,
      HardwareEnforcedHvpt: BOOLEAN,
      HardwareHvptAvailable: BOOLEAN,
      SpareFlags2: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SecureKernelRunning: u8 = unsafe { ::core::mem::transmute(SecureKernelRunning) };
         SecureKernelRunning as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let HvciEnabled: u8 = unsafe { ::core::mem::transmute(HvciEnabled) };
         HvciEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let HvciStrictMode: u8 = unsafe { ::core::mem::transmute(HvciStrictMode) };
         HvciStrictMode as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DebugEnabled: u8 = unsafe { ::core::mem::transmute(DebugEnabled) };
         DebugEnabled as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let FirmwarePageProtection: u8 = unsafe { ::core::mem::transmute(FirmwarePageProtection) };
         FirmwarePageProtection as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let EncryptionKeyAvailable: u8 = unsafe { ::core::mem::transmute(EncryptionKeyAvailable) };
         EncryptionKeyAvailable as u64
      });
      __bindgen_bitfield_unit.set(6usize, 2u8, {
         let SpareFlags: u8 = unsafe { ::core::mem::transmute(SpareFlags) };
         SpareFlags as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let TrustletRunning: u8 = unsafe { ::core::mem::transmute(TrustletRunning) };
         TrustletRunning as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let HvciDisableAllowed: u8 = unsafe { ::core::mem::transmute(HvciDisableAllowed) };
         HvciDisableAllowed as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let HardwareEnforcedVbs: u8 = unsafe { ::core::mem::transmute(HardwareEnforcedVbs) };
         HardwareEnforcedVbs as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let NoSecrets: u8 = unsafe { ::core::mem::transmute(NoSecrets) };
         NoSecrets as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let EncryptionKeyPersistent: u8 =
            unsafe { ::core::mem::transmute(EncryptionKeyPersistent) };
         EncryptionKeyPersistent as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let HardwareEnforcedHvpt: u8 = unsafe { ::core::mem::transmute(HardwareEnforcedHvpt) };
         HardwareEnforcedHvpt as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let HardwareHvptAvailable: u8 = unsafe { ::core::mem::transmute(HardwareHvptAvailable) };
         HardwareHvptAvailable as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let SpareFlags2: u8 = unsafe { ::core::mem::transmute(SpareFlags2) };
         SpareFlags2 as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SYSTEM_ISOLATED_USER_MODE_INFORMATION = _SYSTEM_ISOLATED_USER_MODE_INFORMATION;
pub type PSYSTEM_ISOLATED_USER_MODE_INFORMATION = *mut _SYSTEM_ISOLATED_USER_MODE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SINGLE_MODULE_INFORMATION {
   pub TargetModuleAddress: PVOID,
   pub ExInfo: RTL_PROCESS_MODULE_INFORMATION_EX,
}
impl Default for _SYSTEM_SINGLE_MODULE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SINGLE_MODULE_INFORMATION = _SYSTEM_SINGLE_MODULE_INFORMATION;
pub type PSYSTEM_SINGLE_MODULE_INFORMATION = *mut _SYSTEM_SINGLE_MODULE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_CPU_SET_INFORMATION {
   pub Gsiv: ULONG,
   pub Group: USHORT,
   pub CpuSets: ULONGLONG,
}
pub type SYSTEM_INTERRUPT_CPU_SET_INFORMATION = _SYSTEM_INTERRUPT_CPU_SET_INFORMATION;
pub type PSYSTEM_INTERRUPT_CPU_SET_INFORMATION = *mut _SYSTEM_INTERRUPT_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
   pub PolicyInformation: SYSTEM_SECUREBOOT_POLICY_INFORMATION,
   pub PolicySize: ULONG,
   pub Policy: [UCHAR; 1usize],
}
pub type SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION = _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;
pub type PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION =
   *mut _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KAFFINITY_EX {
   pub Count: USHORT,
   pub Size: USHORT,
   pub Reserved: ULONG,
   pub __bindgen_anon_1: _KAFFINITY_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAFFINITY_EX__bindgen_ty_1 {
   pub Bitmap: [ULONG_PTR; 1usize],
   pub StaticBitmap: [ULONG_PTR; 32usize],
}
impl Default for _KAFFINITY_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _KAFFINITY_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KAFFINITY_EX = _KAFFINITY_EX;
pub type PKAFFINITY_EX = *mut _KAFFINITY_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_ROOT_SILO_INFORMATION {
   pub NumberOfSilos: ULONG,
   pub SiloIdList: [ULONG; 1usize],
}
pub type SYSTEM_ROOT_SILO_INFORMATION = _SYSTEM_ROOT_SILO_INFORMATION;
pub type PSYSTEM_ROOT_SILO_INFORMATION = *mut _SYSTEM_ROOT_SILO_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_TAG_INFORMATION {
   pub Tag: ULONGLONG,
   pub CpuSets: [ULONGLONG; 1usize],
}
pub type SYSTEM_CPU_SET_TAG_INFORMATION = _SYSTEM_CPU_SET_TAG_INFORMATION;
pub type PSYSTEM_CPU_SET_TAG_INFORMATION = *mut _SYSTEM_CPU_SET_TAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION {
   pub ExtentCount: ULONG,
   pub ValidStructureSize: ULONG,
   pub NextExtentIndex: ULONG,
   pub ExtentRestart: ULONG,
   pub CycleCount: ULONG,
   pub TimeoutCount: ULONG,
   pub CycleTime: ULONGLONG,
   pub CycleTimeMax: ULONGLONG,
   pub ExtentTime: ULONGLONG,
   pub ExtentTimeIndex: ULONG,
   pub ExtentTimeMaxIndex: ULONG,
   pub ExtentTimeMax: ULONGLONG,
   pub HyperFlushTimeMax: ULONGLONG,
   pub TranslateVaTimeMax: ULONGLONG,
   pub DebugExemptionCount: ULONGLONG,
   pub TbHitCount: ULONGLONG,
   pub TbMissCount: ULONGLONG,
   pub VinaPendingYield: ULONGLONG,
   pub HashCycles: ULONGLONG,
   pub HistogramOffset: ULONG,
   pub HistogramBuckets: ULONG,
   pub HistogramShift: ULONG,
   pub Reserved1: ULONG,
   pub PageNotPresentCount: ULONGLONG,
}
pub type SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION =
   _SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION;
pub type PSYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION =
   *mut _SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION {
   pub PlatformManifestSize: ULONG,
   pub PlatformManifest: [UCHAR; 1usize],
}
pub type SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION =
   _SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION;
pub type PSYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION =
   *mut _SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT {
   pub Gsiv: ULONG,
   pub ControllerInterrupt: UCHAR,
   pub EdgeInterrupt: UCHAR,
   pub IsPrimaryInterrupt: UCHAR,
   pub TargetAffinity: GROUP_AFFINITY,
}
pub type SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT = _SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT;
pub type PSYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT =
   *mut _SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT {
   pub AsULONG: ULONG,
   pub __bindgen_anon_1: _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT__bindgen_ty_1 {
   #[inline]
   pub fn Enabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Enabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Enabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Enabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Enabled: ULONG, Reserved: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Enabled: u32 = unsafe { ::core::mem::transmute(Enabled) };
         Enabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT =
   _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT;
pub type PSYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT =
   *mut _SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_USAGE_INFORMATION {
   pub TotalPhysicalBytes: ULONGLONG,
   pub AvailableBytes: ULONGLONG,
   pub ResidentAvailableBytes: LONGLONG,
   pub CommittedBytes: ULONGLONG,
   pub SharedCommittedBytes: ULONGLONG,
   pub CommitLimitBytes: ULONGLONG,
   pub PeakCommitmentBytes: ULONGLONG,
}
pub type SYSTEM_MEMORY_USAGE_INFORMATION = _SYSTEM_MEMORY_USAGE_INFORMATION;
pub type PSYSTEM_MEMORY_USAGE_INFORMATION = *mut _SYSTEM_MEMORY_USAGE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {
   pub ImageFile: HANDLE,
   pub Type: ULONG,
}
impl Default for _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION =
   _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION;
pub type PSYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION =
   *mut _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_PHYSICAL_MEMORY_INFORMATION {
   pub TotalPhysicalBytes: ULONGLONG,
   pub LowestPhysicalAddress: ULONGLONG,
   pub HighestPhysicalAddress: ULONGLONG,
}
pub type SYSTEM_PHYSICAL_MEMORY_INFORMATION = _SYSTEM_PHYSICAL_MEMORY_INFORMATION;
pub type PSYSTEM_PHYSICAL_MEMORY_INFORMATION = *mut _SYSTEM_PHYSICAL_MEMORY_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_ACTIVITY_MODERATION_STATE {
   SystemActivityModerationStateSystemManaged = 0,
   SystemActivityModerationStateUserManagedAllowThrottling = 1,
   SystemActivityModerationStateUserManagedDisableThrottling = 2,
   MaxSystemActivityModerationState = 3,
}
pub use self::_SYSTEM_ACTIVITY_MODERATION_STATE as SYSTEM_ACTIVITY_MODERATION_STATE;
#[repr(C)]
pub struct _SYSTEM_ACTIVITY_MODERATION_EXE_STATE {
   pub ExePathNt: UNICODE_STRING,
   pub ModerationState: SYSTEM_ACTIVITY_MODERATION_STATE,
}
impl Default for _SYSTEM_ACTIVITY_MODERATION_EXE_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ACTIVITY_MODERATION_EXE_STATE = _SYSTEM_ACTIVITY_MODERATION_EXE_STATE;
pub type PSYSTEM_ACTIVITY_MODERATION_EXE_STATE = *mut _SYSTEM_ACTIVITY_MODERATION_EXE_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_ACTIVITY_MODERATION_APP_TYPE {
   SystemActivityModerationAppTypeClassic = 0,
   SystemActivityModerationAppTypePackaged = 1,
   MaxSystemActivityModerationAppType = 2,
}
pub use self::_SYSTEM_ACTIVITY_MODERATION_APP_TYPE as SYSTEM_ACTIVITY_MODERATION_APP_TYPE;
#[repr(C)]
pub struct _SYSTEM_ACTIVITY_MODERATION_INFO {
   pub Identifier: UNICODE_STRING,
   pub ModerationState: SYSTEM_ACTIVITY_MODERATION_STATE,
   pub AppType: SYSTEM_ACTIVITY_MODERATION_APP_TYPE,
}
impl Default for _SYSTEM_ACTIVITY_MODERATION_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ACTIVITY_MODERATION_INFO = _SYSTEM_ACTIVITY_MODERATION_INFO;
pub type PSYSTEM_ACTIVITY_MODERATION_INFO = *mut _SYSTEM_ACTIVITY_MODERATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {
   pub UserKeyHandle: HANDLE,
}
impl Default for _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS = _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS;
pub type PSYSTEM_ACTIVITY_MODERATION_USER_SETTINGS = *mut _SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1,
   pub UnlockId: [UCHAR; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Locked(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Locked(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Locked_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Locked_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UnlockApplied(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UnlockApplied(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UnlockApplied_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_UnlockApplied_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UnlockIdValid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UnlockIdValid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UnlockIdValid_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_UnlockIdValid_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            29u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            29u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Locked: ULONG,
      UnlockApplied: ULONG,
      UnlockIdValid: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Locked: u32 = unsafe { ::core::mem::transmute(Locked) };
         Locked as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let UnlockApplied: u32 = unsafe { ::core::mem::transmute(UnlockApplied) };
         UnlockApplied as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let UnlockIdValid: u32 = unsafe { ::core::mem::transmute(UnlockIdValid) };
         UnlockIdValid as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION = _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION;
pub type PSYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION = *mut _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FLUSH_INFORMATION {
   pub SupportedFlushMethods: ULONG,
   pub ProcessorCacheFlushSize: ULONG,
   pub SystemFlushCapabilities: ULONGLONG,
   pub Reserved: [ULONGLONG; 2usize],
}
pub type SYSTEM_FLUSH_INFORMATION = _SYSTEM_FLUSH_INFORMATION;
pub type PSYSTEM_FLUSH_INFORMATION = *mut _SYSTEM_FLUSH_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_WRITE_CONSTRAINT_INFORMATION {
   pub WriteConstraintPolicy: ULONG,
   pub Reserved: ULONG,
}
pub type SYSTEM_WRITE_CONSTRAINT_INFORMATION = _SYSTEM_WRITE_CONSTRAINT_INFORMATION;
pub type PSYSTEM_WRITE_CONSTRAINT_INFORMATION = *mut _SYSTEM_WRITE_CONSTRAINT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1 {
   pub KvaShadowFlags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn KvaShadowEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KvaShadowUserGlobal(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowUserGlobal(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowUserGlobal_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowUserGlobal_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KvaShadowPcid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowPcid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowPcid_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowPcid_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KvaShadowInvpcid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowInvpcid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowInvpcid_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowInvpcid_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KvaShadowRequired(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowRequired(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowRequired_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowRequired_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KvaShadowRequiredAvailable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowRequiredAvailable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowRequiredAvailable_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowRequiredAvailable_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InvalidPteBit(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_InvalidPteBit(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InvalidPteBit_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InvalidPteBit_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn L1DataCacheFlushSupported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_L1DataCacheFlushSupported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn L1DataCacheFlushSupported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_L1DataCacheFlushSupported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn L1TerminalFaultMitigationPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_L1TerminalFaultMitigationPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn L1TerminalFaultMitigationPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_L1TerminalFaultMitigationPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 18u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            18u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            18u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      KvaShadowEnabled: ULONG,
      KvaShadowUserGlobal: ULONG,
      KvaShadowPcid: ULONG,
      KvaShadowInvpcid: ULONG,
      KvaShadowRequired: ULONG,
      KvaShadowRequiredAvailable: ULONG,
      InvalidPteBit: ULONG,
      L1DataCacheFlushSupported: ULONG,
      L1TerminalFaultMitigationPresent: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let KvaShadowEnabled: u32 = unsafe { ::core::mem::transmute(KvaShadowEnabled) };
         KvaShadowEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let KvaShadowUserGlobal: u32 = unsafe { ::core::mem::transmute(KvaShadowUserGlobal) };
         KvaShadowUserGlobal as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let KvaShadowPcid: u32 = unsafe { ::core::mem::transmute(KvaShadowPcid) };
         KvaShadowPcid as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let KvaShadowInvpcid: u32 = unsafe { ::core::mem::transmute(KvaShadowInvpcid) };
         KvaShadowInvpcid as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let KvaShadowRequired: u32 = unsafe { ::core::mem::transmute(KvaShadowRequired) };
         KvaShadowRequired as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let KvaShadowRequiredAvailable: u32 =
            unsafe { ::core::mem::transmute(KvaShadowRequiredAvailable) };
         KvaShadowRequiredAvailable as u64
      });
      __bindgen_bitfield_unit.set(6usize, 6u8, {
         let InvalidPteBit: u32 = unsafe { ::core::mem::transmute(InvalidPteBit) };
         InvalidPteBit as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let L1DataCacheFlushSupported: u32 =
            unsafe { ::core::mem::transmute(L1DataCacheFlushSupported) };
         L1DataCacheFlushSupported as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let L1TerminalFaultMitigationPresent: u32 =
            unsafe { ::core::mem::transmute(L1TerminalFaultMitigationPresent) };
         L1TerminalFaultMitigationPresent as u64
      });
      __bindgen_bitfield_unit.set(14usize, 18u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_KERNEL_VA_SHADOW_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_KERNEL_VA_SHADOW_INFORMATION = _SYSTEM_KERNEL_VA_SHADOW_INFORMATION;
pub type PSYSTEM_KERNEL_VA_SHADOW_INFORMATION = *mut _SYSTEM_KERNEL_VA_SHADOW_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION {
   pub FileHandle: HANDLE,
   pub ImageSize: ULONG,
   pub Image: PVOID,
}
impl Default for _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION =
   _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION;
pub type PSYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION =
   *mut _SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_USER_SHARED_DATA {
   pub TimeUpdateLock: ULONGLONG,
   pub QpcMultiplier: ULONGLONG,
   pub QpcBias: ULONGLONG,
}
pub type SYSTEM_HYPERVISOR_USER_SHARED_DATA = _SYSTEM_HYPERVISOR_USER_SHARED_DATA;
pub type PSYSTEM_HYPERVISOR_USER_SHARED_DATA = *mut _SYSTEM_HYPERVISOR_USER_SHARED_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {
   pub HypervisorSharedUserVa: PSYSTEM_HYPERVISOR_USER_SHARED_DATA,
}
impl Default for _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION = _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION;
pub type PSYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION =
   *mut _SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_FIRMWARE_PARTITION_INFORMATION {
   pub FirmwarePartition: UNICODE_STRING,
}
impl Default for _SYSTEM_FIRMWARE_PARTITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FIRMWARE_PARTITION_INFORMATION = _SYSTEM_FIRMWARE_PARTITION_INFORMATION;
pub type PSYSTEM_FIRMWARE_PARTITION_INFORMATION = *mut _SYSTEM_FIRMWARE_PARTITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SPECULATION_CONTROL_INFORMATION {
   pub SpeculationControlFlags: _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1,
   pub SpeculationControlFlags2: _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn BpbEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BpbEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BpbEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BpbDisabledSystemPolicy(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbDisabledSystemPolicy(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BpbDisabledSystemPolicy_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BpbDisabledSystemPolicy_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BpbDisabledNoHardwareSupport(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbDisabledNoHardwareSupport(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BpbDisabledNoHardwareSupport_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BpbDisabledNoHardwareSupport_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpecCtrlEnumerated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpecCtrlEnumerated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpecCtrlEnumerated_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpecCtrlEnumerated_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpecCmdEnumerated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpecCmdEnumerated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpecCmdEnumerated_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpecCmdEnumerated_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IbrsPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IbrsPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IbrsPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IbrsPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn StibpPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_StibpPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StibpPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StibpPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SmepPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SmepPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SmepPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SmepPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisableAvailable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisableAvailable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpeculativeStoreBypassDisableAvailable_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpeculativeStoreBypassDisableAvailable_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisableSupported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisableSupported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpeculativeStoreBypassDisableSupported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpeculativeStoreBypassDisableSupported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisabledSystemWide(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisabledSystemWide(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpeculativeStoreBypassDisabledSystemWide_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpeculativeStoreBypassDisabledSystemWide_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisabledKernel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisabledKernel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpeculativeStoreBypassDisabledKernel_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpeculativeStoreBypassDisabledKernel_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpeculativeStoreBypassDisableRequired(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpeculativeStoreBypassDisableRequired(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpeculativeStoreBypassDisableRequired_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpeculativeStoreBypassDisableRequired_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BpbDisabledKernelToUser(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbDisabledKernelToUser(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BpbDisabledKernelToUser_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BpbDisabledKernelToUser_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpecCtrlRetpolineEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpecCtrlRetpolineEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpecCtrlRetpolineEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpecCtrlRetpolineEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpecCtrlImportOptimizationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SpecCtrlImportOptimizationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpecCtrlImportOptimizationEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpecCtrlImportOptimizationEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnhancedIbrs(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnhancedIbrs(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnhancedIbrs_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnhancedIbrs_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvL1tfStatusAvailable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfStatusAvailable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvL1tfStatusAvailable_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            17usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HvL1tfStatusAvailable_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            17usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvL1tfProcessorNotAffected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfProcessorNotAffected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvL1tfProcessorNotAffected_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            18usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HvL1tfProcessorNotAffected_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            18usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvL1tfMigitationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfMigitationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(19usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvL1tfMigitationEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            19usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HvL1tfMigitationEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            19usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvL1tfMigitationNotEnabled_Hardware(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfMigitationNotEnabled_Hardware(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvL1tfMigitationNotEnabled_Hardware_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HvL1tfMigitationNotEnabled_Hardware_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvL1tfMigitationNotEnabled_LoadOption(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfMigitationNotEnabled_LoadOption(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvL1tfMigitationNotEnabled_LoadOption_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            21usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HvL1tfMigitationNotEnabled_LoadOption_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            21usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HvL1tfMigitationNotEnabled_CoreScheduler(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HvL1tfMigitationNotEnabled_CoreScheduler(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HvL1tfMigitationNotEnabled_CoreScheduler_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            22usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HvL1tfMigitationNotEnabled_CoreScheduler_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            22usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnhancedIbrsReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnhancedIbrsReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnhancedIbrsReported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            23usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnhancedIbrsReported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            23usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MdsHardwareProtected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MdsHardwareProtected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MdsHardwareProtected_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MdsHardwareProtected_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MbClearEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MbClearEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(25usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MbClearEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            25usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MbClearEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            25usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MbClearReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MbClearReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(26usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MbClearReported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            26usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MbClearReported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            26usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedTaa(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedTaa(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(27usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedTaa_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            27usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedTaa_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            27usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            31usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            31usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      BpbEnabled: ULONG,
      BpbDisabledSystemPolicy: ULONG,
      BpbDisabledNoHardwareSupport: ULONG,
      SpecCtrlEnumerated: ULONG,
      SpecCmdEnumerated: ULONG,
      IbrsPresent: ULONG,
      StibpPresent: ULONG,
      SmepPresent: ULONG,
      SpeculativeStoreBypassDisableAvailable: ULONG,
      SpeculativeStoreBypassDisableSupported: ULONG,
      SpeculativeStoreBypassDisabledSystemWide: ULONG,
      SpeculativeStoreBypassDisabledKernel: ULONG,
      SpeculativeStoreBypassDisableRequired: ULONG,
      BpbDisabledKernelToUser: ULONG,
      SpecCtrlRetpolineEnabled: ULONG,
      SpecCtrlImportOptimizationEnabled: ULONG,
      EnhancedIbrs: ULONG,
      HvL1tfStatusAvailable: ULONG,
      HvL1tfProcessorNotAffected: ULONG,
      HvL1tfMigitationEnabled: ULONG,
      HvL1tfMigitationNotEnabled_Hardware: ULONG,
      HvL1tfMigitationNotEnabled_LoadOption: ULONG,
      HvL1tfMigitationNotEnabled_CoreScheduler: ULONG,
      EnhancedIbrsReported: ULONG,
      MdsHardwareProtected: ULONG,
      MbClearEnabled: ULONG,
      MbClearReported: ULONG,
      ReservedTaa: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let BpbEnabled: u32 = unsafe { ::core::mem::transmute(BpbEnabled) };
         BpbEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let BpbDisabledSystemPolicy: u32 =
            unsafe { ::core::mem::transmute(BpbDisabledSystemPolicy) };
         BpbDisabledSystemPolicy as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let BpbDisabledNoHardwareSupport: u32 =
            unsafe { ::core::mem::transmute(BpbDisabledNoHardwareSupport) };
         BpbDisabledNoHardwareSupport as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SpecCtrlEnumerated: u32 = unsafe { ::core::mem::transmute(SpecCtrlEnumerated) };
         SpecCtrlEnumerated as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let SpecCmdEnumerated: u32 = unsafe { ::core::mem::transmute(SpecCmdEnumerated) };
         SpecCmdEnumerated as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let IbrsPresent: u32 = unsafe { ::core::mem::transmute(IbrsPresent) };
         IbrsPresent as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let StibpPresent: u32 = unsafe { ::core::mem::transmute(StibpPresent) };
         StibpPresent as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let SmepPresent: u32 = unsafe { ::core::mem::transmute(SmepPresent) };
         SmepPresent as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let SpeculativeStoreBypassDisableAvailable: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisableAvailable) };
         SpeculativeStoreBypassDisableAvailable as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let SpeculativeStoreBypassDisableSupported: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisableSupported) };
         SpeculativeStoreBypassDisableSupported as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let SpeculativeStoreBypassDisabledSystemWide: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisabledSystemWide) };
         SpeculativeStoreBypassDisabledSystemWide as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let SpeculativeStoreBypassDisabledKernel: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisabledKernel) };
         SpeculativeStoreBypassDisabledKernel as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let SpeculativeStoreBypassDisableRequired: u32 =
            unsafe { ::core::mem::transmute(SpeculativeStoreBypassDisableRequired) };
         SpeculativeStoreBypassDisableRequired as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let BpbDisabledKernelToUser: u32 =
            unsafe { ::core::mem::transmute(BpbDisabledKernelToUser) };
         BpbDisabledKernelToUser as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let SpecCtrlRetpolineEnabled: u32 =
            unsafe { ::core::mem::transmute(SpecCtrlRetpolineEnabled) };
         SpecCtrlRetpolineEnabled as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let SpecCtrlImportOptimizationEnabled: u32 =
            unsafe { ::core::mem::transmute(SpecCtrlImportOptimizationEnabled) };
         SpecCtrlImportOptimizationEnabled as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let EnhancedIbrs: u32 = unsafe { ::core::mem::transmute(EnhancedIbrs) };
         EnhancedIbrs as u64
      });
      __bindgen_bitfield_unit.set(17usize, 1u8, {
         let HvL1tfStatusAvailable: u32 = unsafe { ::core::mem::transmute(HvL1tfStatusAvailable) };
         HvL1tfStatusAvailable as u64
      });
      __bindgen_bitfield_unit.set(18usize, 1u8, {
         let HvL1tfProcessorNotAffected: u32 =
            unsafe { ::core::mem::transmute(HvL1tfProcessorNotAffected) };
         HvL1tfProcessorNotAffected as u64
      });
      __bindgen_bitfield_unit.set(19usize, 1u8, {
         let HvL1tfMigitationEnabled: u32 =
            unsafe { ::core::mem::transmute(HvL1tfMigitationEnabled) };
         HvL1tfMigitationEnabled as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let HvL1tfMigitationNotEnabled_Hardware: u32 =
            unsafe { ::core::mem::transmute(HvL1tfMigitationNotEnabled_Hardware) };
         HvL1tfMigitationNotEnabled_Hardware as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let HvL1tfMigitationNotEnabled_LoadOption: u32 =
            unsafe { ::core::mem::transmute(HvL1tfMigitationNotEnabled_LoadOption) };
         HvL1tfMigitationNotEnabled_LoadOption as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let HvL1tfMigitationNotEnabled_CoreScheduler: u32 =
            unsafe { ::core::mem::transmute(HvL1tfMigitationNotEnabled_CoreScheduler) };
         HvL1tfMigitationNotEnabled_CoreScheduler as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let EnhancedIbrsReported: u32 = unsafe { ::core::mem::transmute(EnhancedIbrsReported) };
         EnhancedIbrsReported as u64
      });
      __bindgen_bitfield_unit.set(24usize, 1u8, {
         let MdsHardwareProtected: u32 = unsafe { ::core::mem::transmute(MdsHardwareProtected) };
         MdsHardwareProtected as u64
      });
      __bindgen_bitfield_unit.set(25usize, 1u8, {
         let MbClearEnabled: u32 = unsafe { ::core::mem::transmute(MbClearEnabled) };
         MbClearEnabled as u64
      });
      __bindgen_bitfield_unit.set(26usize, 1u8, {
         let MbClearReported: u32 = unsafe { ::core::mem::transmute(MbClearReported) };
         MbClearReported as u64
      });
      __bindgen_bitfield_unit.set(27usize, 4u8, {
         let ReservedTaa: u32 = unsafe { ::core::mem::transmute(ReservedTaa) };
         ReservedTaa as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn SbdrSsdpHardwareProtected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SbdrSsdpHardwareProtected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SbdrSsdpHardwareProtected_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SbdrSsdpHardwareProtected_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FbsdpHardwareProtected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FbsdpHardwareProtected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FbsdpHardwareProtected_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FbsdpHardwareProtected_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PsdpHardwareProtected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PsdpHardwareProtected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PsdpHardwareProtected_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PsdpHardwareProtected_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FbClearEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FbClearEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FbClearEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FbClearEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FbClearReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FbClearReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FbClearReported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FbClearReported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BhbEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BhbEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BhbEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BhbEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BhbDisabledSystemPolicy(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BhbDisabledSystemPolicy(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BhbDisabledSystemPolicy_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BhbDisabledSystemPolicy_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BhbDisabledNoHardwareSupport(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BhbDisabledNoHardwareSupport(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BhbDisabledNoHardwareSupport_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BhbDisabledNoHardwareSupport_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BranchConfusionStatus(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_BranchConfusionStatus(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BranchConfusionStatus_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BranchConfusionStatus_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BranchConfusionReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BranchConfusionReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BranchConfusionReported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BranchConfusionReported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RdclHardwareProtectedReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RdclHardwareProtectedReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RdclHardwareProtectedReported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RdclHardwareProtectedReported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RdclHardwareProtected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RdclHardwareProtected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RdclHardwareProtected_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RdclHardwareProtected_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved3(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved3(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved4(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved4(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved4_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            17usize,
            3u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved4_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            17usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DivideByZeroReported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DivideByZeroReported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DivideByZeroReported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DivideByZeroReported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DivideByZeroStatus(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DivideByZeroStatus(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DivideByZeroStatus_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            21usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DivideByZeroStatus_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            21usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved5(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved5(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved5_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            22usize,
            3u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved5_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            22usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(25usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            25usize,
            7u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            25usize,
            7u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SbdrSsdpHardwareProtected: ULONG,
      FbsdpHardwareProtected: ULONG,
      PsdpHardwareProtected: ULONG,
      FbClearEnabled: ULONG,
      FbClearReported: ULONG,
      BhbEnabled: ULONG,
      BhbDisabledSystemPolicy: ULONG,
      BhbDisabledNoHardwareSupport: ULONG,
      BranchConfusionStatus: ULONG,
      BranchConfusionReported: ULONG,
      RdclHardwareProtectedReported: ULONG,
      RdclHardwareProtected: ULONG,
      Reserved3: ULONG,
      Reserved4: ULONG,
      DivideByZeroReported: ULONG,
      DivideByZeroStatus: ULONG,
      Reserved5: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SbdrSsdpHardwareProtected: u32 =
            unsafe { ::core::mem::transmute(SbdrSsdpHardwareProtected) };
         SbdrSsdpHardwareProtected as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let FbsdpHardwareProtected: u32 =
            unsafe { ::core::mem::transmute(FbsdpHardwareProtected) };
         FbsdpHardwareProtected as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let PsdpHardwareProtected: u32 = unsafe { ::core::mem::transmute(PsdpHardwareProtected) };
         PsdpHardwareProtected as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let FbClearEnabled: u32 = unsafe { ::core::mem::transmute(FbClearEnabled) };
         FbClearEnabled as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let FbClearReported: u32 = unsafe { ::core::mem::transmute(FbClearReported) };
         FbClearReported as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let BhbEnabled: u32 = unsafe { ::core::mem::transmute(BhbEnabled) };
         BhbEnabled as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let BhbDisabledSystemPolicy: u32 =
            unsafe { ::core::mem::transmute(BhbDisabledSystemPolicy) };
         BhbDisabledSystemPolicy as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let BhbDisabledNoHardwareSupport: u32 =
            unsafe { ::core::mem::transmute(BhbDisabledNoHardwareSupport) };
         BhbDisabledNoHardwareSupport as u64
      });
      __bindgen_bitfield_unit.set(8usize, 2u8, {
         let BranchConfusionStatus: u32 = unsafe { ::core::mem::transmute(BranchConfusionStatus) };
         BranchConfusionStatus as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let BranchConfusionReported: u32 =
            unsafe { ::core::mem::transmute(BranchConfusionReported) };
         BranchConfusionReported as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let RdclHardwareProtectedReported: u32 =
            unsafe { ::core::mem::transmute(RdclHardwareProtectedReported) };
         RdclHardwareProtectedReported as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let RdclHardwareProtected: u32 = unsafe { ::core::mem::transmute(RdclHardwareProtected) };
         RdclHardwareProtected as u64
      });
      __bindgen_bitfield_unit.set(13usize, 4u8, {
         let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
         Reserved3 as u64
      });
      __bindgen_bitfield_unit.set(17usize, 3u8, {
         let Reserved4: u32 = unsafe { ::core::mem::transmute(Reserved4) };
         Reserved4 as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let DivideByZeroReported: u32 = unsafe { ::core::mem::transmute(DivideByZeroReported) };
         DivideByZeroReported as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let DivideByZeroStatus: u32 = unsafe { ::core::mem::transmute(DivideByZeroStatus) };
         DivideByZeroStatus as u64
      });
      __bindgen_bitfield_unit.set(22usize, 3u8, {
         let Reserved5: u32 = unsafe { ::core::mem::transmute(Reserved5) };
         Reserved5 as u64
      });
      __bindgen_bitfield_unit.set(25usize, 7u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_SPECULATION_CONTROL_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_SPECULATION_CONTROL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SPECULATION_CONTROL_INFORMATION = _SYSTEM_SPECULATION_CONTROL_INFORMATION;
pub type PSYSTEM_SPECULATION_CONTROL_INFORMATION = *mut _SYSTEM_SPECULATION_CONTROL_INFORMATION;
#[repr(C)]
pub struct _SYSTEM_DMA_GUARD_POLICY_INFORMATION {
   pub DmaGuardPolicyEnabled: BOOLEAN,
}
impl Default for _SYSTEM_DMA_GUARD_POLICY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_DMA_GUARD_POLICY_INFORMATION = _SYSTEM_DMA_GUARD_POLICY_INFORMATION;
pub type PSYSTEM_DMA_GUARD_POLICY_INFORMATION = *mut _SYSTEM_DMA_GUARD_POLICY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION {
   pub EnclaveLaunchSigner: [UCHAR; 32usize],
}
pub type SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION = _SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION;
pub type PSYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION =
   *mut _SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION {
   pub WorkloadClass: ULONGLONG,
   pub CpuSets: [ULONGLONG; 1usize],
}
pub type SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION = _SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION;
pub type PSYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION =
   *mut _SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SECURITY_MODEL_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1 {
   pub SecurityModelFlags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ReservedFlag(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlag(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlag_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlag_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AllowDeviceOwnerProtectionDowngrade(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AllowDeviceOwnerProtectionDowngrade(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AllowDeviceOwnerProtectionDowngrade_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AllowDeviceOwnerProtectionDowngrade_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ReservedFlag: ULONG,
      AllowDeviceOwnerProtectionDowngrade: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ReservedFlag: u32 = unsafe { ::core::mem::transmute(ReservedFlag) };
         ReservedFlag as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AllowDeviceOwnerProtectionDowngrade: u32 =
            unsafe { ::core::mem::transmute(AllowDeviceOwnerProtectionDowngrade) };
         AllowDeviceOwnerProtectionDowngrade as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_SECURITY_MODEL_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_SECURITY_MODEL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SECURITY_MODEL_INFORMATION = _SYSTEM_SECURITY_MODEL_INFORMATION;
pub type PSYSTEM_SECURITY_MODEL_INFORMATION = *mut _SYSTEM_SECURITY_MODEL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECURE_SPECULATION_CONTROL_INFORMATION {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _SECURE_SPECULATION_CONTROL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SECURE_SPECULATION_CONTROL_INFORMATION {
   #[inline]
   pub fn KvaShadowSupported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowSupported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowSupported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowSupported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KvaShadowEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KvaShadowUserGlobal(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowUserGlobal(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowUserGlobal_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowUserGlobal_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KvaShadowPcid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KvaShadowPcid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KvaShadowPcid_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KvaShadowPcid_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MbClearEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MbClearEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MbClearEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MbClearEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn L1TFMitigated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_L1TFMitigated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn L1TFMitigated_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_L1TFMitigated_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BpbEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BpbEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BpbEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IbrsPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IbrsPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IbrsPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IbrsPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnhancedIbrs(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnhancedIbrs(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnhancedIbrs_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnhancedIbrs_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn StibpPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_StibpPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StibpPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StibpPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SsbdSupported(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SsbdSupported(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SsbdSupported_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SsbdSupported_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SsbdRequired(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SsbdRequired(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SsbdRequired_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SsbdRequired_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BpbKernelToUser(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbKernelToUser(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BpbKernelToUser_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BpbKernelToUser_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BpbUserToKernel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BpbUserToKernel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BpbUserToKernel_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BpbUserToKernel_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReturnSpeculate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReturnSpeculate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReturnSpeculate_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReturnSpeculate_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BranchConfusionSafe(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_BranchConfusionSafe(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BranchConfusionSafe_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_BranchConfusionSafe_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SsbsEnabledAlways(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SsbsEnabledAlways(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SsbsEnabledAlways_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SsbsEnabledAlways_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SsbsEnabledKernel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SsbsEnabledKernel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(17usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SsbsEnabledKernel_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            17usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SsbsEnabledKernel_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            17usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 14u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            18usize,
            14u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            18usize,
            14u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      KvaShadowSupported: ULONG,
      KvaShadowEnabled: ULONG,
      KvaShadowUserGlobal: ULONG,
      KvaShadowPcid: ULONG,
      MbClearEnabled: ULONG,
      L1TFMitigated: ULONG,
      BpbEnabled: ULONG,
      IbrsPresent: ULONG,
      EnhancedIbrs: ULONG,
      StibpPresent: ULONG,
      SsbdSupported: ULONG,
      SsbdRequired: ULONG,
      BpbKernelToUser: ULONG,
      BpbUserToKernel: ULONG,
      ReturnSpeculate: ULONG,
      BranchConfusionSafe: ULONG,
      SsbsEnabledAlways: ULONG,
      SsbsEnabledKernel: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let KvaShadowSupported: u32 = unsafe { ::core::mem::transmute(KvaShadowSupported) };
         KvaShadowSupported as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let KvaShadowEnabled: u32 = unsafe { ::core::mem::transmute(KvaShadowEnabled) };
         KvaShadowEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let KvaShadowUserGlobal: u32 = unsafe { ::core::mem::transmute(KvaShadowUserGlobal) };
         KvaShadowUserGlobal as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let KvaShadowPcid: u32 = unsafe { ::core::mem::transmute(KvaShadowPcid) };
         KvaShadowPcid as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let MbClearEnabled: u32 = unsafe { ::core::mem::transmute(MbClearEnabled) };
         MbClearEnabled as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let L1TFMitigated: u32 = unsafe { ::core::mem::transmute(L1TFMitigated) };
         L1TFMitigated as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let BpbEnabled: u32 = unsafe { ::core::mem::transmute(BpbEnabled) };
         BpbEnabled as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let IbrsPresent: u32 = unsafe { ::core::mem::transmute(IbrsPresent) };
         IbrsPresent as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let EnhancedIbrs: u32 = unsafe { ::core::mem::transmute(EnhancedIbrs) };
         EnhancedIbrs as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let StibpPresent: u32 = unsafe { ::core::mem::transmute(StibpPresent) };
         StibpPresent as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let SsbdSupported: u32 = unsafe { ::core::mem::transmute(SsbdSupported) };
         SsbdSupported as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let SsbdRequired: u32 = unsafe { ::core::mem::transmute(SsbdRequired) };
         SsbdRequired as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let BpbKernelToUser: u32 = unsafe { ::core::mem::transmute(BpbKernelToUser) };
         BpbKernelToUser as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let BpbUserToKernel: u32 = unsafe { ::core::mem::transmute(BpbUserToKernel) };
         BpbUserToKernel as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let ReturnSpeculate: u32 = unsafe { ::core::mem::transmute(ReturnSpeculate) };
         ReturnSpeculate as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let BranchConfusionSafe: u32 = unsafe { ::core::mem::transmute(BranchConfusionSafe) };
         BranchConfusionSafe as u64
      });
      __bindgen_bitfield_unit.set(16usize, 1u8, {
         let SsbsEnabledAlways: u32 = unsafe { ::core::mem::transmute(SsbsEnabledAlways) };
         SsbsEnabledAlways as u64
      });
      __bindgen_bitfield_unit.set(17usize, 1u8, {
         let SsbsEnabledKernel: u32 = unsafe { ::core::mem::transmute(SsbsEnabledKernel) };
         SsbsEnabledKernel as u64
      });
      __bindgen_bitfield_unit.set(18usize, 14u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type SECURE_SPECULATION_CONTROL_INFORMATION = _SECURE_SPECULATION_CONTROL_INFORMATION;
pub type PSECURE_SPECULATION_CONTROL_INFORMATION = *mut _SECURE_SPECULATION_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FIRMWARE_RAMDISK_INFORMATION {
   pub Version: ULONG,
   pub BlockSize: ULONG,
   pub BaseAddress: ULONG_PTR,
   pub Size: SIZE_T,
}
pub type SYSTEM_FIRMWARE_RAMDISK_INFORMATION = _SYSTEM_FIRMWARE_RAMDISK_INFORMATION;
pub type PSYSTEM_FIRMWARE_RAMDISK_INFORMATION = *mut _SYSTEM_FIRMWARE_RAMDISK_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_SHADOW_STACK_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn CetCapable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CetCapable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CetCapable_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CetCapable_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UserCetAllowed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UserCetAllowed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UserCetAllowed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_UserCetAllowed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedForUserCet(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedForUserCet(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedForUserCet_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedForUserCet_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KernelCetEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KernelCetEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KernelCetEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KernelCetEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KernelCetAuditModeEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KernelCetAuditModeEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KernelCetAuditModeEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KernelCetAuditModeEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedForKernelCet(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedForKernelCet(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedForKernelCet_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedForKernelCet_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            16u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      CetCapable: ULONG,
      UserCetAllowed: ULONG,
      ReservedForUserCet: ULONG,
      KernelCetEnabled: ULONG,
      KernelCetAuditModeEnabled: ULONG,
      ReservedForKernelCet: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let CetCapable: u32 = unsafe { ::core::mem::transmute(CetCapable) };
         CetCapable as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let UserCetAllowed: u32 = unsafe { ::core::mem::transmute(UserCetAllowed) };
         UserCetAllowed as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let ReservedForUserCet: u32 = unsafe { ::core::mem::transmute(ReservedForUserCet) };
         ReservedForUserCet as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let KernelCetEnabled: u32 = unsafe { ::core::mem::transmute(KernelCetEnabled) };
         KernelCetEnabled as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let KernelCetAuditModeEnabled: u32 =
            unsafe { ::core::mem::transmute(KernelCetAuditModeEnabled) };
         KernelCetAuditModeEnabled as u64
      });
      __bindgen_bitfield_unit.set(10usize, 6u8, {
         let ReservedForKernelCet: u32 = unsafe { ::core::mem::transmute(ReservedForKernelCet) };
         ReservedForKernelCet as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_SHADOW_STACK_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_SHADOW_STACK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_SHADOW_STACK_INFORMATION = _SYSTEM_SHADOW_STACK_INFORMATION;
pub type PSYSTEM_SHADOW_STACK_INFORMATION = *mut _SYSTEM_SHADOW_STACK_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS {
   pub Value32: ULONG,
   pub __bindgen_anon_1: _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS__bindgen_ty_1 {
   #[inline]
   pub fn IsTopLevel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTopLevel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsTopLevel_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsTopLevel_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsChecked(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsChecked(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsChecked_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsChecked_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsTopLevel: ULONG,
      IsChecked: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsTopLevel: u32 = unsafe { ::core::mem::transmute(IsTopLevel) };
         IsTopLevel as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsChecked: u32 = unsafe { ::core::mem::transmute(IsChecked) };
         IsChecked as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BUILD_VERSION_INFORMATION_FLAGS = _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS;
pub type PSYSTEM_BUILD_VERSION_INFORMATION_FLAGS = *mut _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_BUILD_VERSION_INFORMATION {
   pub LayerNumber: USHORT,
   pub LayerCount: USHORT,
   pub OsMajorVersion: ULONG,
   pub OsMinorVersion: ULONG,
   pub NtBuildNumber: ULONG,
   pub NtBuildQfe: ULONG,
   pub LayerName: [UCHAR; 128usize],
   pub NtBuildBranch: [UCHAR; 128usize],
   pub NtBuildLab: [UCHAR; 128usize],
   pub NtBuildLabEx: [UCHAR; 128usize],
   pub NtBuildStamp: [UCHAR; 26usize],
   pub NtBuildArch: [UCHAR; 16usize],
   pub Flags: SYSTEM_BUILD_VERSION_INFORMATION_FLAGS,
}
impl Default for _SYSTEM_BUILD_VERSION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_BUILD_VERSION_INFORMATION = _SYSTEM_BUILD_VERSION_INFORMATION;
pub type PSYSTEM_BUILD_VERSION_INFORMATION = *mut _SYSTEM_BUILD_VERSION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POOL_LIMIT_MEM_INFO {
   pub MemoryLimit: ULONGLONG,
   pub NotificationLimit: ULONGLONG,
}
pub type SYSTEM_POOL_LIMIT_MEM_INFO = _SYSTEM_POOL_LIMIT_MEM_INFO;
pub type PSYSTEM_POOL_LIMIT_MEM_INFO = *mut _SYSTEM_POOL_LIMIT_MEM_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POOL_LIMIT_INFO {
   pub PoolTag: ULONG,
   pub MemLimits: [SYSTEM_POOL_LIMIT_MEM_INFO; 2usize],
   pub NotificationHandle: WNF_STATE_NAME,
}
pub type SYSTEM_POOL_LIMIT_INFO = _SYSTEM_POOL_LIMIT_INFO;
pub type PSYSTEM_POOL_LIMIT_INFO = *mut _SYSTEM_POOL_LIMIT_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POOL_LIMIT_INFORMATION {
   pub Version: ULONG,
   pub EntryCount: ULONG,
   pub LimitEntries: [SYSTEM_POOL_LIMIT_INFO; 1usize],
}
pub type SYSTEM_POOL_LIMIT_INFORMATION = _SYSTEM_POOL_LIMIT_INFORMATION;
pub type PSYSTEM_POOL_LIMIT_INFORMATION = *mut _SYSTEM_POOL_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HV_MINROOT_NUMA_LPS {
   pub NodeIndex: ULONG,
   pub Mask: [ULONG_PTR; 16usize],
}
pub type HV_MINROOT_NUMA_LPS = _HV_MINROOT_NUMA_LPS;
pub type PHV_MINROOT_NUMA_LPS = *mut _HV_MINROOT_NUMA_LPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_XFG_FAILURE_INFORMATION {
   pub ReturnAddress: PVOID,
   pub TargetAddress: PVOID,
   pub DispatchMode: ULONG,
   pub XfgValue: ULONGLONG,
}
impl Default for _SYSTEM_XFG_FAILURE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_XFG_FAILURE_INFORMATION = _SYSTEM_XFG_FAILURE_INFORMATION;
pub type PSYSTEM_XFG_FAILURE_INFORMATION = *mut _SYSTEM_XFG_FAILURE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_IOMMU_STATE {
   IommuStateBlock = 0,
   IommuStateUnblock = 1,
}
pub use self::_SYSTEM_IOMMU_STATE as SYSTEM_IOMMU_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_IOMMU_STATE_INFORMATION {
   pub State: SYSTEM_IOMMU_STATE,
   pub Pdo: PVOID,
}
impl Default for _SYSTEM_IOMMU_STATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_IOMMU_STATE_INFORMATION = _SYSTEM_IOMMU_STATE_INFORMATION;
pub type PSYSTEM_IOMMU_STATE_INFORMATION = *mut _SYSTEM_IOMMU_STATE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_MINROOT_INFORMATION {
   pub NumProc: ULONG,
   pub RootProc: ULONG,
   pub RootProcNumaNodesSpecified: ULONG,
   pub RootProcNumaNodes: [USHORT; 64usize],
   pub RootProcPerCore: ULONG,
   pub RootProcPerNode: ULONG,
   pub RootProcNumaNodesLpsSpecified: ULONG,
   pub RootProcNumaNodeLps: [HV_MINROOT_NUMA_LPS; 64usize],
}
impl Default for _SYSTEM_HYPERVISOR_MINROOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HYPERVISOR_MINROOT_INFORMATION = _SYSTEM_HYPERVISOR_MINROOT_INFORMATION;
pub type PSYSTEM_HYPERVISOR_MINROOT_INFORMATION = *mut _SYSTEM_HYPERVISOR_MINROOT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION {
   pub RangeCount: ULONG,
   pub RangeArray: [ULONG_PTR; 1usize],
}
pub type SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION = _SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION;
pub type PSYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION = *mut _SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POINTER_AUTH_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1,
   pub __bindgen_anon_2: _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1 {
   pub SupportedFlags: USHORT,
   pub __bindgen_anon_1: _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn AddressAuthSupported(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_AddressAuthSupported(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddressAuthSupported_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_AddressAuthSupported_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AddressAuthQarma(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_AddressAuthQarma(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddressAuthQarma_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_AddressAuthQarma_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn GenericAuthSupported(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_GenericAuthSupported(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn GenericAuthSupported_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_GenericAuthSupported_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn GenericAuthQarma(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_GenericAuthQarma(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn GenericAuthQarma_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_GenericAuthQarma_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AddressAuthFaulting(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_AddressAuthFaulting(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddressAuthFaulting_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_AddressAuthFaulting_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SupportedReserved(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
   }
   #[inline]
   pub fn set_SupportedReserved(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 11u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SupportedReserved_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            11u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SupportedReserved_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            11u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      AddressAuthSupported: USHORT,
      AddressAuthQarma: USHORT,
      GenericAuthSupported: USHORT,
      GenericAuthQarma: USHORT,
      AddressAuthFaulting: USHORT,
      SupportedReserved: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let AddressAuthSupported: u16 = unsafe { ::core::mem::transmute(AddressAuthSupported) };
         AddressAuthSupported as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AddressAuthQarma: u16 = unsafe { ::core::mem::transmute(AddressAuthQarma) };
         AddressAuthQarma as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let GenericAuthSupported: u16 = unsafe { ::core::mem::transmute(GenericAuthSupported) };
         GenericAuthSupported as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let GenericAuthQarma: u16 = unsafe { ::core::mem::transmute(GenericAuthQarma) };
         GenericAuthQarma as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let AddressAuthFaulting: u16 = unsafe { ::core::mem::transmute(AddressAuthFaulting) };
         AddressAuthFaulting as u64
      });
      __bindgen_bitfield_unit.set(5usize, 11u8, {
         let SupportedReserved: u16 = unsafe { ::core::mem::transmute(SupportedReserved) };
         SupportedReserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2 {
   pub EnabledFlags: USHORT,
   pub __bindgen_anon_1: _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn UserPerProcessIpAuthEnabled(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_UserPerProcessIpAuthEnabled(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UserPerProcessIpAuthEnabled_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_UserPerProcessIpAuthEnabled_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UserGlobalIpAuthEnabled(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_UserGlobalIpAuthEnabled(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UserGlobalIpAuthEnabled_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_UserGlobalIpAuthEnabled_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UserEnabledReserved(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u16) }
   }
   #[inline]
   pub fn set_UserEnabledReserved(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UserEnabledReserved_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            6u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_UserEnabledReserved_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KernelIpAuthEnabled(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_KernelIpAuthEnabled(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KernelIpAuthEnabled_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_KernelIpAuthEnabled_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KernelEnabledReserved(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
   }
   #[inline]
   pub fn set_KernelEnabledReserved(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KernelEnabledReserved_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            7u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_KernelEnabledReserved_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            7u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      UserPerProcessIpAuthEnabled: USHORT,
      UserGlobalIpAuthEnabled: USHORT,
      UserEnabledReserved: USHORT,
      KernelIpAuthEnabled: USHORT,
      KernelEnabledReserved: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let UserPerProcessIpAuthEnabled: u16 =
            unsafe { ::core::mem::transmute(UserPerProcessIpAuthEnabled) };
         UserPerProcessIpAuthEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let UserGlobalIpAuthEnabled: u16 =
            unsafe { ::core::mem::transmute(UserGlobalIpAuthEnabled) };
         UserGlobalIpAuthEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let UserEnabledReserved: u16 = unsafe { ::core::mem::transmute(UserEnabledReserved) };
         UserEnabledReserved as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let KernelIpAuthEnabled: u16 = unsafe { ::core::mem::transmute(KernelIpAuthEnabled) };
         KernelIpAuthEnabled as u64
      });
      __bindgen_bitfield_unit.set(9usize, 7u8, {
         let KernelEnabledReserved: u16 = unsafe { ::core::mem::transmute(KernelEnabledReserved) };
         KernelEnabledReserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_POINTER_AUTH_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_POINTER_AUTH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POINTER_AUTH_INFORMATION = _SYSTEM_POINTER_AUTH_INFORMATION;
pub type PSYSTEM_POINTER_AUTH_INFORMATION = *mut _SYSTEM_POINTER_AUTH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT {
   pub Version: ULONG,
   pub FeatureName: PWSTR,
   pub BornOnVersion: ULONG,
}
impl Default for _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT =
   _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT;
pub type PSYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT =
   *mut _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT;
#[repr(C)]
pub struct _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT {
   pub Version: ULONG,
   pub FeatureIsEnabled: BOOLEAN,
}
impl Default for _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT =
   _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT;
pub type PSYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT =
   *mut _SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_NUMA_INFORMATION_INPUT {
   pub Version: ULONG,
   pub TargetNodeNumber: ULONG,
   pub Flags: ULONG,
}
pub type SYSTEM_MEMORY_NUMA_INFORMATION_INPUT = _SYSTEM_MEMORY_NUMA_INFORMATION_INPUT;
pub type PSYSTEM_MEMORY_NUMA_INFORMATION_INPUT = *mut _SYSTEM_MEMORY_NUMA_INFORMATION_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT {
   pub Version: ULONG,
   pub Size: ULONG,
   pub InitiatorNode: ULONG,
   pub __bindgen_anon_1: _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn IsAttached(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsAttached(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsAttached_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsAttached_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsAttached: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsAttached: u32 = unsafe { ::core::mem::transmute(IsAttached) };
         IsAttached as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT = _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT;
pub type PSYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT = *mut _SYSTEM_MEMORY_NUMA_INFORMATION_OUTPUT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_MEMORY_NUMA_PERFORMANCE_QUERY_DATA_TYPES {
   SystemMemoryNumaPerformanceQuery_ReadLatency = 0,
   SystemMemoryNumaPerformanceQuery_ReadBandwidth = 1,
   SystemMemoryNumaPerformanceQuery_WriteLatency = 2,
   SystemMemoryNumaPerformanceQuery_WriteBandwidth = 3,
   SystemMemoryNumaPerformanceQuery_Latency = 4,
   SystemMemoryNumaPerformanceQuery_Bandwidth = 5,
   SystemMemoryNumaPerformanceQuery_AllDataTypes = 6,
   SystemMemoryNumaPerformanceQuery_MaxDataType = 7,
}
pub use self::_SYSTEM_MEMORY_NUMA_PERFORMANCE_QUERY_DATA_TYPES as SYSTEM_MEMORY_NUMA_PERFORMANCE_QUERY_DATA_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_INPUT {
   pub Version: ULONG,
   pub TargetNodeNumber: ULONG,
   pub QueryDataType: SYSTEM_MEMORY_NUMA_PERFORMANCE_QUERY_DATA_TYPES,
   pub Flags: ULONG,
}
impl Default for _SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_INPUT =
   _SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_INPUT;
pub type PSYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_INPUT =
   *mut _SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_INPUT;
#[repr(C)]
pub struct _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY {
   pub InitiatorNodeNumber: ULONG,
   pub TargetNodeNumber: ULONG,
   pub DataType: SYSTEM_MEMORY_NUMA_PERFORMANCE_QUERY_DATA_TYPES,
   pub __bindgen_anon_1: _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY__bindgen_ty_1,
   pub MinTransferSizeInBytes: SIZE_T,
   pub EntryValue: ULONG_PTR,
}
#[repr(C)]
pub union _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY__bindgen_ty_1 {
   pub Flags: ::core::mem::ManuallyDrop<BOOLEAN>,
   pub __bindgen_anon_1:
      ::core::mem::ManuallyDrop<_SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn MinTransferSizeToAchieveValues(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_MinTransferSizeToAchieveValues(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MinTransferSizeToAchieveValues_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_MinTransferSizeToAchieveValues_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NonSequentialTransfers(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_NonSequentialTransfers(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NonSequentialTransfers_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_NonSequentialTransfers_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            6u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      MinTransferSizeToAchieveValues: BOOLEAN,
      NonSequentialTransfers: BOOLEAN,
      Reserved: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let MinTransferSizeToAchieveValues: u8 =
            unsafe { ::core::mem::transmute(MinTransferSizeToAchieveValues) };
         MinTransferSizeToAchieveValues as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let NonSequentialTransfers: u8 = unsafe { ::core::mem::transmute(NonSequentialTransfers) };
         NonSequentialTransfers as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY = _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY;
pub type PSYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY = *mut _SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY;
#[repr(C)]
pub struct _SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_OUTPUT {
   pub Version: ULONG,
   pub Size: ULONG,
   pub EntryCount: ULONG,
   pub PerformanceEntries: [SYSTEM_MEMORY_NUMA_PERFORMANCE_ENTRY; 1usize],
}
impl Default for _SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_OUTPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_OUTPUT =
   _SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_OUTPUT;
pub type PSYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_OUTPUT =
   *mut _SYSTEM_MEMORY_NUMA_PERFORMANCE_INFORMATION_OUTPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_OSL_RAMDISK_ENTRY {
   pub BlockSize: ULONG,
   pub BaseAddress: ULONG_PTR,
   pub Size: SIZE_T,
}
pub type SYSTEM_OSL_RAMDISK_ENTRY = _SYSTEM_OSL_RAMDISK_ENTRY;
pub type PSYSTEM_OSL_RAMDISK_ENTRY = *mut _SYSTEM_OSL_RAMDISK_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION {
   pub __bindgen_anon_1: _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION__bindgen_ty_1,
   pub RemoteBreakingRoutine: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONGLONG,
   pub __bindgen_anon_1: _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Supported(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Supported(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Supported_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Supported_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 63u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            63u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            63u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Supported: ULONGLONG,
      Spare: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Supported: u64 = unsafe { ::core::mem::transmute(Supported) };
         Supported as u64
      });
      __bindgen_bitfield_unit.set(1usize, 63u8, {
         let Spare: u64 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION = _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION;
pub type PSYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION = *mut _SYSTEM_TRUSTEDAPPS_RUNTIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_OSL_RAMDISK_INFORMATION {
   pub Version: ULONG,
   pub Count: ULONG,
   pub Entries: [SYSTEM_OSL_RAMDISK_ENTRY; 1usize],
}
pub type SYSTEM_OSL_RAMDISK_INFORMATION = _SYSTEM_OSL_RAMDISK_INFORMATION;
pub type PSYSTEM_OSL_RAMDISK_INFORMATION = *mut _SYSTEM_OSL_RAMDISK_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSDBG_COMMAND {
   SysDbgQueryModuleInformation = 0,
   SysDbgQueryTraceInformation = 1,
   SysDbgSetTracepoint = 2,
   SysDbgSetSpecialCall = 3,
   SysDbgClearSpecialCalls = 4,
   SysDbgQuerySpecialCalls = 5,
   SysDbgBreakPoint = 6,
   SysDbgQueryVersion = 7,
   SysDbgReadVirtual = 8,
   SysDbgWriteVirtual = 9,
   SysDbgReadPhysical = 10,
   SysDbgWritePhysical = 11,
   SysDbgReadControlSpace = 12,
   SysDbgWriteControlSpace = 13,
   SysDbgReadIoSpace = 14,
   SysDbgWriteIoSpace = 15,
   SysDbgReadMsr = 16,
   SysDbgWriteMsr = 17,
   SysDbgReadBusData = 18,
   SysDbgWriteBusData = 19,
   SysDbgCheckLowMemory = 20,
   SysDbgEnableKernelDebugger = 21,
   SysDbgDisableKernelDebugger = 22,
   SysDbgGetAutoKdEnable = 23,
   SysDbgSetAutoKdEnable = 24,
   SysDbgGetPrintBufferSize = 25,
   SysDbgSetPrintBufferSize = 26,
   SysDbgGetKdUmExceptionEnable = 27,
   SysDbgSetKdUmExceptionEnable = 28,
   SysDbgGetTriageDump = 29,
   SysDbgGetKdBlockEnable = 30,
   SysDbgSetKdBlockEnable = 31,
   SysDbgRegisterForUmBreakInfo = 32,
   SysDbgGetUmBreakPid = 33,
   SysDbgClearUmBreakPid = 34,
   SysDbgGetUmAttachPid = 35,
   SysDbgClearUmAttachPid = 36,
   SysDbgGetLiveKernelDump = 37,
   SysDbgKdPullRemoteFile = 38,
   SysDbgMaxInfoClass = 39,
}
pub use self::_SYSDBG_COMMAND as SYSDBG_COMMAND;
pub type PSYSDBG_COMMAND = *mut _SYSDBG_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_VIRTUAL {
   pub Address: PVOID,
   pub Buffer: PVOID,
   pub Request: ULONG,
}
impl Default for _SYSDBG_VIRTUAL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_VIRTUAL = _SYSDBG_VIRTUAL;
pub type PSYSDBG_VIRTUAL = *mut _SYSDBG_VIRTUAL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSDBG_PHYSICAL {
   pub Address: PHYSICAL_ADDRESS,
   pub Buffer: PVOID,
   pub Request: ULONG,
}
impl Default for _SYSDBG_PHYSICAL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_PHYSICAL = _SYSDBG_PHYSICAL;
pub type PSYSDBG_PHYSICAL = *mut _SYSDBG_PHYSICAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_CONTROL_SPACE {
   pub Address: ULONG64,
   pub Buffer: PVOID,
   pub Request: ULONG,
   pub Processor: ULONG,
}
impl Default for _SYSDBG_CONTROL_SPACE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_CONTROL_SPACE = _SYSDBG_CONTROL_SPACE;
pub type PSYSDBG_CONTROL_SPACE = *mut _SYSDBG_CONTROL_SPACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_IO_SPACE {
   pub Address: ULONG64,
   pub Buffer: PVOID,
   pub Request: ULONG,
   pub InterfaceType: _INTERFACE_TYPE,
   pub BusNumber: ULONG,
   pub AddressSpace: ULONG,
}
impl Default for _SYSDBG_IO_SPACE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_IO_SPACE = _SYSDBG_IO_SPACE;
pub type PSYSDBG_IO_SPACE = *mut _SYSDBG_IO_SPACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSDBG_MSR {
   pub Msr: ULONG,
   pub Data: ULONG64,
}
pub type SYSDBG_MSR = _SYSDBG_MSR;
pub type PSYSDBG_MSR = *mut _SYSDBG_MSR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_BUS_DATA {
   pub Address: ULONG,
   pub Buffer: PVOID,
   pub Request: ULONG,
   pub BusDataType: _BUS_DATA_TYPE,
   pub BusNumber: ULONG,
   pub SlotNumber: ULONG,
}
impl Default for _SYSDBG_BUS_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_BUS_DATA = _SYSDBG_BUS_DATA;
pub type PSYSDBG_BUS_DATA = *mut _SYSDBG_BUS_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSDBG_TRIAGE_DUMP {
   pub Flags: ULONG,
   pub BugCheckCode: ULONG,
   pub BugCheckParam1: ULONG_PTR,
   pub BugCheckParam2: ULONG_PTR,
   pub BugCheckParam3: ULONG_PTR,
   pub BugCheckParam4: ULONG_PTR,
   pub ProcessHandles: ULONG,
   pub ThreadHandles: ULONG,
   pub Handles: PHANDLE,
}
impl Default for _SYSDBG_TRIAGE_DUMP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_TRIAGE_DUMP = _SYSDBG_TRIAGE_DUMP;
pub type PSYSDBG_TRIAGE_DUMP = *mut _SYSDBG_TRIAGE_DUMP;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSDBG_LIVEDUMP_CONTROL_FLAGS {
   pub __bindgen_anon_1: _SYSDBG_LIVEDUMP_CONTROL_FLAGS__bindgen_ty_1,
   pub AsUlong: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_CONTROL_FLAGS__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSDBG_LIVEDUMP_CONTROL_FLAGS__bindgen_ty_1 {
   #[inline]
   pub fn UseDumpStorageStack(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UseDumpStorageStack(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UseDumpStorageStack_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_UseDumpStorageStack_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CompressMemoryPagesData(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompressMemoryPagesData(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CompressMemoryPagesData_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CompressMemoryPagesData_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IncludeUserSpaceMemoryPages(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IncludeUserSpaceMemoryPages(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IncludeUserSpaceMemoryPages_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IncludeUserSpaceMemoryPages_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AbortIfMemoryPressure(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AbortIfMemoryPressure(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AbortIfMemoryPressure_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AbortIfMemoryPressure_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SelectiveDump(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SelectiveDump(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SelectiveDump_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SelectiveDump_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      UseDumpStorageStack: ULONG,
      CompressMemoryPagesData: ULONG,
      IncludeUserSpaceMemoryPages: ULONG,
      AbortIfMemoryPressure: ULONG,
      SelectiveDump: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let UseDumpStorageStack: u32 = unsafe { ::core::mem::transmute(UseDumpStorageStack) };
         UseDumpStorageStack as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let CompressMemoryPagesData: u32 =
            unsafe { ::core::mem::transmute(CompressMemoryPagesData) };
         CompressMemoryPagesData as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IncludeUserSpaceMemoryPages: u32 =
            unsafe { ::core::mem::transmute(IncludeUserSpaceMemoryPages) };
         IncludeUserSpaceMemoryPages as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let AbortIfMemoryPressure: u32 = unsafe { ::core::mem::transmute(AbortIfMemoryPressure) };
         AbortIfMemoryPressure as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let SelectiveDump: u32 = unsafe { ::core::mem::transmute(SelectiveDump) };
         SelectiveDump as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSDBG_LIVEDUMP_CONTROL_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_CONTROL_FLAGS = _SYSDBG_LIVEDUMP_CONTROL_FLAGS;
pub type PSYSDBG_LIVEDUMP_CONTROL_FLAGS = *mut _SYSDBG_LIVEDUMP_CONTROL_FLAGS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES {
   pub __bindgen_anon_1: _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES__bindgen_ty_1,
   pub AsUlong: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES__bindgen_ty_1 {
   #[inline]
   pub fn HypervisorPages(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HypervisorPages(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HypervisorPages_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HypervisorPages_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NonEssentialHypervisorPages(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NonEssentialHypervisorPages(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NonEssentialHypervisorPages_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NonEssentialHypervisorPages_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HypervisorPages: ULONG,
      NonEssentialHypervisorPages: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let HypervisorPages: u32 = unsafe { ::core::mem::transmute(HypervisorPages) };
         HypervisorPages as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let NonEssentialHypervisorPages: u32 =
            unsafe { ::core::mem::transmute(NonEssentialHypervisorPages) };
         NonEssentialHypervisorPages as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_CONTROL_ADDPAGES = _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES;
pub type PSYSDBG_LIVEDUMP_CONTROL_ADDPAGES = *mut _SYSDBG_LIVEDUMP_CONTROL_ADDPAGES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL {
   pub Version: ULONG,
   pub Size: ULONG,
   pub __bindgen_anon_1: _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1,
   pub Reserved: [ULONGLONG; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1 {
   pub Flags: ULONGLONG,
   pub __bindgen_anon_1: _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ThreadKernelStacks(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_ThreadKernelStacks(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ThreadKernelStacks_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ThreadKernelStacks_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 63u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            63u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            63u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ThreadKernelStacks: ULONGLONG,
      ReservedFlags: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ThreadKernelStacks: u64 = unsafe { ::core::mem::transmute(ThreadKernelStacks) };
         ThreadKernelStacks as u64
      });
      __bindgen_bitfield_unit.set(1usize, 63u8, {
         let ReservedFlags: u64 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_SELECTIVE_CONTROL = _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL;
pub type PSYSDBG_LIVEDUMP_SELECTIVE_CONTROL = *mut _SYSDBG_LIVEDUMP_SELECTIVE_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_CONTROL_V1 {
   pub Version: ULONG,
   pub BugCheckCode: ULONG,
   pub BugCheckParam1: ULONG_PTR,
   pub BugCheckParam2: ULONG_PTR,
   pub BugCheckParam3: ULONG_PTR,
   pub BugCheckParam4: ULONG_PTR,
   pub DumpFileHandle: HANDLE,
   pub CancelEventHandle: HANDLE,
   pub Flags: SYSDBG_LIVEDUMP_CONTROL_FLAGS,
   pub AddPagesControl: SYSDBG_LIVEDUMP_CONTROL_ADDPAGES,
}
impl Default for _SYSDBG_LIVEDUMP_CONTROL_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_CONTROL_V1 = _SYSDBG_LIVEDUMP_CONTROL_V1;
pub type PSYSDBG_LIVEDUMP_CONTROL_V1 = *mut _SYSDBG_LIVEDUMP_CONTROL_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSDBG_LIVEDUMP_CONTROL {
   pub Version: ULONG,
   pub BugCheckCode: ULONG,
   pub BugCheckParam1: ULONG_PTR,
   pub BugCheckParam2: ULONG_PTR,
   pub BugCheckParam3: ULONG_PTR,
   pub BugCheckParam4: ULONG_PTR,
   pub DumpFileHandle: HANDLE,
   pub CancelEventHandle: HANDLE,
   pub Flags: SYSDBG_LIVEDUMP_CONTROL_FLAGS,
   pub AddPagesControl: SYSDBG_LIVEDUMP_CONTROL_ADDPAGES,
   pub SelectiveControl: PSYSDBG_LIVEDUMP_SELECTIVE_CONTROL,
}
impl Default for _SYSDBG_LIVEDUMP_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_LIVEDUMP_CONTROL = _SYSDBG_LIVEDUMP_CONTROL;
pub type PSYSDBG_LIVEDUMP_CONTROL = *mut _SYSDBG_LIVEDUMP_CONTROL;
#[repr(C)]
pub struct _SYSDBG_KD_PULL_REMOTE_FILE {
   pub ImageFileName: UNICODE_STRING,
}
impl Default for _SYSDBG_KD_PULL_REMOTE_FILE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSDBG_KD_PULL_REMOTE_FILE = _SYSDBG_KD_PULL_REMOTE_FILE;
pub type PSYSDBG_KD_PULL_REMOTE_FILE = *mut _SYSDBG_KD_PULL_REMOTE_FILE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HARDERROR_RESPONSE_OPTION {
   OptionAbortRetryIgnore = 0,
   OptionOk = 1,
   OptionOkCancel = 2,
   OptionRetryCancel = 3,
   OptionYesNo = 4,
   OptionYesNoCancel = 5,
   OptionShutdownSystem = 6,
   OptionOkNoWait = 7,
   OptionCancelTryContinue = 8,
}
pub use self::_HARDERROR_RESPONSE_OPTION as HARDERROR_RESPONSE_OPTION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HARDERROR_RESPONSE {
   ResponseReturnToCaller = 0,
   ResponseNotHandled = 1,
   ResponseAbort = 2,
   ResponseCancel = 3,
   ResponseIgnore = 4,
   ResponseNo = 5,
   ResponseOk = 6,
   ResponseRetry = 7,
   ResponseYes = 8,
   ResponseTryAgain = 9,
   ResponseContinue = 10,
}
pub use self::_HARDERROR_RESPONSE as HARDERROR_RESPONSE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALTERNATIVE_ARCHITECTURE_TYPE {
   StandardDesign = 0,
   NEC98x86 = 1,
   EndAlternatives = 2,
}
pub use self::_ALTERNATIVE_ARCHITECTURE_TYPE as ALTERNATIVE_ARCHITECTURE_TYPE;
#[repr(C)]
pub struct _KUSER_SHARED_DATA {
   pub TickCountLowDeprecated: ULONG,
   pub TickCountMultiplier: ULONG,
   pub InterruptTime: KSYSTEM_TIME,
   pub SystemTime: KSYSTEM_TIME,
   pub TimeZoneBias: KSYSTEM_TIME,
   pub ImageNumberLow: USHORT,
   pub ImageNumberHigh: USHORT,
   pub NtSystemRoot: [WCHAR; 260usize],
   pub MaxStackTraceDepth: ULONG,
   pub CryptoExponent: ULONG,
   pub TimeZoneId: ULONG,
   pub LargePageMinimum: ULONG,
   pub AitSamplingValue: ULONG,
   pub AppCompatFlag: ULONG,
   pub RNGSeedVersion: ULONGLONG,
   pub GlobalValidationRunlevel: ULONG,
   pub TimeZoneBiasStamp: LONG,
   pub NtBuildNumber: ULONG,
   pub NtProductType: NT_PRODUCT_TYPE,
   pub ProductTypeIsValid: BOOLEAN,
   pub Reserved0: [BOOLEAN; 1usize],
   pub NativeProcessorArchitecture: USHORT,
   pub NtMajorVersion: ULONG,
   pub NtMinorVersion: ULONG,
   pub ProcessorFeatures: [BOOLEAN; 64usize],
   pub Reserved1: ULONG,
   pub Reserved3: ULONG,
   pub TimeSlip: ULONG,
   pub AlternativeArchitecture: ALTERNATIVE_ARCHITECTURE_TYPE,
   pub BootId: ULONG,
   pub SystemExpirationDate: LARGE_INTEGER,
   pub SuiteMask: ULONG,
   pub KdDebuggerEnabled: BOOLEAN,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1,
   pub CyclesPerYield: USHORT,
   pub ActiveConsoleId: ULONG,
   pub DismountCount: ULONG,
   pub ComPlusPackage: ULONG,
   pub LastSystemRITEventTickCount: ULONG,
   pub NumberOfPhysicalPages: ULONG,
   pub SafeBootMode: BOOLEAN,
   pub __bindgen_anon_2: _KUSER_SHARED_DATA__bindgen_ty_2,
   pub Reserved12: [UCHAR; 2usize],
   pub __bindgen_anon_3: _KUSER_SHARED_DATA__bindgen_ty_3,
   pub DataFlagsPad: [ULONG; 1usize],
   pub TestRetInstruction: ULONGLONG,
   pub QpcFrequency: LONGLONG,
   pub SystemCall: ULONG,
   pub Reserved2: ULONG,
   pub FullNumberOfPhysicalPages: ULONGLONG,
   pub SystemCallPad: [ULONGLONG; 1usize],
   pub __bindgen_anon_4: _KUSER_SHARED_DATA__bindgen_ty_4,
   pub Cookie: ULONG,
   pub CookiePad: [ULONG; 1usize],
   pub ConsoleSessionForegroundProcessId: LONGLONG,
   pub TimeUpdateLock: ULONGLONG,
   pub BaselineSystemTimeQpc: ULONGLONG,
   pub BaselineInterruptTimeQpc: ULONGLONG,
   pub QpcSystemTimeIncrement: ULONGLONG,
   pub QpcInterruptTimeIncrement: ULONGLONG,
   pub QpcSystemTimeIncrementShift: UCHAR,
   pub QpcInterruptTimeIncrementShift: UCHAR,
   pub UnparkedProcessorCount: USHORT,
   pub EnclaveFeatureMask: [ULONG; 4usize],
   pub TelemetryCoverageRound: ULONG,
   pub UserModeGlobalLogger: [USHORT; 16usize],
   pub ImageFileExecutionOptions: ULONG,
   pub LangGenerationCount: ULONG,
   pub Reserved4: ULONGLONG,
   pub InterruptTimeBias: ULONGLONG,
   pub QpcBias: ULONGLONG,
   pub ActiveProcessorCount: ULONG,
   pub ActiveGroupCount: UCHAR,
   pub Reserved9: UCHAR,
   pub __bindgen_anon_5: _KUSER_SHARED_DATA__bindgen_ty_5,
   pub TimeZoneBiasEffectiveStart: LARGE_INTEGER,
   pub TimeZoneBiasEffectiveEnd: LARGE_INTEGER,
   pub XState: XSTATE_CONFIGURATION,
   pub FeatureConfigurationChangeStamp: KSYSTEM_TIME,
   pub Spare: ULONG,
   pub UserPointerAuthMask: ULONG64,
   pub XStateArm64: XSTATE_CONFIGURATION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_1 {
   pub MitigationPolicies: UCHAR,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NXSupportPolicy(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_NXSupportPolicy(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NXSupportPolicy_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_NXSupportPolicy_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SEHValidationPolicy(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_SEHValidationPolicy(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SEHValidationPolicy_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            2u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SEHValidationPolicy_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CurDirDevicesSkippedForDlls(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_CurDirDevicesSkippedForDlls(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CurDirDevicesSkippedForDlls_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            2u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_CurDirDevicesSkippedForDlls_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            2u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NXSupportPolicy: UCHAR,
      SEHValidationPolicy: UCHAR,
      CurDirDevicesSkippedForDlls: UCHAR,
      Reserved: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let NXSupportPolicy: u8 = unsafe { ::core::mem::transmute(NXSupportPolicy) };
         NXSupportPolicy as u64
      });
      __bindgen_bitfield_unit.set(2usize, 2u8, {
         let SEHValidationPolicy: u8 = unsafe { ::core::mem::transmute(SEHValidationPolicy) };
         SEHValidationPolicy as u64
      });
      __bindgen_bitfield_unit.set(4usize, 2u8, {
         let CurDirDevicesSkippedForDlls: u8 =
            unsafe { ::core::mem::transmute(CurDirDevicesSkippedForDlls) };
         CurDirDevicesSkippedForDlls as u64
      });
      __bindgen_bitfield_unit.set(6usize, 2u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_2 {
   pub VirtualizationFlags: UCHAR,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn ArchStartedInEl2(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ArchStartedInEl2(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ArchStartedInEl2_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ArchStartedInEl2_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn QcSlIsSupported(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_QcSlIsSupported(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn QcSlIsSupported_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_QcSlIsSupported_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ArchStartedInEl2: UCHAR,
      QcSlIsSupported: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ArchStartedInEl2: u8 = unsafe { ::core::mem::transmute(ArchStartedInEl2) };
         ArchStartedInEl2 as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let QcSlIsSupported: u8 = unsafe { ::core::mem::transmute(QcSlIsSupported) };
         QcSlIsSupported as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_3 {
   pub SharedDataFlags: ULONG,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KUSER_SHARED_DATA__bindgen_ty_3__bindgen_ty_1 {
   #[inline]
   pub fn DbgErrorPortPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgErrorPortPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgErrorPortPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgErrorPortPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgElevationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgElevationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgElevationEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgElevationEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgVirtEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgVirtEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgVirtEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgVirtEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgInstallerDetectEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgInstallerDetectEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgInstallerDetectEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgInstallerDetectEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgLkgEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgLkgEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgLkgEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgLkgEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgDynProcessorEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgDynProcessorEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgDynProcessorEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgDynProcessorEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgConsoleBrokerEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgConsoleBrokerEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgConsoleBrokerEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgConsoleBrokerEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgSecureBootEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgSecureBootEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgSecureBootEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgSecureBootEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgMultiSessionSku(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgMultiSessionSku(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgMultiSessionSku_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgMultiSessionSku_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgMultiUsersInSessionSku(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgMultiUsersInSessionSku(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgMultiUsersInSessionSku_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgMultiUsersInSessionSku_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgStateSeparationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgStateSeparationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgStateSeparationEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgStateSeparationEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgSplitTokenEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgSplitTokenEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgSplitTokenEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgSplitTokenEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DbgShadowAdminEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DbgShadowAdminEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DbgShadowAdminEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DbgShadowAdminEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
   }
   #[inline]
   pub fn set_SpareBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 19u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareBits_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            19u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpareBits_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            19u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DbgErrorPortPresent: ULONG,
      DbgElevationEnabled: ULONG,
      DbgVirtEnabled: ULONG,
      DbgInstallerDetectEnabled: ULONG,
      DbgLkgEnabled: ULONG,
      DbgDynProcessorEnabled: ULONG,
      DbgConsoleBrokerEnabled: ULONG,
      DbgSecureBootEnabled: ULONG,
      DbgMultiSessionSku: ULONG,
      DbgMultiUsersInSessionSku: ULONG,
      DbgStateSeparationEnabled: ULONG,
      DbgSplitTokenEnabled: ULONG,
      DbgShadowAdminEnabled: ULONG,
      SpareBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DbgErrorPortPresent: u32 = unsafe { ::core::mem::transmute(DbgErrorPortPresent) };
         DbgErrorPortPresent as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DbgElevationEnabled: u32 = unsafe { ::core::mem::transmute(DbgElevationEnabled) };
         DbgElevationEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DbgVirtEnabled: u32 = unsafe { ::core::mem::transmute(DbgVirtEnabled) };
         DbgVirtEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DbgInstallerDetectEnabled: u32 =
            unsafe { ::core::mem::transmute(DbgInstallerDetectEnabled) };
         DbgInstallerDetectEnabled as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let DbgLkgEnabled: u32 = unsafe { ::core::mem::transmute(DbgLkgEnabled) };
         DbgLkgEnabled as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let DbgDynProcessorEnabled: u32 =
            unsafe { ::core::mem::transmute(DbgDynProcessorEnabled) };
         DbgDynProcessorEnabled as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let DbgConsoleBrokerEnabled: u32 =
            unsafe { ::core::mem::transmute(DbgConsoleBrokerEnabled) };
         DbgConsoleBrokerEnabled as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let DbgSecureBootEnabled: u32 = unsafe { ::core::mem::transmute(DbgSecureBootEnabled) };
         DbgSecureBootEnabled as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let DbgMultiSessionSku: u32 = unsafe { ::core::mem::transmute(DbgMultiSessionSku) };
         DbgMultiSessionSku as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let DbgMultiUsersInSessionSku: u32 =
            unsafe { ::core::mem::transmute(DbgMultiUsersInSessionSku) };
         DbgMultiUsersInSessionSku as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let DbgStateSeparationEnabled: u32 =
            unsafe { ::core::mem::transmute(DbgStateSeparationEnabled) };
         DbgStateSeparationEnabled as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let DbgSplitTokenEnabled: u32 = unsafe { ::core::mem::transmute(DbgSplitTokenEnabled) };
         DbgSplitTokenEnabled as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let DbgShadowAdminEnabled: u32 = unsafe { ::core::mem::transmute(DbgShadowAdminEnabled) };
         DbgShadowAdminEnabled as u64
      });
      __bindgen_bitfield_unit.set(13usize, 19u8, {
         let SpareBits: u32 = unsafe { ::core::mem::transmute(SpareBits) };
         SpareBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_4 {
   pub TickCount: KSYSTEM_TIME,
   pub TickCountQuad: ULONG64,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_4__bindgen_ty_1 {
   pub ReservedTickCountOverlay: [ULONG; 3usize],
   pub TickCountPad: [ULONG; 1usize],
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KUSER_SHARED_DATA__bindgen_ty_5 {
   pub QpcData: USHORT,
   pub __bindgen_anon_1: _KUSER_SHARED_DATA__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KUSER_SHARED_DATA__bindgen_ty_5__bindgen_ty_1 {
   pub QpcBypassEnabled: UCHAR,
   pub QpcReserved: UCHAR,
}
impl Default for _KUSER_SHARED_DATA__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _KUSER_SHARED_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KUSER_SHARED_DATA = _KUSER_SHARED_DATA;
pub type PKUSER_SHARED_DATA = *mut _KUSER_SHARED_DATA;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ATOM_INFORMATION_CLASS {
   AtomBasicInformation = 0,
   AtomTableInformation = 1,
}
pub use self::_ATOM_INFORMATION_CLASS as ATOM_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ATOM_BASIC_INFORMATION {
   pub UsageCount: USHORT,
   pub Flags: USHORT,
   pub NameLength: USHORT,
   pub Name: [WCHAR; 1usize],
}
pub type ATOM_BASIC_INFORMATION = _ATOM_BASIC_INFORMATION;
pub type PATOM_BASIC_INFORMATION = *mut _ATOM_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ATOM_TABLE_INFORMATION {
   pub NumberOfAtoms: ULONG,
   pub Atoms: [RTL_ATOM; 1usize],
}
pub type ATOM_TABLE_INFORMATION = _ATOM_TABLE_INFORMATION;
pub type PATOM_TABLE_INFORMATION = *mut _ATOM_TABLE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SHUTDOWN_ACTION {
   ShutdownNoReboot = 0,
   ShutdownReboot = 1,
   ShutdownPowerOff = 2,
   ShutdownRebootForRecovery = 3,
}
pub use self::_SHUTDOWN_ACTION as SHUTDOWN_ACTION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_MESSAGE_TYPE {
   BCD_MESSAGE_TYPE_NONE = 0,
   BCD_MESSAGE_TYPE_TRACE = 1,
   BCD_MESSAGE_TYPE_INFORMATION = 2,
   BCD_MESSAGE_TYPE_WARNING = 3,
   BCD_MESSAGE_TYPE_ERROR = 4,
   BCD_MESSAGE_TYPE_MAXIMUM = 5,
}
pub use self::_BCD_MESSAGE_TYPE as BCD_MESSAGE_TYPE;
pub type BCD_MESSAGE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(type_: BCD_MESSAGE_TYPE, Message: PCWSTR)>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_IMPORT_FLAGS {
   BCD_IMPORT_NONE = 0,
   BCD_IMPORT_DELETE_FIRMWARE_OBJECTS = 1,
}
pub use self::_BCD_IMPORT_FLAGS as BCD_IMPORT_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_OPEN_FLAGS {
   BCD_OPEN_NONE = 0,
   BCD_OPEN_OPEN_STORE_OFFLINE = 1,
   BCD_OPEN_SYNC_FIRMWARE_ENTRIES = 2,
}
pub use self::_BCD_OPEN_FLAGS as BCD_OPEN_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_OBJECT_TYPE {
   BCD_OBJECT_TYPE_NONE = 0,
   BCD_OBJECT_TYPE_APPLICATION = 1,
   BCD_OBJECT_TYPE_INHERITED = 2,
   BCD_OBJECT_TYPE_DEVICE = 3,
}
pub use self::_BCD_OBJECT_TYPE as BCD_OBJECT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_APPLICATION_OBJECT_TYPE {
   BCD_APPLICATION_OBJECT_NONE = 0,
   BCD_APPLICATION_OBJECT_FIRMWARE_BOOT_MANAGER = 1,
   BCD_APPLICATION_OBJECT_WINDOWS_BOOT_MANAGER = 2,
   BCD_APPLICATION_OBJECT_WINDOWS_BOOT_LOADER = 3,
   BCD_APPLICATION_OBJECT_WINDOWS_RESUME_APPLICATION = 4,
   BCD_APPLICATION_OBJECT_MEMORY_TESTER = 5,
   BCD_APPLICATION_OBJECT_LEGACY_NTLDR = 6,
   BCD_APPLICATION_OBJECT_LEGACY_SETUPLDR = 7,
   BCD_APPLICATION_OBJECT_BOOT_SECTOR = 8,
   BCD_APPLICATION_OBJECT_STARTUP_MODULE = 9,
   BCD_APPLICATION_OBJECT_GENERIC_APPLICATION = 10,
   BCD_APPLICATION_OBJECT_RESERVED = 1048575,
}
pub use self::_BCD_APPLICATION_OBJECT_TYPE as BCD_APPLICATION_OBJECT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_APPLICATION_IMAGE_TYPE {
   BCD_APPLICATION_IMAGE_NONE = 0,
   BCD_APPLICATION_IMAGE_FIRMWARE_APPLICATION = 1,
   BCD_APPLICATION_IMAGE_BOOT_APPLICATION = 2,
   BCD_APPLICATION_IMAGE_LEGACY_LOADER = 3,
   BCD_APPLICATION_IMAGE_REALMODE_CODE = 4,
}
pub use self::_BCD_APPLICATION_IMAGE_TYPE as BCD_APPLICATION_IMAGE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_INHERITED_CLASS_TYPE {
   BCD_INHERITED_CLASS_NONE = 0,
   BCD_INHERITED_CLASS_LIBRARY = 1,
   BCD_INHERITED_CLASS_APPLICATION = 2,
   BCD_INHERITED_CLASS_DEVICE = 3,
}
pub use self::_BCD_INHERITED_CLASS_TYPE as BCD_INHERITED_CLASS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_OBJECT_DATATYPE {
   pub PackedValue: ULONG,
   pub __bindgen_anon_1: _BCD_OBJECT_DATATYPE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_OBJECT_DATATYPE__bindgen_ty_1 {
   pub __bindgen_anon_1: _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_1,
   pub Application: _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_2,
   pub Inherit: _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_3,
   pub Device: _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ObjectType(&self) -> BCD_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ObjectType(&mut self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ObjectType_raw(this: *const Self) -> BCD_OBJECT_TYPE {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ObjectType_raw(this: *mut Self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Reserved: ULONG,
      ObjectType: BCD_OBJECT_TYPE,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 28u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let ObjectType: u32 = unsafe { ::core::mem::transmute(ObjectType) };
         ObjectType as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_2 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_2 {
   #[inline]
   pub fn ApplicationType(&self) -> BCD_APPLICATION_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
   }
   #[inline]
   pub fn set_ApplicationType(&mut self, val: BCD_APPLICATION_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 20u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ApplicationType_raw(this: *const Self) -> BCD_APPLICATION_OBJECT_TYPE {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            20u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ApplicationType_raw(this: *mut Self, val: BCD_APPLICATION_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            20u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageType(&self) -> BCD_APPLICATION_IMAGE_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ImageType(&mut self, val: BCD_APPLICATION_IMAGE_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageType_raw(this: *const Self) -> BCD_APPLICATION_IMAGE_TYPE {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageType_raw(this: *mut Self, val: BCD_APPLICATION_IMAGE_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ObjectType(&self) -> BCD_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ObjectType(&mut self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ObjectType_raw(this: *const Self) -> BCD_OBJECT_TYPE {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ObjectType_raw(this: *mut Self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ApplicationType: BCD_APPLICATION_OBJECT_TYPE,
      ImageType: BCD_APPLICATION_IMAGE_TYPE,
      Reserved: ULONG,
      ObjectType: BCD_OBJECT_TYPE,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 20u8, {
         let ApplicationType: u32 = unsafe { ::core::mem::transmute(ApplicationType) };
         ApplicationType as u64
      });
      __bindgen_bitfield_unit.set(20usize, 4u8, {
         let ImageType: u32 = unsafe { ::core::mem::transmute(ImageType) };
         ImageType as u64
      });
      __bindgen_bitfield_unit.set(24usize, 4u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let ObjectType: u32 = unsafe { ::core::mem::transmute(ObjectType) };
         ObjectType as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_3 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_3 {
   #[inline]
   pub fn Value(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
   }
   #[inline]
   pub fn set_Value(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 20u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Value_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            20u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Value_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            20u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Class(&self) -> BCD_INHERITED_CLASS_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Class(&mut self, val: BCD_INHERITED_CLASS_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Class_raw(this: *const Self) -> BCD_INHERITED_CLASS_TYPE {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Class_raw(this: *mut Self, val: BCD_INHERITED_CLASS_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ObjectType(&self) -> BCD_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ObjectType(&mut self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ObjectType_raw(this: *const Self) -> BCD_OBJECT_TYPE {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ObjectType_raw(this: *mut Self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Value: ULONG,
      Class: BCD_INHERITED_CLASS_TYPE,
      Reserved: ULONG,
      ObjectType: BCD_OBJECT_TYPE,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 20u8, {
         let Value: u32 = unsafe { ::core::mem::transmute(Value) };
         Value as u64
      });
      __bindgen_bitfield_unit.set(20usize, 4u8, {
         let Class: u32 = unsafe { ::core::mem::transmute(Class) };
         Class as u64
      });
      __bindgen_bitfield_unit.set(24usize, 4u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let ObjectType: u32 = unsafe { ::core::mem::transmute(ObjectType) };
         ObjectType as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_4 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_OBJECT_DATATYPE__bindgen_ty_1__bindgen_ty_4 {
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ObjectType(&self) -> BCD_OBJECT_TYPE {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ObjectType(&mut self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ObjectType_raw(this: *const Self) -> BCD_OBJECT_TYPE {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ObjectType_raw(this: *mut Self, val: BCD_OBJECT_TYPE) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Reserved: ULONG,
      ObjectType: BCD_OBJECT_TYPE,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 28u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let ObjectType: u32 = unsafe { ::core::mem::transmute(ObjectType) };
         ObjectType as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _BCD_OBJECT_DATATYPE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_OBJECT_DATATYPE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_OBJECT_DATATYPE = _BCD_OBJECT_DATATYPE;
pub type PBCD_OBJECT_DATATYPE = *mut _BCD_OBJECT_DATATYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_OBJECT_DESCRIPTION {
   pub Version: ULONG,
   pub Type: ULONG,
}
pub type BCD_OBJECT_DESCRIPTION = _BCD_OBJECT_DESCRIPTION;
pub type PBCD_OBJECT_DESCRIPTION = *mut _BCD_OBJECT_DESCRIPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_OBJECT {
   pub Identifer: GUID,
   pub Description: PBCD_OBJECT_DESCRIPTION,
}
impl Default for _BCD_OBJECT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_OBJECT = _BCD_OBJECT;
pub type PBCD_OBJECT = *mut _BCD_OBJECT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_COPY_FLAGS {
   BCD_COPY_NONE = 0,
   BCD_COPY_COPY_CREATE_NEW_OBJECT_IDENTIFIER = 1,
   BCD_COPY_COPY_DELETE_EXISTING_OBJECT = 2,
   BCD_COPY_COPY_UNKNOWN_FIRMWARE_APPLICATION = 4,
   BCD_COPY_IGNORE_SETUP_TEMPLATE_ELEMENTS = 8,
   BCD_COPY_RETAIN_ELEMENT_DATA = 16,
   BCD_COPY_MIGRATE_ELEMENT_DATA = 32,
}
pub use self::_BCD_COPY_FLAGS as BCD_COPY_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_ELEMENT_DATATYPE_FORMAT {
   BCD_ELEMENT_DATATYPE_FORMAT_UNKNOWN = 0,
   BCD_ELEMENT_DATATYPE_FORMAT_DEVICE = 1,
   BCD_ELEMENT_DATATYPE_FORMAT_STRING = 2,
   BCD_ELEMENT_DATATYPE_FORMAT_OBJECT = 3,
   BCD_ELEMENT_DATATYPE_FORMAT_OBJECTLIST = 4,
   BCD_ELEMENT_DATATYPE_FORMAT_INTEGER = 5,
   BCD_ELEMENT_DATATYPE_FORMAT_BOOLEAN = 6,
   BCD_ELEMENT_DATATYPE_FORMAT_INTEGERLIST = 7,
   BCD_ELEMENT_DATATYPE_FORMAT_BINARY = 8,
}
pub use self::_BCD_ELEMENT_DATATYPE_FORMAT as BCD_ELEMENT_DATATYPE_FORMAT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_ELEMENT_DATATYPE_CLASS {
   BCD_ELEMENT_DATATYPE_CLASS_NONE = 0,
   BCD_ELEMENT_DATATYPE_CLASS_LIBRARY = 1,
   BCD_ELEMENT_DATATYPE_CLASS_APPLICATION = 2,
   BCD_ELEMENT_DATATYPE_CLASS_DEVICE = 3,
   BCD_ELEMENT_DATATYPE_CLASS_SETUPTEMPLATE = 4,
   BCD_ELEMENT_DATATYPE_CLASS_OEM = 5,
}
pub use self::_BCD_ELEMENT_DATATYPE_CLASS as BCD_ELEMENT_DATATYPE_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_ELEMENT_DEVICE_TYPE {
   BCD_ELEMENT_DEVICE_TYPE_NONE = 0,
   BCD_ELEMENT_DEVICE_TYPE_BOOT_DEVICE = 1,
   BCD_ELEMENT_DEVICE_TYPE_PARTITION = 2,
   BCD_ELEMENT_DEVICE_TYPE_FILE = 3,
   BCD_ELEMENT_DEVICE_TYPE_RAMDISK = 4,
   BCD_ELEMENT_DEVICE_TYPE_UNKNOWN = 5,
   BCD_ELEMENT_DEVICE_TYPE_QUALIFIED_PARTITION = 6,
   BCD_ELEMENT_DEVICE_TYPE_VMBUS = 7,
   BCD_ELEMENT_DEVICE_TYPE_LOCATE_DEVICE = 8,
   BCD_ELEMENT_DEVICE_TYPE_URI = 9,
   BCD_ELEMENT_DEVICE_TYPE_COMPOSITE = 10,
}
pub use self::_BCD_ELEMENT_DEVICE_TYPE as BCD_ELEMENT_DEVICE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DATATYPE {
   pub PackedValue: ULONG,
   pub __bindgen_anon_1: _BCD_ELEMENT_DATATYPE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_ELEMENT_DATATYPE__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _BCD_ELEMENT_DATATYPE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _BCD_ELEMENT_DATATYPE__bindgen_ty_1 {
   #[inline]
   pub fn SubType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_SubType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SubType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SubType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Format(&self) -> BCD_ELEMENT_DATATYPE_FORMAT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Format(&mut self, val: BCD_ELEMENT_DATATYPE_FORMAT) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Format_raw(this: *const Self) -> BCD_ELEMENT_DATATYPE_FORMAT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Format_raw(this: *mut Self, val: BCD_ELEMENT_DATATYPE_FORMAT) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Class(&self) -> BCD_ELEMENT_DATATYPE_CLASS {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Class(&mut self, val: BCD_ELEMENT_DATATYPE_CLASS) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Class_raw(this: *const Self) -> BCD_ELEMENT_DATATYPE_CLASS {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Class_raw(this: *mut Self, val: BCD_ELEMENT_DATATYPE_CLASS) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SubType: ULONG,
      Format: BCD_ELEMENT_DATATYPE_FORMAT,
      Class: BCD_ELEMENT_DATATYPE_CLASS,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 24u8, {
         let SubType: u32 = unsafe { ::core::mem::transmute(SubType) };
         SubType as u64
      });
      __bindgen_bitfield_unit.set(24usize, 4u8, {
         let Format: u32 = unsafe { ::core::mem::transmute(Format) };
         Format as u64
      });
      __bindgen_bitfield_unit.set(28usize, 4u8, {
         let Class: u32 = unsafe { ::core::mem::transmute(Class) };
         Class as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _BCD_ELEMENT_DATATYPE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT_DATATYPE = _BCD_ELEMENT_DATATYPE;
pub type PBCD_ELEMENT_DATATYPE = *mut _BCD_ELEMENT_DATATYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION {
   pub PartitionStyle: ULONG,
   pub Reserved: ULONG,
   pub __bindgen_anon_1: _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1 {
   pub Mbr: _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_1,
   pub Gpt: _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_1 {
   pub DiskSignature: ULONG,
   pub PartitionOffset: ULONG64,
}
impl Default for _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_2 {
   pub DiskSignature: GUID,
   pub PartitionSignature: GUID,
}
impl Default for _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION = _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION;
pub type PBCD_ELEMENT_DEVICE_QUALIFIED_PARTITION = *mut _BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BCD_ELEMENT_DEVICE {
   pub DeviceType: ULONG,
   pub AdditionalOptions: GUID,
   pub __bindgen_anon_1: _BCD_ELEMENT_DEVICE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BCD_ELEMENT_DEVICE__bindgen_ty_1 {
   pub File: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_1,
   pub Partition: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_2,
   pub Locate: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_3,
   pub Vmbus: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_4,
   pub Unknown: _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_5,
   pub QualifiedPartition: BCD_ELEMENT_DEVICE_QUALIFIED_PARTITION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_1 {
   pub ParentOffset: ULONG,
   pub Path: [WCHAR; 1usize],
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_2 {
   pub Path: [WCHAR; 1usize],
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_3 {
   pub Type: ULONG,
   pub ParentOffset: ULONG,
   pub ElementType: ULONG,
   pub Path: [WCHAR; 1usize],
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_4 {
   pub InterfaceInstance: GUID,
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_5 {
   pub Data: [ULONG; 1usize],
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_ELEMENT_DEVICE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _BCD_ELEMENT_DEVICE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT_DEVICE = _BCD_ELEMENT_DEVICE;
pub type PBCD_ELEMENT_DEVICE = *mut _BCD_ELEMENT_DEVICE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_STRING {
   pub Value: [WCHAR; 1usize],
}
pub type BCD_ELEMENT_STRING = _BCD_ELEMENT_STRING;
pub type PBCD_ELEMENT_STRING = *mut _BCD_ELEMENT_STRING;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_OBJECT {
   pub Object: GUID,
}
pub type BCD_ELEMENT_OBJECT = _BCD_ELEMENT_OBJECT;
pub type PBCD_ELEMENT_OBJECT = *mut _BCD_ELEMENT_OBJECT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_OBJECT_LIST {
   pub ObjectList: [GUID; 1usize],
}
pub type BCD_ELEMENT_OBJECT_LIST = _BCD_ELEMENT_OBJECT_LIST;
pub type PBCD_ELEMENT_OBJECT_LIST = *mut _BCD_ELEMENT_OBJECT_LIST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_INTEGER {
   pub Value: ULONG64,
}
pub type BCD_ELEMENT_INTEGER = _BCD_ELEMENT_INTEGER;
pub type PBCD_ELEMENT_INTEGER = *mut _BCD_ELEMENT_INTEGER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _BCD_ELEMENT_INTEGER_LIST {
   pub Value: [ULONG64; 1usize],
}
pub type BCD_ELEMENT_INTEGER_LIST = _BCD_ELEMENT_INTEGER_LIST;
pub type PBCD_ELEMENT_INTEGER_LIST = *mut _BCD_ELEMENT_INTEGER_LIST;
#[repr(C)]
pub struct _BCD_ELEMENT_BOOLEAN {
   pub Value: BOOLEAN,
}
impl Default for _BCD_ELEMENT_BOOLEAN {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT_BOOLEAN = _BCD_ELEMENT_BOOLEAN;
pub type PBCD_ELEMENT_BOOLEAN = *mut _BCD_ELEMENT_BOOLEAN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BCD_ELEMENT_DESCRIPTION {
   pub Version: ULONG,
   pub Type: ULONG,
   pub DataSize: ULONG,
}
pub type PBCD_ELEMENT_DESCRIPTION = *mut BCD_ELEMENT_DESCRIPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCD_ELEMENT {
   pub Description: PBCD_ELEMENT_DESCRIPTION,
   pub Data: PVOID,
}
impl Default for _BCD_ELEMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type BCD_ELEMENT = _BCD_ELEMENT;
pub type PBCD_ELEMENT = *mut _BCD_ELEMENT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BCD_FLAGS {
   BCD_FLAG_NONE = 0,
   BCD_FLAG_QUALIFIED_PARTITION = 1,
   BCD_FLAG_NO_DEVICE_TRANSLATION = 2,
   BCD_FLAG_ENUMERATE_INHERITED_OBJECTS = 4,
   BCD_FLAG_ENUMERATE_DEVICE_OPTIONS = 8,
   BCD_FLAG_OBSERVE_PRECEDENCE = 16,
   BCD_FLAG_DISABLE_VHD_NT_TRANSLATION = 32,
   BCD_FLAG_DISABLE_VHD_DEVICE_DETECTION = 64,
   BCD_FLAG_DISABLE_POLICY_CHECKS = 128,
}
pub use self::_BCD_FLAGS as BCD_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[doc = "BCD configuration elements for the Boot Manager types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdBootMgrElementTypes {
   #[doc = "The order in which BCD objects should be displayed. [0x24000001]\nObjects are displayed using the string specified by the BcdLibraryString_Description element."]
   BcdBootMgrObjectList_DisplayOrder = 603979777,
   #[doc = "List of boot environment applications the boot manager should execute. [0x24000002]\nThe applications are executed in the order they appear in this list.\nIf the firmware boot manager does not support loading multiple applications, this list cannot contain more than one entry."]
   BcdBootMgrObjectList_BootSequence = 603979778,
   #[doc = "The default boot environment application to load if the user does not select one. [0x23000003]"]
   BcdBootMgrObject_DefaultObject = 587202563,
   #[doc = "The maximum number of seconds a boot selection menu is to be displayed to the user. [0x25000004]\nThe menu is displayed until the user selects an option or the time-out expires.\nIf this value is not specified, the boot manager waits for the user to make a selection."]
   BcdBootMgrInteger_Timeout = 620756996,
   #[doc = "Indicates that a resume operation should be attempted during a system restart. [0x26000005]"]
   BcdBootMgrBoolean_AttemptResume = 637534213,
   #[doc = "The resume application object. [0x23000006]"]
   BcdBootMgrObject_ResumeObject = 587202566,
   #[doc = "The startup sequence. [0x24000007]"]
   BcdBootMgrObjectList_StartupSequence = 603979783,
   #[doc = "The boot manager tools display order list. [0x24000010]"]
   BcdBootMgrObjectList_ToolsDisplayOrder = 603979792,
   #[doc = "Forces the display of the legacy boot menu, regardless of the number of OS entries in the BCD store and their BcdOSLoaderInteger_BootMenuPolicy. [0x26000020]"]
   BcdBootMgrBoolean_DisplayBootMenu = 637534240,
   #[doc = "Indicates whether the display of errors should be suppressed. If this setting is enabled, the boot manager exits to the multi-OS menu on OS launch error. [0x26000021]"]
   BcdBootMgrBoolean_NoErrorDisplay = 637534241,
   #[doc = "The device on which the boot application resides. [0x21000022]"]
   BcdBootMgrDevice_BcdDevice = 553648162,
   #[doc = "The boot application. [0x22000023] (BCDE_BOOTMGR_TYPE_BCD_FILEPATH)"]
   BcdBootMgrString_BcdFilePath = 570425379,
   #[doc = "Indicates whether HORM (Hibernate Once/Resume Many) is enabled. [0x26000024]"]
   BcdBootMgrBoolean_HormEnabled = 637534244,
   #[doc = "Indicates whether the system is in hibernation root mode. [0x26000025]"]
   BcdBootMgrBoolean_HiberRoot = 637534245,
   #[doc = "The password override string. [0x22000026]"]
   BcdBootMgrString_PasswordOverride = 570425382,
   #[doc = "The PIN/passphrase override string. [0x22000027]"]
   BcdBootMgrString_PinpassPhraseOverride = 570425383,
   #[doc = "Controls whether custom actions are processed before a boot sequence. Note This value is supported starting in Windows 8 and Windows Server 2012. [0x26000028]"]
   BcdBootMgrBoolean_ProcessCustomActionsFirst = 637534248,
   #[doc = "Custom Bootstrap Actions. [0x27000030] (BCDE_BOOTMGR_TYPE_CUSTOM_ACTIONS_LIST)"]
   BcdBootMgrIntegerList_CustomActionsList = 654311472,
   #[doc = "Controls whether a boot sequence persists across multiple boots. Note This value is supported starting in Windows 8 and Windows Server 2012. [0x26000031]"]
   BcdBootMgrBoolean_PersistBootSequence = 637534257,
   #[doc = "Indicates whether to skip the startup sequence. [0x26000032]"]
   BcdBootMgrBoolean_SkipStartupSequence = 637534258,
}
#[doc = "BCD configuration elements for the Boot Manager types."]
pub use self::_BcdBootMgrElementTypes as BcdBootMgrElementTypes;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Specifies the policy for using the first megabyte of memory."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_FirstMegabytePolicy {
   FirstMegabytePolicyUseNone = 0,
   FirstMegabytePolicyUseAll = 1,
   FirstMegabytePolicyUsePrivate = 2,
}
#[doc = "Specifies the policy for using the first megabyte of memory."]
pub use self::_BcdLibrary_FirstMegabytePolicy as BcdLibrary_FirstMegabytePolicy;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Specifies the type of debugger."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_DebuggerType {
   DebuggerSerial = 0,
   Debugger1394 = 1,
   DebuggerUsb = 2,
   DebuggerNet = 3,
   DebuggerLocal = 4,
}
#[doc = "Specifies the type of debugger."]
pub use self::_BcdLibrary_DebuggerType as BcdLibrary_DebuggerType;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Specifies the start policy for the debugger."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_DebuggerStartPolicy {
   DebuggerStartActive = 0,
   #[doc = "The debugger will start in the auto-enabled state.\nIf a debugger is attached it will be used; otherwise the debugger port will be available for other applications."]
   DebuggerStartAutoEnable = 1,
   #[doc = "The debugger will start in the auto-enabled state.\nIf a debugger is attached it will be used; otherwise the debugger port will be available for other applications."]
   DebuggerStartDisable = 2,
}
#[doc = "Specifies the start policy for the debugger."]
pub use self::_BcdLibrary_DebuggerStartPolicy as BcdLibrary_DebuggerStartPolicy;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Specifies the access policy for PCI configuration space."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_ConfigAccessPolicy {
   #[doc = "Access to PCI configuration space through the memory-mapped region is allowed."]
   ConfigAccessPolicyDefault = 0,
   #[doc = "Access to PCI configuration space through the memory-mapped region is not allowed.\nThis setting is used for platforms that implement memory-mapped configuration space incorrectly.\nThe CFC/CF8 access mechanism can be used to access configuration space on these platforms."]
   ConfigAccessPolicyDisallowMmConfig = 1,
}
#[doc = "Specifies the access policy for PCI configuration space."]
pub use self::_BcdLibrary_ConfigAccessPolicy as BcdLibrary_ConfigAccessPolicy;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Enumeration for UX Display Message Types in the Boot Configuration Data (BCD) library.\nThis enumeration defines the different UX display message types that can be specified in the BCD library."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_UxDisplayMessageType {
   #[doc = "< Default display message type."]
   DisplayMessageTypeDefault = 0,
   #[doc = "< Display message type for resume."]
   DisplayMessageTypeResume = 1,
   #[doc = "< Display message type for Hyper-V."]
   DisplayMessageTypeHyperV = 2,
   #[doc = "< Display message type for recovery."]
   DisplayMessageTypeRecovery = 3,
   #[doc = "< Display message type for startup repair."]
   DisplayMessageTypeStartupRepair = 4,
   #[doc = "< Display message type for system image recovery."]
   DisplayMessageTypeSystemImageRecovery = 5,
   #[doc = "< Display message type for command prompt."]
   DisplayMessageTypeCommandPrompt = 6,
   #[doc = "< Display message type for system restore."]
   DisplayMessageTypeSystemRestore = 7,
   #[doc = "< Display message type for push button reset."]
   DisplayMessageTypePushButtonReset = 8,
}
#[doc = "Enumeration for UX Display Message Types in the Boot Configuration Data (BCD) library.\nThis enumeration defines the different UX display message types that can be specified in the BCD library."]
pub use self::_BcdLibrary_UxDisplayMessageType as BcdLibrary_UxDisplayMessageType;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Enumeration for Safe Boot options in the Boot Configuration Data (BCD) library.\nThis enumeration defines the different safe boot modes that can be specified in the BCD library."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BcdLibrary_SafeBoot {
   #[doc = "Load the drivers and services specified by name or group under the following registry key:\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Minimal. "]
   SafemodeMinimal = 0,
   #[doc = "Load the drivers and services specified by name or group under the following registry key:\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Network. "]
   SafemodeNetwork = 1,
   #[doc = "Boot the system into a repair mode that restores the Active Directory service from backup medium."]
   SafemodeDsRepair = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibrary_BootUxPolicy {
   BootUxPolicyDisabled = 0,
   BootUxPolicyBasic = 1,
   BootUxPolicyStandard = 2,
}
pub use self::_BcdLibrary_BootUxPolicy as BcdLibrary_BootUxPolicy;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdLibraryElementTypes {
   #[doc = "<summary>\nDevice on which a boot environment application resides.\n</summary>\n<remarks>0x11000001</remarks>"]
   BcdLibraryDevice_ApplicationDevice = 285212673,
   #[doc = "<summary>\nPath to a boot environment application.\n</summary>\n<remarks>0x12000002</remarks>"]
   BcdLibraryString_ApplicationPath = 301989890,
   #[doc = "<summary>\nDisplay name of the boot environment application.\n</summary>\n<remarks>0x12000004</remarks>"]
   BcdLibraryString_Description = 301989892,
   #[doc = "<summary>\nPreferred locale, in RFC 3066 format.\n</summary>\n<remarks>0x12000005</remarks>"]
   BcdLibraryString_PreferredLocale = 301989893,
   #[doc = "<summary>\nList of BCD objects from which the current object should inherit elements.\n</summary>\n<remarks>0x14000006</remarks>"]
   BcdLibraryObjectList_InheritedObjects = 335544326,
   #[doc = "<summary>\nMaximum physical address a boot environment application should recognize. All memory above this address is ignored.\n</summary>\n<remarks>0x15000007</remarks>"]
   BcdLibraryInteger_TruncatePhysicalMemory = 352321543,
   #[doc = "<summary>\nList of boot environment applications to be executed if the associated application fails. The applications are executed in the order they appear in this list.\n</summary>\n<remarks>0x14000008</remarks>"]
   BcdLibraryObjectList_RecoverySequence = 335544328,
   #[doc = "<summary>\nIndicates whether the recovery sequence executes automatically if the boot application fails. Otherwise, the recovery sequence only runs on demand.\n</summary>\n<remarks>0x16000009</remarks>"]
   BcdLibraryBoolean_AutoRecoveryEnabled = 369098761,
   #[doc = "<summary>\nList of page frame numbers describing faulty memory in the system.\n</summary>\n<remarks>0x1700000A</remarks>"]
   BcdLibraryIntegerList_BadMemoryList = 385875978,
   #[doc = "<summary>\nIf TRUE, indicates that a boot application can use memory listed in the BcdLibraryIntegerList_BadMemoryList.\n</summary>\n<remarks>0x1600000B</remarks>"]
   BcdLibraryBoolean_AllowBadMemoryAccess = 369098763,
   #[doc = "<summary>\nIndicates how the first megabyte of memory is to be used. The Integer property is one of the values from the BcdLibrary_FirstMegabytePolicy enumeration. (BCDE_POLICY_LIBRARY_TYPE_FIRST_MEGABYTE_POLICY)\n</summary>\n<remarks>0x1500000C</remarks>"]
   BcdLibraryInteger_FirstMegabytePolicy = 352321548,
   #[doc = "<summary>\nRelocates physical memory on certain AMD processors.\nThis value is not used in Windows 8 or Windows Server 2012.\n</summary>\n<remarks>0x1500000D</remarks>"]
   BcdLibraryInteger_RelocatePhysicalMemory = 352321549,
   #[doc = "<summary>\nSpecifies a minimum physical address to use in the boot environment.\n</summary>\n<remarks>0x1500000E</remarks>"]
   BcdLibraryInteger_AvoidLowPhysicalMemory = 352321550,
   #[doc = "<summary>\n</summary>\n<remarks>0x1600000F</remarks>"]
   BcdLibraryBoolean_TraditionalKsegMappings = 369098767,
   #[doc = "<summary>\nIndicates whether the boot debugger should be enabled.\n</summary>\n<remarks>0x16000010</remarks>"]
   BcdLibraryBoolean_DebuggerEnabled = 369098768,
   #[doc = "<summary>\nDebugger type. The Integer property is one of the values from the BcdLibrary_DebuggerType enumeration.\n</summary>\n<remarks>0x15000011</remarks>"]
   BcdLibraryInteger_DebuggerType = 352321553,
   #[doc = "<summary>\nI/O port address for the serial debugger.\n</summary>\n<remarks>0x15000012</remarks>"]
   BcdLibraryInteger_SerialDebuggerPortAddress = 352321554,
   #[doc = "<summary>\nSerial port number for serial debugging.\nIf this value is not specified, the default is specified by the DBGP ACPI table settings.\n</summary>\n<remarks>0x15000013</remarks>"]
   BcdLibraryInteger_SerialDebuggerPort = 352321555,
   #[doc = "<summary>\nBaud rate for serial debugging.\n</summary>\n<remarks>0x15000014</remarks>"]
   BcdLibraryInteger_SerialDebuggerBaudRate = 352321556,
   #[doc = "<summary>\nChannel number for 1394 debugging.\n</summary>\n<remarks>0x15000015</remarks>"]
   BcdLibraryInteger_1394DebuggerChannel = 352321557,
   #[doc = "<summary>\nThe target name for the USB debugger. The target name is arbitrary but must match between the debugger and the debug target.\n</summary>\n<remarks>0x12000016</remarks>"]
   BcdLibraryString_UsbDebuggerTargetName = 301989910,
   #[doc = "<summary>\nIf TRUE, the debugger will ignore user mode exceptions and only stop for kernel mode exceptions.\n</summary>\n<remarks>0x16000017</remarks>"]
   BcdLibraryBoolean_DebuggerIgnoreUsermodeExceptions = 369098775,
   #[doc = "<summary>\nIndicates the debugger start policy. The Integer property is one of the values from the BcdLibrary_DebuggerStartPolicy enumeration.\n</summary>\n<remarks>0x15000018</remarks>"]
   BcdLibraryInteger_DebuggerStartPolicy = 352321560,
   #[doc = "<summary>\nDefines the PCI bus, device, and function numbers of the debugging device. For example, 1.5.0 describes the debugging device on bus 1, device 5, function 0.\n</summary>\n<remarks>0x12000019</remarks>"]
   BcdLibraryString_DebuggerBusParameters = 301989913,
   #[doc = "<summary>\nDefines the host IP address for the network debugger.\n</summary>\n<remarks>0x1500001A</remarks>"]
   BcdLibraryInteger_DebuggerNetHostIP = 352321562,
   #[doc = "<summary>\nDefines the network port for the network debugger.\n</summary>\n<remarks>0x1500001B</remarks>"]
   BcdLibraryInteger_DebuggerNetPort = 352321563,
   #[doc = "<summary>\nControls the use of DHCP by the network debugger. Setting this to false causes the OS to only use link-local addresses.\nThis value is supported starting in Windows 8 and Windows Server 2012.\n</summary>\n<remarks>0x1600001C</remarks>"]
   BcdLibraryBoolean_DebuggerNetDhcp = 369098780,
   #[doc = "<summary>\nHolds the key used to encrypt the network debug connection.\nThis value is supported starting in Windows 8 and Windows Server 2012.\n</summary>\n<remarks>0x1200001D</remarks>"]
   BcdLibraryString_DebuggerNetKey = 301989917,
   #[doc = "<summary>\n</summary>\n<remarks>0x1600001E</remarks>"]
   BcdLibraryBoolean_DebuggerNetVM = 369098782,
   #[doc = "<summary>\n</summary>\n<remarks>0x1200001F</remarks>"]
   BcdLibraryString_DebuggerNetHostIpv6 = 301989919,
   #[doc = "<summary>\nIndicates whether EMS redirection should be enabled.\n</summary>\n<remarks>0x16000020</remarks>"]
   BcdLibraryBoolean_EmsEnabled = 369098784,
   #[doc = "<summary>\nCOM port number for EMS redirection.\n</summary>\n<remarks>0x15000022</remarks>"]
   BcdLibraryInteger_EmsPort = 352321570,
   #[doc = "<summary>\nBaud rate for EMS redirection.\n</summary>\n<remarks>0x15000023</remarks>"]
   BcdLibraryInteger_EmsBaudRate = 352321571,
   #[doc = "<summary>\nString that is appended to the load options string passed to the kernel to be consumed by kernel-mode components.\nThis is useful for communicating with kernel-mode components that are not BCD-aware.\n</summary>\n<remarks>0x12000030</remarks>"]
   BcdLibraryString_LoadOptionsString = 301989936,
   #[doc = "<summary>\n</summary>\n<remarks>0x16000031</remarks>"]
   BcdLibraryBoolean_AttemptNonBcdStart = 369098801,
   #[doc = "<summary>\nIndicates whether the advanced options boot menu (F8) is displayed.\n</summary>\n<remarks>0x16000040</remarks>"]
   BcdLibraryBoolean_DisplayAdvancedOptions = 369098816,
   #[doc = "<summary>\nIndicates whether the boot options editor is enabled.\n</summary>\n<remarks>0x16000041</remarks>"]
   BcdLibraryBoolean_DisplayOptionsEdit = 369098817,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000042</remarks>"]
   BcdLibraryInteger_FVEKeyRingAddress = 352321602,
   #[doc = "<summary>\nAllows a device override for the bootstat.dat log in the boot manager and winload.exe.\n</summary>\n<remarks>0x11000043</remarks>"]
   BcdLibraryDevice_BsdLogDevice = 285212739,
   #[doc = "<summary>\nAllows a path override for the bootstat.dat log file in the boot manager and winload.exe.\n</summary>\n<remarks>0x12000044</remarks>"]
   BcdLibraryString_BsdLogPath = 301989956,
   #[doc = "<summary>\nIndicates whether graphics mode is disabled and boot applications must use text mode display.\n</summary>\n<remarks>0x16000045</remarks>"]
   BcdLibraryBoolean_BsdPreserveLog = 369098821,
   #[doc = "<summary>\n</summary>\n<remarks>0x16000046</remarks>"]
   BcdLibraryBoolean_GraphicsModeDisabled = 369098822,
   #[doc = "<summary>\nIndicates the access policy for PCI configuration space.\n</summary>\n<remarks>0x15000047</remarks>"]
   BcdLibraryInteger_ConfigAccessPolicy = 352321607,
   #[doc = "<summary>\nDisables integrity checks.\nCannot be set when secure boot is enabled.\nThis value is ignored by Windows 7 and Windows 8.\n</summary>\n<remarks>0x16000048</remarks>"]
   BcdLibraryBoolean_DisableIntegrityChecks = 369098824,
   #[doc = "<summary>\nIndicates whether the test code signing certificate is supported.\n</summary>\n<remarks>0x16000049</remarks>"]
   BcdLibraryBoolean_AllowPrereleaseSignatures = 369098825,
   #[doc = "<summary>\nOverrides the default location of the boot fonts.\n</summary>\n<remarks>0x1200004A</remarks>"]
   BcdLibraryString_FontPath = 301989962,
   #[doc = "<summary>\n</summary>\n<remarks>0x1500004B</remarks>"]
   BcdLibraryInteger_SiPolicy = 352321611,
   #[doc = "<summary>\nThis value (if present) should not be modified.\n</summary>\n<remarks>0x1500004C</remarks>"]
   BcdLibraryInteger_FveBandId = 352321612,
   #[doc = "<summary>\nSpecifies that legacy BIOS systems should use INT 16h Function 10h for console input instead of INT 16h Function 0h.\n</summary>\n<remarks>0x16000050</remarks>"]
   BcdLibraryBoolean_ConsoleExtendedInput = 369098832,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000051</remarks>"]
   BcdLibraryInteger_InitialConsoleInput = 352321617,
   #[doc = "<summary>\nForces a specific graphics resolution at boot.\nPossible values include GraphicsResolution1024x768 (0), GraphicsResolution800x600 (1), and GraphicsResolution1024x600 (2).\n</summary>\n<remarks>0x15000052</remarks>"]
   BcdLibraryInteger_GraphicsResolution = 352321618,
   #[doc = "<summary>\nIf enabled, specifies that boot error screens are not shown when OS launch errors occur, and the system is reset rather than exiting directly back to the firmware.\n</summary>\n<remarks>0x16000053</remarks>"]
   BcdLibraryBoolean_RestartOnFailure = 369098835,
   #[doc = "<summary>\nForces highest available graphics resolution at boot.\nThis value can only be used on UEFI systems.\nThis value is supported starting in Windows 8 and Windows Server 2012.\n</summary>\n<remarks>0x16000054</remarks>"]
   BcdLibraryBoolean_GraphicsForceHighestMode = 369098836,
   #[doc = "<summary>\nThis setting is used to differentiate between the Windows 7 and Windows 8 implementations of UEFI.\nDo not modify this setting.\nIf this setting is removed from a Windows 8 installation, it will not boot.\nIf this setting is added to a Windows 7 installation, it will not boot.\n</summary>\n<remarks>0x16000060</remarks>"]
   BcdLibraryBoolean_IsolatedExecutionContext = 369098848,
   #[doc = "<summary>\nThis setting disables the progress bar and default Windows logo. If a custom text string has been defined, it is also disabled by this setting.\nThe Integer property is one of the values from the BcdLibrary_UxDisplayMessageType enumeration.\n</summary>\n<remarks>0x15000065</remarks>"]
   BcdLibraryInteger_BootUxDisplayMessage = 352321637,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000066</remarks>"]
   BcdLibraryInteger_BootUxDisplayMessageOverride = 352321638,
   #[doc = "<summary>\nThis setting disables the boot logo.\n</summary>\n<remarks>0x16000067</remarks>"]
   BcdLibraryBoolean_BootUxLogoDisable = 369098855,
   #[doc = "<summary>\nThis setting disables the boot status text.\n</summary>\n<remarks>0x16000068</remarks>"]
   BcdLibraryBoolean_BootUxTextDisable = 369098856,
   #[doc = "<summary>\nThis setting disables the boot progress bar.\n</summary>\n<remarks>0x16000069</remarks>"]
   BcdLibraryBoolean_BootUxProgressDisable = 369098857,
   #[doc = "<summary>\nThis setting disables the boot transition fading.\n</summary>\n<remarks>0x1600006A</remarks>"]
   BcdLibraryBoolean_BootUxFadeDisable = 369098858,
   #[doc = "<summary>\n</summary>\n<remarks>0x1600006B</remarks>"]
   BcdLibraryBoolean_BootUxReservePoolDebug = 369098859,
   #[doc = "<summary>\n</summary>\n<remarks>0x1600006C</remarks>"]
   BcdLibraryBoolean_BootUxDisable = 369098860,
   #[doc = "<summary>\n</summary>\n<remarks>0x1500006D</remarks>"]
   BcdLibraryInteger_BootUxFadeFrames = 352321645,
   #[doc = "<summary>\n</summary>\n<remarks>0x1600006E</remarks>"]
   BcdLibraryBoolean_BootUxDumpStats = 369098862,
   #[doc = "<summary>\n</summary>\n<remarks>0x1600006F</remarks>"]
   BcdLibraryBoolean_BootUxShowStats = 369098863,
   #[doc = "<summary>\n</summary>\n<remarks>0x16000071</remarks>"]
   BcdLibraryBoolean_MultiBootSystem = 369098865,
   #[doc = "<summary>\n</summary>\n<remarks>0x16000072</remarks>"]
   BcdLibraryBoolean_ForceNoKeyboard = 369098866,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000073</remarks>"]
   BcdLibraryInteger_AliasWindowsKey = 352321651,
   #[doc = "<summary>\nDisables the 1-minute timer that triggers shutdown on boot error screens, and the F8 menu, on UEFI systems.\n</summary>\n<remarks>0x16000074</remarks>"]
   BcdLibraryBoolean_BootShutdownDisabled = 369098868,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000075</remarks>"]
   BcdLibraryInteger_PerformanceFrequency = 352321653,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000076</remarks>"]
   BcdLibraryInteger_SecurebootRawPolicy = 352321654,
   #[doc = "<summary>\nIndicates whether or not an in-memory BCD setting passed between boot apps will trigger BitLocker recovery.\nThis value should not be modified as it could trigger a BitLocker recovery action.\n</summary>\n<remarks>0x17000077</remarks>"]
   BcdLibraryIntegerList_AllowedInMemorySettings = 352321655,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000079</remarks>"]
   BcdLibraryInteger_BootUxBitmapTransitionTime = 352321657,
   #[doc = "<summary>\n</summary>\n<remarks>0x1600007A</remarks>"]
   BcdLibraryBoolean_TwoBootImages = 369098874,
   #[doc = "<summary>\nForce the use of FIPS cryptography checks on boot applications.\nBcdLibraryBoolean_ForceFipsCrypto is documented with wrong value 0x16000079\n</summary>\n<remarks>0x1600007B</remarks>"]
   BcdLibraryBoolean_ForceFipsCrypto = 369098875,
   #[doc = "<summary>\n</summary>\n<remarks>0x1500007D</remarks>"]
   BcdLibraryInteger_BootErrorUx = 352321661,
   #[doc = "<summary>\n</summary>\n<remarks>0x1600007E</remarks>"]
   BcdLibraryBoolean_AllowFlightSignatures = 369098878,
   #[doc = "<summary>\n</summary>\n<remarks>0x1500007F</remarks>"]
   BcdLibraryInteger_BootMeasurementLogFormat = 352321663,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000080</remarks>"]
   BcdLibraryInteger_DisplayRotation = 352321664,
   #[doc = "<summary>\n</summary>\n<remarks>0x15000081</remarks>"]
   BcdLibraryInteger_LogControl = 352321665,
   #[doc = "<summary>\n</summary>\n<remarks>0x16000082</remarks>"]
   BcdLibraryBoolean_NoFirmwareSync = 369098882,
   #[doc = "<summary>\n</summary>\n<remarks>0x11000084</remarks>"]
   BcdLibraryDevice_WindowsSystemDevice = 285212804,
   #[doc = "<summary>\n</summary>\n<remarks>0x16000087</remarks>"]
   BcdLibraryBoolean_NumLockOn = 369098887,
   #[doc = "<summary>\n</summary>\n<remarks>0x12000088</remarks>"]
   BcdLibraryString_AdditionalCiPolicy = 301990024,
   #[doc = "<summary>\nEnabling the 5-Level Paging feature. 0 = Disabled, 1 = Optout, 2 = Optin\n</summary>\n<remarks>0x15000088</remarks>"]
   BcdLibraryInteger_LinearAddress57 = 352321672,
}
pub use self::_BcdLibraryElementTypes as BcdLibraryElementTypes;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdTemplateElementTypes {
   #[doc = "<summary>\n</summary>\n<remarks>0x45000001</remarks>"]
   BcdSetupInteger_DeviceType = 1157627905,
   #[doc = "<summary>\n</summary>\n<remarks>0x42000002</remarks>"]
   BcdSetupString_ApplicationRelativePath = 1107296258,
   #[doc = "<summary>\n</summary>\n<remarks>0x42000003</remarks>"]
   BcdSetupString_RamdiskDeviceRelativePath = 1107296259,
   #[doc = "<summary>\n</summary>\n<remarks>0x46000004</remarks>"]
   BcdSetupBoolean_OmitOsLoaderElements = 1174405124,
   #[doc = "<summary>\n</summary>\n<remarks>0x47000006</remarks>"]
   BcdSetupIntegerList_ElementsToMigrateList = 1191182342,
   #[doc = "<summary>\n</summary>\n<remarks>0x46000010</remarks>"]
   BcdSetupBoolean_RecoveryOs = 1174405136,
}
pub use self::_BcdTemplateElementTypes as BcdTemplateElementTypes;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Specifies the no-execute page protection policies."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdOSLoader_NxPolicy {
   #[doc = "The no-execute page protection is off by default."]
   NxPolicyOptIn = 0,
   #[doc = "The no-execute page protection is on by default."]
   NxPolicyOptOut = 1,
   #[doc = "The no-execute page protection is always off."]
   NxPolicyAlwaysOff = 2,
   #[doc = "The no-execute page protection is always on."]
   NxPolicyAlwaysOn = 3,
}
#[doc = "Specifies the no-execute page protection policies."]
pub use self::_BcdOSLoader_NxPolicy as BcdOSLoader_NxPolicy;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Specifies the Physical Address Extension (PAE) policies."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdOSLoader_PAEPolicy {
   #[doc = "Enable PAE if hot-pluggable memory is defined above 4GB."]
   PaePolicyDefault = 0,
   #[doc = "PAE is enabled."]
   PaePolicyForceEnable = 1,
   #[doc = "PAE is disabled."]
   PaePolicyForceDisable = 2,
}
#[doc = "Specifies the Physical Address Extension (PAE) policies."]
pub use self::_BcdOSLoader_PAEPolicy as BcdOSLoader_PAEPolicy;
#[repr(i32)]
#[non_exhaustive]
#[doc = "Specifies the boot status policies."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdOSLoader_BootStatusPolicy {
   #[doc = "Display all boot failures."]
   BootStatusPolicyDisplayAllFailures = 0,
   #[doc = "Ignore all boot failures."]
   BootStatusPolicyIgnoreAllFailures = 1,
   #[doc = "Ignore all shutdown failures."]
   BootStatusPolicyIgnoreShutdownFailures = 2,
   #[doc = "Ignore all boot failures."]
   BootStatusPolicyIgnoreBootFailures = 3,
   #[doc = "Ignore checkpoint failures."]
   BootStatusPolicyIgnoreCheckpointFailures = 4,
   #[doc = "Display shutdown failures."]
   BootStatusPolicyDisplayShutdownFailures = 5,
   #[doc = "Display boot failures."]
   BootStatusPolicyDisplayBootFailures = 6,
   #[doc = "Display checkpoint failures."]
   BootStatusPolicyDisplayCheckpointFailures = 7,
   #[doc = "Always display startup failures."]
   BootStatusPolicyAlwaysDisplayStartupFailures = 8,
}
#[doc = "Specifies the boot status policies."]
pub use self::_BcdOSLoader_BootStatusPolicy as BcdOSLoaderBootStatusPolicy;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BcdOSLoaderElementTypes {
   #[doc = "<summary>\nThe device on which the operating system resides.\n</summary>\n<remarks>0x21000001</remarks>"]
   BcdOSLoaderDevice_OSDevice = 553648129,
   #[doc = "<summary>\nThe file path to the operating system (%SystemRoot% minus the volume).\n</summary>\n<remarks>0x22000002</remarks>"]
   BcdOSLoaderString_SystemRoot = 570425346,
   #[doc = "<summary>\nThe resume application associated with the operating system.\n</summary>\n<remarks>0x23000003</remarks>"]
   BcdOSLoaderObject_AssociatedResumeObject = 587202563,
   #[doc = "<summary>\n</summary>\n<remarks>0x26000004</remarks>"]
   BcdOSLoaderBoolean_StampDisks = 637534212,
   #[doc = "<summary>\nIndicates whether the operating system loader should determine the kernel and HAL to load based on the platform features.\n</summary>\n<remarks>0x26000010</remarks>"]
   BcdOSLoaderBoolean_DetectKernelAndHal = 637534224,
   #[doc = "<summary>\nThe kernel to be loaded by the operating system loader. This value overrides the default kernel.\n</summary>\n<remarks>0x22000011</remarks>"]
   BcdOSLoaderString_KernelPath = 570425361,
   #[doc = "<summary>\nThe HAL to be loaded by the operating system loader. This value overrides the default HAL.\n</summary>\n<remarks>0x22000012</remarks>"]
   BcdOSLoaderString_HalPath = 570425362,
   #[doc = "<summary>\nThe transport DLL to be loaded by the operating system loader. This value overrides the default Kdcom.dll.\n</summary>\n<remarks>0x22000013</remarks>"]
   BcdOSLoaderString_DbgTransportPath = 570425363,
   #[doc = "<summary>\nThe no-execute page protection policy. The Integer property is one of the values from the BcdOSLoader_NxPolicy enumeration.\n</summary>\n<remarks>0x25000020</remarks>"]
   BcdOSLoaderInteger_NxPolicy = 620757024,
   #[doc = "<summary>\nThe Physical Address Extension (PAE) policy. The Integer property is one of the values from the BcdOSLoader_PAEPolicy enumeration.\n</summary>\n<remarks>0x25000021</remarks>"]
   BcdOSLoaderInteger_PAEPolicy = 620757025,
   #[doc = "<summary>\nIndicates that the system should be started in Windows Preinstallation Environment (Windows PE) mode.\n</summary>\n<remarks>0x26000022</remarks>"]
   BcdOSLoaderBoolean_WinPEMode = 637534242,
   #[doc = "<summary>\nIndicates that the system should not automatically reboot when it crashes.\n</summary>\n<remarks>0x26000024</remarks>"]
   BcdOSLoaderBoolean_DisableCrashAutoReboot = 637534244,
   #[doc = "<summary>\nIndicates that the system should use the last-known good settings.\n</summary>\n<remarks>0x26000025</remarks>"]
   BcdOSLoaderBoolean_UseLastGoodSettings = 637534245,
   #[doc = "<summary>\n</summary>\n<remarks>0x26000026</remarks>"]
   BcdOSLoaderBoolean_DisableCodeIntegrityChecks = 637534246,
   #[doc = "<summary>\nIndicates whether the test code signing certificate is supported.\n</summary>\n<remarks>0x26000027</remarks>"]
   BcdOSLoaderBoolean_AllowPrereleaseSignatures = 637534247,
   #[doc = "<summary>\nIndicates whether the system should utilize the first 4GB of physical memory.\nThis option requires 5GB of physical memory, and on x86 systems it requires PAE to be enabled.\n</summary>\n<remarks>0x26000030</remarks>"]
   BcdOSLoaderBoolean_NoLowMemory = 637534256,
   #[doc = "<summary>\nThe amount of memory the system should ignore.\n</summary>\n<remarks>0x25000031</remarks>"]
   BcdOSLoaderInteger_RemoveMemory = 620757041,
   #[doc = "<summary>\nThe amount of memory that should be utilized by the process address space, in bytes.\nThis value should be between 2GB and 3GB.\nIncreasing this value from the default 2GB decreases the amount of virtual address space available to the system and device drivers.\n</summary>\n<remarks>0x25000032</remarks>"]
   BcdOSLoaderInteger_IncreaseUserVa = 620757042,
   #[doc = "<summary>\nBCDE_OSLOADER_TYPE_PERFORMANCE_DATA_MEMORY\n</summary>\n<remarks>0x25000033</remarks>"]
   BcdOSLoaderInteger_PerformaceDataMemory = 620757043,
   #[doc = "<summary>\nIndicates whether the system should use the standard VGA display driver instead of a high-performance display driver.\n</summary>\n<remarks>0x26000040</remarks>"]
   BcdOSLoaderBoolean_UseVgaDriver = 637534272,
   #[doc = "<summary>\nIndicates whether the system should initialize the VGA driver responsible for displaying simple graphics during the boot process.\nIf not, there is no display is presented during the boot process.\n</summary>\n<remarks>0x26000041</remarks>"]
   BcdOSLoaderBoolean_DisableBootDisplay = 637534273,
   #[doc = "<summary>\nIndicates whether the VGA driver should avoid VESA BIOS calls.\nNote This value is ignored by Windows 8 and Windows Server 2012.\n</summary>\n<remarks>0x26000042</remarks>"]
   BcdOSLoaderBoolean_DisableVesaBios = 637534274,
   #[doc = "<summary>\nDisables the use of VGA modes in the OS.\n</summary>\n<remarks>0x26000043</remarks>"]
   BcdOSLoaderBoolean_DisableVgaMode = 637534275,
   #[doc = "<summary>\nIndicates that cluster-mode APIC addressing should be utilized, and the value is the maximum number of processors per cluster.\n</summary>\n<remarks>0x25000050</remarks>"]
   BcdOSLoaderInteger_ClusterModeAddressing = 620757072,
   #[doc = "<summary>\nIndicates whether to enable physical-destination mode for all APIC messages.\n</summary>\n<remarks>0x26000051</remarks>"]
   BcdOSLoaderBoolean_UsePhysicalDestination = 637534289,
   #[doc = "<summary>\nThe maximum number of APIC clusters that should be used by cluster-mode addressing.\n</summary>\n<remarks>0x25000052</remarks>"]
   BcdOSLoaderInteger_RestrictApicCluster = 620757074,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000053</remarks>"]
   BcdOSLoaderString_OSLoaderTypeEVStore = 570425427,
   #[doc = "<summary>\nUsed to force legacy APIC mode, even if the processors and chipset support extended APIC mode.\n</summary>\n<remarks>0x26000054</remarks>"]
   BcdOSLoaderBoolean_UseLegacyApicMode = 637534292,
   #[doc = "<summary>\nEnables the use of extended APIC mode, if supported.\nZero (0) indicates default behavior, one (1) indicates that extended APIC mode is disabled, and two (2) indicates that extended APIC mode is enabled.\nThe system defaults to using extended APIC mode if available.\n</summary>\n<remarks>0x25000055</remarks>"]
   BcdOSLoaderInteger_X2ApicPolicy = 620757077,
   #[doc = "<summary>\nIndicates whether the operating system should initialize or start non-boot processors.\n</summary>\n<remarks>0x26000060</remarks>"]
   BcdOSLoaderBoolean_UseBootProcessorOnly = 637534304,
   #[doc = "<summary>\nThe maximum number of processors that can be utilized by the system; all other processors are ignored.\n</summary>\n<remarks>0x25000061</remarks>"]
   BcdOSLoaderInteger_NumberOfProcessors = 620757089,
   #[doc = "<summary>\nIndicates whether the system should use the maximum number of processors.\n</summary>\n<remarks>0x26000062</remarks>"]
   BcdOSLoaderBoolean_ForceMaximumProcessors = 637534306,
   #[doc = "<summary>\nIndicates whether processor specific configuration flags are to be used.\n</summary>\n<remarks>0x25000063</remarks>"]
   BcdOSLoaderBoolean_ProcessorConfigurationFlags = 620757091,
   #[doc = "<summary>\nMaximizes the number of groups created when assigning nodes to processor groups.\n</summary>\n<remarks>0x26000064</remarks>"]
   BcdOSLoaderBoolean_MaximizeGroupsCreated = 637534308,
   #[doc = "<summary>\nThis setting makes drivers group aware and can be used to determine improper group usage.\n</summary>\n<remarks>0x26000065</remarks>"]
   BcdOSLoaderBoolean_ForceGroupAwareness = 637534309,
   #[doc = "<summary>\nSpecifies the size of all processor groups. Must be set to a power of 2.\n</summary>\n<remarks>0x25000066</remarks>"]
   BcdOSLoaderInteger_GroupSize = 620757094,
   #[doc = "<summary>\nIndicates whether the system should use I/O and IRQ resources created by the system firmware instead of using dynamically configured resources.\n</summary>\n<remarks>0x26000070</remarks>"]
   BcdOSLoaderInteger_UseFirmwarePciSettings = 637534320,
   #[doc = "<summary>\nThe PCI Message Signaled Interrupt (MSI) policy. Zero (0) indicates default, and one (1) indicates that MSI interrupts are forcefully disabled.\n</summary>\n<remarks>0x25000071</remarks>"]
   BcdOSLoaderInteger_MsiPolicy = 620757105,
   #[doc = "<summary>\nZero (0) indicates default, and one (1) indicates that PCI Express is forcefully disabled.\n</summary>\n<remarks>0x25000072</remarks>"]
   BcdOSLoaderInteger_PciExpressPolicy = 620757106,
   #[doc = "<summary>\nThe Integer property is one of the values from the BcdLibrary_SafeBoot enumeration.\n</summary>\n<remarks>0x25000080</remarks>"]
   BcdOSLoaderInteger_SafeBoot = 620757120,
   #[doc = "<summary>\nIndicates whether the system should use the shell specified under the following registry key instead of the default shell:\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\AlternateShell. </summary>\n<remarks>0x26000081</remarks>"]
   BcdOSLoaderBoolean_SafeBootAlternateShell = 637534337,
   #[doc = "<summary>\nIndicates whether the system should write logging information to %SystemRoot%\\Ntbtlog.txt during initialization.\n</summary>\n<remarks>0x26000090</remarks>"]
   BcdOSLoaderBoolean_BootLogInitialization = 637534352,
   #[doc = "<summary>\nIndicates whether the system should display verbose information.\n</summary>\n<remarks>0x26000091</remarks>"]
   BcdOSLoaderBoolean_VerboseObjectLoadMode = 637534353,
   #[doc = "<summary>\nIndicates whether the kernel debugger should be enabled using the settings in the inherited debugger object.\n</summary>\n<remarks>0x260000A0</remarks>"]
   BcdOSLoaderBoolean_KernelDebuggerEnabled = 637534368,
   #[doc = "<summary>\nIndicates whether the HAL should call DbgBreakPoint at the start of HalInitSystem for phase 0 initialization of the kernel.\n</summary>\n<remarks>0x260000A1</remarks>"]
   BcdOSLoaderBoolean_DebuggerHalBreakpoint = 637534369,
   #[doc = "<summary>\nForces the use of the platform clock as the system's performance counter.\n</summary>\n<remarks>0x260000A2</remarks>"]
   BcdOSLoaderBoolean_UsePlatformClock = 637534370,
   #[doc = "<summary>\nForces the OS to assume the presence of legacy PC devices like CMOS and keyboard controllers.\nThis value should only be used for debugging.\n</summary>\n<remarks>0x260000A3</remarks>"]
   BcdOSLoaderBoolean_ForceLegacyPlatform = 637534371,
   #[doc = "<summary>\n</summary>\n<remarks>0x260000A4</remarks>"]
   BcdOSLoaderBoolean_UsePlatformTick = 637534372,
   #[doc = "<summary>\n</summary>\n<remarks>0x260000A5</remarks>"]
   BcdOSLoaderBoolean_DisableDynamicTick = 637534373,
   #[doc = "<summary>\nControls the TSC synchronization policy. Possible values include default (0), legacy (1), or enhanced (2).\nThis value is supported starting in Windows 8 and Windows Server 2012.\n</summary>\n<remarks>0x250000A6</remarks>"]
   BcdOSLoaderInteger_TscSyncPolicy = 620757158,
   #[doc = "<summary>\nIndicates whether EMS should be enabled in the kernel.\n</summary>\n<remarks>0x260000B0</remarks>"]
   BcdOSLoaderBoolean_EmsEnabled = 637534384,
   #[doc = "<summary>\n</summary>\n<remarks>0x250000C0</remarks>"]
   BcdOSLoaderInteger_ForceFailure = 620757184,
   #[doc = "<summary>\nIndicates the driver load failure policy. Zero (0) indicates that a failed driver load is fatal and the boot will not continue,\none (1) indicates that the standard error control is used.\n</summary>\n<remarks>0x250000C1</remarks>"]
   BcdOSLoaderInteger_DriverLoadFailurePolicy = 620757185,
   #[doc = "<summary>\nDefines the type of boot menus the system will use. Possible values include menupolicylegacy (0) or menupolicystandard (1).\nThe default value is menupolicylegacy (0).\n</summary>\n<remarks>0x250000C2</remarks>"]
   BcdOSLoaderInteger_BootMenuPolicy = 620757186,
   #[doc = "<summary>\nControls whether the system boots to the legacy menu (F8 menu) on the next boot.\nNote This value is supported starting in Windows 8 and Windows Server 2012.\n</summary>\n<remarks>0x260000C3</remarks>"]
   BcdOSLoaderBoolean_AdvancedOptionsOneTime = 637534403,
   #[doc = "<summary>\n</summary>\n<remarks>0x260000C4</remarks>"]
   BcdOSLoaderBoolean_OptionsEditOneTime = 637534404,
   #[doc = "<summary>\nThe boot status policy. The Integer property is one of the values from the BcdOSLoaderBootStatusPolicy enumeration\n</summary>\n<remarks>0x250000E0</remarks>"]
   BcdOSLoaderInteger_BootStatusPolicy = 620757216,
   #[doc = "<summary>\nThe OS loader removes this entry for security reasons. This option can only be triggered by using the F8 menu; a user must be physically present to trigger this option.\nThis value is supported starting in Windows 8 and Windows Server 2012.\n</summary>\n<remarks>0x260000E1</remarks>"]
   BcdOSLoaderBoolean_DisableElamDrivers = 637534433,
   #[doc = "<summary>\nControls the hypervisor launch type. Options are HyperVisorLaunchOff (0) and HypervisorLaunchAuto (1).\n</summary>\n<remarks>0x250000F0</remarks>"]
   BcdOSLoaderInteger_HypervisorLaunchType = 620757232,
   #[doc = "<summary>\n</summary>\n<remarks>0x250000F1</remarks>"]
   BcdOSLoaderString_HypervisorPath = 620757233,
   #[doc = "<summary>\nControls whether the hypervisor debugger is enabled.\n</summary>\n<remarks>0x260000F2</remarks>"]
   BcdOSLoaderBoolean_HypervisorDebuggerEnabled = 637534450,
   #[doc = "<summary>\nControls the hypervisor debugger type. Can be set to SERIAL (0), 1394 (1), or NET (2).\n</summary>\n<remarks>0x250000F3</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerType = 620757235,
   #[doc = "<summary>\nSpecifies the serial port number for serial debugging.\n</summary>\n<remarks>0x250000F4</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerPortNumber = 620757236,
   #[doc = "<summary>\nSpecifies the baud rate for serial debugging.\n</summary>\n<remarks>0x250000F5</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerBaudrate = 620757237,
   #[doc = "<summary>\nSpecifies the channel number for 1394 debugging.\n</summary>\n<remarks>0x250000F6</remarks>"]
   BcdOSLoaderInteger_HypervisorDebugger1394Channel = 620757238,
   #[doc = "<summary>\nValues are Disabled (0), Basic (1), and Standard (2).\n</summary>\n<remarks>0x250000F7</remarks>"]
   BcdOSLoaderInteger_BootUxPolicy = 620757239,
   #[doc = "<summary>\n</summary>\n<remarks>0x220000F8</remarks>"]
   BcdOSLoaderInteger_HypervisorSlatDisabled = 570425592,
   #[doc = "<summary>\nDefines the PCI bus, device, and function numbers of the debugging device used with the hypervisor.\nFor example, 1.5.0 describes the debugging device on bus 1, device 5, function 0.\n</summary>\n<remarks>0x220000F9</remarks>"]
   BcdOSLoaderString_HypervisorDebuggerBusParams = 570425593,
   #[doc = "<summary>\n</summary>\n<remarks>0x250000FA</remarks>"]
   BcdOSLoaderInteger_HypervisorNumProc = 620757242,
   #[doc = "<summary>\n</summary>\n<remarks>0x250000FB</remarks>"]
   BcdOSLoaderInteger_HypervisorRootProcPerNode = 620757243,
   #[doc = "<summary>\n</summary>\n<remarks>0x260000FC</remarks>"]
   BcdOSLoaderBoolean_HypervisorUseLargeVTlb = 637534460,
   #[doc = "<summary>\n</summary>\n<remarks>0x250000FD</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerNetHostIp = 620757245,
   #[doc = "<summary>\n</summary>\n<remarks>0x250000FE</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerNetHostPort = 620757246,
   #[doc = "<summary>\n</summary>\n<remarks>0x250000FF</remarks>"]
   BcdOSLoaderInteger_HypervisorDebuggerPages = 620757247,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000100</remarks>"]
   BcdOSLoaderInteger_TpmBootEntropyPolicy = 620757248,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000110</remarks>"]
   BcdOSLoaderString_HypervisorDebuggerNetKey = 570425616,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000112</remarks>"]
   BcdOSLoaderString_HypervisorProductSkuType = 570425618,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000113</remarks>"]
   BcdOSLoaderInteger_HypervisorRootProc = 570425619,
   #[doc = "<summary>\n</summary>\n<remarks>0x26000114</remarks>"]
   BcdOSLoaderBoolean_HypervisorDebuggerNetDhcp = 637534484,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000115</remarks>"]
   BcdOSLoaderInteger_HypervisorIommuPolicy = 620757269,
   #[doc = "<summary>\n</summary>\n<remarks>0x26000116</remarks>"]
   BcdOSLoaderBoolean_HypervisorUseVApic = 637534486,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000117</remarks>"]
   BcdOSLoaderString_HypervisorLoadOptions = 570425623,
   #[doc = "<summary>\nBCDE_POLICY_OSLOADER_TYPE_HYPERVISOR_MSR_FILTER_POLICY\n</summary>\n<remarks>0x25000118</remarks>"]
   BcdOSLoaderInteger_HypervisorMsrFilterPolicy = 620757272,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000119</remarks>"]
   BcdOSLoaderInteger_HypervisorMmioNxPolicy = 620757273,
   #[doc = "<summary>\n</summary>\n<remarks>0x2500011A</remarks>"]
   BcdOSLoaderInteger_HypervisorSchedulerType = 620757274,
   #[doc = "<summary>\n</summary>\n<remarks>0x2200011B</remarks>"]
   BcdOSLoaderString_HypervisorRootProcNumaNodes = 570425627,
   #[doc = "<summary>\nBCDE_POLICY_OSLOADER_TYPE_HYPERVISOR_PERFMON\n</summary>\n<remarks>0x2500011C</remarks>"]
   BcdOSLoaderInteger_HypervisorPerfmon = 620757276,
   #[doc = "<summary>\n</summary>\n<remarks>0x2500011D</remarks>"]
   BcdOSLoaderInteger_HypervisorRootProcPerCore = 620757277,
   #[doc = "<summary>\n</summary>\n<remarks>0x2200011E</remarks>"]
   BcdOSLoaderString_HypervisorRootProcNumaNodeLps = 570425630,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000120</remarks>"]
   BcdOSLoaderInteger_XSavePolicy = 620757280,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000121</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature0 = 620757281,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000122</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature1 = 620757282,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000123</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature2 = 620757283,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000124</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature3 = 620757284,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000125</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature4 = 620757285,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000126</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature5 = 620757286,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000127</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature6 = 620757287,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000128</remarks>"]
   BcdOSLoaderInteger_XSaveAddFeature7 = 620757288,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000129</remarks>"]
   BcdOSLoaderInteger_XSaveRemoveFeature = 620757289,
   #[doc = "<summary>\n</summary>\n<remarks>0x2500012A</remarks>"]
   BcdOSLoaderInteger_XSaveProcessorsMask = 620757290,
   #[doc = "<summary>\n</summary>\n<remarks>0x2500012B</remarks>"]
   BcdOSLoaderInteger_XSaveDisable = 620757291,
   #[doc = "<summary>\n</summary>\n<remarks>0x2500012C</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerType = 620757292,
   #[doc = "<summary>\n</summary>\n<remarks>0x2200012D</remarks>"]
   BcdOSLoaderString_KernelDebuggerBusParameters = 570425645,
   #[doc = "<summary>\n</summary>\n<remarks>0x2500012E</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerPortAddress = 620757294,
   #[doc = "<summary>\n</summary>\n<remarks>0x2500012F</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerPortNumber = 620757295,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000130</remarks>"]
   BcdOSLoaderInteger_ClaimedTpmCounter = 620757296,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000131</remarks>"]
   BcdOSLoaderInteger_KernelDebugger1394Channel = 620757297,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000132</remarks>"]
   BcdOSLoaderString_KernelDebuggerUsbTargetname = 570425650,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000133</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerNetHostIp = 620757299,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000134</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerNetHostPort = 620757300,
   #[doc = "<summary>\n</summary>\n<remarks>0x26000135</remarks>"]
   BcdOSLoaderBoolean_KernelDebuggerNetDhcp = 637534517,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000136</remarks>"]
   BcdOSLoaderString_KernelDebuggerNetKey = 570425654,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000137</remarks>"]
   BcdOSLoaderString_IMCHiveName = 570425655,
   #[doc = "<summary>\n</summary>\n<remarks>0x21000138</remarks>"]
   BcdOSLoaderDevice_IMCDevice = 553648440,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000139</remarks>"]
   BcdOSLoaderInteger_KernelDebuggerBaudrate = 620757305,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000140</remarks>"]
   BcdOSLoaderString_ManufacturingMode = 570425664,
   #[doc = "<summary>\n</summary>\n<remarks>0x26000141</remarks>"]
   BcdOSLoaderBoolean_EventLoggingEnabled = 637534529,
   #[doc = "<summary>\n</summary>\n<remarks>0x25000142</remarks>"]
   BcdOSLoaderInteger_VsmLaunchType = 620757314,
   #[doc = "<summary>\nZero (0) indicates Disabled, one (1) indicates that Enabled and two (2) indicates strict mode.\n</summary>\n<remarks>0x25000144</remarks>"]
   BcdOSLoaderInteger_HypervisorEnforcedCodeIntegrity = 620757316,
   #[doc = "<summary>\n</summary>\n<remarks>0x26000145</remarks>"]
   BcdOSLoaderBoolean_DtraceEnabled = 637534533,
   #[doc = "<summary>\n</summary>\n<remarks>0x21000150</remarks>"]
   BcdOSLoaderDevice_SystemDataDevice = 553648464,
   #[doc = "<summary>\n</summary>\n<remarks>0x21000151</remarks>"]
   BcdOSLoaderDevice_OsArcDevice = 553648465,
   #[doc = "<summary>\n</summary>\n<remarks>0x21000153</remarks>"]
   BcdOSLoaderDevice_OsDataDevice = 553648467,
   #[doc = "<summary>\n</summary>\n<remarks>0x21000154</remarks>"]
   BcdOSLoaderDevice_BspDevice = 553648468,
   #[doc = "<summary>\n</summary>\n<remarks>0x21000155</remarks>"]
   BcdOSLoaderDevice_BspFilepath = 553648469,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000156</remarks>"]
   BcdOSLoaderString_KernelDebuggerNetHostIpv6 = 570425686,
   #[doc = "<summary>\n</summary>\n<remarks>0x22000161</remarks>"]
   BcdOSLoaderString_HypervisorDebuggerNetHostIpv6 = 570425697,
}
pub use self::_BcdOSLoaderElementTypes as BcdOSLoaderElementTypes;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_INFORMATION_CLASS {
   MemoryBasicInformation = 0,
   MemoryWorkingSetInformation = 1,
   MemoryMappedFilenameInformation = 2,
   MemoryRegionInformation = 3,
   MemoryWorkingSetExInformation = 4,
   MemorySharedCommitInformation = 5,
   MemoryImageInformation = 6,
   MemoryRegionInformationEx = 7,
   MemoryPrivilegedBasicInformation = 8,
   MemoryEnclaveImageInformation = 9,
   MemoryBasicInformationCapped = 10,
   MemoryPhysicalContiguityInformation = 11,
   MemoryBadInformation = 12,
   MemoryBadInformationAllProcesses = 13,
   MemoryImageExtensionInformation = 14,
   MaxMemoryInfoClass = 15,
}
pub use self::_MEMORY_INFORMATION_CLASS as MEMORY_INFORMATION_CLASS;
#[doc = "The MEMORY_WORKING_SET_BLOCK structure contains working set information for a page.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_block](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_block)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_WORKING_SET_BLOCK {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MEMORY_WORKING_SET_BLOCK {
   #[inline]
   pub fn Protection(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
   }
   #[inline]
   pub fn set_Protection(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Protection_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            5u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Protection_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            5u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ShareCount(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_ShareCount(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ShareCount_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ShareCount_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Shared(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Shared(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Shared_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Shared_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Node(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Node(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Node_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Node_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualPage(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
   }
   #[inline]
   pub fn set_VirtualPage(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 52u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualPage_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            52u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualPage_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            52u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Protection: ULONG_PTR,
      ShareCount: ULONG_PTR,
      Shared: ULONG_PTR,
      Node: ULONG_PTR,
      VirtualPage: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 5u8, {
         let Protection: u64 = unsafe { ::core::mem::transmute(Protection) };
         Protection as u64
      });
      __bindgen_bitfield_unit.set(5usize, 3u8, {
         let ShareCount: u64 = unsafe { ::core::mem::transmute(ShareCount) };
         ShareCount as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let Shared: u64 = unsafe { ::core::mem::transmute(Shared) };
         Shared as u64
      });
      __bindgen_bitfield_unit.set(9usize, 3u8, {
         let Node: u64 = unsafe { ::core::mem::transmute(Node) };
         Node as u64
      });
      __bindgen_bitfield_unit.set(12usize, 52u8, {
         let VirtualPage: u64 = unsafe { ::core::mem::transmute(VirtualPage) };
         VirtualPage as u64
      });
      __bindgen_bitfield_unit
   }
}
#[doc = "The MEMORY_WORKING_SET_BLOCK structure contains working set information for a page.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_block](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_block)"]
pub type MEMORY_WORKING_SET_BLOCK = _MEMORY_WORKING_SET_BLOCK;
#[doc = "The MEMORY_WORKING_SET_BLOCK structure contains working set information for a page.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_block](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_block)"]
pub type PMEMORY_WORKING_SET_BLOCK = *mut _MEMORY_WORKING_SET_BLOCK;
#[doc = "The MEMORY_WORKING_SET_INFORMATION structure contains working set information for a process.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_information](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_information)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_WORKING_SET_INFORMATION {
   pub NumberOfEntries: ULONG_PTR,
   pub WorkingSetInfo: [MEMORY_WORKING_SET_BLOCK; 1usize],
}
#[doc = "The MEMORY_WORKING_SET_INFORMATION structure contains working set information for a process.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_information](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_information)"]
pub type MEMORY_WORKING_SET_INFORMATION = _MEMORY_WORKING_SET_INFORMATION;
#[doc = "The MEMORY_WORKING_SET_INFORMATION structure contains working set information for a process.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_information](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_information)"]
pub type PMEMORY_WORKING_SET_INFORMATION = *mut _MEMORY_WORKING_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_REGION_INFORMATION {
   pub AllocationBase: PVOID,
   pub AllocationProtect: ULONG,
   pub __bindgen_anon_1: _MEMORY_REGION_INFORMATION__bindgen_ty_1,
   pub RegionSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub PartitionId: ULONG_PTR,
   pub NodePreference: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_REGION_INFORMATION__bindgen_ty_1 {
   pub RegionType: ULONG,
   pub __bindgen_anon_1: _MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Private(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Private(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Private_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Private_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MappedDataFile(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedDataFile(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MappedDataFile_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MappedDataFile_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MappedImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MappedImage_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MappedImage_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MappedPageFile(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedPageFile(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MappedPageFile_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MappedPageFile_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MappedPhysical(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedPhysical(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MappedPhysical_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MappedPhysical_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DirectMapped(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DirectMapped(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DirectMapped_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DirectMapped_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SoftwareEnclave(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SoftwareEnclave(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SoftwareEnclave_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SoftwareEnclave_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PageSize64K(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PageSize64K(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PageSize64K_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PageSize64K_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PlaceholderReservation(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PlaceholderReservation(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PlaceholderReservation_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PlaceholderReservation_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MappedAwe(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedAwe(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MappedAwe_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MappedAwe_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MappedWriteWatch(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MappedWriteWatch(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MappedWriteWatch_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MappedWriteWatch_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PageSizeLarge(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PageSizeLarge(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PageSizeLarge_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PageSizeLarge_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PageSizeHuge(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PageSizeHuge(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PageSizeHuge_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PageSizeHuge_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 19u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            19u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            19u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Private: ULONG,
      MappedDataFile: ULONG,
      MappedImage: ULONG,
      MappedPageFile: ULONG,
      MappedPhysical: ULONG,
      DirectMapped: ULONG,
      SoftwareEnclave: ULONG,
      PageSize64K: ULONG,
      PlaceholderReservation: ULONG,
      MappedAwe: ULONG,
      MappedWriteWatch: ULONG,
      PageSizeLarge: ULONG,
      PageSizeHuge: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Private: u32 = unsafe { ::core::mem::transmute(Private) };
         Private as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let MappedDataFile: u32 = unsafe { ::core::mem::transmute(MappedDataFile) };
         MappedDataFile as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let MappedImage: u32 = unsafe { ::core::mem::transmute(MappedImage) };
         MappedImage as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let MappedPageFile: u32 = unsafe { ::core::mem::transmute(MappedPageFile) };
         MappedPageFile as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let MappedPhysical: u32 = unsafe { ::core::mem::transmute(MappedPhysical) };
         MappedPhysical as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let DirectMapped: u32 = unsafe { ::core::mem::transmute(DirectMapped) };
         DirectMapped as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let SoftwareEnclave: u32 = unsafe { ::core::mem::transmute(SoftwareEnclave) };
         SoftwareEnclave as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let PageSize64K: u32 = unsafe { ::core::mem::transmute(PageSize64K) };
         PageSize64K as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let PlaceholderReservation: u32 =
            unsafe { ::core::mem::transmute(PlaceholderReservation) };
         PlaceholderReservation as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let MappedAwe: u32 = unsafe { ::core::mem::transmute(MappedAwe) };
         MappedAwe as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let MappedWriteWatch: u32 = unsafe { ::core::mem::transmute(MappedWriteWatch) };
         MappedWriteWatch as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let PageSizeLarge: u32 = unsafe { ::core::mem::transmute(PageSizeLarge) };
         PageSizeLarge as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let PageSizeHuge: u32 = unsafe { ::core::mem::transmute(PageSizeHuge) };
         PageSizeHuge as u64
      });
      __bindgen_bitfield_unit.set(13usize, 19u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_REGION_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_REGION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_REGION_INFORMATION = _MEMORY_REGION_INFORMATION;
pub type PMEMORY_REGION_INFORMATION = *mut _MEMORY_REGION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_WORKING_SET_EX_LOCATION {
   MemoryLocationInvalid = 0,
   MemoryLocationResident = 1,
   MemoryLocationPagefile = 2,
   MemoryLocationReserved = 3,
}
pub use self::_MEMORY_WORKING_SET_EX_LOCATION as MEMORY_WORKING_SET_EX_LOCATION;
#[doc = "The MEMORY_WORKING_SET_EX_BLOCK structure contains extended working set information for a page.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_WORKING_SET_EX_BLOCK {
   pub Flags: ULONG_PTR,
   pub __bindgen_anon_1: _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1 {
   pub __bindgen_anon_1: _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_1,
   pub Invalid: _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Valid(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Valid(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Valid_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Valid_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ShareCount(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_ShareCount(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ShareCount_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ShareCount_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Win32Protection(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 11u8) as u64) }
   }
   #[inline]
   pub fn set_Win32Protection(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 11u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Win32Protection_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            11u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Win32Protection_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            11u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Shared(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Shared(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Shared_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Shared_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Node(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u64) }
   }
   #[inline]
   pub fn set_Node(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Node_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            6u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Node_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Locked(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Locked(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Locked_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            22usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Locked_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            22usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LargePage(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_LargePage(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LargePage_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            23usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_LargePage_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            23usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Priority(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Priority_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Priority_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(27usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            27usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            27usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SharedOriginal(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_SharedOriginal(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(30usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SharedOriginal_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            30usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_SharedOriginal_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            30usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Bad(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Bad(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Bad_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            31usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Bad_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            31usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Win32GraphicsProtection(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u64) }
   }
   #[inline]
   pub fn set_Win32GraphicsProtection(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(32usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Win32GraphicsProtection_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            32usize,
            4u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Win32GraphicsProtection_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            32usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedUlong(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 28u8) as u64) }
   }
   #[inline]
   pub fn set_ReservedUlong(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(36usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedUlong_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            36usize,
            28u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedUlong_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            36usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Valid: ULONG_PTR,
      ShareCount: ULONG_PTR,
      Win32Protection: ULONG_PTR,
      Shared: ULONG_PTR,
      Node: ULONG_PTR,
      Locked: ULONG_PTR,
      LargePage: ULONG_PTR,
      Priority: ULONG_PTR,
      Reserved: ULONG_PTR,
      SharedOriginal: ULONG_PTR,
      Bad: ULONG_PTR,
      Win32GraphicsProtection: ULONG_PTR,
      ReservedUlong: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Valid: u64 = unsafe { ::core::mem::transmute(Valid) };
         Valid as u64
      });
      __bindgen_bitfield_unit.set(1usize, 3u8, {
         let ShareCount: u64 = unsafe { ::core::mem::transmute(ShareCount) };
         ShareCount as u64
      });
      __bindgen_bitfield_unit.set(4usize, 11u8, {
         let Win32Protection: u64 = unsafe { ::core::mem::transmute(Win32Protection) };
         Win32Protection as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let Shared: u64 = unsafe { ::core::mem::transmute(Shared) };
         Shared as u64
      });
      __bindgen_bitfield_unit.set(16usize, 6u8, {
         let Node: u64 = unsafe { ::core::mem::transmute(Node) };
         Node as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let Locked: u64 = unsafe { ::core::mem::transmute(Locked) };
         Locked as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let LargePage: u64 = unsafe { ::core::mem::transmute(LargePage) };
         LargePage as u64
      });
      __bindgen_bitfield_unit.set(24usize, 3u8, {
         let Priority: u64 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit.set(27usize, 3u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(30usize, 1u8, {
         let SharedOriginal: u64 = unsafe { ::core::mem::transmute(SharedOriginal) };
         SharedOriginal as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Bad: u64 = unsafe { ::core::mem::transmute(Bad) };
         Bad as u64
      });
      __bindgen_bitfield_unit.set(32usize, 4u8, {
         let Win32GraphicsProtection: u64 =
            unsafe { ::core::mem::transmute(Win32GraphicsProtection) };
         Win32GraphicsProtection as u64
      });
      __bindgen_bitfield_unit.set(36usize, 28u8, {
         let ReservedUlong: u64 = unsafe { ::core::mem::transmute(ReservedUlong) };
         ReservedUlong as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_2 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1__bindgen_ty_2 {
   #[inline]
   pub fn Valid(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Valid(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Valid_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Valid_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved0(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 14u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved0(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 14u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved0_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            14u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved0_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            14u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Shared(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Shared(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Shared_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Shared_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved1(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            5u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            5u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PageTable(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_PageTable(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PageTable_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            21usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_PageTable_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            21usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Location(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_Location(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Location_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            22usize,
            2u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Location_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            22usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Priority(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Priority_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Priority_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ModifiedList(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_ModifiedList(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(27usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ModifiedList_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            27usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ModifiedList_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            27usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved2(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved2(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            2u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SharedOriginal(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_SharedOriginal(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(30usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SharedOriginal_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            30usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_SharedOriginal_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            30usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Bad(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Bad(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Bad_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            31usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Bad_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            31usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedUlong(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u64) }
   }
   #[inline]
   pub fn set_ReservedUlong(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(32usize, 32u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedUlong_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            32usize,
            32u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedUlong_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            32usize,
            32u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Valid: ULONG_PTR,
      Reserved0: ULONG_PTR,
      Shared: ULONG_PTR,
      Reserved1: ULONG_PTR,
      PageTable: ULONG_PTR,
      Location: ULONG_PTR,
      Priority: ULONG_PTR,
      ModifiedList: ULONG_PTR,
      Reserved2: ULONG_PTR,
      SharedOriginal: ULONG_PTR,
      Bad: ULONG_PTR,
      ReservedUlong: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Valid: u64 = unsafe { ::core::mem::transmute(Valid) };
         Valid as u64
      });
      __bindgen_bitfield_unit.set(1usize, 14u8, {
         let Reserved0: u64 = unsafe { ::core::mem::transmute(Reserved0) };
         Reserved0 as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let Shared: u64 = unsafe { ::core::mem::transmute(Shared) };
         Shared as u64
      });
      __bindgen_bitfield_unit.set(16usize, 5u8, {
         let Reserved1: u64 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let PageTable: u64 = unsafe { ::core::mem::transmute(PageTable) };
         PageTable as u64
      });
      __bindgen_bitfield_unit.set(22usize, 2u8, {
         let Location: u64 = unsafe { ::core::mem::transmute(Location) };
         Location as u64
      });
      __bindgen_bitfield_unit.set(24usize, 3u8, {
         let Priority: u64 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit.set(27usize, 1u8, {
         let ModifiedList: u64 = unsafe { ::core::mem::transmute(ModifiedList) };
         ModifiedList as u64
      });
      __bindgen_bitfield_unit.set(28usize, 2u8, {
         let Reserved2: u64 = unsafe { ::core::mem::transmute(Reserved2) };
         Reserved2 as u64
      });
      __bindgen_bitfield_unit.set(30usize, 1u8, {
         let SharedOriginal: u64 = unsafe { ::core::mem::transmute(SharedOriginal) };
         SharedOriginal as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Bad: u64 = unsafe { ::core::mem::transmute(Bad) };
         Bad as u64
      });
      __bindgen_bitfield_unit.set(32usize, 32u8, {
         let ReservedUlong: u64 = unsafe { ::core::mem::transmute(ReservedUlong) };
         ReservedUlong as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_WORKING_SET_EX_BLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_WORKING_SET_EX_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The MEMORY_WORKING_SET_EX_BLOCK structure contains extended working set information for a page.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block)"]
pub type MEMORY_WORKING_SET_EX_BLOCK = _MEMORY_WORKING_SET_EX_BLOCK;
#[doc = "The MEMORY_WORKING_SET_EX_BLOCK structure contains extended working set information for a page.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_block)"]
pub type PMEMORY_WORKING_SET_EX_BLOCK = *mut _MEMORY_WORKING_SET_EX_BLOCK;
#[doc = "The MEMORY_WORKING_SET_EX_INFORMATION structure contains extended working set information for a process.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_information](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_information)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_WORKING_SET_EX_INFORMATION {
   pub VirtualAddress: PVOID,
   pub VirtualAttributes: MEMORY_WORKING_SET_EX_BLOCK,
}
impl Default for _MEMORY_WORKING_SET_EX_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The MEMORY_WORKING_SET_EX_INFORMATION structure contains extended working set information for a process.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_information](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_information)"]
pub type MEMORY_WORKING_SET_EX_INFORMATION = _MEMORY_WORKING_SET_EX_INFORMATION;
#[doc = "The MEMORY_WORKING_SET_EX_INFORMATION structure contains extended working set information for a process.\n[https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_information](https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_working_set_ex_information)"]
pub type PMEMORY_WORKING_SET_EX_INFORMATION = *mut _MEMORY_WORKING_SET_EX_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_SHARED_COMMIT_INFORMATION {
   pub CommitSize: SIZE_T,
}
pub type MEMORY_SHARED_COMMIT_INFORMATION = _MEMORY_SHARED_COMMIT_INFORMATION;
pub type PMEMORY_SHARED_COMMIT_INFORMATION = *mut _MEMORY_SHARED_COMMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_IMAGE_INFORMATION {
   pub ImageBase: PVOID,
   pub SizeOfImage: SIZE_T,
   pub __bindgen_anon_1: _MEMORY_IMAGE_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_IMAGE_INFORMATION__bindgen_ty_1 {
   pub ImageFlags: ULONG,
   pub __bindgen_anon_1: _MEMORY_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MEMORY_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ImagePartialMap(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImagePartialMap(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImagePartialMap_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImagePartialMap_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageNotExecutable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageNotExecutable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageNotExecutable_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageNotExecutable_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageSigningLevel(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_ImageSigningLevel(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageSigningLevel_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageSigningLevel_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageExtensionPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageExtensionPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageExtensionPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageExtensionPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 25u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            25u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            25u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ImagePartialMap: ULONG,
      ImageNotExecutable: ULONG,
      ImageSigningLevel: ULONG,
      ImageExtensionPresent: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ImagePartialMap: u32 = unsafe { ::core::mem::transmute(ImagePartialMap) };
         ImagePartialMap as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ImageNotExecutable: u32 = unsafe { ::core::mem::transmute(ImageNotExecutable) };
         ImageNotExecutable as u64
      });
      __bindgen_bitfield_unit.set(2usize, 4u8, {
         let ImageSigningLevel: u32 = unsafe { ::core::mem::transmute(ImageSigningLevel) };
         ImageSigningLevel as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ImageExtensionPresent: u32 = unsafe { ::core::mem::transmute(ImageExtensionPresent) };
         ImageExtensionPresent as u64
      });
      __bindgen_bitfield_unit.set(7usize, 25u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_IMAGE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_IMAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_IMAGE_INFORMATION = _MEMORY_IMAGE_INFORMATION;
pub type PMEMORY_IMAGE_INFORMATION = *mut _MEMORY_IMAGE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_ENCLAVE_IMAGE_INFORMATION {
   pub ImageInfo: MEMORY_IMAGE_INFORMATION,
   pub UniqueID: [UCHAR; 32usize],
   pub AuthorID: [UCHAR; 32usize],
}
impl Default for _MEMORY_ENCLAVE_IMAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_ENCLAVE_IMAGE_INFORMATION = _MEMORY_ENCLAVE_IMAGE_INFORMATION;
pub type PMEMORY_ENCLAVE_IMAGE_INFORMATION = *mut _MEMORY_ENCLAVE_IMAGE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE {
   MemoryNotContiguous = 0,
   MemoryAlignedAndContiguous = 1,
   MemoryNotResident = 2,
   MemoryNotEligibleToMakeContiguous = 3,
   MemoryContiguityStateMax = 4,
}
pub use self::_MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE as MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION {
   pub __bindgen_anon_1: _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub AllInformation: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn State(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_State(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn State_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_State_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(State: ULONG, Reserved: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let State: u32 = unsafe { ::core::mem::transmute(State) };
         State as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION = _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION;
pub type PMEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION =
   *mut _MEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION {
   pub VirtualAddress: PVOID,
   pub Size: ULONG_PTR,
   pub ContiguityUnitSize: ULONG_PTR,
   pub Flags: ULONG,
   pub ContiguityUnitInformation: PMEMORY_PHYSICAL_CONTIGUITY_UNIT_INFORMATION,
}
impl Default for _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PHYSICAL_CONTIGUITY_INFORMATION = _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION;
pub type PMEMORY_PHYSICAL_CONTIGUITY_INFORMATION = *mut _MEMORY_PHYSICAL_CONTIGUITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_SCP_CFG_ARM64_HEADER {
   pub EcInvalidCallHandlerRva: ULONG,
   pub EcCfgCheckRva: ULONG,
   pub EcCfgCheckESRva: ULONG,
   pub EcCallCheckRva: ULONG,
   pub CpuInitializationCompleteLoadRva: ULONG,
   pub LdrpValidateEcCallTargetInitRva: ULONG,
   pub SyscallFfsSizeRva: ULONG,
   pub SyscallFfsBaseRva: ULONG,
}
pub type RTL_SCP_CFG_ARM64_HEADER = _RTL_SCP_CFG_ARM64_HEADER;
pub type PRTL_SCP_CFG_ARM64_HEADER = *mut _RTL_SCP_CFG_ARM64_HEADER;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_SCP_CFG_PAGE_TYPE {
   RtlScpCfgPageTypeNop = 0,
   RtlScpCfgPageTypeDefault = 1,
   RtlScpCfgPageTypeExportSuppression = 2,
   RtlScpCfgPageTypeFptr = 3,
   RtlScpCfgPageTypeMax = 4,
   RtlScpCfgPageTypeNone = 5,
}
pub use self::_RTL_SCP_CFG_PAGE_TYPE as RTL_SCP_CFG_PAGE_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_SCP_CFG_COMMON_HEADER {
   pub CfgDispatchRva: ULONG,
   pub CfgDispatchESRva: ULONG,
   pub CfgCheckRva: ULONG,
   pub CfgCheckESRva: ULONG,
   pub InvalidCallHandlerRva: ULONG,
   pub FnTableRva: ULONG,
}
pub type RTL_SCP_CFG_COMMON_HEADER = _RTL_SCP_CFG_COMMON_HEADER;
pub type PRTL_SCP_CFG_COMMON_HEADER = *mut _RTL_SCP_CFG_COMMON_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_SCP_CFG_HEADER {
   pub Common: RTL_SCP_CFG_COMMON_HEADER,
}
pub type RTL_SCP_CFG_HEADER = _RTL_SCP_CFG_HEADER;
pub type PRTL_SCP_CFG_HEADER = *mut _RTL_SCP_CFG_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SCP_CFG_REGION_BOUNDS {
   pub StartAddress: PVOID,
   pub EndAddress: PVOID,
}
impl Default for _RTL_SCP_CFG_REGION_BOUNDS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SCP_CFG_REGION_BOUNDS = _RTL_SCP_CFG_REGION_BOUNDS;
pub type PRTL_SCP_CFG_REGION_BOUNDS = *mut _RTL_SCP_CFG_REGION_BOUNDS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SCP_CFG_NTDLL_EXPORTS {
   pub ScpRegions: [RTL_SCP_CFG_REGION_BOUNDS; 4usize],
   pub CfgDispatchFptr: PVOID,
   pub CfgDispatchESFptr: PVOID,
   pub CfgCheckFptr: PVOID,
   pub CfgCheckESFptr: PVOID,
   pub IllegalCallHandler: PVOID,
}
impl Default for _RTL_SCP_CFG_NTDLL_EXPORTS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SCP_CFG_NTDLL_EXPORTS = _RTL_SCP_CFG_NTDLL_EXPORTS;
pub type PRTL_SCP_CFG_NTDLL_EXPORTS = *mut _RTL_SCP_CFG_NTDLL_EXPORTS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC {
   pub EcInvalidCallHandler: PVOID,
   pub EcCfgCheckFptr: PVOID,
   pub EcCfgCheckESFptr: PVOID,
   pub EcCallCheckFptr: PVOID,
   pub CpuInitializationComplete: PVOID,
   pub LdrpValidateEcCallTargetInit: PVOID,
   pub __bindgen_anon_1: _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC__bindgen_ty_1,
   pub SyscallFfsBase: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC__bindgen_ty_1 {
   pub SyscallFfsSize: PVOID,
   pub __bindgen_anon_1: _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC__bindgen_ty_1__bindgen_ty_1 {
   pub Ptr: PVOID,
   pub Value: ULONG,
}
impl Default for _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC = _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC;
pub type PRTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC = *mut _RTL_SCP_CFG_NTDLL_EXPORTS_ARM64EC;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_RETPOLINE_ROUTINES {
   pub SwitchtableJump: [ULONG; 16usize],
   pub CfgIndirectRax: ULONG,
   pub NonCfgIndirectRax: ULONG,
   pub ImportR10: ULONG,
   pub JumpHpat: ULONG,
}
pub type RTL_RETPOLINE_ROUTINES = _RTL_RETPOLINE_ROUTINES;
pub type PRTL_RETPOLINE_ROUTINES = *mut _RTL_RETPOLINE_ROUTINES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_KSCP_ROUTINES {
   pub UnwindDataOffset: ULONG,
   pub RetpolineRoutines: RTL_RETPOLINE_ROUTINES,
   pub CfgDispatchSmep: ULONG,
   pub CfgDispatchNoSmep: ULONG,
}
pub type RTL_KSCP_ROUTINES = _RTL_KSCP_ROUTINES;
pub type PRTL_KSCP_ROUTINES = *mut _RTL_KSCP_ROUTINES;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_IMAGE_EXTENSION_TYPE {
   MemoryImageExtensionCfgScp = 0,
   MemoryImageExtensionCfgEmulatedScp = 1,
   MemoryImageExtensionTypeMax = 2,
}
pub use self::_MEMORY_IMAGE_EXTENSION_TYPE as MEMORY_IMAGE_EXTENSION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_IMAGE_EXTENSION_INFORMATION {
   pub ExtensionType: MEMORY_IMAGE_EXTENSION_TYPE,
   pub Flags: ULONG,
   pub ExtensionImageBaseRva: PVOID,
   pub ExtensionSize: SIZE_T,
}
impl Default for _MEMORY_IMAGE_EXTENSION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_IMAGE_EXTENSION_INFORMATION = _MEMORY_IMAGE_EXTENSION_INFORMATION;
pub type PMEMORY_IMAGE_EXTENSION_INFORMATION = *mut _MEMORY_IMAGE_EXTENSION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_FRAME_INFORMATION {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _MEMORY_FRAME_INFORMATION {
   #[inline]
   pub fn UseDescription(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u64) }
   }
   #[inline]
   pub fn set_UseDescription(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UseDescription_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            4u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_UseDescription_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ListDescription(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_ListDescription(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ListDescription_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ListDescription_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Cold(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Cold(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Cold_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Cold_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Pinned(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Pinned(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Pinned_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Pinned_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DontUse(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_DontUse(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DontUse_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            48u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DontUse_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            48u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Priority(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(57usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Priority_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            57usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Priority_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            57usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NonTradeable(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_NonTradeable(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(60usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NonTradeable_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            60usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_NonTradeable_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            60usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(61usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            61usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            61usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      UseDescription: ULONGLONG,
      ListDescription: ULONGLONG,
      Cold: ULONGLONG,
      Pinned: ULONGLONG,
      DontUse: ULONGLONG,
      Priority: ULONGLONG,
      NonTradeable: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let UseDescription: u64 = unsafe { ::core::mem::transmute(UseDescription) };
         UseDescription as u64
      });
      __bindgen_bitfield_unit.set(4usize, 3u8, {
         let ListDescription: u64 = unsafe { ::core::mem::transmute(ListDescription) };
         ListDescription as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let Cold: u64 = unsafe { ::core::mem::transmute(Cold) };
         Cold as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let Pinned: u64 = unsafe { ::core::mem::transmute(Pinned) };
         Pinned as u64
      });
      __bindgen_bitfield_unit.set(9usize, 48u8, {
         let DontUse: u64 = unsafe { ::core::mem::transmute(DontUse) };
         DontUse as u64
      });
      __bindgen_bitfield_unit.set(57usize, 3u8, {
         let Priority: u64 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit.set(60usize, 1u8, {
         let NonTradeable: u64 = unsafe { ::core::mem::transmute(NonTradeable) };
         NonTradeable as u64
      });
      __bindgen_bitfield_unit.set(61usize, 3u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type MEMORY_FRAME_INFORMATION = _MEMORY_FRAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILEOFFSET_INFORMATION {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _FILEOFFSET_INFORMATION {
   #[inline]
   pub fn DontUse(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u64) }
   }
   #[inline]
   pub fn set_DontUse(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 9u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DontUse_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            9u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DontUse_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            9u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Offset(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_Offset(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Offset_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            48u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Offset_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            48u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(57usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            57usize,
            7u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            57usize,
            7u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DontUse: ULONGLONG,
      Offset: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 9u8, {
         let DontUse: u64 = unsafe { ::core::mem::transmute(DontUse) };
         DontUse as u64
      });
      __bindgen_bitfield_unit.set(9usize, 48u8, {
         let Offset: u64 = unsafe { ::core::mem::transmute(Offset) };
         Offset as u64
      });
      __bindgen_bitfield_unit.set(57usize, 7u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type FILEOFFSET_INFORMATION = _FILEOFFSET_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PAGEDIR_INFORMATION {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PAGEDIR_INFORMATION {
   #[inline]
   pub fn DontUse(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u64) }
   }
   #[inline]
   pub fn set_DontUse(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 9u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DontUse_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            9u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DontUse_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            9u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PageDirectoryBase(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_PageDirectoryBase(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PageDirectoryBase_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            48u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_PageDirectoryBase_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            48u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(57usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            57usize,
            7u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            57usize,
            7u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DontUse: ULONGLONG,
      PageDirectoryBase: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 9u8, {
         let DontUse: u64 = unsafe { ::core::mem::transmute(DontUse) };
         DontUse as u64
      });
      __bindgen_bitfield_unit.set(9usize, 48u8, {
         let PageDirectoryBase: u64 = unsafe { ::core::mem::transmute(PageDirectoryBase) };
         PageDirectoryBase as u64
      });
      __bindgen_bitfield_unit.set(57usize, 7u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PAGEDIR_INFORMATION = _PAGEDIR_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _UNIQUE_PROCESS_INFORMATION {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _UNIQUE_PROCESS_INFORMATION {
   #[inline]
   pub fn DontUse(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u64) }
   }
   #[inline]
   pub fn set_DontUse(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 9u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DontUse_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            9u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_DontUse_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            9u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UniqueProcessKey(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_UniqueProcessKey(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UniqueProcessKey_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            48u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_UniqueProcessKey_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            48u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(57usize, 7u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            57usize,
            7u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            57usize,
            7u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DontUse: ULONGLONG,
      UniqueProcessKey: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 9u8, {
         let DontUse: u64 = unsafe { ::core::mem::transmute(DontUse) };
         DontUse as u64
      });
      __bindgen_bitfield_unit.set(9usize, 48u8, {
         let UniqueProcessKey: u64 = unsafe { ::core::mem::transmute(UniqueProcessKey) };
         UniqueProcessKey as u64
      });
      __bindgen_bitfield_unit.set(57usize, 7u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type UNIQUE_PROCESS_INFORMATION = _UNIQUE_PROCESS_INFORMATION;
pub type PUNIQUE_PROCESS_INFORMATION = *mut _UNIQUE_PROCESS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPFN_IDENTITY {
   pub u1: _MMPFN_IDENTITY__bindgen_ty_1,
   pub PageFrameIndex: ULONG_PTR,
   pub u2: _MMPFN_IDENTITY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN_IDENTITY__bindgen_ty_1 {
   pub e1: MEMORY_FRAME_INFORMATION,
   pub e2: FILEOFFSET_INFORMATION,
   pub e3: PAGEDIR_INFORMATION,
   pub e4: UNIQUE_PROCESS_INFORMATION,
}
impl Default for _MMPFN_IDENTITY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPFN_IDENTITY__bindgen_ty_2 {
   pub e1: _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_1,
   pub e2: _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_2,
   pub FileObject: ULONG_PTR,
   pub UniqueFileObjectKey: ULONG_PTR,
   pub ProtoPteAddress: ULONG_PTR,
   pub VirtualAddress: ULONG_PTR,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 7usize],
}
impl _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn Image(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Image(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Image_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Image_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Mismatch(&self) -> ULONG_PTR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_Mismatch(&mut self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Mismatch_raw(this: *const Self) -> ULONG_PTR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Mismatch_raw(this: *mut Self, val: ULONG_PTR) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Image: ULONG_PTR,
      Mismatch: ULONG_PTR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Image: u64 = unsafe { ::core::mem::transmute(Image) };
         Image as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Mismatch: u64 = unsafe { ::core::mem::transmute(Mismatch) };
         Mismatch as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN_IDENTITY__bindgen_ty_2__bindgen_ty_2 {
   pub CombinedPage: ULONG_PTR,
}
impl Default for _MMPFN_IDENTITY__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MMPFN_IDENTITY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MMPFN_IDENTITY = _MMPFN_IDENTITY;
pub type PMMPFN_IDENTITY = *mut _MMPFN_IDENTITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MMPFN_MEMSNAP_INFORMATION {
   pub InitialPageFrameIndex: ULONG_PTR,
   pub Count: ULONG_PTR,
}
pub type MMPFN_MEMSNAP_INFORMATION = _MMPFN_MEMSNAP_INFORMATION;
pub type PMMPFN_MEMSNAP_INFORMATION = *mut _MMPFN_MEMSNAP_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECTION_INFORMATION_CLASS {
   SectionBasicInformation = 0,
   SectionImageInformation = 1,
   SectionRelocationInformation = 2,
   SectionOriginalBaseInformation = 3,
   SectionInternalImageInformation = 4,
   MaxSectionInfoClass = 5,
}
pub use self::_SECTION_INFORMATION_CLASS as SECTION_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SECTION_BASIC_INFORMATION {
   pub BaseAddress: PVOID,
   pub AllocationAttributes: ULONG,
   pub MaximumSize: LARGE_INTEGER,
}
impl Default for _SECTION_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SECTION_BASIC_INFORMATION = _SECTION_BASIC_INFORMATION;
pub type PSECTION_BASIC_INFORMATION = *mut _SECTION_BASIC_INFORMATION;
#[repr(C)]
pub struct _SECTION_IMAGE_INFORMATION {
   pub TransferAddress: PVOID,
   pub ZeroBits: ULONG,
   pub MaximumStackSize: SIZE_T,
   pub CommittedStackSize: SIZE_T,
   pub SubSystemType: ULONG,
   pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_1,
   pub __bindgen_anon_2: _SECTION_IMAGE_INFORMATION__bindgen_ty_2,
   pub ImageCharacteristics: USHORT,
   pub DllCharacteristics: USHORT,
   pub Machine: USHORT,
   pub ImageContainsCode: BOOLEAN,
   pub __bindgen_anon_3: _SECTION_IMAGE_INFORMATION__bindgen_ty_3,
   pub LoaderFlags: ULONG,
   pub ImageFileSize: ULONG,
   pub CheckSum: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub SubSystemVersion: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub SubSystemMinorVersion: USHORT,
   pub SubSystemMajorVersion: USHORT,
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_2 {
   pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1,
   pub OperatingSystemVersion: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub MajorOperatingSystemVersion: USHORT,
   pub MinorOperatingSystemVersion: USHORT,
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_IMAGE_INFORMATION__bindgen_ty_3 {
   pub ImageFlags: UCHAR,
   pub __bindgen_anon_1: _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SECTION_IMAGE_INFORMATION__bindgen_ty_3__bindgen_ty_1 {
   #[inline]
   pub fn ComPlusNativeReady(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ComPlusNativeReady(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ComPlusNativeReady_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ComPlusNativeReady_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ComPlusILOnly(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ComPlusILOnly(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ComPlusILOnly_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ComPlusILOnly_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageDynamicallyRelocated(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ImageDynamicallyRelocated(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageDynamicallyRelocated_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ImageDynamicallyRelocated_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageMappedFlat(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ImageMappedFlat(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageMappedFlat_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ImageMappedFlat_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BaseBelow4gb(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_BaseBelow4gb(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BaseBelow4gb_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_BaseBelow4gb_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ComPlusPrefer32bit(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ComPlusPrefer32bit(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ComPlusPrefer32bit_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ComPlusPrefer32bit_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            2u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ComPlusNativeReady: UCHAR,
      ComPlusILOnly: UCHAR,
      ImageDynamicallyRelocated: UCHAR,
      ImageMappedFlat: UCHAR,
      BaseBelow4gb: UCHAR,
      ComPlusPrefer32bit: UCHAR,
      Reserved: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ComPlusNativeReady: u8 = unsafe { ::core::mem::transmute(ComPlusNativeReady) };
         ComPlusNativeReady as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ComPlusILOnly: u8 = unsafe { ::core::mem::transmute(ComPlusILOnly) };
         ComPlusILOnly as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ImageDynamicallyRelocated: u8 =
            unsafe { ::core::mem::transmute(ImageDynamicallyRelocated) };
         ImageDynamicallyRelocated as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ImageMappedFlat: u8 = unsafe { ::core::mem::transmute(ImageMappedFlat) };
         ImageMappedFlat as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let BaseBelow4gb: u8 = unsafe { ::core::mem::transmute(BaseBelow4gb) };
         BaseBelow4gb as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ComPlusPrefer32bit: u8 = unsafe { ::core::mem::transmute(ComPlusPrefer32bit) };
         ComPlusPrefer32bit as u64
      });
      __bindgen_bitfield_unit.set(6usize, 2u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SECTION_IMAGE_INFORMATION__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SECTION_IMAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SECTION_IMAGE_INFORMATION = _SECTION_IMAGE_INFORMATION;
pub type PSECTION_IMAGE_INFORMATION = *mut _SECTION_IMAGE_INFORMATION;
#[repr(C)]
pub struct _SECTION_INTERNAL_IMAGE_INFORMATION {
   pub SectionInformation: SECTION_IMAGE_INFORMATION,
   pub __bindgen_anon_1: _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1 {
   pub ExtendedFlags: ULONG,
   pub __bindgen_anon_1: _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ImageExportSuppressionEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageExportSuppressionEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageExportSuppressionEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageExportSuppressionEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageCetShadowStacksReady(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetShadowStacksReady(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageCetShadowStacksReady_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageCetShadowStacksReady_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageXfgEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageXfgEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageXfgEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageXfgEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageCetShadowStacksStrictMode(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetShadowStacksStrictMode(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageCetShadowStacksStrictMode_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageCetShadowStacksStrictMode_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageCetSetContextIpValidationRelaxedMode(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetSetContextIpValidationRelaxedMode(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageCetSetContextIpValidationRelaxedMode_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageCetSetContextIpValidationRelaxedMode_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageCetDynamicApisAllowInProc(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetDynamicApisAllowInProc(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageCetDynamicApisAllowInProc_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageCetDynamicApisAllowInProc_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageCetDowngradeReserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetDowngradeReserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageCetDowngradeReserved1_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageCetDowngradeReserved1_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageCetDowngradeReserved2(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCetDowngradeReserved2(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageCetDowngradeReserved2_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageCetDowngradeReserved2_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageExportSuppressionInfoPresent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageExportSuppressionInfoPresent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageExportSuppressionInfoPresent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageExportSuppressionInfoPresent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageCfgEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageCfgEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageCfgEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageCfgEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 22u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            22u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            22u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ImageExportSuppressionEnabled: ULONG,
      ImageCetShadowStacksReady: ULONG,
      ImageXfgEnabled: ULONG,
      ImageCetShadowStacksStrictMode: ULONG,
      ImageCetSetContextIpValidationRelaxedMode: ULONG,
      ImageCetDynamicApisAllowInProc: ULONG,
      ImageCetDowngradeReserved1: ULONG,
      ImageCetDowngradeReserved2: ULONG,
      ImageExportSuppressionInfoPresent: ULONG,
      ImageCfgEnabled: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ImageExportSuppressionEnabled: u32 =
            unsafe { ::core::mem::transmute(ImageExportSuppressionEnabled) };
         ImageExportSuppressionEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ImageCetShadowStacksReady: u32 =
            unsafe { ::core::mem::transmute(ImageCetShadowStacksReady) };
         ImageCetShadowStacksReady as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ImageXfgEnabled: u32 = unsafe { ::core::mem::transmute(ImageXfgEnabled) };
         ImageXfgEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ImageCetShadowStacksStrictMode: u32 =
            unsafe { ::core::mem::transmute(ImageCetShadowStacksStrictMode) };
         ImageCetShadowStacksStrictMode as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let ImageCetSetContextIpValidationRelaxedMode: u32 =
            unsafe { ::core::mem::transmute(ImageCetSetContextIpValidationRelaxedMode) };
         ImageCetSetContextIpValidationRelaxedMode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ImageCetDynamicApisAllowInProc: u32 =
            unsafe { ::core::mem::transmute(ImageCetDynamicApisAllowInProc) };
         ImageCetDynamicApisAllowInProc as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ImageCetDowngradeReserved1: u32 =
            unsafe { ::core::mem::transmute(ImageCetDowngradeReserved1) };
         ImageCetDowngradeReserved1 as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let ImageCetDowngradeReserved2: u32 =
            unsafe { ::core::mem::transmute(ImageCetDowngradeReserved2) };
         ImageCetDowngradeReserved2 as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let ImageExportSuppressionInfoPresent: u32 =
            unsafe { ::core::mem::transmute(ImageExportSuppressionInfoPresent) };
         ImageExportSuppressionInfoPresent as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let ImageCfgEnabled: u32 = unsafe { ::core::mem::transmute(ImageCfgEnabled) };
         ImageCfgEnabled as u64
      });
      __bindgen_bitfield_unit.set(10usize, 22u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SECTION_INTERNAL_IMAGE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SECTION_INTERNAL_IMAGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SECTION_INTERNAL_IMAGE_INFORMATION = _SECTION_INTERNAL_IMAGE_INFORMATION;
pub type PSECTION_INTERNAL_IMAGE_INFORMATION = *mut _SECTION_INTERNAL_IMAGE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECTION_INHERIT {
   ViewShare = 1,
   ViewUnmap = 2,
}
pub use self::_SECTION_INHERIT as SECTION_INHERIT;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _VIRTUAL_MEMORY_INFORMATION_CLASS {
   VmPrefetchInformation = 0,
   VmPagePriorityInformation = 1,
   VmCfgCallTargetInformation = 2,
   VmPageDirtyStateInformation = 3,
   VmImageHotPatchInformation = 4,
   VmPhysicalContiguityInformation = 5,
   VmVirtualMachinePrepopulateInformation = 6,
   VmRemoveFromWorkingSetInformation = 7,
   MaxVmInfoClass = 8,
}
pub use self::_VIRTUAL_MEMORY_INFORMATION_CLASS as VIRTUAL_MEMORY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_RANGE_ENTRY {
   pub VirtualAddress: PVOID,
   pub NumberOfBytes: SIZE_T,
}
impl Default for _MEMORY_RANGE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_RANGE_ENTRY = _MEMORY_RANGE_ENTRY;
pub type PMEMORY_RANGE_ENTRY = *mut _MEMORY_RANGE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PREFETCH_INFORMATION {
   pub Flags: ULONG,
}
pub type MEMORY_PREFETCH_INFORMATION = _MEMORY_PREFETCH_INFORMATION;
pub type PMEMORY_PREFETCH_INFORMATION = *mut _MEMORY_PREFETCH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CFG_CALL_TARGET_LIST_INFORMATION {
   pub NumberOfEntries: ULONG,
   pub Reserved: ULONG,
   pub NumberOfEntriesProcessed: PULONG,
   pub CallTargetInfo: PCFG_CALL_TARGET_INFO,
   pub Section: PVOID,
   pub FileOffset: ULONGLONG,
}
impl Default for _CFG_CALL_TARGET_LIST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CFG_CALL_TARGET_LIST_INFORMATION = _CFG_CALL_TARGET_LIST_INFORMATION;
pub type PCFG_CALL_TARGET_LIST_INFORMATION = *mut _CFG_CALL_TARGET_LIST_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PARTITION_INFORMATION_CLASS {
   SystemMemoryPartitionInformation = 0,
   SystemMemoryPartitionMoveMemory = 1,
   SystemMemoryPartitionAddPagefile = 2,
   SystemMemoryPartitionCombineMemory = 3,
   SystemMemoryPartitionInitialAddMemory = 4,
   SystemMemoryPartitionGetMemoryEvents = 5,
   SystemMemoryPartitionSetAttributes = 6,
   SystemMemoryPartitionNodeInformation = 7,
   SystemMemoryPartitionCreateLargePages = 8,
   SystemMemoryPartitionDedicatedMemoryInformation = 9,
   SystemMemoryPartitionOpenDedicatedMemory = 10,
   SystemMemoryPartitionMemoryChargeAttributes = 11,
   SystemMemoryPartitionClearAttributes = 12,
   SystemMemoryPartitionSetMemoryThresholds = 13,
   SystemMemoryPartitionMemoryListCommand = 14,
   SystemMemoryPartitionMax = 15,
}
pub use self::_PARTITION_INFORMATION_CLASS as PARTITION_INFORMATION_CLASS;
pub type PPARTITION_INFORMATION_CLASS = *mut _PARTITION_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION {
   pub Flags: ULONG,
   pub NumaNode: ULONG,
   pub Channel: ULONG,
   pub NumberOfNumaNodes: ULONG,
   pub ResidentAvailablePages: SIZE_T,
   pub CommittedPages: SIZE_T,
   pub CommitLimit: SIZE_T,
   pub PeakCommitment: SIZE_T,
   pub TotalNumberOfPages: SIZE_T,
   pub AvailablePages: SIZE_T,
   pub ZeroPages: SIZE_T,
   pub FreePages: SIZE_T,
   pub StandbyPages: SIZE_T,
   pub StandbyPageCountByPriority: [SIZE_T; 8usize],
   pub RepurposedPagesByPriority: [SIZE_T; 8usize],
   pub MaximumCommitLimit: SIZE_T,
   pub Reserved: SIZE_T,
   pub PartitionId: ULONG,
}
pub type MEMORY_PARTITION_CONFIGURATION_INFORMATION = _MEMORY_PARTITION_CONFIGURATION_INFORMATION;
pub type PMEMORY_PARTITION_CONFIGURATION_INFORMATION =
   *mut _MEMORY_PARTITION_CONFIGURATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_TRANSFER_INFORMATION {
   pub NumberOfPages: SIZE_T,
   pub NumaNode: ULONG,
   pub Flags: ULONG,
}
pub type MEMORY_PARTITION_TRANSFER_INFORMATION = _MEMORY_PARTITION_TRANSFER_INFORMATION;
pub type PMEMORY_PARTITION_TRANSFER_INFORMATION = *mut _MEMORY_PARTITION_TRANSFER_INFORMATION;
#[repr(C)]
pub struct _MEMORY_PARTITION_PAGEFILE_INFORMATION {
   pub PageFileName: UNICODE_STRING,
   pub MinimumSize: LARGE_INTEGER,
   pub MaximumSize: LARGE_INTEGER,
   pub Flags: ULONG,
}
impl Default for _MEMORY_PARTITION_PAGEFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PARTITION_PAGEFILE_INFORMATION = _MEMORY_PARTITION_PAGEFILE_INFORMATION;
pub type PMEMORY_PARTITION_PAGEFILE_INFORMATION = *mut _MEMORY_PARTITION_PAGEFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
   pub StopHandle: HANDLE,
   pub Flags: ULONG,
   pub TotalNumberOfPages: SIZE_T,
}
impl Default for _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PARTITION_PAGE_COMBINE_INFORMATION = _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION;
pub type PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION =
   *mut _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_PAGE_RANGE {
   pub StartPage: ULONG_PTR,
   pub NumberOfPages: ULONG_PTR,
}
pub type MEMORY_PARTITION_PAGE_RANGE = _MEMORY_PARTITION_PAGE_RANGE;
pub type PMEMORY_PARTITION_PAGE_RANGE = *mut _MEMORY_PARTITION_PAGE_RANGE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION {
   pub Flags: ULONG,
   pub NumberOfRanges: ULONG,
   pub NumberOfPagesAdded: SIZE_T,
   pub PartitionRanges: [MEMORY_PARTITION_PAGE_RANGE; 1usize],
}
pub type MEMORY_PARTITION_INITIAL_ADD_INFORMATION = _MEMORY_PARTITION_INITIAL_ADD_INFORMATION;
pub type PMEMORY_PARTITION_INITIAL_ADD_INFORMATION = *mut _MEMORY_PARTITION_INITIAL_ADD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION {
   pub Flags: _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1,
   pub HandleAttributes: ULONG,
   pub DesiredAccess: ACCESS_MASK,
   pub LowCommitCondition: HANDLE,
   pub HighCommitCondition: HANDLE,
   pub MaximumCommitCondition: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn CommitEvents(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CommitEvents(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CommitEvents_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CommitEvents_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(CommitEvents: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let CommitEvents: u32 = unsafe { ::core::mem::transmute(CommitEvents) };
         CommitEvents as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION = _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION;
pub type PMEMORY_PARTITION_MEMORY_EVENTS_INFORMATION =
   *mut _MEMORY_PARTITION_MEMORY_EVENTS_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _OBJECT_INFORMATION_CLASS {
   ObjectBasicInformation = 0,
   ObjectNameInformation = 1,
   ObjectTypeInformation = 2,
   ObjectTypesInformation = 3,
   ObjectHandleFlagInformation = 4,
   ObjectSessionInformation = 5,
   ObjectSessionObjectInformation = 6,
   MaxObjectInfoClass = 7,
}
pub use self::_OBJECT_INFORMATION_CLASS as OBJECT_INFORMATION_CLASS;
#[doc = "The OBJECT_BASIC_INFORMATION structure contains basic information about an object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_BASIC_INFORMATION {
   pub Attributes: ULONG,
   pub GrantedAccess: ACCESS_MASK,
   pub HandleCount: ULONG,
   pub PointerCount: ULONG,
   pub PagedPoolCharge: ULONG,
   pub NonPagedPoolCharge: ULONG,
   pub Reserved: [ULONG; 3usize],
   pub NameInfoSize: ULONG,
   pub TypeInfoSize: ULONG,
   pub SecurityDescriptorSize: ULONG,
   pub CreationTime: LARGE_INTEGER,
}
impl Default for _OBJECT_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The OBJECT_BASIC_INFORMATION structure contains basic information about an object."]
pub type OBJECT_BASIC_INFORMATION = _OBJECT_BASIC_INFORMATION;
#[doc = "The OBJECT_BASIC_INFORMATION structure contains basic information about an object."]
pub type POBJECT_BASIC_INFORMATION = *mut _OBJECT_BASIC_INFORMATION;
#[doc = "The OBJECT_NAME_INFORMATION structure contains the name, if there is one, of a given object."]
#[repr(C)]
pub struct _OBJECT_NAME_INFORMATION {
   pub Name: UNICODE_STRING,
}
impl Default for _OBJECT_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The OBJECT_NAME_INFORMATION structure contains the name, if there is one, of a given object."]
pub type OBJECT_NAME_INFORMATION = _OBJECT_NAME_INFORMATION;
#[doc = "The OBJECT_NAME_INFORMATION structure contains the name, if there is one, of a given object."]
pub type POBJECT_NAME_INFORMATION = *mut _OBJECT_NAME_INFORMATION;
#[doc = "The OBJECT_NAME_INFORMATION structure contains various statistics and properties about an object type."]
#[repr(C)]
pub struct _OBJECT_TYPE_INFORMATION {
   pub TypeName: UNICODE_STRING,
   pub TotalNumberOfObjects: ULONG,
   pub TotalNumberOfHandles: ULONG,
   pub TotalPagedPoolUsage: ULONG,
   pub TotalNonPagedPoolUsage: ULONG,
   pub TotalNamePoolUsage: ULONG,
   pub TotalHandleTableUsage: ULONG,
   pub HighWaterNumberOfObjects: ULONG,
   pub HighWaterNumberOfHandles: ULONG,
   pub HighWaterPagedPoolUsage: ULONG,
   pub HighWaterNonPagedPoolUsage: ULONG,
   pub HighWaterNamePoolUsage: ULONG,
   pub HighWaterHandleTableUsage: ULONG,
   pub InvalidAttributes: ULONG,
   pub GenericMapping: GENERIC_MAPPING,
   pub ValidAccessMask: ULONG,
   pub SecurityRequired: BOOLEAN,
   pub MaintainHandleCount: BOOLEAN,
   pub TypeIndex: UCHAR,
   pub ReservedByte: CHAR,
   pub PoolType: ULONG,
   pub DefaultPagedPoolCharge: ULONG,
   pub DefaultNonPagedPoolCharge: ULONG,
}
impl Default for _OBJECT_TYPE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The OBJECT_NAME_INFORMATION structure contains various statistics and properties about an object type."]
pub type OBJECT_TYPE_INFORMATION = _OBJECT_TYPE_INFORMATION;
#[doc = "The OBJECT_NAME_INFORMATION structure contains various statistics and properties about an object type."]
pub type POBJECT_TYPE_INFORMATION = *mut _OBJECT_TYPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_TYPES_INFORMATION {
   pub NumberOfTypes: ULONG,
}
pub type OBJECT_TYPES_INFORMATION = _OBJECT_TYPES_INFORMATION;
pub type POBJECT_TYPES_INFORMATION = *mut _OBJECT_TYPES_INFORMATION;
#[repr(C)]
pub struct _OBJECT_HANDLE_FLAG_INFORMATION {
   pub Inherit: BOOLEAN,
   pub ProtectFromClose: BOOLEAN,
}
impl Default for _OBJECT_HANDLE_FLAG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_HANDLE_FLAG_INFORMATION = _OBJECT_HANDLE_FLAG_INFORMATION;
pub type POBJECT_HANDLE_FLAG_INFORMATION = *mut _OBJECT_HANDLE_FLAG_INFORMATION;
#[repr(C)]
pub struct _OBJECT_DIRECTORY_INFORMATION {
   pub Name: UNICODE_STRING,
   pub TypeName: UNICODE_STRING,
}
impl Default for _OBJECT_DIRECTORY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_DIRECTORY_INFORMATION = _OBJECT_DIRECTORY_INFORMATION;
pub type POBJECT_DIRECTORY_INFORMATION = *mut _OBJECT_DIRECTORY_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BOUNDARY_ENTRY_TYPE {
   OBNS_Invalid = 0,
   OBNS_Name = 1,
   OBNS_SID = 2,
   OBNS_IL = 3,
}
pub use self::_BOUNDARY_ENTRY_TYPE as BOUNDARY_ENTRY_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_BOUNDARY_ENTRY {
   pub EntryType: BOUNDARY_ENTRY_TYPE,
   pub EntrySize: ULONG,
}
impl Default for _OBJECT_BOUNDARY_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_BOUNDARY_ENTRY = _OBJECT_BOUNDARY_ENTRY;
pub type POBJECT_BOUNDARY_ENTRY = *mut _OBJECT_BOUNDARY_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_BOUNDARY_DESCRIPTOR {
   pub Version: ULONG,
   pub Items: ULONG,
   pub TotalSize: ULONG,
   pub __bindgen_anon_1: _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn AddAppContainerSid(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AddAppContainerSid(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddAppContainerSid_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AddAppContainerSid_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      AddAppContainerSid: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let AddAppContainerSid: u32 = unsafe { ::core::mem::transmute(AddAppContainerSid) };
         AddAppContainerSid as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _OBJECT_BOUNDARY_DESCRIPTOR__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _OBJECT_BOUNDARY_DESCRIPTOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type OBJECT_BOUNDARY_DESCRIPTOR = _OBJECT_BOUNDARY_DESCRIPTOR;
pub type POBJECT_BOUNDARY_DESCRIPTOR = *mut _OBJECT_BOUNDARY_DESCRIPTOR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYMBOLIC_LINK_INFO_CLASS {
   SymbolicLinkGlobalInformation = 1,
   SymbolicLinkAccessMask = 2,
   MaxnSymbolicLinkInfoClass = 3,
}
pub use self::_SYMBOLIC_LINK_INFO_CLASS as SYMBOLIC_LINK_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA {
   pub Magic: ULONG,
   pub HeaderSize: ULONG,
   pub FormatVersion: ULONG,
   pub TotalSize: ULONG,
   pub DefaultTocOffset: ULONG,
   pub ExtendedTocOffset: ULONG,
   pub AssemblyRosterOffset: ULONG,
   pub Flags: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA = _ACTIVATION_CONTEXT_DATA;
pub type PACTIVATION_CONTEXT_DATA = *mut _ACTIVATION_CONTEXT_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_TOC_HEADER {
   pub HeaderSize: ULONG,
   pub EntryCount: ULONG,
   pub FirstEntryOffset: ULONG,
   pub Flags: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_TOC_HEADER = _ACTIVATION_CONTEXT_DATA_TOC_HEADER;
pub type PACTIVATION_CONTEXT_DATA_TOC_HEADER = *mut _ACTIVATION_CONTEXT_DATA_TOC_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_TOC_ENTRY {
   pub Id: ULONG,
   pub Offset: ULONG,
   pub Length: ULONG,
   pub Format: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_TOC_ENTRY = _ACTIVATION_CONTEXT_DATA_TOC_ENTRY;
pub type PACTIVATION_CONTEXT_DATA_TOC_ENTRY = *mut _ACTIVATION_CONTEXT_DATA_TOC_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER {
   pub HeaderSize: ULONG,
   pub EntryCount: ULONG,
   pub FirstEntryOffset: ULONG,
   pub Flags: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER = _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER;
pub type PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER =
   *mut _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY {
   pub ExtensionGuid: GUID,
   pub TocOffset: ULONG,
   pub Length: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY = _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY;
pub type PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY =
   *mut _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER {
   pub HeaderSize: ULONG,
   pub HashAlgorithm: ULONG,
   pub EntryCount: ULONG,
   pub FirstEntryOffset: ULONG,
   pub AssemblyInformationSectionOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER =
   _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER;
pub type PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER =
   *mut _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY {
   pub Flags: ULONG,
   pub PseudoKey: ULONG,
   pub AssemblyNameOffset: ULONG,
   pub AssemblyNameLength: ULONG,
   pub AssemblyInformationOffset: ULONG,
   pub AssemblyInformationLength: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY =
   _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY;
pub type PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY =
   *mut _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STRING_SECTION_HEADER {
   pub Magic: ULONG,
   pub HeaderSize: ULONG,
   pub FormatVersion: ULONG,
   pub DataFormatVersion: ULONG,
   pub Flags: ULONG,
   pub ElementCount: ULONG,
   pub ElementListOffset: ULONG,
   pub HashAlgorithm: ULONG,
   pub SearchStructureOffset: ULONG,
   pub UserDataOffset: ULONG,
   pub UserDataSize: ULONG,
}
pub type ACTIVATION_CONTEXT_STRING_SECTION_HEADER = _ACTIVATION_CONTEXT_STRING_SECTION_HEADER;
pub type PACTIVATION_CONTEXT_STRING_SECTION_HEADER = *mut _ACTIVATION_CONTEXT_STRING_SECTION_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STRING_SECTION_ENTRY {
   pub PseudoKey: ULONG,
   pub KeyOffset: ULONG,
   pub KeyLength: ULONG,
   pub Offset: ULONG,
   pub Length: ULONG,
   pub AssemblyRosterIndex: ULONG,
}
pub type ACTIVATION_CONTEXT_STRING_SECTION_ENTRY = _ACTIVATION_CONTEXT_STRING_SECTION_ENTRY;
pub type PACTIVATION_CONTEXT_STRING_SECTION_ENTRY = *mut _ACTIVATION_CONTEXT_STRING_SECTION_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE {
   pub BucketTableEntryCount: ULONG,
   pub BucketTableOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE =
   _ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE;
pub type PACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE =
   *mut _ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET {
   pub ChainCount: ULONG,
   pub ChainOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET =
   _ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET;
pub type PACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET =
   *mut _ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_GUID_SECTION_HEADER {
   pub Magic: ULONG,
   pub HeaderSize: ULONG,
   pub FormatVersion: ULONG,
   pub DataFormatVersion: ULONG,
   pub Flags: ULONG,
   pub ElementCount: ULONG,
   pub ElementListOffset: ULONG,
   pub SearchStructureOffset: ULONG,
   pub UserDataOffset: ULONG,
   pub UserDataSize: ULONG,
}
pub type ACTIVATION_CONTEXT_GUID_SECTION_HEADER = _ACTIVATION_CONTEXT_GUID_SECTION_HEADER;
pub type PACTIVATION_CONTEXT_GUID_SECTION_HEADER = *mut _ACTIVATION_CONTEXT_GUID_SECTION_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_GUID_SECTION_ENTRY {
   pub Guid: GUID,
   pub Offset: ULONG,
   pub Length: ULONG,
   pub AssemblyRosterIndex: ULONG,
}
pub type ACTIVATION_CONTEXT_GUID_SECTION_ENTRY = _ACTIVATION_CONTEXT_GUID_SECTION_ENTRY;
pub type PACTIVATION_CONTEXT_GUID_SECTION_ENTRY = *mut _ACTIVATION_CONTEXT_GUID_SECTION_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE {
   pub BucketTableEntryCount: ULONG,
   pub BucketTableOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE = _ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE;
pub type PACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE =
   *mut _ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET {
   pub ChainCount: ULONG,
   pub ChainOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET = _ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET;
pub type PACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET =
   *mut _ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub EncodedAssemblyIdentityLength: ULONG,
   pub EncodedAssemblyIdentityOffset: ULONG,
   pub ManifestPathType: ULONG,
   pub ManifestPathLength: ULONG,
   pub ManifestPathOffset: ULONG,
   pub ManifestLastWriteTime: LARGE_INTEGER,
   pub PolicyPathType: ULONG,
   pub PolicyPathLength: ULONG,
   pub PolicyPathOffset: ULONG,
   pub PolicyLastWriteTime: LARGE_INTEGER,
   pub MetadataSatelliteRosterIndex: ULONG,
   pub Unused2: ULONG,
   pub ManifestVersionMajor: ULONG,
   pub ManifestVersionMinor: ULONG,
   pub PolicyVersionMajor: ULONG,
   pub PolicyVersionMinor: ULONG,
   pub AssemblyDirectoryNameLength: ULONG,
   pub AssemblyDirectoryNameOffset: ULONG,
   pub NumOfFilesInAssembly: ULONG,
   pub LanguageLength: ULONG,
   pub LanguageOffset: ULONG,
   pub RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
   pub UiAccess: ULONG,
}
impl Default for _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION =
   _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;
pub type PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION =
   *mut _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub PolicyCoherencyGuid: GUID,
   pub PolicyOverrideGuid: GUID,
   pub ApplicationDirectoryPathType: ULONG,
   pub ApplicationDirectoryLength: ULONG,
   pub ApplicationDirectoryOffset: ULONG,
   pub ResourceName: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION =
   _ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION;
pub type PACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION =
   *mut _ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub TotalPathLength: ULONG,
   pub PathSegmentCount: ULONG,
   pub PathSegmentOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION = _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION = *mut _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT {
   pub Length: ULONG,
   pub Offset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT =
   _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT;
pub type PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT =
   *mut _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub VersionSpecificClassNameLength: ULONG,
   pub VersionSpecificClassNameOffset: ULONG,
   pub DllNameLength: ULONG,
   pub DllNameOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub ThreadingModel: ULONG,
   pub ReferenceClsid: GUID,
   pub ConfiguredClsid: GUID,
   pub ImplementedClsid: GUID,
   pub TypeLibraryId: GUID,
   pub ModuleLength: ULONG,
   pub ModuleOffset: ULONG,
   pub ProgIdLength: ULONG,
   pub ProgIdOffset: ULONG,
   pub ShimDataLength: ULONG,
   pub ShimDataOffset: ULONG,
   pub MiscStatusDefault: ULONG,
   pub MiscStatusContent: ULONG,
   pub MiscStatusThumbnail: ULONG,
   pub MiscStatusIcon: ULONG,
   pub MiscStatusDocPrint: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub Type: ULONG,
   pub ModuleLength: ULONG,
   pub ModuleOffset: ULONG,
   pub TypeLength: ULONG,
   pub TypeOffset: ULONG,
   pub ShimVersionLength: ULONG,
   pub ShimVersionOffset: ULONG,
   pub DataLength: ULONG,
   pub DataOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM =
   _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM;
pub type PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM =
   *mut _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub ProxyStubClsid32: GUID,
   pub NumMethods: ULONG,
   pub TypeLibraryId: GUID,
   pub BaseInterface: GUID,
   pub NameLength: ULONG,
   pub NameOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION {
   pub Major: USHORT,
   pub Minor: USHORT,
}
pub type ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION =
   _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION;
pub type PACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION =
   *mut _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub NameLength: ULONG,
   pub NameOffset: ULONG,
   pub ResourceId: USHORT,
   pub LibraryFlags: USHORT,
   pub HelpDirLength: ULONG,
   pub HelpDirOffset: ULONG,
   pub Version: ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION,
}
pub type ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub ConfiguredClsidOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION =
   _ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION;
pub type PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION =
   *mut _ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_CLR_SURROGATE {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub SurrogateIdent: GUID,
   pub VersionOffset: ULONG,
   pub VersionLength: ULONG,
   pub TypeNameOffset: ULONG,
   pub TypeNameLength: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_CLR_SURROGATE = _ACTIVATION_CONTEXT_DATA_CLR_SURROGATE;
pub type PACTIVATION_CONTEXT_DATA_CLR_SURROGATE = *mut _ACTIVATION_CONTEXT_DATA_CLR_SURROGATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS {
   pub Size: ULONG,
   pub Flags: ULONG,
   pub SettingNamespaceLength: ULONG,
   pub SettingNamespaceOffset: ULONG,
   pub SettingNameLength: ULONG,
   pub SettingNameOffset: ULONG,
   pub SettingValueLength: ULONG,
   pub SettingValueOffset: ULONG,
}
pub type ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS =
   _ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS;
pub type PACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS =
   *mut _ACTIVATION_CONTEXT_DATA_APPLICATION_SETTINGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPATIBILITY_CONTEXT_ELEMENT_LEGACY {
   pub Id: GUID,
   pub Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
}
impl Default for _COMPATIBILITY_CONTEXT_ELEMENT_LEGACY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COMPATIBILITY_CONTEXT_ELEMENT_LEGACY = _COMPATIBILITY_CONTEXT_ELEMENT_LEGACY;
pub type PCOMPATIBILITY_CONTEXT_ELEMENT_LEGACY = *mut _COMPATIBILITY_CONTEXT_ELEMENT_LEGACY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY {
   pub ElementCount: ULONG,
   pub Elements: [COMPATIBILITY_CONTEXT_ELEMENT_LEGACY; 1usize],
}
impl Default for _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY =
   _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY;
pub type PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY =
   *mut _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_LEGACY;
#[repr(C)]
pub struct _ASSEMBLY_STORAGE_MAP_ENTRY {
   pub Flags: ULONG,
   pub DosPath: UNICODE_STRING,
   pub Handle: HANDLE,
}
impl Default for _ASSEMBLY_STORAGE_MAP_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ASSEMBLY_STORAGE_MAP_ENTRY = _ASSEMBLY_STORAGE_MAP_ENTRY;
pub type PASSEMBLY_STORAGE_MAP_ENTRY = *mut _ASSEMBLY_STORAGE_MAP_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ASSEMBLY_STORAGE_MAP {
   pub Flags: ULONG,
   pub AssemblyCount: ULONG,
   pub AssemblyArray: *mut PASSEMBLY_STORAGE_MAP_ENTRY,
}
impl Default for _ASSEMBLY_STORAGE_MAP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ASSEMBLY_STORAGE_MAP = _ASSEMBLY_STORAGE_MAP;
pub type PASSEMBLY_STORAGE_MAP = *mut _ASSEMBLY_STORAGE_MAP;
pub type PACTIVATION_CONTEXT_NOTIFY_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      NotificationType: ULONG,
      ActivationContext: PACTIVATION_CONTEXT,
      ActivationContextData: PACTIVATION_CONTEXT_DATA,
      NotificationContext: PVOID,
      NotificationData: PVOID,
      DisableThisNotification: PBOOLEAN,
   ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT {
   pub RefCount: LONG,
   pub Flags: ULONG,
   pub ActivationContextData: PACTIVATION_CONTEXT_DATA,
   pub NotificationRoutine: PACTIVATION_CONTEXT_NOTIFY_ROUTINE,
   pub NotificationContext: PVOID,
   pub SentNotifications: [ULONG; 8usize],
   pub DisabledNotifications: [ULONG; 8usize],
   pub StorageMap: ASSEMBLY_STORAGE_MAP,
   pub InlineStorageMapEntries: [PASSEMBLY_STORAGE_MAP_ENTRY; 32usize],
}
impl Default for _ACTIVATION_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTIVATION_CONTEXT = _ACTIVATION_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
   pub Previous: *mut _RTL_ACTIVATION_CONTEXT_STACK_FRAME,
   pub ActivationContext: PACTIVATION_CONTEXT,
   pub Flags: ULONG,
}
impl Default for _RTL_ACTIVATION_CONTEXT_STACK_FRAME {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_ACTIVATION_CONTEXT_STACK_FRAME = _RTL_ACTIVATION_CONTEXT_STACK_FRAME;
pub type PRTL_ACTIVATION_CONTEXT_STACK_FRAME = *mut _RTL_ACTIVATION_CONTEXT_STACK_FRAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_STACK {
   pub ActiveFrame: PRTL_ACTIVATION_CONTEXT_STACK_FRAME,
   pub FrameListCache: LIST_ENTRY,
   pub Flags: ULONG,
   pub NextCookieSequenceNumber: ULONG,
   pub StackId: ULONG,
}
impl Default for _ACTIVATION_CONTEXT_STACK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ACTIVATION_CONTEXT_STACK = _ACTIVATION_CONTEXT_STACK;
pub type PACTIVATION_CONTEXT_STACK = *mut _ACTIVATION_CONTEXT_STACK;
pub type PRTL_USER_PROCESS_PARAMETERS = *mut _RTL_USER_PROCESS_PARAMETERS;
pub type PSILO_USER_SHARED_DATA = *mut _SILO_USER_SHARED_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_SECOND_DATA {
   _unused: [u8; 0],
}
pub type PLEAP_SECOND_DATA = *mut _LEAP_SECOND_DATA;
pub type PEB_LDR_DATA = _PEB_LDR_DATA;
pub type PPEB_LDR_DATA = *mut _PEB_LDR_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _API_SET_NAMESPACE {
   pub Version: ULONG,
   pub Size: ULONG,
   pub Flags: ULONG,
   pub Count: ULONG,
   pub EntryOffset: ULONG,
   pub HashOffset: ULONG,
   pub HashFactor: ULONG,
}
pub type API_SET_NAMESPACE = _API_SET_NAMESPACE;
pub type PAPI_SET_NAMESPACE = *mut _API_SET_NAMESPACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _API_SET_HASH_ENTRY {
   pub Hash: ULONG,
   pub Index: ULONG,
}
pub type API_SET_HASH_ENTRY = _API_SET_HASH_ENTRY;
pub type PAPI_SET_HASH_ENTRY = *mut _API_SET_HASH_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _API_SET_NAMESPACE_ENTRY {
   pub Flags: ULONG,
   pub NameOffset: ULONG,
   pub NameLength: ULONG,
   pub HashedLength: ULONG,
   pub ValueOffset: ULONG,
   pub ValueCount: ULONG,
}
pub type API_SET_NAMESPACE_ENTRY = _API_SET_NAMESPACE_ENTRY;
pub type PAPI_SET_NAMESPACE_ENTRY = *mut _API_SET_NAMESPACE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _API_SET_VALUE_ENTRY {
   pub Flags: ULONG,
   pub NameOffset: ULONG,
   pub NameLength: ULONG,
   pub ValueOffset: ULONG,
   pub ValueLength: ULONG,
}
pub type API_SET_VALUE_ENTRY = _API_SET_VALUE_ENTRY;
pub type PAPI_SET_VALUE_ENTRY = *mut _API_SET_VALUE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TELEMETRY_COVERAGE_HEADER {
   pub MajorVersion: UCHAR,
   pub MinorVersion: UCHAR,
   pub __bindgen_anon_1: _TELEMETRY_COVERAGE_HEADER__bindgen_ty_1,
   pub HashTableEntries: ULONG,
   pub HashIndexMask: ULONG,
   pub TableUpdateVersion: ULONG,
   pub TableSizeInBytes: ULONG,
   pub LastResetTick: ULONG,
   pub ResetRound: ULONG,
   pub Reserved2: ULONG,
   pub RecordedCount: ULONG,
   pub Reserved3: [ULONG; 4usize],
   pub HashTable: [ULONG; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TELEMETRY_COVERAGE_HEADER__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TELEMETRY_COVERAGE_HEADER__bindgen_ty_1 {
   #[inline]
   pub fn TracingEnabled(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_TracingEnabled(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TracingEnabled_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_TracingEnabled_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved1(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 15u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved1_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            15u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved1_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            15u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      TracingEnabled: USHORT,
      Reserved1: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let TracingEnabled: u16 = unsafe { ::core::mem::transmute(TracingEnabled) };
         TracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 15u8, {
         let Reserved1: u16 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type TELEMETRY_COVERAGE_HEADER = _TELEMETRY_COVERAGE_HEADER;
pub type PTELEMETRY_COVERAGE_HEADER = *mut _TELEMETRY_COVERAGE_HEADER;
#[repr(C)]
pub struct _WER_RECOVERY_INFO {
   pub Length: ULONG,
   pub Callback: PVOID,
   pub Parameter: PVOID,
   pub Started: HANDLE,
   pub Finished: HANDLE,
   pub InProgress: HANDLE,
   pub LastError: LONG,
   pub Successful: BOOL,
   pub PingInterval: ULONG,
   pub Flags: ULONG,
}
impl Default for _WER_RECOVERY_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_RECOVERY_INFO = _WER_RECOVERY_INFO;
pub type PWER_RECOVERY_INFO = *mut _WER_RECOVERY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WER_FILE {
   pub Flags: USHORT,
   pub Path: [WCHAR; 260usize],
}
impl Default for _WER_FILE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_FILE = _WER_FILE;
pub type PWER_FILE = *mut _WER_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WER_MEMORY {
   pub Address: PVOID,
   pub Size: ULONG,
}
impl Default for _WER_MEMORY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_MEMORY = _WER_MEMORY;
pub type PWER_MEMORY = *mut _WER_MEMORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WER_GATHER {
   pub Next: PVOID,
   pub Flags: USHORT,
   pub v: _WER_GATHER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WER_GATHER__bindgen_ty_1 {
   pub File: WER_FILE,
   pub Memory: WER_MEMORY,
}
impl Default for _WER_GATHER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WER_GATHER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_GATHER = _WER_GATHER;
pub type PWER_GATHER = *mut _WER_GATHER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WER_METADATA {
   pub Next: PVOID,
   pub Key: [WCHAR; 64usize],
   pub Value: [WCHAR; 128usize],
}
impl Default for _WER_METADATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_METADATA = _WER_METADATA;
pub type PWER_METADATA = *mut _WER_METADATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WER_RUNTIME_DLL {
   pub Next: PVOID,
   pub Length: ULONG,
   pub Context: PVOID,
   pub CallbackDllPath: [WCHAR; 260usize],
}
impl Default for _WER_RUNTIME_DLL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_RUNTIME_DLL = _WER_RUNTIME_DLL;
pub type PWER_RUNTIME_DLL = *mut _WER_RUNTIME_DLL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WER_DUMP_COLLECTION {
   pub Next: PVOID,
   pub ProcessId: ULONG,
   pub ThreadId: ULONG,
}
impl Default for _WER_DUMP_COLLECTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_DUMP_COLLECTION = _WER_DUMP_COLLECTION;
pub type PWER_DUMP_COLLECTION = *mut _WER_DUMP_COLLECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WER_HEAP_MAIN_HEADER {
   pub Signature: [WCHAR; 16usize],
   pub Links: LIST_ENTRY,
   pub Mutex: HANDLE,
   pub FreeHeap: PVOID,
   pub FreeCount: ULONG,
}
impl Default for _WER_HEAP_MAIN_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_HEAP_MAIN_HEADER = _WER_HEAP_MAIN_HEADER;
pub type PWER_HEAP_MAIN_HEADER = *mut _WER_HEAP_MAIN_HEADER;
#[repr(C)]
pub struct _WER_PEB_HEADER_BLOCK {
   pub Length: LONG,
   pub Signature: [WCHAR; 16usize],
   pub AppDataRelativePath: [WCHAR; 64usize],
   pub RestartCommandLine: [WCHAR; 1024usize],
   pub RecoveryInfo: WER_RECOVERY_INFO,
   pub Gather: PWER_GATHER,
   pub MetaData: PWER_METADATA,
   pub RuntimeDll: PWER_RUNTIME_DLL,
   pub DumpCollection: PWER_DUMP_COLLECTION,
   pub GatherCount: LONG,
   pub MetaDataCount: LONG,
   pub DumpCount: LONG,
   pub Flags: LONG,
   pub MainHeader: WER_HEAP_MAIN_HEADER,
   pub Reserved: PVOID,
}
impl Default for _WER_PEB_HEADER_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WER_PEB_HEADER_BLOCK = _WER_PEB_HEADER_BLOCK;
pub type PWER_PEB_HEADER_BLOCK = *mut _WER_PEB_HEADER_BLOCK;
pub type GDI_HANDLE_BUFFER = [ULONG; 60usize];
pub type GDI_HANDLE_BUFFER32 = [ULONG; 34usize];
pub type GDI_HANDLE_BUFFER64 = [ULONG; 60usize];
pub type PPS_POST_PROCESS_INIT_ROUTINE = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "Process Environment Block (PEB) structure.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb"]
#[repr(C)]
pub struct _PEB {
   pub InheritedAddressSpace: BOOLEAN,
   pub ReadImageFileExecOptions: BOOLEAN,
   pub BeingDebugged: BOOLEAN,
   pub __bindgen_anon_1: _PEB__bindgen_ty_1,
   pub Mutant: HANDLE,
   pub ImageBaseAddress: PVOID,
   pub Ldr: PPEB_LDR_DATA,
   pub ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
   pub SubSystemData: PVOID,
   pub ProcessHeap: PVOID,
   pub FastPebLock: PRTL_CRITICAL_SECTION,
   pub AtlThunkSListPtr: PSLIST_HEADER,
   pub IFEOKey: PVOID,
   pub __bindgen_anon_2: _PEB__bindgen_ty_2,
   pub __bindgen_anon_3: _PEB__bindgen_ty_3,
   pub SystemReserved: ULONG,
   pub AtlThunkSListPtr32: ULONG,
   pub ApiSetMap: PAPI_SET_NAMESPACE,
   pub TlsExpansionCounter: ULONG,
   pub TlsBitmap: PRTL_BITMAP,
   pub TlsBitmapBits: [ULONG; 2usize],
   pub ReadOnlySharedMemoryBase: PVOID,
   pub SharedData: PSILO_USER_SHARED_DATA,
   pub ReadOnlyStaticServerData: *mut PVOID,
   pub AnsiCodePageData: PVOID,
   pub OemCodePageData: PVOID,
   pub UnicodeCaseTableData: PVOID,
   pub NumberOfProcessors: ULONG,
   pub NtGlobalFlag: ULONG,
   pub CriticalSectionTimeout: LARGE_INTEGER,
   pub HeapSegmentReserve: SIZE_T,
   pub HeapSegmentCommit: SIZE_T,
   pub HeapDeCommitTotalFreeThreshold: SIZE_T,
   pub HeapDeCommitFreeBlockThreshold: SIZE_T,
   pub NumberOfHeaps: ULONG,
   pub MaximumNumberOfHeaps: ULONG,
   pub ProcessHeaps: *mut PVOID,
   pub GdiSharedHandleTable: PVOID,
   pub ProcessStarterHelper: PVOID,
   pub GdiDCAttributeList: ULONG,
   pub LoaderLock: PRTL_CRITICAL_SECTION,
   pub OSMajorVersion: ULONG,
   pub OSMinorVersion: ULONG,
   pub OSBuildNumber: USHORT,
   pub OSCSDVersion: USHORT,
   pub OSPlatformId: ULONG,
   pub ImageSubsystem: ULONG,
   pub ImageSubsystemMajorVersion: ULONG,
   pub ImageSubsystemMinorVersion: ULONG,
   pub ActiveProcessAffinityMask: KAFFINITY,
   pub GdiHandleBuffer: GDI_HANDLE_BUFFER,
   pub PostProcessInitRoutine: PPS_POST_PROCESS_INIT_ROUTINE,
   pub TlsExpansionBitmap: PRTL_BITMAP,
   pub TlsExpansionBitmapBits: [ULONG; 32usize],
   pub SessionId: ULONG,
   pub AppCompatFlags: ULARGE_INTEGER,
   pub AppCompatFlagsUser: ULARGE_INTEGER,
   pub pShimData: PVOID,
   pub AppCompatInfo: PVOID,
   pub CSDVersion: UNICODE_STRING,
   pub ActivationContextData: PACTIVATION_CONTEXT_DATA,
   pub ProcessAssemblyStorageMap: PASSEMBLY_STORAGE_MAP,
   pub SystemDefaultActivationContextData: PACTIVATION_CONTEXT_DATA,
   pub SystemAssemblyStorageMap: PASSEMBLY_STORAGE_MAP,
   pub MinimumStackCommit: SIZE_T,
   pub SparePointers: [PVOID; 2usize],
   pub PatchLoaderData: PVOID,
   pub ChpeV2ProcessInfo: PVOID,
   pub AppModelFeatureState: ULONG,
   pub SpareUlongs: [ULONG; 2usize],
   pub ActiveCodePage: USHORT,
   pub OemCodePage: USHORT,
   pub UseCaseMapping: USHORT,
   pub UnusedNlsField: USHORT,
   pub WerRegistrationData: PWER_PEB_HEADER_BLOCK,
   pub WerShipAssertPtr: PVOID,
   pub __bindgen_anon_4: _PEB__bindgen_ty_4,
   pub pImageHeaderHash: PVOID,
   pub __bindgen_anon_5: _PEB__bindgen_ty_5,
   pub CsrServerReadOnlySharedMemoryBase: ULONGLONG,
   pub TppWorkerpListLock: PRTL_CRITICAL_SECTION,
   pub TppWorkerpList: LIST_ENTRY,
   pub WaitOnAddressHashTable: [PVOID; 128usize],
   pub TelemetryCoverageHeader: PTELEMETRY_COVERAGE_HEADER,
   pub CloudFileFlags: ULONG,
   pub CloudFileDiagFlags: ULONG,
   pub PlaceholderCompatibilityMode: CHAR,
   pub PlaceholderCompatibilityModeReserved: [CHAR; 7usize],
   pub LeapSecondData: PLEAP_SECOND_DATA,
   pub __bindgen_anon_6: _PEB__bindgen_ty_6,
   pub NtGlobalFlag2: ULONG,
   pub ExtendedFeatureDisableMask: ULONGLONG,
}
#[repr(C)]
pub union _PEB__bindgen_ty_1 {
   pub BitField: ::core::mem::ManuallyDrop<BOOLEAN>,
   pub __bindgen_anon_1: ::core::mem::ManuallyDrop<_PEB__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct _PEB__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _PEB__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PEB__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ImageUsesLargePages(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ImageUsesLargePages(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageUsesLargePages_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ImageUsesLargePages_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsProtectedProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsProtectedProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsProtectedProcess_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsProtectedProcess_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsImageDynamicallyRelocated(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsImageDynamicallyRelocated(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsImageDynamicallyRelocated_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsImageDynamicallyRelocated_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SkipPatchingUser32Forwarders(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SkipPatchingUser32Forwarders(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SkipPatchingUser32Forwarders_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SkipPatchingUser32Forwarders_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsPackagedProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsPackagedProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsPackagedProcess_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsPackagedProcess_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsAppContainer(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsAppContainer(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsAppContainer_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsAppContainer_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsProtectedProcessLight(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsProtectedProcessLight(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsProtectedProcessLight_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsProtectedProcessLight_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsLongPathAwareProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsLongPathAwareProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsLongPathAwareProcess_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsLongPathAwareProcess_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ImageUsesLargePages: BOOLEAN,
      IsProtectedProcess: BOOLEAN,
      IsImageDynamicallyRelocated: BOOLEAN,
      SkipPatchingUser32Forwarders: BOOLEAN,
      IsPackagedProcess: BOOLEAN,
      IsAppContainer: BOOLEAN,
      IsProtectedProcessLight: BOOLEAN,
      IsLongPathAwareProcess: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ImageUsesLargePages: u8 = unsafe { ::core::mem::transmute(ImageUsesLargePages) };
         ImageUsesLargePages as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsProtectedProcess: u8 = unsafe { ::core::mem::transmute(IsProtectedProcess) };
         IsProtectedProcess as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsImageDynamicallyRelocated: u8 =
            unsafe { ::core::mem::transmute(IsImageDynamicallyRelocated) };
         IsImageDynamicallyRelocated as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SkipPatchingUser32Forwarders: u8 =
            unsafe { ::core::mem::transmute(SkipPatchingUser32Forwarders) };
         SkipPatchingUser32Forwarders as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let IsPackagedProcess: u8 = unsafe { ::core::mem::transmute(IsPackagedProcess) };
         IsPackagedProcess as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let IsAppContainer: u8 = unsafe { ::core::mem::transmute(IsAppContainer) };
         IsAppContainer as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let IsProtectedProcessLight: u8 =
            unsafe { ::core::mem::transmute(IsProtectedProcessLight) };
         IsProtectedProcessLight as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let IsLongPathAwareProcess: u8 = unsafe { ::core::mem::transmute(IsLongPathAwareProcess) };
         IsLongPathAwareProcess as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_2 {
   pub CrossProcessFlags: ULONG,
   pub __bindgen_anon_1: _PEB__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn ProcessInJob(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessInJob(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessInJob_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessInJob_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessInitializing(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessInitializing(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessInitializing_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessInitializing_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessUsingVEH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingVEH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessUsingVEH_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessUsingVEH_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessUsingVCH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingVCH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessUsingVCH_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessUsingVCH_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessUsingFTH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingFTH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessUsingFTH_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessUsingFTH_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessPreviouslyThrottled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessPreviouslyThrottled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessPreviouslyThrottled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessPreviouslyThrottled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessCurrentlyThrottled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessCurrentlyThrottled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessCurrentlyThrottled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessCurrentlyThrottled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessImagesHotPatched(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessImagesHotPatched(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessImagesHotPatched_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessImagesHotPatched_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedBits0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedBits0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedBits0_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedBits0_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ProcessInJob: ULONG,
      ProcessInitializing: ULONG,
      ProcessUsingVEH: ULONG,
      ProcessUsingVCH: ULONG,
      ProcessUsingFTH: ULONG,
      ProcessPreviouslyThrottled: ULONG,
      ProcessCurrentlyThrottled: ULONG,
      ProcessImagesHotPatched: ULONG,
      ReservedBits0: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ProcessInJob: u32 = unsafe { ::core::mem::transmute(ProcessInJob) };
         ProcessInJob as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ProcessInitializing: u32 = unsafe { ::core::mem::transmute(ProcessInitializing) };
         ProcessInitializing as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ProcessUsingVEH: u32 = unsafe { ::core::mem::transmute(ProcessUsingVEH) };
         ProcessUsingVEH as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ProcessUsingVCH: u32 = unsafe { ::core::mem::transmute(ProcessUsingVCH) };
         ProcessUsingVCH as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let ProcessUsingFTH: u32 = unsafe { ::core::mem::transmute(ProcessUsingFTH) };
         ProcessUsingFTH as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ProcessPreviouslyThrottled: u32 =
            unsafe { ::core::mem::transmute(ProcessPreviouslyThrottled) };
         ProcessPreviouslyThrottled as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ProcessCurrentlyThrottled: u32 =
            unsafe { ::core::mem::transmute(ProcessCurrentlyThrottled) };
         ProcessCurrentlyThrottled as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let ProcessImagesHotPatched: u32 =
            unsafe { ::core::mem::transmute(ProcessImagesHotPatched) };
         ProcessImagesHotPatched as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let ReservedBits0: u32 = unsafe { ::core::mem::transmute(ReservedBits0) };
         ReservedBits0 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_3 {
   pub KernelCallbackTable: PVOID,
   pub UserSharedInfoPtr: PVOID,
}
impl Default for _PEB__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_4 {
   pub pContextData: PVOID,
   pub EcCodeBitMap: PVOID,
}
impl Default for _PEB__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_5 {
   pub TracingFlags: ULONG,
   pub __bindgen_anon_1: _PEB__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_5__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_5__bindgen_ty_1 {
   #[inline]
   pub fn HeapTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HeapTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HeapTracingEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HeapTracingEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CritSecTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CritSecTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CritSecTracingEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CritSecTracingEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LibLoaderTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LibLoaderTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LibLoaderTracingEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LibLoaderTracingEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareTracingBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_SpareTracingBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareTracingBits_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            29u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpareTracingBits_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            29u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HeapTracingEnabled: ULONG,
      CritSecTracingEnabled: ULONG,
      LibLoaderTracingEnabled: ULONG,
      SpareTracingBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let HeapTracingEnabled: u32 = unsafe { ::core::mem::transmute(HeapTracingEnabled) };
         HeapTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let CritSecTracingEnabled: u32 = unsafe { ::core::mem::transmute(CritSecTracingEnabled) };
         CritSecTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let LibLoaderTracingEnabled: u32 =
            unsafe { ::core::mem::transmute(LibLoaderTracingEnabled) };
         LibLoaderTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let SpareTracingBits: u32 = unsafe { ::core::mem::transmute(SpareTracingBits) };
         SpareTracingBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB__bindgen_ty_6 {
   pub LeapSecondFlags: ULONG,
   pub __bindgen_anon_1: _PEB__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB__bindgen_ty_6__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB__bindgen_ty_6__bindgen_ty_1 {
   #[inline]
   pub fn SixtySecondEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SixtySecondEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SixtySecondEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SixtySecondEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SixtySecondEnabled: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SixtySecondEnabled: u32 = unsafe { ::core::mem::transmute(SixtySecondEnabled) };
         SixtySecondEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB__bindgen_ty_6 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PEB {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "Process Environment Block (PEB) structure.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb"]
pub type PEB = _PEB;
#[doc = "Process Environment Block (PEB) structure.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb"]
pub type PPEB = *mut _PEB;
#[doc = "The GDI_TEB_BATCH structure is used to store information about GDI batch operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDI_TEB_BATCH {
   pub Offset: ULONG,
   pub HDC: ULONG_PTR,
   pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The GDI_TEB_BATCH structure is used to store information about GDI batch operations."]
pub type GDI_TEB_BATCH = _GDI_TEB_BATCH;
#[doc = "The GDI_TEB_BATCH structure is used to store information about GDI batch operations."]
pub type PGDI_TEB_BATCH = *mut _GDI_TEB_BATCH;
#[doc = "The TEB_ACTIVE_FRAME_CONTEXT structure is used to store information about an active frame context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME_CONTEXT {
   pub Flags: ULONG,
   pub FrameName: PCSTR,
}
impl Default for _TEB_ACTIVE_FRAME_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The TEB_ACTIVE_FRAME_CONTEXT structure is used to store information about an active frame context."]
pub type TEB_ACTIVE_FRAME_CONTEXT = _TEB_ACTIVE_FRAME_CONTEXT;
#[doc = "The TEB_ACTIVE_FRAME_CONTEXT structure is used to store information about an active frame context."]
pub type PTEB_ACTIVE_FRAME_CONTEXT = *mut _TEB_ACTIVE_FRAME_CONTEXT;
#[doc = "The TEB_ACTIVE_FRAME_CONTEXT_EX structure extends TEB_ACTIVE_FRAME_CONTEXT with additional information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME_CONTEXT_EX {
   pub BasicContext: TEB_ACTIVE_FRAME_CONTEXT,
   pub SourceLocation: PCSTR,
}
impl Default for _TEB_ACTIVE_FRAME_CONTEXT_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The TEB_ACTIVE_FRAME_CONTEXT_EX structure extends TEB_ACTIVE_FRAME_CONTEXT with additional information."]
pub type TEB_ACTIVE_FRAME_CONTEXT_EX = _TEB_ACTIVE_FRAME_CONTEXT_EX;
#[doc = "The TEB_ACTIVE_FRAME_CONTEXT_EX structure extends TEB_ACTIVE_FRAME_CONTEXT with additional information."]
pub type PTEB_ACTIVE_FRAME_CONTEXT_EX = *mut _TEB_ACTIVE_FRAME_CONTEXT_EX;
#[doc = "The TEB_ACTIVE_FRAME structure is used to store information about an active frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME {
   pub Flags: ULONG,
   pub Previous: *mut _TEB_ACTIVE_FRAME,
   pub Context: PTEB_ACTIVE_FRAME_CONTEXT,
}
impl Default for _TEB_ACTIVE_FRAME {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The TEB_ACTIVE_FRAME structure is used to store information about an active frame."]
pub type TEB_ACTIVE_FRAME = _TEB_ACTIVE_FRAME;
#[doc = "The TEB_ACTIVE_FRAME structure is used to store information about an active frame."]
pub type PTEB_ACTIVE_FRAME = *mut _TEB_ACTIVE_FRAME;
#[doc = "The TEB_ACTIVE_FRAME_EX structure extends TEB_ACTIVE_FRAME with additional information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB_ACTIVE_FRAME_EX {
   pub BasicFrame: TEB_ACTIVE_FRAME,
   pub ExtensionIdentifier: PVOID,
}
impl Default for _TEB_ACTIVE_FRAME_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The TEB_ACTIVE_FRAME_EX structure extends TEB_ACTIVE_FRAME with additional information."]
pub type TEB_ACTIVE_FRAME_EX = _TEB_ACTIVE_FRAME_EX;
#[doc = "The TEB_ACTIVE_FRAME_EX structure extends TEB_ACTIVE_FRAME with additional information."]
pub type PTEB_ACTIVE_FRAME_EX = *mut _TEB_ACTIVE_FRAME_EX;
#[doc = "Thread Environment Block (TEB) structure.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb"]
#[repr(C)]
pub struct _TEB {
   pub NtTib: NT_TIB,
   pub EnvironmentPointer: PVOID,
   pub ClientId: CLIENT_ID,
   pub ActiveRpcHandle: PVOID,
   pub ThreadLocalStoragePointer: PVOID,
   pub ProcessEnvironmentBlock: PPEB,
   pub LastErrorValue: ULONG,
   pub CountOfOwnedCriticalSections: ULONG,
   pub CsrClientThread: PVOID,
   pub Win32ThreadInfo: PVOID,
   pub User32Reserved: [ULONG; 26usize],
   pub UserReserved: [ULONG; 5usize],
   pub WOW32Reserved: PVOID,
   pub CurrentLocale: LCID,
   pub FpSoftwareStatusRegister: ULONG,
   pub ReservedForDebuggerInstrumentation: [PVOID; 16usize],
   pub SystemReserved1: [PVOID; 25usize],
   pub HeapFlsData: PVOID,
   pub RngState: [ULONG_PTR; 4usize],
   pub PlaceholderCompatibilityMode: CHAR,
   pub PlaceholderHydrationAlwaysExplicit: BOOLEAN,
   pub PlaceholderReserved: [CHAR; 10usize],
   pub ProxiedProcessId: ULONG,
   pub ActivationStack: ACTIVATION_CONTEXT_STACK,
   pub WorkingOnBehalfTicket: [UCHAR; 8usize],
   pub ExceptionCode: NTSTATUS,
   pub ActivationContextStackPointer: PACTIVATION_CONTEXT_STACK,
   pub InstrumentationCallbackSp: ULONG_PTR,
   pub InstrumentationCallbackPreviousPc: ULONG_PTR,
   pub InstrumentationCallbackPreviousSp: ULONG_PTR,
   pub TxFsContext: ULONG,
   pub InstrumentationCallbackDisabled: BOOLEAN,
   pub UnalignedLoadStoreExceptions: BOOLEAN,
   pub GdiTebBatch: GDI_TEB_BATCH,
   pub RealClientId: CLIENT_ID,
   pub GdiCachedProcessHandle: HANDLE,
   pub GdiClientPID: ULONG,
   pub GdiClientTID: ULONG,
   pub GdiThreadLocalInfo: PVOID,
   pub Win32ClientInfo: [ULONG_PTR; 62usize],
   pub glDispatchTable: [PVOID; 233usize],
   pub glReserved1: [ULONG_PTR; 29usize],
   pub glReserved2: PVOID,
   pub glSectionInfo: PVOID,
   pub glSection: PVOID,
   pub glTable: PVOID,
   pub glCurrentRC: PVOID,
   pub glContext: PVOID,
   pub LastStatusValue: NTSTATUS,
   pub StaticUnicodeString: UNICODE_STRING,
   pub StaticUnicodeBuffer: [WCHAR; 261usize],
   pub DeallocationStack: PVOID,
   pub TlsSlots: [PVOID; 64usize],
   pub TlsLinks: LIST_ENTRY,
   pub Vdm: PVOID,
   pub ReservedForNtRpc: PVOID,
   pub DbgSsReserved: [PVOID; 2usize],
   pub HardErrorMode: ULONG,
   pub Instrumentation: [PVOID; 11usize],
   pub ActivityId: GUID,
   pub SubProcessTag: PVOID,
   pub PerflibData: PVOID,
   pub EtwTraceData: PVOID,
   pub WinSockData: HANDLE,
   pub GdiBatchCount: ULONG,
   pub __bindgen_anon_1: _TEB__bindgen_ty_1,
   pub GuaranteedStackBytes: ULONG,
   pub ReservedForPerf: PVOID,
   pub ReservedForOle: PVOID,
   pub WaitingOnLoaderLock: ULONG,
   pub SavedPriorityState: PVOID,
   pub ReservedForCodeCoverage: ULONG_PTR,
   pub ThreadPoolData: PVOID,
   pub TlsExpansionSlots: *mut PVOID,
   pub ChpeV2CpuAreaInfo: PVOID,
   pub Unused: PVOID,
   pub MuiGeneration: ULONG,
   pub IsImpersonating: ULONG,
   pub NlsCache: PVOID,
   pub pShimData: PVOID,
   pub HeapData: ULONG,
   pub CurrentTransactionHandle: HANDLE,
   pub ActiveFrame: PTEB_ACTIVE_FRAME,
   pub FlsData: PVOID,
   pub PreferredLanguages: PVOID,
   pub UserPrefLanguages: PVOID,
   pub MergedPrefLanguages: PVOID,
   pub MuiImpersonation: ULONG,
   pub __bindgen_anon_2: _TEB__bindgen_ty_2,
   pub __bindgen_anon_3: _TEB__bindgen_ty_3,
   pub TxnScopeEnterCallback: PVOID,
   pub TxnScopeExitCallback: PVOID,
   pub TxnScopeContext: PVOID,
   pub LockCount: ULONG,
   pub WowTebOffset: LONG,
   pub ResourceRetValue: PVOID,
   pub ReservedForWdf: PVOID,
   pub ReservedForCrt: ULONGLONG,
   pub EffectiveContainerId: GUID,
   pub LastSleepCounter: ULONGLONG,
   pub SpinCallCount: ULONG,
   pub ExtendedFeatureDisableMask: ULONGLONG,
   pub SchedulerSharedDataSlot: PVOID,
   pub HeapWalkContext: PVOID,
   pub PrimaryGroupAffinity: GROUP_AFFINITY,
   pub Rcu: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_1 {
   pub CurrentIdealProcessor: PROCESSOR_NUMBER,
   pub IdealProcessorValue: ULONG,
   pub __bindgen_anon_1: _TEB__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB__bindgen_ty_1__bindgen_ty_1 {
   pub ReservedPad0: UCHAR,
   pub ReservedPad1: UCHAR,
   pub ReservedPad2: UCHAR,
   pub IdealProcessor: UCHAR,
}
impl Default for _TEB__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_2 {
   pub CrossTebFlags: USHORT,
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _TEB__bindgen_ty_2 {
   #[inline]
   pub fn SpareCrossTebBits(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
   }
   #[inline]
   pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareCrossTebBits_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            16u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SpareCrossTebBits_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 16u8, {
         let SpareCrossTebBits: u16 = unsafe { ::core::mem::transmute(SpareCrossTebBits) };
         SpareCrossTebBits as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB__bindgen_ty_3 {
   pub SameTebFlags: USHORT,
   pub __bindgen_anon_1: _TEB__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB__bindgen_ty_3__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB__bindgen_ty_3__bindgen_ty_1 {
   #[inline]
   pub fn SafeThunkCall(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SafeThunkCall(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SafeThunkCall_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SafeThunkCall_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InDebugPrint(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_InDebugPrint(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InDebugPrint_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_InDebugPrint_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HasFiberData(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_HasFiberData(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HasFiberData_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_HasFiberData_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SkipThreadAttach(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SkipThreadAttach(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SkipThreadAttach_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SkipThreadAttach_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn WerInShipAssertCode(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_WerInShipAssertCode(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn WerInShipAssertCode_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_WerInShipAssertCode_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RanProcessInit(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_RanProcessInit(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RanProcessInit_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_RanProcessInit_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ClonedThread(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_ClonedThread(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ClonedThread_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_ClonedThread_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SuppressDebugMsg(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SuppressDebugMsg(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SuppressDebugMsg_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SuppressDebugMsg_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DisableUserStackWalk(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_DisableUserStackWalk(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisableUserStackWalk_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_DisableUserStackWalk_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RtlExceptionAttached(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RtlExceptionAttached_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_RtlExceptionAttached_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InitialThread(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_InitialThread(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InitialThread_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_InitialThread_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SessionAware(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SessionAware(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SessionAware_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SessionAware_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoadOwner(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_LoadOwner(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoadOwner_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_LoadOwner_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoaderWorker(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_LoaderWorker(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoaderWorker_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_LoaderWorker_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SkipLoaderInit(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SkipLoaderInit(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SkipLoaderInit_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SkipLoaderInit_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SkipFileAPIBrokering(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SkipFileAPIBrokering(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SkipFileAPIBrokering_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SkipFileAPIBrokering_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SafeThunkCall: USHORT,
      InDebugPrint: USHORT,
      HasFiberData: USHORT,
      SkipThreadAttach: USHORT,
      WerInShipAssertCode: USHORT,
      RanProcessInit: USHORT,
      ClonedThread: USHORT,
      SuppressDebugMsg: USHORT,
      DisableUserStackWalk: USHORT,
      RtlExceptionAttached: USHORT,
      InitialThread: USHORT,
      SessionAware: USHORT,
      LoadOwner: USHORT,
      LoaderWorker: USHORT,
      SkipLoaderInit: USHORT,
      SkipFileAPIBrokering: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SafeThunkCall: u16 = unsafe { ::core::mem::transmute(SafeThunkCall) };
         SafeThunkCall as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let InDebugPrint: u16 = unsafe { ::core::mem::transmute(InDebugPrint) };
         InDebugPrint as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let HasFiberData: u16 = unsafe { ::core::mem::transmute(HasFiberData) };
         HasFiberData as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SkipThreadAttach: u16 = unsafe { ::core::mem::transmute(SkipThreadAttach) };
         SkipThreadAttach as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let WerInShipAssertCode: u16 = unsafe { ::core::mem::transmute(WerInShipAssertCode) };
         WerInShipAssertCode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let RanProcessInit: u16 = unsafe { ::core::mem::transmute(RanProcessInit) };
         RanProcessInit as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ClonedThread: u16 = unsafe { ::core::mem::transmute(ClonedThread) };
         ClonedThread as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let SuppressDebugMsg: u16 = unsafe { ::core::mem::transmute(SuppressDebugMsg) };
         SuppressDebugMsg as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let DisableUserStackWalk: u16 = unsafe { ::core::mem::transmute(DisableUserStackWalk) };
         DisableUserStackWalk as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let RtlExceptionAttached: u16 = unsafe { ::core::mem::transmute(RtlExceptionAttached) };
         RtlExceptionAttached as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let InitialThread: u16 = unsafe { ::core::mem::transmute(InitialThread) };
         InitialThread as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let SessionAware: u16 = unsafe { ::core::mem::transmute(SessionAware) };
         SessionAware as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let LoadOwner: u16 = unsafe { ::core::mem::transmute(LoadOwner) };
         LoadOwner as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let LoaderWorker: u16 = unsafe { ::core::mem::transmute(LoaderWorker) };
         LoaderWorker as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let SkipLoaderInit: u16 = unsafe { ::core::mem::transmute(SkipLoaderInit) };
         SkipLoaderInit as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let SkipFileAPIBrokering: u16 = unsafe { ::core::mem::transmute(SkipFileAPIBrokering) };
         SkipFileAPIBrokering as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _TEB__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TEB {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "Thread Environment Block (TEB) structure.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb"]
pub type TEB = _TEB;
#[repr(C)]
pub struct _PEB_LDR_DATA {
   pub Length: ULONG,
   pub Initialized: BOOLEAN,
   pub SsHandle: HANDLE,
   pub InLoadOrderModuleList: LIST_ENTRY,
   pub InMemoryOrderModuleList: LIST_ENTRY,
   pub InInitializationOrderModuleList: LIST_ENTRY,
   pub EntryInProgress: PVOID,
   pub ShutdownInProgress: BOOLEAN,
   pub ShutdownThreadId: HANDLE,
}
impl Default for _PEB_LDR_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INITIAL_TEB {
   pub OldInitialTeb: _INITIAL_TEB__bindgen_ty_1,
   pub StackBase: PVOID,
   pub StackLimit: PVOID,
   pub StackAllocationBase: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INITIAL_TEB__bindgen_ty_1 {
   pub OldStackBase: PVOID,
   pub OldStackLimit: PVOID,
}
impl Default for _INITIAL_TEB__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _INITIAL_TEB {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type INITIAL_TEB = _INITIAL_TEB;
pub type PINITIAL_TEB = *mut _INITIAL_TEB;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESSINFOCLASS {
   ProcessBasicInformation = 0,
   ProcessQuotaLimits = 1,
   ProcessIoCounters = 2,
   ProcessVmCounters = 3,
   ProcessTimes = 4,
   ProcessBasePriority = 5,
   ProcessRaisePriority = 6,
   ProcessDebugPort = 7,
   ProcessExceptionPort = 8,
   ProcessAccessToken = 9,
   ProcessLdtInformation = 10,
   ProcessLdtSize = 11,
   ProcessDefaultHardErrorMode = 12,
   ProcessIoPortHandlers = 13,
   ProcessPooledUsageAndLimits = 14,
   ProcessWorkingSetWatch = 15,
   ProcessUserModeIOPL = 16,
   ProcessEnableAlignmentFaultFixup = 17,
   ProcessPriorityClass = 18,
   ProcessWx86Information = 19,
   ProcessHandleCount = 20,
   ProcessAffinityMask = 21,
   ProcessPriorityBoost = 22,
   ProcessDeviceMap = 23,
   ProcessSessionInformation = 24,
   ProcessForegroundInformation = 25,
   ProcessWow64Information = 26,
   ProcessImageFileName = 27,
   ProcessLUIDDeviceMapsEnabled = 28,
   ProcessBreakOnTermination = 29,
   ProcessDebugObjectHandle = 30,
   ProcessDebugFlags = 31,
   ProcessHandleTracing = 32,
   ProcessIoPriority = 33,
   ProcessExecuteFlags = 34,
   ProcessTlsInformation = 35,
   ProcessCookie = 36,
   ProcessImageInformation = 37,
   ProcessCycleTime = 38,
   ProcessPagePriority = 39,
   ProcessInstrumentationCallback = 40,
   ProcessThreadStackAllocation = 41,
   ProcessWorkingSetWatchEx = 42,
   ProcessImageFileNameWin32 = 43,
   ProcessImageFileMapping = 44,
   ProcessAffinityUpdateMode = 45,
   ProcessMemoryAllocationMode = 46,
   ProcessGroupInformation = 47,
   ProcessTokenVirtualizationEnabled = 48,
   ProcessConsoleHostProcess = 49,
   ProcessWindowInformation = 50,
   ProcessHandleInformation = 51,
   ProcessMitigationPolicy = 52,
   ProcessDynamicFunctionTableInformation = 53,
   ProcessHandleCheckingMode = 54,
   ProcessKeepAliveCount = 55,
   ProcessRevokeFileHandles = 56,
   ProcessWorkingSetControl = 57,
   ProcessHandleTable = 58,
   ProcessCheckStackExtentsMode = 59,
   ProcessCommandLineInformation = 60,
   ProcessProtectionInformation = 61,
   ProcessMemoryExhaustion = 62,
   ProcessFaultInformation = 63,
   ProcessTelemetryIdInformation = 64,
   ProcessCommitReleaseInformation = 65,
   ProcessDefaultCpuSetsInformation = 66,
   ProcessAllowedCpuSetsInformation = 67,
   ProcessSubsystemProcess = 68,
   ProcessJobMemoryInformation = 69,
   ProcessInPrivate = 70,
   ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
   ProcessIumChallengeResponse = 72,
   ProcessChildProcessInformation = 73,
   ProcessHighGraphicsPriorityInformation = 74,
   ProcessSubsystemInformation = 75,
   ProcessEnergyValues = 76,
   ProcessPowerThrottlingState = 77,
   ProcessReserved3Information = 78,
   ProcessWin32kSyscallFilterInformation = 79,
   ProcessDisableSystemAllowedCpuSets = 80,
   ProcessWakeInformation = 81,
   ProcessEnergyTrackingState = 82,
   ProcessManageWritesToExecutableMemory = 83,
   ProcessCaptureTrustletLiveDump = 84,
   ProcessTelemetryCoverage = 85,
   ProcessEnclaveInformation = 86,
   ProcessEnableReadWriteVmLogging = 87,
   ProcessUptimeInformation = 88,
   ProcessImageSection = 89,
   ProcessDebugAuthInformation = 90,
   ProcessSystemResourceManagement = 91,
   ProcessSequenceNumber = 92,
   ProcessLoaderDetour = 93,
   ProcessSecurityDomainInformation = 94,
   ProcessCombineSecurityDomainsInformation = 95,
   ProcessEnableLogging = 96,
   ProcessLeapSecondInformation = 97,
   ProcessFiberShadowStackAllocation = 98,
   ProcessFreeFiberShadowStackAllocation = 99,
   ProcessAltSystemCallInformation = 100,
   ProcessDynamicEHContinuationTargets = 101,
   ProcessDynamicEnforcedCetCompatibleRanges = 102,
   ProcessCreateStateChange = 103,
   ProcessApplyStateChange = 104,
   ProcessEnableOptionalXStateFeatures = 105,
   ProcessAltPrefetchParam = 106,
   ProcessAssignCpuPartitions = 107,
   ProcessPriorityClassEx = 108,
   ProcessMembershipInformation = 109,
   ProcessEffectiveIoPriority = 110,
   ProcessEffectivePagePriority = 111,
   ProcessSchedulerSharedData = 112,
   ProcessSlistRollbackInformation = 113,
   ProcessNetworkIoCounters = 114,
   ProcessFindFirstThreadByTebValue = 115,
   MaxProcessInfoClass = 116,
}
pub use self::_PROCESSINFOCLASS as PROCESSINFOCLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREADINFOCLASS {
   ThreadBasicInformation = 0,
   ThreadTimes = 1,
   ThreadPriority = 2,
   ThreadBasePriority = 3,
   ThreadAffinityMask = 4,
   ThreadImpersonationToken = 5,
   ThreadDescriptorTableEntry = 6,
   ThreadEnableAlignmentFaultFixup = 7,
   ThreadEventPair = 8,
   ThreadQuerySetWin32StartAddress = 9,
   ThreadZeroTlsCell = 10,
   ThreadPerformanceCount = 11,
   ThreadAmILastThread = 12,
   ThreadIdealProcessor = 13,
   ThreadPriorityBoost = 14,
   ThreadSetTlsArrayAddress = 15,
   ThreadIsIoPending = 16,
   ThreadHideFromDebugger = 17,
   ThreadBreakOnTermination = 18,
   ThreadSwitchLegacyState = 19,
   ThreadIsTerminated = 20,
   ThreadLastSystemCall = 21,
   ThreadIoPriority = 22,
   ThreadCycleTime = 23,
   ThreadPagePriority = 24,
   ThreadActualBasePriority = 25,
   ThreadTebInformation = 26,
   ThreadCSwitchMon = 27,
   ThreadCSwitchPmu = 28,
   ThreadWow64Context = 29,
   ThreadGroupInformation = 30,
   ThreadUmsInformation = 31,
   ThreadCounterProfiling = 32,
   ThreadIdealProcessorEx = 33,
   ThreadCpuAccountingInformation = 34,
   ThreadSuspendCount = 35,
   ThreadHeterogeneousCpuPolicy = 36,
   ThreadContainerId = 37,
   ThreadNameInformation = 38,
   ThreadSelectedCpuSets = 39,
   ThreadSystemThreadInformation = 40,
   ThreadActualGroupAffinity = 41,
   ThreadDynamicCodePolicyInfo = 42,
   ThreadExplicitCaseSensitivity = 43,
   ThreadWorkOnBehalfTicket = 44,
   ThreadSubsystemInformation = 45,
   ThreadDbgkWerReportActive = 46,
   ThreadAttachContainer = 47,
   ThreadManageWritesToExecutableMemory = 48,
   ThreadPowerThrottlingState = 49,
   ThreadWorkloadClass = 50,
   ThreadCreateStateChange = 51,
   ThreadApplyStateChange = 52,
   ThreadStrongerBadHandleChecks = 53,
   ThreadEffectiveIoPriority = 54,
   ThreadEffectivePagePriority = 55,
   ThreadUpdateLockOwnership = 56,
   ThreadSchedulerSharedDataSlot = 57,
   ThreadTebInformationAtomic = 58,
   ThreadIndexInformation = 59,
   MaxThreadInfoClass = 60,
}
pub use self::_THREADINFOCLASS as THREADINFOCLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PAGE_PRIORITY_INFORMATION {
   pub PagePriority: ULONG,
}
pub type PAGE_PRIORITY_INFORMATION = _PAGE_PRIORITY_INFORMATION;
pub type PPAGE_PRIORITY_INFORMATION = *mut _PAGE_PRIORITY_INFORMATION;
#[doc = "The PROCESS_BASIC_INFORMATION structure contains basic information about a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess#process_basic_information"]
#[repr(C)]
pub struct _PROCESS_BASIC_INFORMATION {
   pub ExitStatus: NTSTATUS,
   pub PebBaseAddress: PPEB,
   pub AffinityMask: KAFFINITY,
   pub BasePriority: KPRIORITY,
   pub UniqueProcessId: HANDLE,
   pub InheritedFromUniqueProcessId: HANDLE,
}
impl Default for _PROCESS_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_BASIC_INFORMATION structure contains basic information about a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess#process_basic_information"]
pub type PROCESS_BASIC_INFORMATION = _PROCESS_BASIC_INFORMATION;
#[doc = "The PROCESS_BASIC_INFORMATION structure contains basic information about a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess#process_basic_information"]
pub type PPROCESS_BASIC_INFORMATION = *mut _PROCESS_BASIC_INFORMATION;
#[doc = "The PROCESS_EXTENDED_BASIC_INFORMATION structure contains extended basic information about a process."]
#[repr(C)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION {
   pub Size: SIZE_T,
   pub __bindgen_anon_1: _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1,
   pub __bindgen_anon_2: _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_2,
}
#[repr(C)]
pub union _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 {
   pub BasicInfo: ::core::mem::ManuallyDrop<PROCESS_BASIC_INFORMATION>,
   pub __bindgen_anon_1:
      ::core::mem::ManuallyDrop<_PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub ExitStatus: NTSTATUS,
   pub PebBaseAddress: PPEB,
   pub AffinityMask: KAFFINITY,
   pub BasePriority: KPRIORITY,
   pub UniqueProcessId: HANDLE,
   pub InheritedFromUniqueProcessId: HANDLE,
}
impl Default for _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_2 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn IsProtectedProcess(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsProtectedProcess(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsProtectedProcess_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsProtectedProcess_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsWow64Process(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsWow64Process(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsWow64Process_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsWow64Process_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsProcessDeleting(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsProcessDeleting(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsProcessDeleting_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsProcessDeleting_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsCrossSessionCreate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsCrossSessionCreate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsCrossSessionCreate_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsCrossSessionCreate_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsFrozen(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsFrozen(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsFrozen_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsFrozen_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsBackground(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsBackground(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsBackground_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsBackground_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsStronglyNamed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsStronglyNamed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsStronglyNamed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsStronglyNamed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsSecureProcess(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSecureProcess(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsSecureProcess_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsSecureProcess_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsSubsystemProcess(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSubsystemProcess(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsSubsystemProcess_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsSubsystemProcess_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsTrustedApp(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTrustedApp(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsTrustedApp_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsTrustedApp_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
   }
   #[inline]
   pub fn set_SpareBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 22u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareBits_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            22u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpareBits_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            22u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsProtectedProcess: ULONG,
      IsWow64Process: ULONG,
      IsProcessDeleting: ULONG,
      IsCrossSessionCreate: ULONG,
      IsFrozen: ULONG,
      IsBackground: ULONG,
      IsStronglyNamed: ULONG,
      IsSecureProcess: ULONG,
      IsSubsystemProcess: ULONG,
      IsTrustedApp: ULONG,
      SpareBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsProtectedProcess: u32 = unsafe { ::core::mem::transmute(IsProtectedProcess) };
         IsProtectedProcess as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsWow64Process: u32 = unsafe { ::core::mem::transmute(IsWow64Process) };
         IsWow64Process as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsProcessDeleting: u32 = unsafe { ::core::mem::transmute(IsProcessDeleting) };
         IsProcessDeleting as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let IsCrossSessionCreate: u32 = unsafe { ::core::mem::transmute(IsCrossSessionCreate) };
         IsCrossSessionCreate as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let IsFrozen: u32 = unsafe { ::core::mem::transmute(IsFrozen) };
         IsFrozen as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let IsBackground: u32 = unsafe { ::core::mem::transmute(IsBackground) };
         IsBackground as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let IsStronglyNamed: u32 = unsafe { ::core::mem::transmute(IsStronglyNamed) };
         IsStronglyNamed as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let IsSecureProcess: u32 = unsafe { ::core::mem::transmute(IsSecureProcess) };
         IsSecureProcess as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let IsSubsystemProcess: u32 = unsafe { ::core::mem::transmute(IsSubsystemProcess) };
         IsSubsystemProcess as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let IsTrustedApp: u32 = unsafe { ::core::mem::transmute(IsTrustedApp) };
         IsTrustedApp as u64
      });
      __bindgen_bitfield_unit.set(10usize, 22u8, {
         let SpareBits: u32 = unsafe { ::core::mem::transmute(SpareBits) };
         SpareBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_EXTENDED_BASIC_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_EXTENDED_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_EXTENDED_BASIC_INFORMATION structure contains extended basic information about a process."]
pub type PROCESS_EXTENDED_BASIC_INFORMATION = _PROCESS_EXTENDED_BASIC_INFORMATION;
#[doc = "The PROCESS_EXTENDED_BASIC_INFORMATION structure contains extended basic information about a process."]
pub type PPROCESS_EXTENDED_BASIC_INFORMATION = *mut _PROCESS_EXTENDED_BASIC_INFORMATION;
#[doc = "The VM_COUNTERS structure contains various memory usage statistics for a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VM_COUNTERS {
   pub PeakVirtualSize: SIZE_T,
   pub VirtualSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub PeakWorkingSetSize: SIZE_T,
   pub WorkingSetSize: SIZE_T,
   pub QuotaPeakPagedPoolUsage: SIZE_T,
   pub QuotaPagedPoolUsage: SIZE_T,
   pub QuotaPeakNonPagedPoolUsage: SIZE_T,
   pub QuotaNonPagedPoolUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
}
#[doc = "The VM_COUNTERS structure contains various memory usage statistics for a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters"]
pub type VM_COUNTERS = _VM_COUNTERS;
#[doc = "The VM_COUNTERS structure contains various memory usage statistics for a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters"]
pub type PVM_COUNTERS = *mut _VM_COUNTERS;
#[doc = "The VM_COUNTERS_EX structure extends VM_COUNTERS to include private memory usage.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex2"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VM_COUNTERS_EX {
   pub PeakVirtualSize: SIZE_T,
   pub VirtualSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub PeakWorkingSetSize: SIZE_T,
   pub WorkingSetSize: SIZE_T,
   pub QuotaPeakPagedPoolUsage: SIZE_T,
   pub QuotaPagedPoolUsage: SIZE_T,
   pub QuotaPeakNonPagedPoolUsage: SIZE_T,
   pub QuotaNonPagedPoolUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
   pub PrivateUsage: SIZE_T,
}
#[doc = "The VM_COUNTERS_EX structure extends VM_COUNTERS to include private memory usage.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex2"]
pub type VM_COUNTERS_EX = _VM_COUNTERS_EX;
#[doc = "The VM_COUNTERS_EX structure extends VM_COUNTERS to include private memory usage.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex2"]
pub type PVM_COUNTERS_EX = *mut _VM_COUNTERS_EX;
#[doc = "The VM_COUNTERS_EX2 structure extends VM_COUNTERS_EX to include private working set size and shared commit usage.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex2"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VM_COUNTERS_EX2 {
   pub __bindgen_anon_1: _VM_COUNTERS_EX2__bindgen_ty_1,
   pub PrivateWorkingSetSize: SIZE_T,
   pub SharedCommitUsage: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VM_COUNTERS_EX2__bindgen_ty_1 {
   pub CountersEx: VM_COUNTERS_EX,
   pub __bindgen_anon_1: _VM_COUNTERS_EX2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VM_COUNTERS_EX2__bindgen_ty_1__bindgen_ty_1 {
   pub PeakVirtualSize: SIZE_T,
   pub VirtualSize: SIZE_T,
   pub PageFaultCount: ULONG,
   pub PeakWorkingSetSize: SIZE_T,
   pub WorkingSetSize: SIZE_T,
   pub QuotaPeakPagedPoolUsage: SIZE_T,
   pub QuotaPagedPoolUsage: SIZE_T,
   pub QuotaPeakNonPagedPoolUsage: SIZE_T,
   pub QuotaNonPagedPoolUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
   pub PrivateUsage: SIZE_T,
}
impl Default for _VM_COUNTERS_EX2__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _VM_COUNTERS_EX2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The VM_COUNTERS_EX2 structure extends VM_COUNTERS_EX to include private working set size and shared commit usage.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex2"]
pub type VM_COUNTERS_EX2 = _VM_COUNTERS_EX2;
#[doc = "The VM_COUNTERS_EX2 structure extends VM_COUNTERS_EX to include private working set size and shared commit usage.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-process_memory_counters_ex2"]
pub type PVM_COUNTERS_EX2 = *mut _VM_COUNTERS_EX2;
#[doc = "The KERNEL_USER_TIMES structure contains timing information for a process or thread.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KERNEL_USER_TIMES {
   pub CreateTime: LARGE_INTEGER,
   pub ExitTime: LARGE_INTEGER,
   pub KernelTime: LARGE_INTEGER,
   pub UserTime: LARGE_INTEGER,
}
impl Default for _KERNEL_USER_TIMES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The KERNEL_USER_TIMES structure contains timing information for a process or thread.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes"]
pub type KERNEL_USER_TIMES = _KERNEL_USER_TIMES;
#[doc = "The KERNEL_USER_TIMES structure contains timing information for a process or thread.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes"]
pub type PKERNEL_USER_TIMES = *mut _KERNEL_USER_TIMES;
#[doc = "The POOLED_USAGE_AND_LIMITS structure contains information about the usage and limits of paged and non-paged pool memory."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POOLED_USAGE_AND_LIMITS {
   pub PeakPagedPoolUsage: SIZE_T,
   pub PagedPoolUsage: SIZE_T,
   pub PagedPoolLimit: SIZE_T,
   pub PeakNonPagedPoolUsage: SIZE_T,
   pub NonPagedPoolUsage: SIZE_T,
   pub NonPagedPoolLimit: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub PagefileLimit: SIZE_T,
}
#[doc = "The POOLED_USAGE_AND_LIMITS structure contains information about the usage and limits of paged and non-paged pool memory."]
pub type POOLED_USAGE_AND_LIMITS = _POOLED_USAGE_AND_LIMITS;
#[doc = "The POOLED_USAGE_AND_LIMITS structure contains information about the usage and limits of paged and non-paged pool memory."]
pub type PPOOLED_USAGE_AND_LIMITS = *mut _POOLED_USAGE_AND_LIMITS;
#[doc = "The PROCESS_EXCEPTION_PORT structure is used to manage exception ports for a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_EXCEPTION_PORT {
   pub ExceptionPortHandle: HANDLE,
   pub StateFlags: ULONG,
}
impl Default for _PROCESS_EXCEPTION_PORT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_EXCEPTION_PORT structure is used to manage exception ports for a process."]
pub type PROCESS_EXCEPTION_PORT = _PROCESS_EXCEPTION_PORT;
#[doc = "The PROCESS_EXCEPTION_PORT structure is used to manage exception ports for a process."]
pub type PPROCESS_EXCEPTION_PORT = *mut _PROCESS_EXCEPTION_PORT;
#[doc = "The PROCESS_ACCESS_TOKEN structure is used to manage the security context of a process or thread.\nA process's access token can only be changed if the process has no threads or a single thread that has not yet begun execution."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_ACCESS_TOKEN {
   pub Token: HANDLE,
   pub Thread: HANDLE,
}
impl Default for _PROCESS_ACCESS_TOKEN {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_ACCESS_TOKEN structure is used to manage the security context of a process or thread.\nA process's access token can only be changed if the process has no threads or a single thread that has not yet begun execution."]
pub type PROCESS_ACCESS_TOKEN = _PROCESS_ACCESS_TOKEN;
#[doc = "The PROCESS_ACCESS_TOKEN structure is used to manage the security context of a process or thread.\nA process's access token can only be changed if the process has no threads or a single thread that has not yet begun execution."]
pub type PPROCESS_ACCESS_TOKEN = *mut _PROCESS_ACCESS_TOKEN;
#[doc = "The PROCESS_LDT_INFORMATION structure is used to manage Local Descriptor Table (LDT) entries for a process."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_LDT_INFORMATION {
   pub Start: ULONG,
   pub Length: ULONG,
   pub LdtEntries: [LDT_ENTRY; 1usize],
}
impl Default for _PROCESS_LDT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_LDT_INFORMATION structure is used to manage Local Descriptor Table (LDT) entries for a process."]
pub type PROCESS_LDT_INFORMATION = _PROCESS_LDT_INFORMATION;
#[doc = "The PROCESS_LDT_INFORMATION structure is used to manage Local Descriptor Table (LDT) entries for a process."]
pub type PPROCESS_LDT_INFORMATION = *mut _PROCESS_LDT_INFORMATION;
#[doc = "The PROCESS_LDT_SIZE structure is used to specify the size of the Local Descriptor Table (LDT) for a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_LDT_SIZE {
   pub Length: ULONG,
}
#[doc = "The PROCESS_LDT_SIZE structure is used to specify the size of the Local Descriptor Table (LDT) for a process."]
pub type PROCESS_LDT_SIZE = _PROCESS_LDT_SIZE;
#[doc = "The PROCESS_LDT_SIZE structure is used to specify the size of the Local Descriptor Table (LDT) for a process."]
pub type PPROCESS_LDT_SIZE = *mut _PROCESS_LDT_SIZE;
#[doc = "The PROCESS_WS_WATCH_INFORMATION structure is used to store information about working set watch events for a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_ws_watch_information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WS_WATCH_INFORMATION {
   pub FaultingPc: PVOID,
   pub FaultingVa: PVOID,
}
impl Default for _PROCESS_WS_WATCH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_WS_WATCH_INFORMATION structure is used to store information about working set watch events for a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_ws_watch_information"]
pub type PROCESS_WS_WATCH_INFORMATION = _PROCESS_WS_WATCH_INFORMATION;
#[doc = "The PROCESS_WS_WATCH_INFORMATION structure is used to store information about working set watch events for a process.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_ws_watch_information"]
pub type PPROCESS_WS_WATCH_INFORMATION = *mut _PROCESS_WS_WATCH_INFORMATION;
#[doc = "The PROCESS_WS_WATCH_INFORMATION_EX structure contains extended information about a page added to a process working set.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_ws_watch_information_ex"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_WS_WATCH_INFORMATION_EX {
   pub __bindgen_anon_1: _PROCESS_WS_WATCH_INFORMATION_EX__bindgen_ty_1,
   pub FaultingThreadId: HANDLE,
   pub Flags: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_WS_WATCH_INFORMATION_EX__bindgen_ty_1 {
   pub BasicInfo: PROCESS_WS_WATCH_INFORMATION,
   pub __bindgen_anon_1: _PROCESS_WS_WATCH_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WS_WATCH_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   pub FaultingPc: PVOID,
   pub FaultingVa: PVOID,
}
impl Default for _PROCESS_WS_WATCH_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_WS_WATCH_INFORMATION_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_WS_WATCH_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_WS_WATCH_INFORMATION_EX structure contains extended information about a page added to a process working set.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_ws_watch_information_ex"]
pub type PROCESS_WS_WATCH_INFORMATION_EX = _PROCESS_WS_WATCH_INFORMATION_EX;
#[doc = "The PROCESS_WS_WATCH_INFORMATION_EX structure contains extended information about a page added to a process working set.\n> https://learn.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-psapi_ws_watch_information_ex"]
pub type PPROCESS_WS_WATCH_INFORMATION_EX = *mut _PROCESS_WS_WATCH_INFORMATION_EX;
#[doc = "The PROCESS_PRIORITY_CLASS structure is used to manage the priority class of a process."]
#[repr(C)]
pub struct _PROCESS_PRIORITY_CLASS {
   pub Foreground: BOOLEAN,
   pub PriorityClass: UCHAR,
}
impl Default for _PROCESS_PRIORITY_CLASS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_PRIORITY_CLASS structure is used to manage the priority class of a process."]
pub type PROCESS_PRIORITY_CLASS = _PROCESS_PRIORITY_CLASS;
#[doc = "The PROCESS_PRIORITY_CLASS structure is used to manage the priority class of a process."]
pub type PPROCESS_PRIORITY_CLASS = *mut _PROCESS_PRIORITY_CLASS;
#[doc = "The PROCESS_PRIORITY_CLASS_EX structure extends PROCESS_PRIORITY_CLASS to include validity flags."]
#[repr(C)]
pub struct _PROCESS_PRIORITY_CLASS_EX {
   pub __bindgen_anon_1: _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1,
   pub PriorityClass: UCHAR,
   pub Foreground: BOOLEAN,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1 {
   pub __bindgen_anon_1: _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1__bindgen_ty_1,
   pub AllFlags: USHORT,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: u8,
}
impl _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ForegroundValid(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_ForegroundValid(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ForegroundValid_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_ForegroundValid_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PriorityClassValid(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_PriorityClassValid(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PriorityClassValid_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_PriorityClassValid_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ForegroundValid: USHORT,
      PriorityClassValid: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ForegroundValid: u16 = unsafe { ::core::mem::transmute(ForegroundValid) };
         ForegroundValid as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let PriorityClassValid: u16 = unsafe { ::core::mem::transmute(PriorityClassValid) };
         PriorityClassValid as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_PRIORITY_CLASS_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_PRIORITY_CLASS_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_PRIORITY_CLASS_EX structure extends PROCESS_PRIORITY_CLASS to include validity flags."]
pub type PROCESS_PRIORITY_CLASS_EX = _PROCESS_PRIORITY_CLASS_EX;
#[doc = "The PROCESS_PRIORITY_CLASS_EX structure extends PROCESS_PRIORITY_CLASS to include validity flags."]
pub type PPROCESS_PRIORITY_CLASS_EX = *mut _PROCESS_PRIORITY_CLASS_EX;
#[doc = "The PROCESS_FOREGROUND_BACKGROUND structure is used to manage the the priority class of a process, specifically whether it runs in the foreground or background."]
#[repr(C)]
pub struct _PROCESS_FOREGROUND_BACKGROUND {
   pub Foreground: BOOLEAN,
}
impl Default for _PROCESS_FOREGROUND_BACKGROUND {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_FOREGROUND_BACKGROUND structure is used to manage the the priority class of a process, specifically whether it runs in the foreground or background."]
pub type PROCESS_FOREGROUND_BACKGROUND = _PROCESS_FOREGROUND_BACKGROUND;
#[doc = "The PROCESS_FOREGROUND_BACKGROUND structure is used to manage the the priority class of a process, specifically whether it runs in the foreground or background."]
pub type PPROCESS_FOREGROUND_BACKGROUND = *mut _PROCESS_FOREGROUND_BACKGROUND;
#[doc = "The PROCESS_DEVICEMAP_INFORMATION structure contains information about a process's device map."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION {
   pub __bindgen_anon_1: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 {
   pub Set: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub Query: _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub DirectoryHandle: HANDLE,
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
   pub DriveMap: ULONG,
   pub DriveType: [UCHAR; 32usize],
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_DEVICEMAP_INFORMATION structure contains information about a process's device map."]
pub type PROCESS_DEVICEMAP_INFORMATION = _PROCESS_DEVICEMAP_INFORMATION;
#[doc = "The PROCESS_DEVICEMAP_INFORMATION structure contains information about a process's device map."]
pub type PPROCESS_DEVICEMAP_INFORMATION = *mut _PROCESS_DEVICEMAP_INFORMATION;
#[doc = "The _PROCESS_DEVICEMAP_INFORMATION_EX structure contains information about a process's device map."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX {
   pub __bindgen_anon_1: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1,
   pub Flags: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 {
   pub Set: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1,
   pub Query: _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   pub DirectoryHandle: HANDLE,
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1__bindgen_ty_2 {
   pub DriveMap: ULONG,
   pub DriveType: [UCHAR; 32usize],
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_DEVICEMAP_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The _PROCESS_DEVICEMAP_INFORMATION_EX structure contains information about a process's device map."]
pub type PROCESS_DEVICEMAP_INFORMATION_EX = _PROCESS_DEVICEMAP_INFORMATION_EX;
#[doc = "The _PROCESS_DEVICEMAP_INFORMATION_EX structure contains information about a process's device map."]
pub type PPROCESS_DEVICEMAP_INFORMATION_EX = *mut _PROCESS_DEVICEMAP_INFORMATION_EX;
#[doc = "The PROCESS_SESSION_INFORMATION structure is used to store information about the session ID of a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_SESSION_INFORMATION {
   pub SessionId: ULONG,
}
#[doc = "The PROCESS_SESSION_INFORMATION structure is used to store information about the session ID of a process."]
pub type PROCESS_SESSION_INFORMATION = _PROCESS_SESSION_INFORMATION;
#[doc = "The PROCESS_SESSION_INFORMATION structure is used to store information about the session ID of a process."]
pub type PPROCESS_SESSION_INFORMATION = *mut _PROCESS_SESSION_INFORMATION;
#[doc = "The PROCESS_HANDLE_TRACING_ENABLE structure is used to enable handle tracing for a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENABLE {
   pub Flags: ULONG,
}
#[doc = "The PROCESS_HANDLE_TRACING_ENABLE structure is used to enable handle tracing for a process."]
pub type PROCESS_HANDLE_TRACING_ENABLE = _PROCESS_HANDLE_TRACING_ENABLE;
#[doc = "The PROCESS_HANDLE_TRACING_ENABLE structure is used to enable handle tracing for a process."]
pub type PPROCESS_HANDLE_TRACING_ENABLE = *mut _PROCESS_HANDLE_TRACING_ENABLE;
#[doc = "The PROCESS_HANDLE_TRACING_ENABLE_EX structure extends PROCESS_HANDLE_TRACING_ENABLE to include the total number of slots."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENABLE_EX {
   pub Flags: ULONG,
   pub TotalSlots: ULONG,
}
#[doc = "The PROCESS_HANDLE_TRACING_ENABLE_EX structure extends PROCESS_HANDLE_TRACING_ENABLE to include the total number of slots."]
pub type PROCESS_HANDLE_TRACING_ENABLE_EX = _PROCESS_HANDLE_TRACING_ENABLE_EX;
#[doc = "The PROCESS_HANDLE_TRACING_ENABLE_EX structure extends PROCESS_HANDLE_TRACING_ENABLE to include the total number of slots."]
pub type PPROCESS_HANDLE_TRACING_ENABLE_EX = *mut _PROCESS_HANDLE_TRACING_ENABLE_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_ENTRY {
   pub Handle: HANDLE,
   pub ClientId: CLIENT_ID,
   pub Type: ULONG,
   pub Stacks: [PVOID; 16usize],
}
impl Default for _PROCESS_HANDLE_TRACING_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_HANDLE_TRACING_ENTRY = _PROCESS_HANDLE_TRACING_ENTRY;
pub type PPROCESS_HANDLE_TRACING_ENTRY = *mut _PROCESS_HANDLE_TRACING_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TRACING_QUERY {
   pub Handle: HANDLE,
   pub TotalTraces: ULONG,
   pub HandleTrace: [PROCESS_HANDLE_TRACING_ENTRY; 1usize],
}
impl Default for _PROCESS_HANDLE_TRACING_QUERY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_HANDLE_TRACING_QUERY = _PROCESS_HANDLE_TRACING_QUERY;
pub type PPROCESS_HANDLE_TRACING_QUERY = *mut _PROCESS_HANDLE_TRACING_QUERY;
#[doc = "The THREAD_TLS_INFORMATION structure contains information about the Thread Local Storage (TLS) data for a thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_TLS_INFORMATION {
   pub Flags: ULONG,
   pub NewTlsData: PVOID,
   pub OldTlsData: PVOID,
   pub ThreadId: HANDLE,
}
impl Default for _THREAD_TLS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The THREAD_TLS_INFORMATION structure contains information about the Thread Local Storage (TLS) data for a thread."]
pub type THREAD_TLS_INFORMATION = _THREAD_TLS_INFORMATION;
#[doc = "The THREAD_TLS_INFORMATION structure contains information about the Thread Local Storage (TLS) data for a thread."]
pub type PTHREAD_TLS_INFORMATION = *mut _THREAD_TLS_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[doc = "The PROCESS_TLS_INFORMATION_TYPE enumeration defines the types of TLS operations that can be performed on a process."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_TLS_INFORMATION_TYPE {
   ProcessTlsReplaceIndex = 0,
   ProcessTlsReplaceVector = 1,
   MaxProcessTlsOperation = 2,
}
#[doc = "The PROCESS_TLS_INFORMATION_TYPE enumeration defines the types of TLS operations that can be performed on a process."]
pub use self::_PROCESS_TLS_INFORMATION_TYPE as PROCESS_TLS_INFORMATION_TYPE;
#[doc = "The PROCESS_TLS_INFORMATION_TYPE enumeration defines the types of TLS operations that can be performed on a process."]
pub type PPROCESS_TLS_INFORMATION_TYPE = *mut _PROCESS_TLS_INFORMATION_TYPE;
#[doc = "The PROCESS_TLS_INFORMATION structure contains information about the TLS operations for a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_TLS_INFORMATION {
   pub Flags: ULONG,
   pub OperationType: ULONG,
   pub ThreadDataCount: ULONG,
   pub TlsIndex: ULONG,
   pub PreviousCount: ULONG,
   pub ThreadData: [THREAD_TLS_INFORMATION; 1usize],
}
impl Default for _PROCESS_TLS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_TLS_INFORMATION structure contains information about the TLS operations for a process."]
pub type PROCESS_TLS_INFORMATION = _PROCESS_TLS_INFORMATION;
#[doc = "The PROCESS_TLS_INFORMATION structure contains information about the TLS operations for a process."]
pub type PPROCESS_TLS_INFORMATION = *mut _PROCESS_TLS_INFORMATION;
#[doc = "The PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION structure contains information about the instrumentation callback for a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
   pub Version: ULONG,
   pub Reserved: ULONG,
   pub Callback: PVOID,
}
impl Default for _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION structure contains information about the instrumentation callback for a process."]
pub type PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION =
   _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;
#[doc = "The PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION structure contains information about the instrumentation callback for a process."]
pub type PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION =
   *mut _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;
#[doc = "The PROCESS_STACK_ALLOCATION_INFORMATION structure contains information about the stack allocation for a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_STACK_ALLOCATION_INFORMATION {
   pub ReserveSize: SIZE_T,
   pub ZeroBits: SIZE_T,
   pub StackBase: PVOID,
}
impl Default for _PROCESS_STACK_ALLOCATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_STACK_ALLOCATION_INFORMATION structure contains information about the stack allocation for a process."]
pub type PROCESS_STACK_ALLOCATION_INFORMATION = _PROCESS_STACK_ALLOCATION_INFORMATION;
#[doc = "The PROCESS_STACK_ALLOCATION_INFORMATION structure contains information about the stack allocation for a process."]
pub type PPROCESS_STACK_ALLOCATION_INFORMATION = *mut _PROCESS_STACK_ALLOCATION_INFORMATION;
#[doc = "The PROCESS_STACK_ALLOCATION_INFORMATION_EX structure extends PROCESS_STACK_ALLOCATION_INFORMATION to include additional fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_STACK_ALLOCATION_INFORMATION_EX {
   pub PreferredNode: ULONG,
   pub Reserved0: ULONG,
   pub Reserved1: ULONG,
   pub Reserved2: ULONG,
   pub AllocInfo: PROCESS_STACK_ALLOCATION_INFORMATION,
}
impl Default for _PROCESS_STACK_ALLOCATION_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_STACK_ALLOCATION_INFORMATION_EX structure extends PROCESS_STACK_ALLOCATION_INFORMATION to include additional fields."]
pub type PROCESS_STACK_ALLOCATION_INFORMATION_EX = _PROCESS_STACK_ALLOCATION_INFORMATION_EX;
#[doc = "The PROCESS_STACK_ALLOCATION_INFORMATION_EX structure extends PROCESS_STACK_ALLOCATION_INFORMATION to include additional fields."]
pub type PPROCESS_STACK_ALLOCATION_INFORMATION_EX = *mut _PROCESS_STACK_ALLOCATION_INFORMATION_EX;
#[doc = "The PROCESS_AFFINITY_UPDATE_MODE union is used to specify the affinity update mode for a process."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_AFFINITY_UPDATE_MODE {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_AFFINITY_UPDATE_MODE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_AFFINITY_UPDATE_MODE__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_AFFINITY_UPDATE_MODE__bindgen_ty_1 {
   #[inline]
   pub fn EnableAutoUpdate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableAutoUpdate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableAutoUpdate_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableAutoUpdate_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Permanent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Permanent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Permanent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Permanent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableAutoUpdate: ULONG,
      Permanent: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableAutoUpdate: u32 = unsafe { ::core::mem::transmute(EnableAutoUpdate) };
         EnableAutoUpdate as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Permanent: u32 = unsafe { ::core::mem::transmute(Permanent) };
         Permanent as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_AFFINITY_UPDATE_MODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_AFFINITY_UPDATE_MODE union is used to specify the affinity update mode for a process."]
pub type PROCESS_AFFINITY_UPDATE_MODE = _PROCESS_AFFINITY_UPDATE_MODE;
#[doc = "The PROCESS_AFFINITY_UPDATE_MODE union is used to specify the affinity update mode for a process."]
pub type PPROCESS_AFFINITY_UPDATE_MODE = *mut _PROCESS_AFFINITY_UPDATE_MODE;
#[doc = "The PROCESS_MEMORY_ALLOCATION_MODE union is used to specify the memory allocation mode for a process."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MEMORY_ALLOCATION_MODE {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_MEMORY_ALLOCATION_MODE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MEMORY_ALLOCATION_MODE__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MEMORY_ALLOCATION_MODE__bindgen_ty_1 {
   #[inline]
   pub fn TopDown(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_TopDown(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TopDown_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TopDown_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(TopDown: ULONG, Reserved: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let TopDown: u32 = unsafe { ::core::mem::transmute(TopDown) };
         TopDown as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MEMORY_ALLOCATION_MODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_MEMORY_ALLOCATION_MODE union is used to specify the memory allocation mode for a process."]
pub type PROCESS_MEMORY_ALLOCATION_MODE = _PROCESS_MEMORY_ALLOCATION_MODE;
#[doc = "The PROCESS_MEMORY_ALLOCATION_MODE union is used to specify the memory allocation mode for a process."]
pub type PPROCESS_MEMORY_ALLOCATION_MODE = *mut _PROCESS_MEMORY_ALLOCATION_MODE;
#[doc = "The PROCESS_HANDLE_INFORMATION structure contains information about the handles of a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_HANDLE_INFORMATION {
   pub HandleCount: ULONG,
   pub HandleCountHighWatermark: ULONG,
}
#[doc = "The PROCESS_HANDLE_INFORMATION structure contains information about the handles of a process."]
pub type PROCESS_HANDLE_INFORMATION = _PROCESS_HANDLE_INFORMATION;
#[doc = "The PROCESS_HANDLE_INFORMATION structure contains information about the handles of a process."]
pub type PPROCESS_HANDLE_INFORMATION = *mut _PROCESS_HANDLE_INFORMATION;
#[doc = "The PROCESS_CYCLE_TIME_INFORMATION structure contains information about the cycle time of a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_CYCLE_TIME_INFORMATION {
   pub AccumulatedCycles: ULONGLONG,
   pub CurrentCycleCount: ULONGLONG,
}
#[doc = "The PROCESS_CYCLE_TIME_INFORMATION structure contains information about the cycle time of a process."]
pub type PROCESS_CYCLE_TIME_INFORMATION = _PROCESS_CYCLE_TIME_INFORMATION;
#[doc = "The PROCESS_CYCLE_TIME_INFORMATION structure contains information about the cycle time of a process."]
pub type PPROCESS_CYCLE_TIME_INFORMATION = *mut _PROCESS_CYCLE_TIME_INFORMATION;
#[doc = "The PROCESS_WINDOW_INFORMATION structure contains information about the windows of a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_WINDOW_INFORMATION {
   pub WindowFlags: ULONG,
   pub WindowTitleLength: USHORT,
   pub WindowTitle: [WCHAR; 1usize],
}
#[doc = "The PROCESS_WINDOW_INFORMATION structure contains information about the windows of a process."]
pub type PROCESS_WINDOW_INFORMATION = _PROCESS_WINDOW_INFORMATION;
#[doc = "The PROCESS_WINDOW_INFORMATION structure contains information about the windows of a process."]
pub type PPROCESS_WINDOW_INFORMATION = *mut _PROCESS_WINDOW_INFORMATION;
#[doc = "The PROCESS_HANDLE_TABLE_ENTRY_INFO structure contains information about a handle table entry of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_TABLE_ENTRY_INFO {
   pub HandleValue: HANDLE,
   pub HandleCount: SIZE_T,
   pub PointerCount: SIZE_T,
   pub GrantedAccess: ACCESS_MASK,
   pub ObjectTypeIndex: ULONG,
   pub HandleAttributes: ULONG,
   pub Reserved: ULONG,
}
impl Default for _PROCESS_HANDLE_TABLE_ENTRY_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_HANDLE_TABLE_ENTRY_INFO structure contains information about a handle table entry of a process."]
pub type PROCESS_HANDLE_TABLE_ENTRY_INFO = _PROCESS_HANDLE_TABLE_ENTRY_INFO;
#[doc = "The PROCESS_HANDLE_TABLE_ENTRY_INFO structure contains information about a handle table entry of a process."]
pub type PPROCESS_HANDLE_TABLE_ENTRY_INFO = *mut _PROCESS_HANDLE_TABLE_ENTRY_INFO;
#[doc = "The PROCESS_HANDLE_SNAPSHOT_INFORMATION structure contains information about the handle snapshot of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
   pub NumberOfHandles: ULONG_PTR,
   pub Reserved: ULONG_PTR,
   pub Handles: [PROCESS_HANDLE_TABLE_ENTRY_INFO; 1usize],
}
impl Default for _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_HANDLE_SNAPSHOT_INFORMATION structure contains information about the handle snapshot of a process."]
pub type PROCESS_HANDLE_SNAPSHOT_INFORMATION = _PROCESS_HANDLE_SNAPSHOT_INFORMATION;
#[doc = "The PROCESS_HANDLE_SNAPSHOT_INFORMATION structure contains information about the handle snapshot of a process."]
pub type PPROCESS_HANDLE_SNAPSHOT_INFORMATION = *mut _PROCESS_HANDLE_SNAPSHOT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2 {
   pub __bindgen_anon_1: _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1:
      _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn AssemblyManifestRedirectionTrust(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_AssemblyManifestRedirectionTrust(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AssemblyManifestRedirectionTrust_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AssemblyManifestRedirectionTrust_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      AssemblyManifestRedirectionTrust: ULONG,
      ReservedFlags: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let AssemblyManifestRedirectionTrust: u32 =
            unsafe { ::core::mem::transmute(AssemblyManifestRedirectionTrust) };
         AssemblyManifestRedirectionTrust as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let ReservedFlags: u32 = unsafe { ::core::mem::transmute(ReservedFlags) };
         ReservedFlags as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2 =
   _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2;
pub type PPROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2 =
   *mut _PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_POLICY_INFORMATION {
   pub Policy: PROCESS_MITIGATION_POLICY,
   pub __bindgen_anon_1: _PROCESS_MITIGATION_POLICY_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_POLICY_INFORMATION__bindgen_ty_1 {
   pub ASLRPolicy: PROCESS_MITIGATION_ASLR_POLICY,
   pub StrictHandleCheckPolicy: PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY,
   pub SystemCallDisablePolicy: PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY,
   pub ExtensionPointDisablePolicy: PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY,
   pub DynamicCodePolicy: PROCESS_MITIGATION_DYNAMIC_CODE_POLICY,
   pub ControlFlowGuardPolicy: PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY,
   pub SignaturePolicy: PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY,
   pub FontDisablePolicy: PROCESS_MITIGATION_FONT_DISABLE_POLICY,
   pub ImageLoadPolicy: PROCESS_MITIGATION_IMAGE_LOAD_POLICY,
   pub SystemCallFilterPolicy: PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY,
   pub PayloadRestrictionPolicy: PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY,
   pub ChildProcessPolicy: PROCESS_MITIGATION_CHILD_PROCESS_POLICY,
   pub SideChannelIsolationPolicy: PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY,
   pub UserShadowStackPolicy: PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY,
   pub RedirectionTrustPolicy: PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY,
   pub UserPointerAuthPolicy: PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY,
   pub SEHOPPolicy: PROCESS_MITIGATION_SEHOP_POLICY,
}
impl Default for _PROCESS_MITIGATION_POLICY_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PROCESS_MITIGATION_POLICY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_MITIGATION_POLICY_INFORMATION = _PROCESS_MITIGATION_POLICY_INFORMATION;
pub type PPROCESS_MITIGATION_POLICY_INFORMATION = *mut _PROCESS_MITIGATION_POLICY_INFORMATION;
#[repr(C)]
pub struct _PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION {
   pub DynamicFunctionTable: *mut _DYNAMIC_FUNCTION_TABLE,
   pub Remove: BOOLEAN,
}
impl Default for _PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION = _PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION;
pub type PPROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION =
   *mut _PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_KEEPALIVE_COUNT_INFORMATION {
   pub WakeCount: ULONG,
   pub NoWakeCount: ULONG,
}
pub type PROCESS_KEEPALIVE_COUNT_INFORMATION = _PROCESS_KEEPALIVE_COUNT_INFORMATION;
pub type PPROCESS_KEEPALIVE_COUNT_INFORMATION = *mut _PROCESS_KEEPALIVE_COUNT_INFORMATION;
#[repr(C)]
pub struct _PROCESS_REVOKE_FILE_HANDLES_INFORMATION {
   pub TargetDevicePath: UNICODE_STRING,
}
impl Default for _PROCESS_REVOKE_FILE_HANDLES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_REVOKE_FILE_HANDLES_INFORMATION = _PROCESS_REVOKE_FILE_HANDLES_INFORMATION;
pub type PPROCESS_REVOKE_FILE_HANDLES_INFORMATION = *mut _PROCESS_REVOKE_FILE_HANDLES_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[doc = "The PROCESS_WORKING_SET_OPERATION enumeration defines the operation to perform on a process's working set."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_WORKING_SET_OPERATION {
   ProcessWorkingSetSwap = 0,
   ProcessWorkingSetEmpty = 1,
   ProcessWorkingSetOperationMax = 2,
}
#[doc = "The PROCESS_WORKING_SET_OPERATION enumeration defines the operation to perform on a process's working set."]
pub use self::_PROCESS_WORKING_SET_OPERATION as PROCESS_WORKING_SET_OPERATION;
#[doc = "The PROCESS_WORKING_SET_CONTROL structure is used to control the working set of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WORKING_SET_CONTROL {
   pub Version: ULONG,
   pub Operation: PROCESS_WORKING_SET_OPERATION,
   pub Flags: ULONG,
}
impl Default for _PROCESS_WORKING_SET_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_WORKING_SET_CONTROL structure is used to control the working set of a process."]
pub type PROCESS_WORKING_SET_CONTROL = _PROCESS_WORKING_SET_CONTROL;
#[doc = "The PROCESS_WORKING_SET_CONTROL structure is used to control the working set of a process."]
pub type PPROCESS_WORKING_SET_CONTROL = *mut _PROCESS_WORKING_SET_CONTROL;
#[repr(i32)]
#[non_exhaustive]
#[doc = "The PS_PROTECTED_TYPE enumeration defines the types of protection that can be applied to a process."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_PROTECTED_TYPE {
   PsProtectedTypeNone = 0,
   PsProtectedTypeProtectedLight = 1,
   PsProtectedTypeProtected = 2,
   PsProtectedTypeMax = 3,
}
#[doc = "The PS_PROTECTED_TYPE enumeration defines the types of protection that can be applied to a process."]
pub use self::_PS_PROTECTED_TYPE as PS_PROTECTED_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[doc = "The PS_PROTECTED_SIGNER enumeration defines the types of signers that can be associated with a protected process."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_PROTECTED_SIGNER {
   PsProtectedSignerNone = 0,
   PsProtectedSignerAuthenticode = 1,
   PsProtectedSignerCodeGen = 2,
   PsProtectedSignerAntimalware = 3,
   PsProtectedSignerLsa = 4,
   PsProtectedSignerWindows = 5,
   PsProtectedSignerWinTcb = 6,
   PsProtectedSignerWinSystem = 7,
   PsProtectedSignerApp = 8,
   PsProtectedSignerMax = 9,
}
#[doc = "The PS_PROTECTED_SIGNER enumeration defines the types of signers that can be associated with a protected process."]
pub use self::_PS_PROTECTED_SIGNER as PS_PROTECTED_SIGNER;
#[doc = "The PS_PROTECTION structure is used to define the protection level of a process."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_PROTECTION {
   pub __bindgen_anon_1: _PS_PROTECTION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_PROTECTION__bindgen_ty_1 {
   pub Level: UCHAR,
   pub __bindgen_anon_1: _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PS_PROTECTION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Type(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Type_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            3u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Type_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Audit(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Audit(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Audit_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Audit_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Signer(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_Signer(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Signer_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            4u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Signer_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Type: UCHAR,
      Audit: UCHAR,
      Signer: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 3u8, {
         let Type: u8 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let Audit: u8 = unsafe { ::core::mem::transmute(Audit) };
         Audit as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let Signer: u8 = unsafe { ::core::mem::transmute(Signer) };
         Signer as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_PROTECTION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_PROTECTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PS_PROTECTION structure is used to define the protection level of a process."]
pub type PS_PROTECTION = _PS_PROTECTION;
#[doc = "The PS_PROTECTION structure is used to define the protection level of a process."]
pub type PPS_PROTECTION = *mut _PS_PROTECTION;
#[doc = "The PROCESS_FAULT_INFORMATION structure contains information about process faults."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_FAULT_INFORMATION {
   pub FaultFlags: ULONG,
   pub AdditionalInfo: ULONG,
}
#[doc = "The PROCESS_FAULT_INFORMATION structure contains information about process faults."]
pub type PROCESS_FAULT_INFORMATION = _PROCESS_FAULT_INFORMATION;
#[doc = "The PROCESS_FAULT_INFORMATION structure contains information about process faults."]
pub type PPROCESS_FAULT_INFORMATION = *mut _PROCESS_FAULT_INFORMATION;
#[doc = "The PROCESS_TELEMETRY_ID_INFORMATION structure contains telemetry information about a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_TELEMETRY_ID_INFORMATION {
   pub HeaderSize: ULONG,
   pub ProcessId: ULONG,
   pub ProcessStartKey: ULONGLONG,
   pub CreateTime: ULONGLONG,
   pub CreateInterruptTime: ULONGLONG,
   pub CreateUnbiasedInterruptTime: ULONGLONG,
   pub ProcessSequenceNumber: ULONGLONG,
   pub SessionCreateTime: ULONGLONG,
   pub SessionId: ULONG,
   pub BootId: ULONG,
   pub ImageChecksum: ULONG,
   pub ImageTimeDateStamp: ULONG,
   pub UserSidOffset: ULONG,
   pub ImagePathOffset: ULONG,
   pub PackageNameOffset: ULONG,
   pub RelativeAppNameOffset: ULONG,
   pub CommandLineOffset: ULONG,
}
#[doc = "The PROCESS_TELEMETRY_ID_INFORMATION structure contains telemetry information about a process."]
pub type PROCESS_TELEMETRY_ID_INFORMATION = _PROCESS_TELEMETRY_ID_INFORMATION;
#[doc = "The PROCESS_TELEMETRY_ID_INFORMATION structure contains telemetry information about a process."]
pub type PPROCESS_TELEMETRY_ID_INFORMATION = *mut _PROCESS_TELEMETRY_ID_INFORMATION;
#[doc = "The PROCESS_COMMIT_RELEASE_INFORMATION structure contains information about the commit and release of memory for a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_COMMIT_RELEASE_INFORMATION {
   pub Version: ULONG,
   pub __bindgen_anon_1: _PROCESS_COMMIT_RELEASE_INFORMATION__bindgen_ty_1,
   pub CommitDebt: SIZE_T,
   pub CommittedMemResetSize: SIZE_T,
   pub RepurposedMemResetSize: SIZE_T,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_COMMIT_RELEASE_INFORMATION__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_COMMIT_RELEASE_INFORMATION__bindgen_ty_1 {
   #[inline]
   pub fn Eligible(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Eligible(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Eligible_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Eligible_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReleaseRepurposedMemResetCommit(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReleaseRepurposedMemResetCommit(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReleaseRepurposedMemResetCommit_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReleaseRepurposedMemResetCommit_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ForceReleaseMemResetCommit(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ForceReleaseMemResetCommit(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ForceReleaseMemResetCommit_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ForceReleaseMemResetCommit_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            29u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            29u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Eligible: ULONG,
      ReleaseRepurposedMemResetCommit: ULONG,
      ForceReleaseMemResetCommit: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Eligible: u32 = unsafe { ::core::mem::transmute(Eligible) };
         Eligible as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ReleaseRepurposedMemResetCommit: u32 =
            unsafe { ::core::mem::transmute(ReleaseRepurposedMemResetCommit) };
         ReleaseRepurposedMemResetCommit as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ForceReleaseMemResetCommit: u32 =
            unsafe { ::core::mem::transmute(ForceReleaseMemResetCommit) };
         ForceReleaseMemResetCommit as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
#[doc = "The PROCESS_COMMIT_RELEASE_INFORMATION structure contains information about the commit and release of memory for a process."]
pub type PROCESS_COMMIT_RELEASE_INFORMATION = _PROCESS_COMMIT_RELEASE_INFORMATION;
#[doc = "The PROCESS_COMMIT_RELEASE_INFORMATION structure contains information about the commit and release of memory for a process."]
pub type PPROCESS_COMMIT_RELEASE_INFORMATION = *mut _PROCESS_COMMIT_RELEASE_INFORMATION;
#[doc = "The PROCESS_JOB_MEMORY_INFO structure contains Represents app memory usage at a single point in time.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-app_memory_information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_JOB_MEMORY_INFO {
   pub SharedCommitUsage: ULONGLONG,
   pub PrivateCommitUsage: ULONGLONG,
   pub PeakPrivateCommitUsage: ULONGLONG,
   pub PrivateCommitLimit: ULONGLONG,
   pub TotalCommitLimit: ULONGLONG,
}
#[doc = "The PROCESS_JOB_MEMORY_INFO structure contains Represents app memory usage at a single point in time.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-app_memory_information"]
pub type PROCESS_JOB_MEMORY_INFO = _PROCESS_JOB_MEMORY_INFO;
#[doc = "The PROCESS_JOB_MEMORY_INFO structure contains Represents app memory usage at a single point in time.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-app_memory_information"]
pub type PPROCESS_JOB_MEMORY_INFO = *mut _PROCESS_JOB_MEMORY_INFO;
#[doc = "The PROCESS_CHILD_PROCESS_INFORMATION structure contains information about child process policies."]
#[repr(C)]
pub struct _PROCESS_CHILD_PROCESS_INFORMATION {
   pub ProhibitChildProcesses: BOOLEAN,
   pub AlwaysAllowSecureChildProcess: BOOLEAN,
   pub AuditProhibitChildProcesses: BOOLEAN,
}
impl Default for _PROCESS_CHILD_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROCESS_CHILD_PROCESS_INFORMATION structure contains information about child process policies."]
pub type PROCESS_CHILD_PROCESS_INFORMATION = _PROCESS_CHILD_PROCESS_INFORMATION;
#[doc = "The PROCESS_CHILD_PROCESS_INFORMATION structure contains information about child process policies."]
pub type PPROCESS_CHILD_PROCESS_INFORMATION = *mut _PROCESS_CHILD_PROCESS_INFORMATION;
#[doc = "The POWER_THROTTLING_PROCESS_STATE structure is used to manage the power throttling state of a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_THROTTLING_PROCESS_STATE {
   pub Version: ULONG,
   pub ControlMask: ULONG,
   pub StateMask: ULONG,
}
#[doc = "The POWER_THROTTLING_PROCESS_STATE structure is used to manage the power throttling state of a process."]
pub type POWER_THROTTLING_PROCESS_STATE = _POWER_THROTTLING_PROCESS_STATE;
#[doc = "The POWER_THROTTLING_PROCESS_STATE structure is used to manage the power throttling state of a process."]
pub type PPOWER_THROTTLING_PROCESS_STATE = *mut _POWER_THROTTLING_PROCESS_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WIN32K_SYSCALL_FILTER {
   pub FilterState: ULONG,
   pub FilterSet: ULONG,
}
pub type WIN32K_SYSCALL_FILTER = _WIN32K_SYSCALL_FILTER;
pub type PWIN32K_SYSCALL_FILTER = *mut _WIN32K_SYSCALL_FILTER;
pub type PJOBOBJECT_WAKE_FILTER = *mut _JOBOBJECT_WAKE_FILTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_WAKE_INFORMATION {
   pub NotificationChannel: ULONGLONG,
   pub WakeCounters: [ULONG; 7usize],
   pub WakeFilter: PJOBOBJECT_WAKE_FILTER,
}
impl Default for _PROCESS_WAKE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_WAKE_INFORMATION = _PROCESS_WAKE_INFORMATION;
pub type PPROCESS_WAKE_INFORMATION = *mut _PROCESS_WAKE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_ENERGY_TRACKING_STATE {
   pub StateUpdateMask: ULONG,
   pub StateDesiredValue: ULONG,
   pub StateSequence: ULONG,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: u16,
   pub Tag: [WCHAR; 64usize],
}
impl Default for _PROCESS_ENERGY_TRACKING_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PROCESS_ENERGY_TRACKING_STATE {
   #[inline]
   pub fn UpdateTag(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_UpdateTag(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UpdateTag_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_UpdateTag_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(UpdateTag: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let UpdateTag: u32 = unsafe { ::core::mem::transmute(UpdateTag) };
         UpdateTag as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PROCESS_ENERGY_TRACKING_STATE = _PROCESS_ENERGY_TRACKING_STATE;
pub type PPROCESS_ENERGY_TRACKING_STATE = *mut _PROCESS_ENERGY_TRACKING_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MANAGE_WRITES_TO_EXECUTABLE_MEMORY {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub KernelWriteToExecutableSignal: PVOID,
}
impl Default for _MANAGE_WRITES_TO_EXECUTABLE_MEMORY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _MANAGE_WRITES_TO_EXECUTABLE_MEMORY {
   #[inline]
   pub fn Version(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Version(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Version_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Version_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessEnableWriteExceptions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessEnableWriteExceptions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessEnableWriteExceptions_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessEnableWriteExceptions_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ThreadAllowWrites(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ThreadAllowWrites(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ThreadAllowWrites_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ThreadAllowWrites_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 22u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            22u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            22u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Version: ULONG,
      ProcessEnableWriteExceptions: ULONG,
      ThreadAllowWrites: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Version: u32 = unsafe { ::core::mem::transmute(Version) };
         Version as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let ProcessEnableWriteExceptions: u32 =
            unsafe { ::core::mem::transmute(ProcessEnableWriteExceptions) };
         ProcessEnableWriteExceptions as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let ThreadAllowWrites: u32 = unsafe { ::core::mem::transmute(ThreadAllowWrites) };
         ThreadAllowWrites as u64
      });
      __bindgen_bitfield_unit.set(10usize, 22u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type MANAGE_WRITES_TO_EXECUTABLE_MEMORY = _MANAGE_WRITES_TO_EXECUTABLE_MEMORY;
pub type PMANAGE_WRITES_TO_EXECUTABLE_MEMORY = *mut _MANAGE_WRITES_TO_EXECUTABLE_MEMORY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_THROTTLING_THREAD_STATE {
   pub Version: ULONG,
   pub ControlMask: ULONG,
   pub StateMask: ULONG,
}
pub type POWER_THROTTLING_THREAD_STATE = _POWER_THROTTLING_THREAD_STATE;
pub type PPOWER_THROTTLING_THREAD_STATE = *mut _POWER_THROTTLING_THREAD_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_READWRITEVM_LOGGING_INFORMATION {
   pub Flags: UCHAR,
   pub __bindgen_anon_1: _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PROCESS_READWRITEVM_LOGGING_INFORMATION__bindgen_ty_1 {
   #[inline]
   pub fn EnableReadVmLogging(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EnableReadVmLogging(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableReadVmLogging_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_EnableReadVmLogging_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableWriteVmLogging(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EnableWriteVmLogging(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableWriteVmLogging_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_EnableWriteVmLogging_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Unused(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
   }
   #[inline]
   pub fn set_Unused(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Unused_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            6u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Unused_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableReadVmLogging: UCHAR,
      EnableWriteVmLogging: UCHAR,
      Unused: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableReadVmLogging: u8 = unsafe { ::core::mem::transmute(EnableReadVmLogging) };
         EnableReadVmLogging as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnableWriteVmLogging: u8 = unsafe { ::core::mem::transmute(EnableWriteVmLogging) };
         EnableWriteVmLogging as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let Unused: u8 = unsafe { ::core::mem::transmute(Unused) };
         Unused as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_READWRITEVM_LOGGING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_READWRITEVM_LOGGING_INFORMATION = _PROCESS_READWRITEVM_LOGGING_INFORMATION;
pub type PPROCESS_READWRITEVM_LOGGING_INFORMATION = *mut _PROCESS_READWRITEVM_LOGGING_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_UPTIME_INFORMATION {
   pub QueryInterruptTime: ULONGLONG,
   pub QueryUnbiasedTime: ULONGLONG,
   pub EndInterruptTime: ULONGLONG,
   pub TimeSinceCreation: ULONGLONG,
   pub Uptime: ULONGLONG,
   pub SuspendedTime: ULONGLONG,
   pub __bindgen_anon_1: _PROCESS_UPTIME_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_UPTIME_INFORMATION__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
   pub __bindgen_padding_0: u16,
}
impl _PROCESS_UPTIME_INFORMATION__bindgen_ty_1 {
   #[inline]
   pub fn HangCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_HangCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HangCount_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HangCount_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn GhostCount(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_GhostCount(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn GhostCount_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_GhostCount_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Crashed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Crashed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Crashed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Crashed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Terminated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Terminated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Terminated_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Terminated_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HangCount: ULONG,
      GhostCount: ULONG,
      Crashed: ULONG,
      Terminated: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let HangCount: u32 = unsafe { ::core::mem::transmute(HangCount) };
         HangCount as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let GhostCount: u32 = unsafe { ::core::mem::transmute(GhostCount) };
         GhostCount as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let Crashed: u32 = unsafe { ::core::mem::transmute(Crashed) };
         Crashed as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let Terminated: u32 = unsafe { ::core::mem::transmute(Terminated) };
         Terminated as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PROCESS_UPTIME_INFORMATION = _PROCESS_UPTIME_INFORMATION;
pub type PPROCESS_UPTIME_INFORMATION = *mut _PROCESS_UPTIME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_SYSTEM_RESOURCE_MANAGEMENT {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_SYSTEM_RESOURCE_MANAGEMENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_SYSTEM_RESOURCE_MANAGEMENT__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_SYSTEM_RESOURCE_MANAGEMENT__bindgen_ty_1 {
   #[inline]
   pub fn Foreground(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Foreground(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Foreground_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Foreground_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Foreground: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Foreground: u32 = unsafe { ::core::mem::transmute(Foreground) };
         Foreground as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_SYSTEM_RESOURCE_MANAGEMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_SYSTEM_RESOURCE_MANAGEMENT = _PROCESS_SYSTEM_RESOURCE_MANAGEMENT;
pub type PPROCESS_SYSTEM_RESOURCE_MANAGEMENT = *mut _PROCESS_SYSTEM_RESOURCE_MANAGEMENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_SECURITY_DOMAIN_INFORMATION {
   pub SecurityDomain: ULONGLONG,
}
pub type PROCESS_SECURITY_DOMAIN_INFORMATION = _PROCESS_SECURITY_DOMAIN_INFORMATION;
pub type PPROCESS_SECURITY_DOMAIN_INFORMATION = *mut _PROCESS_SECURITY_DOMAIN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION {
   pub ProcessHandle: HANDLE,
}
impl Default for _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION =
   _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION;
pub type PPROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION =
   *mut _PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_LOGGING_INFORMATION {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PROCESS_LOGGING_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_LOGGING_INFORMATION__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_LOGGING_INFORMATION__bindgen_ty_1 {
   #[inline]
   pub fn EnableReadVmLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableReadVmLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableReadVmLogging_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableReadVmLogging_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableWriteVmLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableWriteVmLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableWriteVmLogging_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableWriteVmLogging_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableProcessSuspendResumeLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableProcessSuspendResumeLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableProcessSuspendResumeLogging_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableProcessSuspendResumeLogging_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableThreadSuspendResumeLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableThreadSuspendResumeLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableThreadSuspendResumeLogging_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableThreadSuspendResumeLogging_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableLocalExecProtectVmLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableLocalExecProtectVmLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableLocalExecProtectVmLogging_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableLocalExecProtectVmLogging_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableRemoteExecProtectVmLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableRemoteExecProtectVmLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableRemoteExecProtectVmLogging_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableRemoteExecProtectVmLogging_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableImpersonationLogging(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EnableImpersonationLogging(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableImpersonationLogging_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnableImpersonationLogging_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 25u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            25u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            25u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EnableReadVmLogging: ULONG,
      EnableWriteVmLogging: ULONG,
      EnableProcessSuspendResumeLogging: ULONG,
      EnableThreadSuspendResumeLogging: ULONG,
      EnableLocalExecProtectVmLogging: ULONG,
      EnableRemoteExecProtectVmLogging: ULONG,
      EnableImpersonationLogging: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let EnableReadVmLogging: u32 = unsafe { ::core::mem::transmute(EnableReadVmLogging) };
         EnableReadVmLogging as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnableWriteVmLogging: u32 = unsafe { ::core::mem::transmute(EnableWriteVmLogging) };
         EnableWriteVmLogging as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let EnableProcessSuspendResumeLogging: u32 =
            unsafe { ::core::mem::transmute(EnableProcessSuspendResumeLogging) };
         EnableProcessSuspendResumeLogging as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let EnableThreadSuspendResumeLogging: u32 =
            unsafe { ::core::mem::transmute(EnableThreadSuspendResumeLogging) };
         EnableThreadSuspendResumeLogging as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let EnableLocalExecProtectVmLogging: u32 =
            unsafe { ::core::mem::transmute(EnableLocalExecProtectVmLogging) };
         EnableLocalExecProtectVmLogging as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let EnableRemoteExecProtectVmLogging: u32 =
            unsafe { ::core::mem::transmute(EnableRemoteExecProtectVmLogging) };
         EnableRemoteExecProtectVmLogging as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let EnableImpersonationLogging: u32 =
            unsafe { ::core::mem::transmute(EnableImpersonationLogging) };
         EnableImpersonationLogging as u64
      });
      __bindgen_bitfield_unit.set(7usize, 25u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PROCESS_LOGGING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_LOGGING_INFORMATION = _PROCESS_LOGGING_INFORMATION;
pub type PPROCESS_LOGGING_INFORMATION = *mut _PROCESS_LOGGING_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_LEAP_SECOND_INFORMATION {
   pub Flags: ULONG,
   pub Reserved: ULONG,
}
pub type PROCESS_LEAP_SECOND_INFORMATION = _PROCESS_LEAP_SECOND_INFORMATION;
pub type PPROCESS_LEAP_SECOND_INFORMATION = *mut _PROCESS_LEAP_SECOND_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION {
   pub ReserveSize: ULONGLONG,
   pub CommitSize: ULONGLONG,
   pub PreferredNode: ULONG,
   pub Reserved: ULONG,
   pub Ssp: PVOID,
}
impl Default for _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION =
   _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;
pub type PPROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION =
   *mut _PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION {
   pub Ssp: PVOID,
}
impl Default for _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION =
   _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;
pub type PPROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION =
   *mut _PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_SYSCALL_PROVIDER_INFORMATION {
   pub ProviderId: GUID,
   pub Level: UCHAR,
}
pub type PROCESS_SYSCALL_PROVIDER_INFORMATION = _PROCESS_SYSCALL_PROVIDER_INFORMATION;
pub type PPROCESS_SYSCALL_PROVIDER_INFORMATION = *mut _PROCESS_SYSCALL_PROVIDER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_MEMBERSHIP_INFORMATION {
   pub ServerSiloId: ULONG,
}
pub type PROCESS_MEMBERSHIP_INFORMATION = _PROCESS_MEMBERSHIP_INFORMATION;
pub type PPROCESS_MEMBERSHIP_INFORMATION = *mut _PROCESS_MEMBERSHIP_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_NETWORK_COUNTERS {
   pub BytesIn: ULONG64,
   pub BytesOut: ULONG64,
}
pub type PROCESS_NETWORK_COUNTERS = _PROCESS_NETWORK_COUNTERS;
pub type PPROCESS_NETWORK_COUNTERS = *mut _PROCESS_NETWORK_COUNTERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_TEB_VALUE_INFORMATION {
   pub ThreadId: ULONG,
   pub TebOffset: ULONG,
   pub Value: ULONG_PTR,
}
pub type PROCESS_TEB_VALUE_INFORMATION = _PROCESS_TEB_VALUE_INFORMATION;
pub type PPROCESS_TEB_VALUE_INFORMATION = *mut _PROCESS_TEB_VALUE_INFORMATION;
#[repr(C)]
pub struct _THREAD_BASIC_INFORMATION {
   pub ExitStatus: NTSTATUS,
   pub TebBaseAddress: PTEB,
   pub ClientId: CLIENT_ID,
   pub AffinityMask: KAFFINITY,
   pub Priority: KPRIORITY,
   pub BasePriority: KPRIORITY,
}
impl Default for _THREAD_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_BASIC_INFORMATION = _THREAD_BASIC_INFORMATION;
pub type PTHREAD_BASIC_INFORMATION = *mut _THREAD_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_LAST_SYSCALL_INFORMATION {
   pub FirstArgument: PVOID,
   pub SystemCallNumber: USHORT,
   pub Pad: [USHORT; 1usize],
   pub WaitTime: ULONG64,
}
impl Default for _THREAD_LAST_SYSCALL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_LAST_SYSCALL_INFORMATION = _THREAD_LAST_SYSCALL_INFORMATION;
pub type PTHREAD_LAST_SYSCALL_INFORMATION = *mut _THREAD_LAST_SYSCALL_INFORMATION;
#[doc = "The THREAD_CYCLE_TIME_INFORMATION structure contains information about the cycle time of a thread."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THREAD_CYCLE_TIME_INFORMATION {
   pub AccumulatedCycles: ULONGLONG,
   pub CurrentCycleCount: ULONGLONG,
}
#[doc = "The THREAD_CYCLE_TIME_INFORMATION structure contains information about the cycle time of a thread."]
pub type THREAD_CYCLE_TIME_INFORMATION = _THREAD_CYCLE_TIME_INFORMATION;
#[doc = "The THREAD_CYCLE_TIME_INFORMATION structure contains information about the cycle time of a thread."]
pub type PTHREAD_CYCLE_TIME_INFORMATION = *mut _THREAD_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THREAD_LOCK_OWNERSHIP {
   pub SrwLock: [ULONG; 1usize],
}
pub type THREAD_LOCK_OWNERSHIP = _THREAD_LOCK_OWNERSHIP;
pub type PTHREAD_LOCK_OWNERSHIP = *mut _THREAD_LOCK_OWNERSHIP;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCHEDULER_SHARED_DATA_SLOT_ACTION {
   SchedulerSharedSlotAssign = 0,
   SchedulerSharedSlotFree = 1,
   SchedulerSharedSlotQuery = 2,
}
pub use self::_SCHEDULER_SHARED_DATA_SLOT_ACTION as SCHEDULER_SHARED_DATA_SLOT_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCHEDULER_SHARED_DATA_SLOT_INFORMATION {
   pub Action: SCHEDULER_SHARED_DATA_SLOT_ACTION,
   pub SchedulerSharedDataHandle: PVOID,
   pub Slot: PVOID,
}
impl Default for _SCHEDULER_SHARED_DATA_SLOT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SCHEDULER_SHARED_DATA_SLOT_INFORMATION = _SCHEDULER_SHARED_DATA_SLOT_INFORMATION;
pub type PSCHEDULER_SHARED_DATA_SLOT_INFORMATION = *mut _SCHEDULER_SHARED_DATA_SLOT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_TEB_INFORMATION {
   pub TebInformation: PVOID,
   pub TebOffset: ULONG,
   pub BytesToRead: ULONG,
}
impl Default for _THREAD_TEB_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_TEB_INFORMATION = _THREAD_TEB_INFORMATION;
pub type PTHREAD_TEB_INFORMATION = *mut _THREAD_TEB_INFORMATION;
#[doc = "The COUNTER_READING structure is used to store individual counter data from a hardware counter.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-hardware_counter_data](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-hardware_counter_data)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COUNTER_READING {
   pub Type: HARDWARE_COUNTER_TYPE,
   pub Index: ULONG,
   pub Start: ULONG64,
   pub Total: ULONG64,
}
impl Default for _COUNTER_READING {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The COUNTER_READING structure is used to store individual counter data from a hardware counter.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-hardware_counter_data](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-hardware_counter_data)"]
pub type COUNTER_READING = _COUNTER_READING;
#[doc = "The COUNTER_READING structure is used to store individual counter data from a hardware counter.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-hardware_counter_data](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-hardware_counter_data)"]
pub type PCOUNTER_READING = *mut _COUNTER_READING;
#[doc = "The THREAD_PERFORMANCE_DATA structure aggregates various performance metrics for a thread.\n> https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-performance_data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_PERFORMANCE_DATA {
   pub Size: USHORT,
   pub Version: USHORT,
   pub ProcessorNumber: PROCESSOR_NUMBER,
   pub ContextSwitches: ULONG,
   pub HwCountersCount: ULONG,
   pub UpdateCount: ULONG64,
   pub WaitReasonBitMap: ULONG64,
   pub HardwareCounters: ULONG64,
   pub CycleTime: COUNTER_READING,
   pub HwCounters: [COUNTER_READING; 16usize],
}
impl Default for _THREAD_PERFORMANCE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The THREAD_PERFORMANCE_DATA structure aggregates various performance metrics for a thread.\n> https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-performance_data"]
pub type THREAD_PERFORMANCE_DATA = _THREAD_PERFORMANCE_DATA;
#[doc = "The THREAD_PERFORMANCE_DATA structure aggregates various performance metrics for a thread.\n> https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-performance_data"]
pub type PTHREAD_PERFORMANCE_DATA = *mut _THREAD_PERFORMANCE_DATA;
#[doc = "The THREAD_PROFILING_INFORMATION structure contains profiling information and references to performance data.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readthreadprofilingdata](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readthreadprofilingdata)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_PROFILING_INFORMATION {
   pub HardwareCounters: ULONG64,
   pub Flags: ULONG,
   pub Enable: ULONG,
   pub PerformanceData: PTHREAD_PERFORMANCE_DATA,
}
impl Default for _THREAD_PROFILING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The THREAD_PROFILING_INFORMATION structure contains profiling information and references to performance data.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readthreadprofilingdata](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readthreadprofilingdata)"]
pub type THREAD_PROFILING_INFORMATION = _THREAD_PROFILING_INFORMATION;
#[doc = "The THREAD_PROFILING_INFORMATION structure contains profiling information and references to performance data.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readthreadprofilingdata](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readthreadprofilingdata)"]
pub type PTHREAD_PROFILING_INFORMATION = *mut _THREAD_PROFILING_INFORMATION;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _RTL_UMS_CONTEXT {
   pub Link: SINGLE_LIST_ENTRY,
   pub __bindgen_padding_0: u64,
   pub Context: CONTEXT,
   pub Teb: PVOID,
   pub UserContext: PVOID,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub Flags: LONG,
   pub _bitfield_align_2: [u64; 0],
   pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
   pub ContextLock: ULONG64,
   pub PrimaryUmsContext: *mut _RTL_UMS_CONTEXT,
   pub SwitchCount: ULONG,
   pub KernelYieldCount: ULONG,
   pub MixedYieldCount: ULONG,
   pub YieldCount: ULONG,
}
impl Default for _RTL_UMS_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _RTL_UMS_CONTEXT {
   #[inline]
   pub fn ScheduledThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ScheduledThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ScheduledThread_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ScheduledThread_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Suspended(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Suspended(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Suspended_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Suspended_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VolatileContext(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VolatileContext(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VolatileContext_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VolatileContext_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Terminated(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Terminated(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Terminated_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Terminated_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DebugActive(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DebugActive(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DebugActive_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DebugActive_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RunningOnSelfThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RunningOnSelfThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RunningOnSelfThread_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RunningOnSelfThread_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DenyRunningOnSelfThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DenyRunningOnSelfThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DenyRunningOnSelfThread_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DenyRunningOnSelfThread_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ScheduledThread: ULONG,
      Suspended: ULONG,
      VolatileContext: ULONG,
      Terminated: ULONG,
      DebugActive: ULONG,
      RunningOnSelfThread: ULONG,
      DenyRunningOnSelfThread: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ScheduledThread: u32 = unsafe { ::core::mem::transmute(ScheduledThread) };
         ScheduledThread as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Suspended: u32 = unsafe { ::core::mem::transmute(Suspended) };
         Suspended as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let VolatileContext: u32 = unsafe { ::core::mem::transmute(VolatileContext) };
         VolatileContext as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let Terminated: u32 = unsafe { ::core::mem::transmute(Terminated) };
         Terminated as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let DebugActive: u32 = unsafe { ::core::mem::transmute(DebugActive) };
         DebugActive as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let RunningOnSelfThread: u32 = unsafe { ::core::mem::transmute(RunningOnSelfThread) };
         RunningOnSelfThread as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let DenyRunningOnSelfThread: u32 =
            unsafe { ::core::mem::transmute(DenyRunningOnSelfThread) };
         DenyRunningOnSelfThread as u64
      });
      __bindgen_bitfield_unit
   }
   #[inline]
   pub fn KernelUpdateLock(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_KernelUpdateLock(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_2.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KernelUpdateLock_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_2),
            0usize,
            2u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_KernelUpdateLock_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_2),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PrimaryClientID(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 62u8) as u64) }
   }
   #[inline]
   pub fn set_PrimaryClientID(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_2.set(2usize, 62u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PrimaryClientID_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_2),
            2usize,
            62u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_PrimaryClientID_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_2),
            2usize,
            62u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_2(
      KernelUpdateLock: ULONG64,
      PrimaryClientID: ULONG64,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let KernelUpdateLock: u64 = unsafe { ::core::mem::transmute(KernelUpdateLock) };
         KernelUpdateLock as u64
      });
      __bindgen_bitfield_unit.set(2usize, 62u8, {
         let PrimaryClientID: u64 = unsafe { ::core::mem::transmute(PrimaryClientID) };
         PrimaryClientID as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type RTL_UMS_CONTEXT = _RTL_UMS_CONTEXT;
pub type PRTL_UMS_CONTEXT = *mut _RTL_UMS_CONTEXT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREAD_UMS_INFORMATION_COMMAND {
   UmsInformationCommandInvalid = 0,
   UmsInformationCommandAttach = 1,
   UmsInformationCommandDetach = 2,
   UmsInformationCommandQuery = 3,
}
pub use self::_THREAD_UMS_INFORMATION_COMMAND as THREAD_UMS_INFORMATION_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_UMS_COMPLETION_LIST {
   pub ThreadListHead: PSINGLE_LIST_ENTRY,
   pub CompletionEvent: PVOID,
   pub CompletionFlags: ULONG,
   pub InternalListHead: SINGLE_LIST_ENTRY,
}
impl Default for _RTL_UMS_COMPLETION_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_UMS_COMPLETION_LIST = _RTL_UMS_COMPLETION_LIST;
pub type PRTL_UMS_COMPLETION_LIST = *mut _RTL_UMS_COMPLETION_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _THREAD_UMS_INFORMATION {
   pub Command: THREAD_UMS_INFORMATION_COMMAND,
   pub CompletionList: PRTL_UMS_COMPLETION_LIST,
   pub UmsContext: PRTL_UMS_CONTEXT,
   pub __bindgen_anon_1: _THREAD_UMS_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _THREAD_UMS_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _THREAD_UMS_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THREAD_UMS_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _THREAD_UMS_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn IsUmsSchedulerThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsUmsSchedulerThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsUmsSchedulerThread_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsUmsSchedulerThread_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsUmsWorkerThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsUmsWorkerThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsUmsWorkerThread_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsUmsWorkerThread_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_SpareBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareBits_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpareBits_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsUmsSchedulerThread: ULONG,
      IsUmsWorkerThread: ULONG,
      SpareBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsUmsSchedulerThread: u32 = unsafe { ::core::mem::transmute(IsUmsSchedulerThread) };
         IsUmsSchedulerThread as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsUmsWorkerThread: u32 = unsafe { ::core::mem::transmute(IsUmsWorkerThread) };
         IsUmsWorkerThread as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let SpareBits: u32 = unsafe { ::core::mem::transmute(SpareBits) };
         SpareBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _THREAD_UMS_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _THREAD_UMS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type THREAD_UMS_INFORMATION = _THREAD_UMS_INFORMATION;
pub type PTHREAD_UMS_INFORMATION = *mut _THREAD_UMS_INFORMATION;
#[doc = "The THREAD_NAME_INFORMATION structure assigns a description to a thread.\n> The handle must have THREAD_SET_LIMITED_INFORMATION access.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreaddescription"]
#[repr(C)]
pub struct _THREAD_NAME_INFORMATION {
   pub ThreadName: UNICODE_STRING,
}
impl Default for _THREAD_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The THREAD_NAME_INFORMATION structure assigns a description to a thread.\n> The handle must have THREAD_SET_LIMITED_INFORMATION access.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreaddescription"]
pub type THREAD_NAME_INFORMATION = _THREAD_NAME_INFORMATION;
#[doc = "The THREAD_NAME_INFORMATION structure assigns a description to a thread.\n> The handle must have THREAD_SET_LIMITED_INFORMATION access.\n> https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreaddescription"]
pub type PTHREAD_NAME_INFORMATION = *mut _THREAD_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_WORK_ON_BEHALF_TICKET {
   pub ThreadId: ULONG,
   pub ThreadCreationTimeLow: ULONG,
}
pub type ALPC_WORK_ON_BEHALF_TICKET = _ALPC_WORK_ON_BEHALF_TICKET;
pub type PALPC_WORK_ON_BEHALF_TICKET = *mut _ALPC_WORK_ON_BEHALF_TICKET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_WORK_ON_BEHALF_TICKET_EX {
   pub Ticket: ALPC_WORK_ON_BEHALF_TICKET,
   pub __bindgen_anon_1: _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1,
   pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn CurrentThread(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CurrentThread(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CurrentThread_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CurrentThread_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      CurrentThread: ULONG,
      Reserved1: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let CurrentThread: u32 = unsafe { ::core::mem::transmute(CurrentThread) };
         CurrentThread as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_WORK_ON_BEHALF_TICKET_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_WORK_ON_BEHALF_TICKET_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_WORK_ON_BEHALF_TICKET_EX = _RTL_WORK_ON_BEHALF_TICKET_EX;
pub type PRTL_WORK_ON_BEHALF_TICKET_EX = *mut _RTL_WORK_ON_BEHALF_TICKET_EX;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SUBSYSTEM_INFORMATION_TYPE {
   SubsystemInformationTypeWin32 = 0,
   SubsystemInformationTypeWSL = 1,
   MaxSubsystemInformationType = 2,
}
pub use self::_SUBSYSTEM_INFORMATION_TYPE as SUBSYSTEM_INFORMATION_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREAD_WORKLOAD_CLASS {
   ThreadWorkloadClassDefault = 0,
   ThreadWorkloadClassGraphics = 1,
   MaxThreadWorkloadClass = 2,
}
pub use self::_THREAD_WORKLOAD_CLASS as THREAD_WORKLOAD_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ARM_NT_NEON128 {
   pub Low: ULONGLONG,
   pub High: LONGLONG,
}
pub type ARM_NT_NEON128 = _ARM_NT_NEON128;
pub type PARM_NT_NEON128 = *mut _ARM_NT_NEON128;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ARM_NT_CONTEXT {
   pub ContextFlags: DWORD,
   pub R0: DWORD,
   pub R1: DWORD,
   pub R2: DWORD,
   pub R3: DWORD,
   pub R4: DWORD,
   pub R5: DWORD,
   pub R6: DWORD,
   pub R7: DWORD,
   pub R8: DWORD,
   pub R9: DWORD,
   pub R10: DWORD,
   pub R11: DWORD,
   pub R12: DWORD,
   pub Sp: DWORD,
   pub Lr: DWORD,
   pub Pc: DWORD,
   pub Cpsr: DWORD,
   pub Fpscr: DWORD,
   pub Padding: DWORD,
   pub __bindgen_anon_1: _ARM_NT_CONTEXT__bindgen_ty_1,
   pub Bvr: [DWORD; 8usize],
   pub Bcr: [DWORD; 8usize],
   pub Wvr: [DWORD; 1usize],
   pub Wcr: [DWORD; 1usize],
   pub Padding2: [DWORD; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARM_NT_CONTEXT__bindgen_ty_1 {
   pub Q: [ARM_NT_NEON128; 16usize],
   pub D: [ULONGLONG; 32usize],
   pub S: [DWORD; 32usize],
}
impl Default for _ARM_NT_CONTEXT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ARM_NT_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ARM_NT_CONTEXT = _ARM_NT_CONTEXT;
pub type PARM_NT_CONTEXT = *mut _ARM_NT_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _THREAD_INDEX_INFORMATION {
   pub Index: ULONG,
   pub Sequence: ULONG,
}
pub type THREAD_INDEX_INFORMATION = _THREAD_INDEX_INFORMATION;
pub type PTHREAD_INDEX_INFORMATION = *mut _THREAD_INDEX_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_STATE_CHANGE_TYPE {
   ProcessStateChangeSuspend = 0,
   ProcessStateChangeResume = 1,
   ProcessStateChangeMax = 2,
}
pub use self::_PROCESS_STATE_CHANGE_TYPE as PROCESS_STATE_CHANGE_TYPE;
pub type PPROCESS_STATE_CHANGE_TYPE = *mut _PROCESS_STATE_CHANGE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREAD_STATE_CHANGE_TYPE {
   ThreadStateChangeSuspend = 0,
   ThreadStateChangeResume = 1,
   ThreadStateChangeMax = 2,
}
pub use self::_THREAD_STATE_CHANGE_TYPE as THREAD_STATE_CHANGE_TYPE;
pub type PTHREAD_STATE_CHANGE_TYPE = *mut _THREAD_STATE_CHANGE_TYPE;
#[doc = "A pointer to a function that serves as an APC routine.\n# Arguments\n\n* `ApcArgument1` - Optional. A pointer to the first argument to be passed to the APC routine.\n* `ApcArgument2` - Optional. A pointer to the second argument to be passed to the APC routine.\n* `ApcArgument3` - Optional. A pointer to the third argument to be passed to the APC routine."]
pub type PPS_APC_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(ApcArgument1: PVOID, ApcArgument2: PVOID, ApcArgument3: PVOID),
>;
#[doc = "The APC_CALLBACK_DATA_CONTEXT structure is used to pass information to the APC callback routine."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _APC_CALLBACK_DATA_CONTEXT {
   pub Parameter: ULONG_PTR,
   pub ContextRecord: PCONTEXT,
   pub Reserved0: ULONG_PTR,
   pub Reserved1: ULONG_PTR,
}
impl Default for _APC_CALLBACK_DATA_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The APC_CALLBACK_DATA_CONTEXT structure is used to pass information to the APC callback routine."]
pub type APC_CALLBACK_DATA_CONTEXT = _APC_CALLBACK_DATA_CONTEXT;
#[doc = "The APC_CALLBACK_DATA_CONTEXT structure is used to pass information to the APC callback routine."]
pub type PAPC_CALLBACK_DATA_CONTEXT = *mut _APC_CALLBACK_DATA_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROC_THREAD_ATTRIBUTE {
   pub Attribute: ULONG_PTR,
   pub Size: SIZE_T,
   pub Value: ULONG_PTR,
}
pub type PROC_THREAD_ATTRIBUTE = _PROC_THREAD_ATTRIBUTE;
pub type PPROC_THREAD_ATTRIBUTE = *mut _PROC_THREAD_ATTRIBUTE;
#[doc = "The PROC_THREAD_ATTRIBUTE_LIST structure contains the list of attributes for process and thread creation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_THREAD_ATTRIBUTE_LIST {
   pub PresentFlags: ULONG,
   pub AttributeCount: ULONG,
   pub LastAttribute: ULONG,
   pub SpareUlong0: ULONG,
   pub ExtendedFlagsAttribute: PPROC_THREAD_ATTRIBUTE,
   pub Attributes: [PROC_THREAD_ATTRIBUTE; 1usize],
}
impl Default for _PROC_THREAD_ATTRIBUTE_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The PROC_THREAD_ATTRIBUTE_LIST structure contains the list of attributes for process and thread creation."]
pub type PROC_THREAD_ATTRIBUTE_LIST = _PROC_THREAD_ATTRIBUTE_LIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS {
   SeSafeOpenExperienceNone = 0,
   SeSafeOpenExperienceCalled = 1,
   SeSafeOpenExperienceAppRepCalled = 2,
   SeSafeOpenExperiencePromptDisplayed = 4,
   SeSafeOpenExperienceUAC = 8,
   SeSafeOpenExperienceUninstaller = 16,
   SeSafeOpenExperienceIgnoreUnknownOrBad = 32,
   SeSafeOpenExperienceDefenderTrustedInstaller = 64,
   SeSafeOpenExperienceMOTWPresent = 128,
   SeSafeOpenExperienceElevatedNoPropagation = 256,
}
pub use self::_SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS as SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_SAFE_OPEN_PROMPT_RESULTS {
   pub Results: SE_SAFE_OPEN_PROMPT_EXPERIENCE_RESULTS,
   pub Path: [WCHAR; 260usize],
}
impl Default for _SE_SAFE_OPEN_PROMPT_RESULTS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SE_SAFE_OPEN_PROMPT_RESULTS = _SE_SAFE_OPEN_PROMPT_RESULTS;
pub type PSE_SAFE_OPEN_PROMPT_RESULTS = *mut _SE_SAFE_OPEN_PROMPT_RESULTS;
#[repr(C)]
pub struct _PROC_THREAD_BNOISOLATION_ATTRIBUTE {
   pub IsolationEnabled: BOOL,
   pub IsolationPrefix: [WCHAR; 136usize],
}
impl Default for _PROC_THREAD_BNOISOLATION_ATTRIBUTE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PROC_THREAD_BNOISOLATION_ATTRIBUTE = _PROC_THREAD_BNOISOLATION_ATTRIBUTE;
pub type PPROC_THREAD_BNOISOLATION_ATTRIBUTE = *mut _PROC_THREAD_BNOISOLATION_ATTRIBUTE;
#[repr(C)]
pub struct _ISOLATION_MANIFEST_PROPERTIES {
   pub InstancePath: UNICODE_STRING,
   pub FriendlyName: UNICODE_STRING,
   pub Description: UNICODE_STRING,
   pub Level: ULONG_PTR,
}
impl Default for _ISOLATION_MANIFEST_PROPERTIES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ISOLATION_MANIFEST_PROPERTIES = _ISOLATION_MANIFEST_PROPERTIES;
pub type PISOLATION_MANIFEST_PROPERTIES = *mut _ISOLATION_MANIFEST_PROPERTIES;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_ATTRIBUTE_NUM {
   PsAttributeParentProcess = 0,
   PsAttributeDebugObject = 1,
   PsAttributeToken = 2,
   PsAttributeClientId = 3,
   PsAttributeTebAddress = 4,
   PsAttributeImageName = 5,
   PsAttributeImageInfo = 6,
   PsAttributeMemoryReserve = 7,
   PsAttributePriorityClass = 8,
   PsAttributeErrorMode = 9,
   PsAttributeStdHandleInfo = 10,
   PsAttributeHandleList = 11,
   PsAttributeGroupAffinity = 12,
   PsAttributePreferredNode = 13,
   PsAttributeIdealProcessor = 14,
   PsAttributeUmsThread = 15,
   PsAttributeMitigationOptions = 16,
   PsAttributeProtectionLevel = 17,
   PsAttributeSecureProcess = 18,
   PsAttributeJobList = 19,
   PsAttributeChildProcessPolicy = 20,
   PsAttributeAllApplicationPackagesPolicy = 21,
   PsAttributeWin32kFilter = 22,
   PsAttributeSafeOpenPromptOriginClaim = 23,
   PsAttributeBnoIsolation = 24,
   PsAttributeDesktopAppPolicy = 25,
   PsAttributeChpe = 26,
   PsAttributeMitigationAuditOptions = 27,
   PsAttributeMachineType = 28,
   PsAttributeComponentFilter = 29,
   PsAttributeEnableOptionalXStateFeatures = 30,
   PsAttributeSupportedMachines = 31,
   PsAttributeSveVectorLength = 32,
   PsAttributeMax = 33,
}
pub use self::_PS_ATTRIBUTE_NUM as PS_ATTRIBUTE_NUM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_ATTRIBUTE {
   pub Attribute: ULONG_PTR,
   pub Size: SIZE_T,
   pub __bindgen_anon_1: _PS_ATTRIBUTE__bindgen_ty_1,
   pub ReturnLength: PSIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_ATTRIBUTE__bindgen_ty_1 {
   pub Value: ULONG_PTR,
   pub ValuePtr: PVOID,
}
impl Default for _PS_ATTRIBUTE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_ATTRIBUTE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_ATTRIBUTE = _PS_ATTRIBUTE;
pub type PPS_ATTRIBUTE = *mut _PS_ATTRIBUTE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_ATTRIBUTE_LIST {
   pub TotalLength: SIZE_T,
   pub Attributes: [PS_ATTRIBUTE; 1usize],
}
impl Default for _PS_ATTRIBUTE_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_ATTRIBUTE_LIST = _PS_ATTRIBUTE_LIST;
pub type PPS_ATTRIBUTE_LIST = *mut _PS_ATTRIBUTE_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_MEMORY_RESERVE {
   pub ReserveAddress: PVOID,
   pub ReserveSize: SIZE_T,
}
impl Default for _PS_MEMORY_RESERVE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_MEMORY_RESERVE = _PS_MEMORY_RESERVE;
pub type PPS_MEMORY_RESERVE = *mut _PS_MEMORY_RESERVE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_STD_HANDLE_STATE {
   PsNeverDuplicate = 0,
   PsRequestDuplicate = 1,
   PsAlwaysDuplicate = 2,
   PsMaxStdHandleStates = 3,
}
pub use self::_PS_STD_HANDLE_STATE as PS_STD_HANDLE_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_STD_HANDLE_INFO {
   pub __bindgen_anon_1: _PS_STD_HANDLE_INFO__bindgen_ty_1,
   pub StdHandleSubsystemType: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_STD_HANDLE_INFO__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PS_STD_HANDLE_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_STD_HANDLE_INFO__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _PS_STD_HANDLE_INFO__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn StdHandleState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_StdHandleState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StdHandleState_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StdHandleState_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PseudoHandleMask(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
   }
   #[inline]
   pub fn set_PseudoHandleMask(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PseudoHandleMask_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            3u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PseudoHandleMask_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      StdHandleState: ULONG,
      PseudoHandleMask: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let StdHandleState: u32 = unsafe { ::core::mem::transmute(StdHandleState) };
         StdHandleState as u64
      });
      __bindgen_bitfield_unit.set(2usize, 3u8, {
         let PseudoHandleMask: u32 = unsafe { ::core::mem::transmute(PseudoHandleMask) };
         PseudoHandleMask as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_STD_HANDLE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_STD_HANDLE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_STD_HANDLE_INFO = _PS_STD_HANDLE_INFO;
pub type PPS_STD_HANDLE_INFO = *mut _PS_STD_HANDLE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub AccessRights: UCHAR,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS {
   #[inline]
   pub fn Trustlet(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Trustlet(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Trustlet_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Trustlet_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Ntos(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Ntos(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Ntos_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Ntos_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn WriteHandle(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WriteHandle(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn WriteHandle_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_WriteHandle_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReadHandle(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ReadHandle(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReadHandle_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ReadHandle_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            4u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Trustlet: UCHAR,
      Ntos: UCHAR,
      WriteHandle: UCHAR,
      ReadHandle: UCHAR,
      Reserved: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Trustlet: u8 = unsafe { ::core::mem::transmute(Trustlet) };
         Trustlet as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let Ntos: u8 = unsafe { ::core::mem::transmute(Ntos) };
         Ntos as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let WriteHandle: u8 = unsafe { ::core::mem::transmute(WriteHandle) };
         WriteHandle as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ReadHandle: u8 = unsafe { ::core::mem::transmute(ReadHandle) };
         ReadHandle as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS = _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS;
pub type PPS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS = *mut _PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_TYPE {
   pub __bindgen_anon_1: _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1 {
   pub __bindgen_anon_1: _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1,
   pub AttributeType: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1 {
   pub Version: UCHAR,
   pub DataCount: UCHAR,
   pub SemanticType: UCHAR,
   pub AccessRights: PS_TRUSTLET_ATTRIBUTE_ACCESSRIGHTS,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_TYPE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_TRUSTLET_ATTRIBUTE_TYPE = _PS_TRUSTLET_ATTRIBUTE_TYPE;
pub type PPS_TRUSTLET_ATTRIBUTE_TYPE = *mut _PS_TRUSTLET_ATTRIBUTE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_HEADER {
   pub AttributeType: PS_TRUSTLET_ATTRIBUTE_TYPE,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PS_TRUSTLET_ATTRIBUTE_HEADER {
   #[inline]
   pub fn InstanceNumber(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_InstanceNumber(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InstanceNumber_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InstanceNumber_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      InstanceNumber: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let InstanceNumber: u32 = unsafe { ::core::mem::transmute(InstanceNumber) };
         InstanceNumber as u64
      });
      __bindgen_bitfield_unit.set(8usize, 24u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PS_TRUSTLET_ATTRIBUTE_HEADER = _PS_TRUSTLET_ATTRIBUTE_HEADER;
pub type PPS_TRUSTLET_ATTRIBUTE_HEADER = *mut _PS_TRUSTLET_ATTRIBUTE_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_ATTRIBUTE_DATA {
   pub Header: PS_TRUSTLET_ATTRIBUTE_HEADER,
   pub Data: [ULONGLONG; 1usize],
}
impl Default for _PS_TRUSTLET_ATTRIBUTE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_TRUSTLET_ATTRIBUTE_DATA = _PS_TRUSTLET_ATTRIBUTE_DATA;
pub type PPS_TRUSTLET_ATTRIBUTE_DATA = *mut _PS_TRUSTLET_ATTRIBUTE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_TRUSTLET_CREATE_ATTRIBUTES {
   pub TrustletIdentity: ULONGLONG,
   pub Attributes: [PS_TRUSTLET_ATTRIBUTE_DATA; 1usize],
}
impl Default for _PS_TRUSTLET_CREATE_ATTRIBUTES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_TRUSTLET_CREATE_ATTRIBUTES = _PS_TRUSTLET_CREATE_ATTRIBUTES;
pub type PPS_TRUSTLET_CREATE_ATTRIBUTES = *mut _PS_TRUSTLET_CREATE_ATTRIBUTES;
#[repr(C)]
pub struct _PS_BNO_ISOLATION_PARAMETERS {
   pub IsolationPrefix: UNICODE_STRING,
   pub HandleCount: ULONG,
   pub Handles: *mut PVOID,
   pub IsolationEnabled: BOOLEAN,
}
impl Default for _PS_BNO_ISOLATION_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_BNO_ISOLATION_PARAMETERS = _PS_BNO_ISOLATION_PARAMETERS;
pub type PPS_BNO_ISOLATION_PARAMETERS = *mut _PS_BNO_ISOLATION_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_PROCESS_CREATION_SVE_VECTOR_LENGTH {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for _PS_PROCESS_CREATION_SVE_VECTOR_LENGTH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PS_PROCESS_CREATION_SVE_VECTOR_LENGTH {
   #[inline]
   pub fn VectorLength(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
   }
   #[inline]
   pub fn set_VectorLength(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VectorLength_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            24u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VectorLength_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FlagsReserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_FlagsReserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FlagsReserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FlagsReserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      VectorLength: ULONG,
      FlagsReserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 24u8, {
         let VectorLength: u32 = unsafe { ::core::mem::transmute(VectorLength) };
         VectorLength as u64
      });
      __bindgen_bitfield_unit.set(24usize, 8u8, {
         let FlagsReserved: u32 = unsafe { ::core::mem::transmute(FlagsReserved) };
         FlagsReserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PS_PROCESS_CREATION_SVE_VECTOR_LENGTH = _PS_PROCESS_CREATION_SVE_VECTOR_LENGTH;
pub type PPS_PROCESS_CREATION_SVE_VECTOR_LENGTH = *mut _PS_PROCESS_CREATION_SVE_VECTOR_LENGTH;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_MITIGATION_OPTION {
   PS_MITIGATION_OPTION_NX = 0,
   PS_MITIGATION_OPTION_SEHOP = 1,
   PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES = 2,
   PS_MITIGATION_OPTION_HEAP_TERMINATE = 3,
   PS_MITIGATION_OPTION_BOTTOM_UP_ASLR = 4,
   PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR = 5,
   PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS = 6,
   PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE = 7,
   PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE = 8,
   PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE = 9,
   PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD = 10,
   PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES = 11,
   PS_MITIGATION_OPTION_FONT_DISABLE = 12,
   PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE = 13,
   PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL = 14,
   PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32 = 15,
   PS_MITIGATION_OPTION_RETURN_FLOW_GUARD = 16,
   PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY = 17,
   PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD = 18,
   PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT = 19,
   PS_MITIGATION_OPTION_ROP_STACKPIVOT = 20,
   PS_MITIGATION_OPTION_ROP_CALLER_CHECK = 21,
   PS_MITIGATION_OPTION_ROP_SIMEXEC = 22,
   PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER = 23,
   PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS = 24,
   PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION = 25,
   PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER = 26,
   PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION = 27,
   PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION = 28,
   PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE = 29,
   PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY = 30,
   PS_MITIGATION_OPTION_CET_USER_SHADOW_STACKS = 31,
   PS_MITIGATION_OPTION_USER_CET_SET_CONTEXT_IP_VALIDATION = 32,
   PS_MITIGATION_OPTION_BLOCK_NON_CET_BINARIES = 33,
   PS_MITIGATION_OPTION_CET_DYNAMIC_APIS_OUT_OF_PROC_ONLY = 34,
   PS_MITIGATION_OPTION_REDIRECTION_TRUST = 35,
   PS_MITIGATION_OPTION_RESTRICT_CORE_SHARING = 36,
   PS_MITIGATION_OPTION_FSCTL_SYSTEM_CALL_DISABLE = 37,
}
pub use self::_PS_MITIGATION_OPTION as PS_MITIGATION_OPTION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PS_CREATE_STATE {
   PsCreateInitialState = 0,
   PsCreateFailOnFileOpen = 1,
   PsCreateFailOnSectionCreate = 2,
   PsCreateFailExeFormat = 3,
   PsCreateFailMachineMismatch = 4,
   PsCreateFailExeName = 5,
   PsCreateSuccess = 6,
   PsCreateMaximumStates = 7,
}
pub use self::_PS_CREATE_STATE as PS_CREATE_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_CREATE_INFO {
   pub Size: SIZE_T,
   pub State: PS_CREATE_STATE,
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CREATE_INFO__bindgen_ty_1 {
   pub InitState: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1,
   pub FailSection: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_2,
   pub ExeFormat: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_3,
   pub ExeName: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_4,
   pub SuccessState: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1 {
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
   pub AdditionalFileAccess: ACCESS_MASK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
   pub InitFlags: ULONG,
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn WriteOutputOnExit(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WriteOutputOnExit(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn WriteOutputOnExit_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_WriteOutputOnExit_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DetectManifest(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DetectManifest(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DetectManifest_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_DetectManifest_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IFEOSkipDebugger(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IFEOSkipDebugger(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IFEOSkipDebugger_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IFEOSkipDebugger_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IFEODoNotPropagateKeyState(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IFEODoNotPropagateKeyState(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IFEODoNotPropagateKeyState_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IFEODoNotPropagateKeyState_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareBits1(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_SpareBits1(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareBits1_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            4u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SpareBits1_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareBits2(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
   }
   #[inline]
   pub fn set_SpareBits2(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareBits2_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            8u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SpareBits2_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProhibitedImageCharacteristics(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u16) }
   }
   #[inline]
   pub fn set_ProhibitedImageCharacteristics(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProhibitedImageCharacteristics_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            16u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_ProhibitedImageCharacteristics_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      WriteOutputOnExit: UCHAR,
      DetectManifest: UCHAR,
      IFEOSkipDebugger: UCHAR,
      IFEODoNotPropagateKeyState: UCHAR,
      SpareBits1: UCHAR,
      SpareBits2: UCHAR,
      ProhibitedImageCharacteristics: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let WriteOutputOnExit: u8 = unsafe { ::core::mem::transmute(WriteOutputOnExit) };
         WriteOutputOnExit as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DetectManifest: u8 = unsafe { ::core::mem::transmute(DetectManifest) };
         DetectManifest as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IFEOSkipDebugger: u8 = unsafe { ::core::mem::transmute(IFEOSkipDebugger) };
         IFEOSkipDebugger as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let IFEODoNotPropagateKeyState: u8 =
            unsafe { ::core::mem::transmute(IFEODoNotPropagateKeyState) };
         IFEODoNotPropagateKeyState as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let SpareBits1: u8 = unsafe { ::core::mem::transmute(SpareBits1) };
         SpareBits1 as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let SpareBits2: u8 = unsafe { ::core::mem::transmute(SpareBits2) };
         SpareBits2 as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let ProhibitedImageCharacteristics: u16 =
            unsafe { ::core::mem::transmute(ProhibitedImageCharacteristics) };
         ProhibitedImageCharacteristics as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_2 {
   pub FileHandle: HANDLE,
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_3 {
   pub DllCharacteristics: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_4 {
   pub IFEOKey: HANDLE,
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5 {
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
   pub FileHandle: HANDLE,
   pub SectionHandle: HANDLE,
   pub UserProcessParametersNative: ULONGLONG,
   pub UserProcessParametersWow64: ULONG,
   pub CurrentParameterFlags: ULONG,
   pub PebAddressNative: ULONGLONG,
   pub PebAddressWow64: ULONG,
   pub ManifestAddress: ULONGLONG,
   pub ManifestSize: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
   pub OutputFlags: ULONG,
   pub __bindgen_anon_1: _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ProtectedProcess(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ProtectedProcess(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProtectedProcess_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ProtectedProcess_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AddressSpaceOverride(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_AddressSpaceOverride(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddressSpaceOverride_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_AddressSpaceOverride_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DevOverrideEnabled(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DevOverrideEnabled(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DevOverrideEnabled_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_DevOverrideEnabled_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ManifestDetected(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ManifestDetected(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ManifestDetected_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ManifestDetected_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProtectedProcessLight(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ProtectedProcessLight(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProtectedProcessLight_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ProtectedProcessLight_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareBits1(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
   }
   #[inline]
   pub fn set_SpareBits1(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareBits1_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            3u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SpareBits1_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareBits2(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
   }
   #[inline]
   pub fn set_SpareBits2(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareBits2_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            8u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SpareBits2_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareBits3(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u16) }
   }
   #[inline]
   pub fn set_SpareBits3(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareBits3_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            16u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SpareBits3_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ProtectedProcess: UCHAR,
      AddressSpaceOverride: UCHAR,
      DevOverrideEnabled: UCHAR,
      ManifestDetected: UCHAR,
      ProtectedProcessLight: UCHAR,
      SpareBits1: UCHAR,
      SpareBits2: UCHAR,
      SpareBits3: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ProtectedProcess: u8 = unsafe { ::core::mem::transmute(ProtectedProcess) };
         ProtectedProcess as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let AddressSpaceOverride: u8 = unsafe { ::core::mem::transmute(AddressSpaceOverride) };
         AddressSpaceOverride as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let DevOverrideEnabled: u8 = unsafe { ::core::mem::transmute(DevOverrideEnabled) };
         DevOverrideEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ManifestDetected: u8 = unsafe { ::core::mem::transmute(ManifestDetected) };
         ManifestDetected as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let ProtectedProcessLight: u8 = unsafe { ::core::mem::transmute(ProtectedProcessLight) };
         ProtectedProcessLight as u64
      });
      __bindgen_bitfield_unit.set(5usize, 3u8, {
         let SpareBits1: u8 = unsafe { ::core::mem::transmute(SpareBits1) };
         SpareBits1 as u64
      });
      __bindgen_bitfield_unit.set(8usize, 8u8, {
         let SpareBits2: u8 = unsafe { ::core::mem::transmute(SpareBits2) };
         SpareBits2 as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let SpareBits3: u16 = unsafe { ::core::mem::transmute(SpareBits3) };
         SpareBits3 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_CREATE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PS_CREATE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PS_CREATE_INFO = _PS_CREATE_INFO;
pub type PPS_CREATE_INFO = *mut _PS_CREATE_INFO;
#[doc = "A pointer to a user-defined function that serves as the starting routine for a new thread.\n# Arguments\n\n* `ThreadParameter` - A pointer to a variable to be passed to the thread.\n# Returns\n\nNTSTATUS Successful or errant status."]
pub type PUSER_THREAD_START_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(ThreadParameter: PVOID) -> NTSTATUS>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 {
   pub BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
   pub IoInfo: IO_COUNTERS,
   pub ProcessMemoryLimit: SIZE_T,
   pub JobMemoryLimit: SIZE_T,
   pub PeakProcessMemoryUsed: SIZE_T,
   pub PeakJobMemoryUsed: SIZE_T,
   pub JobTotalMemoryLimit: SIZE_T,
}
impl Default for _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 = _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2;
pub type PJOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 = *mut _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION {
   pub BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
   pub IoInfo: IO_COUNTERS,
   pub DiskIoInfo: PROCESS_DISK_COUNTERS,
   pub ContextSwitches: ULONG64,
   pub TotalCycleTime: LARGE_INTEGER,
   pub ReadyTime: ULONG64,
   pub EnergyValues: PROCESS_ENERGY_VALUES,
}
impl Default for _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION = _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION =
   *mut _JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_WAKE_INFORMATION {
   pub NotificationChannel: HANDLE,
   pub WakeCounters: [ULONG64; 7usize],
}
impl Default for _JOBOBJECT_WAKE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_WAKE_INFORMATION = _JOBOBJECT_WAKE_INFORMATION;
pub type PJOBOBJECT_WAKE_INFORMATION = *mut _JOBOBJECT_WAKE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_WAKE_INFORMATION_V1 {
   pub NotificationChannel: HANDLE,
   pub WakeCounters: [ULONG64; 4usize],
}
impl Default for _JOBOBJECT_WAKE_INFORMATION_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_WAKE_INFORMATION_V1 = _JOBOBJECT_WAKE_INFORMATION_V1;
pub type PJOBOBJECT_WAKE_INFORMATION_V1 = *mut _JOBOBJECT_WAKE_INFORMATION_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_INTERFERENCE_INFORMATION {
   pub Count: ULONG64,
}
pub type JOBOBJECT_INTERFERENCE_INFORMATION = _JOBOBJECT_INTERFERENCE_INFORMATION;
pub type PJOBOBJECT_INTERFERENCE_INFORMATION = *mut _JOBOBJECT_INTERFERENCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_WAKE_FILTER {
   pub HighEdgeFilter: ULONG,
   pub LowEdgeFilter: ULONG,
}
pub type JOBOBJECT_WAKE_FILTER = _JOBOBJECT_WAKE_FILTER;
#[repr(C)]
pub struct _JOBOBJECT_FREEZE_INFORMATION {
   pub __bindgen_anon_1: _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1,
   pub Freeze: BOOLEAN,
   pub Swap: BOOLEAN,
   pub Reserved0: [UCHAR; 2usize],
   pub WakeFilter: JOBOBJECT_WAKE_FILTER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn FreezeOperation(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FreezeOperation(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FreezeOperation_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FreezeOperation_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FilterOperation(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FilterOperation(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FilterOperation_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FilterOperation_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SwapOperation(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SwapOperation(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SwapOperation_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SwapOperation_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            29u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            29u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FreezeOperation: ULONG,
      FilterOperation: ULONG,
      SwapOperation: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let FreezeOperation: u32 = unsafe { ::core::mem::transmute(FreezeOperation) };
         FreezeOperation as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let FilterOperation: u32 = unsafe { ::core::mem::transmute(FilterOperation) };
         FilterOperation as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let SwapOperation: u32 = unsafe { ::core::mem::transmute(SwapOperation) };
         SwapOperation as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _JOBOBJECT_FREEZE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _JOBOBJECT_FREEZE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_FREEZE_INFORMATION = _JOBOBJECT_FREEZE_INFORMATION;
pub type PJOBOBJECT_FREEZE_INFORMATION = *mut _JOBOBJECT_FREEZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_CONTAINER_IDENTIFIER_V2 {
   pub ContainerId: GUID,
   pub ContainerTelemetryId: GUID,
   pub JobId: ULONG,
}
pub type JOBOBJECT_CONTAINER_IDENTIFIER_V2 = _JOBOBJECT_CONTAINER_IDENTIFIER_V2;
pub type PJOBOBJECT_CONTAINER_IDENTIFIER_V2 = *mut _JOBOBJECT_CONTAINER_IDENTIFIER_V2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_MEMORY_USAGE_INFORMATION {
   pub JobMemory: ULONG64,
   pub PeakJobMemoryUsed: ULONG64,
}
pub type JOBOBJECT_MEMORY_USAGE_INFORMATION = _JOBOBJECT_MEMORY_USAGE_INFORMATION;
pub type PJOBOBJECT_MEMORY_USAGE_INFORMATION = *mut _JOBOBJECT_MEMORY_USAGE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_MEMORY_USAGE_INFORMATION_V2 {
   pub BasicInfo: JOBOBJECT_MEMORY_USAGE_INFORMATION,
   pub JobSharedMemory: ULONG64,
   pub Reserved: [ULONG64; 2usize],
}
pub type JOBOBJECT_MEMORY_USAGE_INFORMATION_V2 = _JOBOBJECT_MEMORY_USAGE_INFORMATION_V2;
pub type PJOBOBJECT_MEMORY_USAGE_INFORMATION_V2 = *mut _JOBOBJECT_MEMORY_USAGE_INFORMATION_V2;
#[repr(C)]
pub struct _SILO_USER_SHARED_DATA {
   pub ServiceSessionId: ULONG,
   pub ActiveConsoleId: ULONG,
   pub ConsoleSessionForegroundProcessId: LONGLONG,
   pub NtProductType: NT_PRODUCT_TYPE,
   pub SuiteMask: ULONG,
   pub SharedUserSessionId: ULONG,
   pub IsMultiSessionSku: BOOLEAN,
   pub IsStateSeparationEnabled: BOOLEAN,
   pub NtSystemRoot: [WCHAR; 260usize],
   pub UserModeGlobalLogger: [USHORT; 16usize],
   pub TimeZoneId: ULONG,
   pub TimeZoneBiasStamp: LONG,
   pub TimeZoneBias: KSYSTEM_TIME,
   pub TimeZoneBiasEffectiveStart: LARGE_INTEGER,
   pub TimeZoneBiasEffectiveEnd: LARGE_INTEGER,
}
impl Default for _SILO_USER_SHARED_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SILO_USER_SHARED_DATA = _SILO_USER_SHARED_DATA;
#[repr(C)]
pub struct _SILOOBJECT_ROOT_DIRECTORY {
   pub __bindgen_anon_1: _SILOOBJECT_ROOT_DIRECTORY__bindgen_ty_1,
}
#[repr(C)]
pub union _SILOOBJECT_ROOT_DIRECTORY__bindgen_ty_1 {
   pub ControlFlags: ::core::mem::ManuallyDrop<ULONG>,
   pub Path: ::core::mem::ManuallyDrop<UNICODE_STRING>,
}
impl Default for _SILOOBJECT_ROOT_DIRECTORY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SILOOBJECT_ROOT_DIRECTORY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SILOOBJECT_ROOT_DIRECTORY = _SILOOBJECT_ROOT_DIRECTORY;
pub type PSILOOBJECT_ROOT_DIRECTORY = *mut _SILOOBJECT_ROOT_DIRECTORY;
#[repr(C)]
pub struct _SERVERSILO_INIT_INFORMATION {
   pub DeleteEvent: HANDLE,
   pub IsDownlevelContainer: BOOLEAN,
}
impl Default for _SERVERSILO_INIT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SERVERSILO_INIT_INFORMATION = _SERVERSILO_INIT_INFORMATION;
pub type PSERVERSILO_INIT_INFORMATION = *mut _SERVERSILO_INIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_ENERGY_TRACKING_STATE {
   pub Value: ULONG64,
   pub UpdateMask: ULONG,
   pub DesiredState: ULONG,
}
pub type JOBOBJECT_ENERGY_TRACKING_STATE = _JOBOBJECT_ENERGY_TRACKING_STATE;
pub type PJOBOBJECT_ENERGY_TRACKING_STATE = *mut _JOBOBJECT_ENERGY_TRACKING_STATE;
impl _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS {
   pub const JOBOBJECT_IO_PRIORITY_LIMIT_VALID_FLAGS: _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS =
      _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS::JOBOBJECT_IO_PRIORITY_LIMIT_ENABLE;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS {
   JOBOBJECT_IO_PRIORITY_LIMIT_ENABLE = 1,
}
pub use self::_JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS as JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_IO_PRIORITY_LIMIT {
   pub Flags: JOBOBJECT_IO_PRIORITY_LIMIT_FLAGS,
   pub Priority: ULONG,
}
impl Default for _JOBOBJECT_IO_PRIORITY_LIMIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_IO_PRIORITY_LIMIT = _JOBOBJECT_IO_PRIORITY_LIMIT;
pub type PJOBOBJECT_IO_PRIORITY_LIMIT = *mut _JOBOBJECT_IO_PRIORITY_LIMIT;
impl _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS {
   pub const JOBOBJECT_PAGE_PRIORITY_LIMIT_VALID_FLAGS: _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS =
      _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS::JOBOBJECT_PAGE_PRIORITY_LIMIT_ENABLE;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS {
   JOBOBJECT_PAGE_PRIORITY_LIMIT_ENABLE = 1,
}
pub use self::_JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS as JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_PAGE_PRIORITY_LIMIT {
   pub Flags: JOBOBJECT_PAGE_PRIORITY_LIMIT_FLAGS,
   pub Priority: ULONG,
}
impl Default for _JOBOBJECT_PAGE_PRIORITY_LIMIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type JOBOBJECT_PAGE_PRIORITY_LIMIT = _JOBOBJECT_PAGE_PRIORITY_LIMIT;
pub type PJOBOBJECT_PAGE_PRIORITY_LIMIT = *mut _JOBOBJECT_PAGE_PRIORITY_LIMIT;
#[repr(C)]
pub struct _SERVERSILO_DIAGNOSTIC_INFORMATION {
   pub ExitStatus: NTSTATUS,
   pub CriticalProcessName: [WCHAR; 15usize],
}
impl Default for _SERVERSILO_DIAGNOSTIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SERVERSILO_DIAGNOSTIC_INFORMATION = _SERVERSILO_DIAGNOSTIC_INFORMATION;
pub type PSERVERSILO_DIAGNOSTIC_INFORMATION = *mut _SERVERSILO_DIAGNOSTIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _JOBOBJECT_NETWORK_ACCOUNTING_INFORMATION {
   pub DataBytesIn: ULONG64,
   pub DataBytesOut: ULONG64,
}
pub type JOBOBJECT_NETWORK_ACCOUNTING_INFORMATION = _JOBOBJECT_NETWORK_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_NETWORK_ACCOUNTING_INFORMATION = *mut _JOBOBJECT_NETWORK_ACCOUNTING_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_RESERVE_TYPE {
   MemoryReserveUserApc = 0,
   MemoryReserveIoCompletion = 1,
   MemoryReserveTypeMax = 2,
}
pub use self::_MEMORY_RESERVE_TYPE as MEMORY_RESERVE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PSSNT_CAPTURE_FLAGS {
   PSSNT_CAPTURE_NONE = 0,
   PSSNT_CAPTURE_VA_CLONE = 1,
   PSSNT_CAPTURE_RESERVED_00000002 = 2,
   PSSNT_CAPTURE_HANDLES = 4,
   PSSNT_CAPTURE_HANDLE_NAME_INFORMATION = 8,
   PSSNT_CAPTURE_HANDLE_BASIC_INFORMATION = 16,
   PSSNT_CAPTURE_HANDLE_TYPE_SPECIFIC_INFORMATION = 32,
   PSSNT_CAPTURE_HANDLE_TRACE = 64,
   PSSNT_CAPTURE_THREADS = 128,
   PSSNT_CAPTURE_THREAD_CONTEXT = 256,
   PSSNT_CAPTURE_THREAD_CONTEXT_EXTENDED = 512,
   PSSNT_CAPTURE_RESERVED_00000400 = 1024,
   PSSNT_CAPTURE_VA_SPACE = 2048,
   PSSNT_CAPTURE_VA_SPACE_SECTION_INFORMATION = 4096,
   PSSNT_CAPTURE_IPT_TRACE = 8192,
   PSSNT_CAPTURE_RESERVED_00004000 = 16384,
   PSSNT_CREATE_BREAKAWAY_OPTIONAL = 67108864,
   PSSNT_CREATE_BREAKAWAY = 134217728,
   PSSNT_CREATE_FORCE_BREAKAWAY = 268435456,
   PSSNT_CREATE_USE_VM_ALLOCATIONS = 536870912,
   PSSNT_CREATE_MEASURE_PERFORMANCE = 1073741824,
   PSSNT_CREATE_RELEASE_SECTION = -2147483648,
}
pub use self::_PSSNT_CAPTURE_FLAGS as PSSNT_CAPTURE_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PSSNT_DUPLICATE_FLAGS {
   PSSNT_DUPLICATE_NONE = 0,
   PSSNT_DUPLICATE_CLOSE_SOURCE = 1,
}
pub use self::_PSSNT_DUPLICATE_FLAGS as PSSNT_DUPLICATE_FLAGS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PSSNT_QUERY_INFORMATION_CLASS {
   PSSNT_QUERY_PROCESS_INFORMATION = 0,
   PSSNT_QUERY_VA_CLONE_INFORMATION = 1,
   PSSNT_QUERY_AUXILIARY_PAGES_INFORMATION = 2,
   PSSNT_QUERY_VA_SPACE_INFORMATION = 3,
   PSSNT_QUERY_HANDLE_INFORMATION = 4,
   PSSNT_QUERY_THREAD_INFORMATION = 5,
   PSSNT_QUERY_HANDLE_TRACE_INFORMATION = 6,
   PSSNT_QUERY_PERFORMANCE_COUNTERS = 7,
}
pub use self::_PSSNT_QUERY_INFORMATION_CLASS as PSSNT_QUERY_INFORMATION_CLASS;
#[doc = "The NTPSS_MEMORY_BULK_INFORMATION structure is used to query basic memory information in bulk for a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTPSS_MEMORY_BULK_INFORMATION {
   pub QueryFlags: ULONG,
   pub NumberOfEntries: ULONG,
   pub NextValidAddress: PVOID,
}
impl Default for _NTPSS_MEMORY_BULK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The NTPSS_MEMORY_BULK_INFORMATION structure is used to query basic memory information in bulk for a process."]
pub type NTPSS_MEMORY_BULK_INFORMATION = _NTPSS_MEMORY_BULK_INFORMATION;
#[doc = "The NTPSS_MEMORY_BULK_INFORMATION structure is used to query basic memory information in bulk for a process."]
pub type PNTPSS_MEMORY_BULK_INFORMATION = *mut _NTPSS_MEMORY_BULK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_EXCEPTION {
   pub ExceptionRecord: EXCEPTION_RECORD,
   pub FirstChance: ULONG,
}
impl Default for _DBGKM_EXCEPTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_EXCEPTION = _DBGKM_EXCEPTION;
pub type PDBGKM_EXCEPTION = *mut _DBGKM_EXCEPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_CREATE_THREAD {
   pub SubSystemKey: ULONG,
   pub StartAddress: PVOID,
}
impl Default for _DBGKM_CREATE_THREAD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_CREATE_THREAD = _DBGKM_CREATE_THREAD;
pub type PDBGKM_CREATE_THREAD = *mut _DBGKM_CREATE_THREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_CREATE_PROCESS {
   pub SubSystemKey: ULONG,
   pub FileHandle: HANDLE,
   pub BaseOfImage: PVOID,
   pub DebugInfoFileOffset: ULONG,
   pub DebugInfoSize: ULONG,
   pub InitialThread: DBGKM_CREATE_THREAD,
}
impl Default for _DBGKM_CREATE_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_CREATE_PROCESS = _DBGKM_CREATE_PROCESS;
pub type PDBGKM_CREATE_PROCESS = *mut _DBGKM_CREATE_PROCESS;
#[repr(C)]
pub struct _DBGKM_EXIT_THREAD {
   pub ExitStatus: NTSTATUS,
}
impl Default for _DBGKM_EXIT_THREAD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_EXIT_THREAD = _DBGKM_EXIT_THREAD;
pub type PDBGKM_EXIT_THREAD = *mut _DBGKM_EXIT_THREAD;
#[repr(C)]
pub struct _DBGKM_EXIT_PROCESS {
   pub ExitStatus: NTSTATUS,
}
impl Default for _DBGKM_EXIT_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_EXIT_PROCESS = _DBGKM_EXIT_PROCESS;
pub type PDBGKM_EXIT_PROCESS = *mut _DBGKM_EXIT_PROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_LOAD_DLL {
   pub FileHandle: HANDLE,
   pub BaseOfDll: PVOID,
   pub DebugInfoFileOffset: ULONG,
   pub DebugInfoSize: ULONG,
   pub NamePointer: PVOID,
}
impl Default for _DBGKM_LOAD_DLL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_LOAD_DLL = _DBGKM_LOAD_DLL;
pub type PDBGKM_LOAD_DLL = *mut _DBGKM_LOAD_DLL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGKM_UNLOAD_DLL {
   pub BaseAddress: PVOID,
}
impl Default for _DBGKM_UNLOAD_DLL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGKM_UNLOAD_DLL = _DBGKM_UNLOAD_DLL;
pub type PDBGKM_UNLOAD_DLL = *mut _DBGKM_UNLOAD_DLL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DBG_STATE {
   DbgIdle = 0,
   DbgReplyPending = 1,
   DbgCreateThreadStateChange = 2,
   DbgCreateProcessStateChange = 3,
   DbgExitThreadStateChange = 4,
   DbgExitProcessStateChange = 5,
   DbgExceptionStateChange = 6,
   DbgBreakpointStateChange = 7,
   DbgSingleStepStateChange = 8,
   DbgLoadDllStateChange = 9,
   DbgUnloadDllStateChange = 10,
}
pub use self::_DBG_STATE as DBG_STATE;
pub type PDBG_STATE = *mut _DBG_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGUI_CREATE_THREAD {
   pub HandleToThread: HANDLE,
   pub NewThread: DBGKM_CREATE_THREAD,
}
impl Default for _DBGUI_CREATE_THREAD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGUI_CREATE_THREAD = _DBGUI_CREATE_THREAD;
pub type PDBGUI_CREATE_THREAD = *mut _DBGUI_CREATE_THREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DBGUI_CREATE_PROCESS {
   pub HandleToProcess: HANDLE,
   pub HandleToThread: HANDLE,
   pub NewProcess: DBGKM_CREATE_PROCESS,
}
impl Default for _DBGUI_CREATE_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGUI_CREATE_PROCESS = _DBGUI_CREATE_PROCESS;
pub type PDBGUI_CREATE_PROCESS = *mut _DBGUI_CREATE_PROCESS;
#[repr(C)]
pub struct _DBGUI_WAIT_STATE_CHANGE {
   pub NewState: DBG_STATE,
   pub AppClientId: CLIENT_ID,
   pub StateInfo: _DBGUI_WAIT_STATE_CHANGE__bindgen_ty_1,
}
#[repr(C)]
pub union _DBGUI_WAIT_STATE_CHANGE__bindgen_ty_1 {
   pub Exception: ::core::mem::ManuallyDrop<DBGKM_EXCEPTION>,
   pub CreateThread: ::core::mem::ManuallyDrop<DBGUI_CREATE_THREAD>,
   pub CreateProcessInfo: ::core::mem::ManuallyDrop<DBGUI_CREATE_PROCESS>,
   pub ExitThread: ::core::mem::ManuallyDrop<DBGKM_EXIT_THREAD>,
   pub ExitProcess: ::core::mem::ManuallyDrop<DBGKM_EXIT_PROCESS>,
   pub LoadDll: ::core::mem::ManuallyDrop<DBGKM_LOAD_DLL>,
   pub UnloadDll: ::core::mem::ManuallyDrop<DBGKM_UNLOAD_DLL>,
}
impl Default for _DBGUI_WAIT_STATE_CHANGE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _DBGUI_WAIT_STATE_CHANGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DBGUI_WAIT_STATE_CHANGE = _DBGUI_WAIT_STATE_CHANGE;
pub type PDBGUI_WAIT_STATE_CHANGE = *mut _DBGUI_WAIT_STATE_CHANGE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEBUGOBJECTINFOCLASS {
   DebugObjectUnusedInformation = 0,
   DebugObjectKillProcessOnExitInformation = 1,
   MaxDebugObjectInfoClass = 2,
}
pub use self::_DEBUGOBJECTINFOCLASS as DEBUGOBJECTINFOCLASS;
pub type PDEBUGOBJECTINFOCLASS = *mut _DEBUGOBJECTINFOCLASS;
pub type PENABLECALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      SourceId: LPCGUID,
      IsEnabled: ULONG,
      Level: UCHAR,
      MatchAnyKeyword: ULONGLONG,
      MatchAllKeyword: ULONGLONG,
      FilterData: PEVENT_FILTER_DESCRIPTOR,
      CallbackContext: PVOID,
   ),
>;
pub type REGHANDLE = ULONGLONG;
pub type PREGHANDLE = *mut ULONGLONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXTENDED_CREATE_INFORMATION {
   pub ExtendedCreateFlags: LONGLONG,
   pub EaBuffer: PVOID,
   pub EaLength: ULONG,
}
impl Default for _EXTENDED_CREATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EXTENDED_CREATE_INFORMATION = _EXTENDED_CREATE_INFORMATION;
pub type PEXTENDED_CREATE_INFORMATION = *mut _EXTENDED_CREATE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXTENDED_CREATE_INFORMATION_32 {
   pub ExtendedCreateFlags: LONGLONG,
   pub EaBuffer: *mut ::core::ffi::c_void,
   pub EaLength: ULONG,
}
impl Default for _EXTENDED_CREATE_INFORMATION_32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EXTENDED_CREATE_INFORMATION_32 = _EXTENDED_CREATE_INFORMATION_32;
pub type PEXTENDED_CREATE_INFORMATION_32 = *mut _EXTENDED_CREATE_INFORMATION_32;
#[repr(C)]
pub struct _IO_STATUS_BLOCK {
   pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
   pub Information: ULONG_PTR,
}
#[repr(C)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
   pub Status: ::core::mem::ManuallyDrop<NTSTATUS>,
   pub Pointer: ::core::mem::ManuallyDrop<PVOID>,
}
impl Default for _IO_STATUS_BLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IO_STATUS_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_APC_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
#[repr(C)]
pub struct _FILE_IO_COMPLETION_INFORMATION {
   pub KeyContext: PVOID,
   pub ApcContext: PVOID,
   pub IoStatusBlock: IO_STATUS_BLOCK,
}
impl Default for _FILE_IO_COMPLETION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IO_COMPLETION_INFORMATION = _FILE_IO_COMPLETION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_INFORMATION_CLASS {
   FileDirectoryInformation = 1,
   FileFullDirectoryInformation = 2,
   FileBothDirectoryInformation = 3,
   FileBasicInformation = 4,
   FileStandardInformation = 5,
   FileInternalInformation = 6,
   FileEaInformation = 7,
   FileAccessInformation = 8,
   FileNameInformation = 9,
   FileRenameInformation = 10,
   FileLinkInformation = 11,
   FileNamesInformation = 12,
   FileDispositionInformation = 13,
   FilePositionInformation = 14,
   FileFullEaInformation = 15,
   FileModeInformation = 16,
   FileAlignmentInformation = 17,
   FileAllInformation = 18,
   FileAllocationInformation = 19,
   FileEndOfFileInformation = 20,
   FileAlternateNameInformation = 21,
   FileStreamInformation = 22,
   FilePipeInformation = 23,
   FilePipeLocalInformation = 24,
   FilePipeRemoteInformation = 25,
   FileMailslotQueryInformation = 26,
   FileMailslotSetInformation = 27,
   FileCompressionInformation = 28,
   FileObjectIdInformation = 29,
   FileCompletionInformation = 30,
   FileMoveClusterInformation = 31,
   FileQuotaInformation = 32,
   FileReparsePointInformation = 33,
   FileNetworkOpenInformation = 34,
   FileAttributeTagInformation = 35,
   FileTrackingInformation = 36,
   FileIdBothDirectoryInformation = 37,
   FileIdFullDirectoryInformation = 38,
   FileValidDataLengthInformation = 39,
   FileShortNameInformation = 40,
   FileIoCompletionNotificationInformation = 41,
   FileIoStatusBlockRangeInformation = 42,
   FileIoPriorityHintInformation = 43,
   FileSfioReserveInformation = 44,
   FileSfioVolumeInformation = 45,
   FileHardLinkInformation = 46,
   FileProcessIdsUsingFileInformation = 47,
   FileNormalizedNameInformation = 48,
   FileNetworkPhysicalNameInformation = 49,
   FileIdGlobalTxDirectoryInformation = 50,
   FileIsRemoteDeviceInformation = 51,
   FileUnusedInformation = 52,
   FileNumaNodeInformation = 53,
   FileStandardLinkInformation = 54,
   FileRemoteProtocolInformation = 55,
   FileRenameInformationBypassAccessCheck = 56,
   FileLinkInformationBypassAccessCheck = 57,
   FileVolumeNameInformation = 58,
   FileIdInformation = 59,
   FileIdExtdDirectoryInformation = 60,
   FileReplaceCompletionInformation = 61,
   FileHardLinkFullIdInformation = 62,
   FileIdExtdBothDirectoryInformation = 63,
   FileDispositionInformationEx = 64,
   FileRenameInformationEx = 65,
   FileRenameInformationExBypassAccessCheck = 66,
   FileDesiredStorageClassInformation = 67,
   FileStatInformation = 68,
   FileMemoryPartitionInformation = 69,
   FileStatLxInformation = 70,
   FileCaseSensitiveInformation = 71,
   FileLinkInformationEx = 72,
   FileLinkInformationExBypassAccessCheck = 73,
   FileStorageReserveIdInformation = 74,
   FileCaseSensitiveInformationForceAccessCheck = 75,
   FileKnownFolderInformation = 76,
   FileStatBasicInformation = 77,
   FileId64ExtdDirectoryInformation = 78,
   FileId64ExtdBothDirectoryInformation = 79,
   FileIdAllExtdDirectoryInformation = 80,
   FileIdAllExtdBothDirectoryInformation = 81,
   FileStreamReservationInformation = 82,
   FileMupProviderInfo = 83,
   FileMaximumInformation = 84,
}
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
#[doc = "The FILE_BASIC_INFORMATION structure contains timestamps and basic attributes of a file.\n- If you specify a value of zero for any of the XxxTime members, the file system keeps a file's current value for that time.\n- If you specify a value of -1 for any of the XxxTime members, time stamp updates are disabled for I/O operations preformed on the file handle.\n- If you specify a value of -2 for any of the XxxTime members, time stamp updates are enabled for I/O operations preformed on the file handle.\n> To set the members of this structure, the caller must have FILE_WRITE_ATTRIBUTES access to the file."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub FileAttributes: ULONG,
}
impl Default for _FILE_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The FILE_BASIC_INFORMATION structure contains timestamps and basic attributes of a file.\n- If you specify a value of zero for any of the XxxTime members, the file system keeps a file's current value for that time.\n- If you specify a value of -1 for any of the XxxTime members, time stamp updates are disabled for I/O operations preformed on the file handle.\n- If you specify a value of -2 for any of the XxxTime members, time stamp updates are enabled for I/O operations preformed on the file handle.\n> To set the members of this structure, the caller must have FILE_WRITE_ATTRIBUTES access to the file."]
pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION;
#[doc = "The FILE_BASIC_INFORMATION structure contains timestamps and basic attributes of a file.\n- If you specify a value of zero for any of the XxxTime members, the file system keeps a file's current value for that time.\n- If you specify a value of -1 for any of the XxxTime members, time stamp updates are disabled for I/O operations preformed on the file handle.\n- If you specify a value of -2 for any of the XxxTime members, time stamp updates are enabled for I/O operations preformed on the file handle.\n> To set the members of this structure, the caller must have FILE_WRITE_ATTRIBUTES access to the file."]
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[doc = "The FILE_STANDARD_INFORMATION structure contains standard information of a file.\n> EndOfFile specifies the byte offset to the end of the file.\nBecause this value is zero-based, it actually refers to the first free byte in the file; that is, it is the offset to the byte immediately following the last valid byte in the file."]
#[repr(C)]
pub struct _FILE_STANDARD_INFORMATION {
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub NumberOfLinks: ULONG,
   pub DeletePending: BOOLEAN,
   pub Directory: BOOLEAN,
}
impl Default for _FILE_STANDARD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The FILE_STANDARD_INFORMATION structure contains standard information of a file.\n> EndOfFile specifies the byte offset to the end of the file.\nBecause this value is zero-based, it actually refers to the first free byte in the file; that is, it is the offset to the byte immediately following the last valid byte in the file."]
pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION;
#[doc = "The FILE_STANDARD_INFORMATION structure contains standard information of a file.\n> EndOfFile specifies the byte offset to the end of the file.\nBecause this value is zero-based, it actually refers to the first free byte in the file; that is, it is the offset to the byte immediately following the last valid byte in the file."]
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
pub struct _FILE_STANDARD_INFORMATION_EX {
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub NumberOfLinks: ULONG,
   pub DeletePending: BOOLEAN,
   pub Directory: BOOLEAN,
   pub AlternateStream: BOOLEAN,
   pub MetadataAttribute: BOOLEAN,
}
impl Default for _FILE_STANDARD_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STANDARD_INFORMATION_EX = _FILE_STANDARD_INFORMATION_EX;
pub type PFILE_STANDARD_INFORMATION_EX = *mut _FILE_STANDARD_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION {
   pub __bindgen_anon_1: _FILE_INTERNAL_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_INTERNAL_INFORMATION__bindgen_ty_1 {
   pub IndexNumber: ULARGE_INTEGER,
   pub __bindgen_anon_1: _FILE_INTERNAL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _FILE_INTERNAL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn MftRecordIndex(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_MftRecordIndex(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MftRecordIndex_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            48u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_MftRecordIndex_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            48u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SequenceNumber(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
   }
   #[inline]
   pub fn set_SequenceNumber(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(48usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SequenceNumber_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            48usize,
            16u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_SequenceNumber_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            48usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      MftRecordIndex: ULONGLONG,
      SequenceNumber: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 48u8, {
         let MftRecordIndex: u64 = unsafe { ::core::mem::transmute(MftRecordIndex) };
         MftRecordIndex as u64
      });
      __bindgen_bitfield_unit.set(48usize, 16u8, {
         let SequenceNumber: u64 = unsafe { ::core::mem::transmute(SequenceNumber) };
         SequenceNumber as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _FILE_INTERNAL_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_INTERNAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_INTERNAL_INFORMATION = _FILE_INTERNAL_INFORMATION;
pub type PFILE_INTERNAL_INFORMATION = *mut _FILE_INTERNAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_EA_INFORMATION {
   pub EaSize: ULONG,
}
pub type FILE_EA_INFORMATION = _FILE_EA_INFORMATION;
pub type PFILE_EA_INFORMATION = *mut _FILE_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ACCESS_INFORMATION {
   pub AccessFlags: ACCESS_MASK,
}
pub type FILE_ACCESS_INFORMATION = _FILE_ACCESS_INFORMATION;
pub type PFILE_ACCESS_INFORMATION = *mut _FILE_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_POSITION_INFORMATION {
   pub CurrentByteOffset: LARGE_INTEGER,
}
impl Default for _FILE_POSITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_MODE_INFORMATION {
   pub Mode: ULONG,
}
pub type FILE_MODE_INFORMATION = _FILE_MODE_INFORMATION;
pub type PFILE_MODE_INFORMATION = *mut _FILE_MODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFORMATION {
   pub AlignmentRequirement: ULONG,
}
pub type FILE_ALIGNMENT_INFORMATION = _FILE_ALIGNMENT_INFORMATION;
pub type PFILE_ALIGNMENT_INFORMATION = *mut _FILE_ALIGNMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NAME_INFORMATION {
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_NAME_INFORMATION = _FILE_NAME_INFORMATION;
pub type PFILE_NAME_INFORMATION = *mut _FILE_NAME_INFORMATION;
#[repr(C)]
pub struct _FILE_ALL_INFORMATION {
   pub BasicInformation: FILE_BASIC_INFORMATION,
   pub StandardInformation: FILE_STANDARD_INFORMATION,
   pub InternalInformation: FILE_INTERNAL_INFORMATION,
   pub EaInformation: FILE_EA_INFORMATION,
   pub AccessInformation: FILE_ACCESS_INFORMATION,
   pub PositionInformation: FILE_POSITION_INFORMATION,
   pub ModeInformation: FILE_MODE_INFORMATION,
   pub AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
   pub NameInformation: FILE_NAME_INFORMATION,
}
impl Default for _FILE_ALL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ALL_INFORMATION = _FILE_ALL_INFORMATION;
pub type PFILE_ALL_INFORMATION = *mut _FILE_ALL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub FileAttributes: ULONG,
}
impl Default for _FILE_NETWORK_OPEN_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFORMATION {
   pub FileAttributes: ULONG,
   pub ReparseTag: ULONG,
}
pub type FILE_ATTRIBUTE_TAG_INFORMATION = _FILE_ATTRIBUTE_TAG_INFORMATION;
pub type PFILE_ATTRIBUTE_TAG_INFORMATION = *mut _FILE_ATTRIBUTE_TAG_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFORMATION {
   pub AllocationSize: LARGE_INTEGER,
}
impl Default for _FILE_ALLOCATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ALLOCATION_INFORMATION = _FILE_ALLOCATION_INFORMATION;
pub type PFILE_ALLOCATION_INFORMATION = *mut _FILE_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFORMATION {
   pub CompressedFileSize: LARGE_INTEGER,
   pub CompressionFormat: USHORT,
   pub CompressionUnitShift: UCHAR,
   pub ChunkShift: UCHAR,
   pub ClusterShift: UCHAR,
   pub Reserved: [UCHAR; 3usize],
}
impl Default for _FILE_COMPRESSION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_COMPRESSION_INFORMATION = _FILE_COMPRESSION_INFORMATION;
pub type PFILE_COMPRESSION_INFORMATION = *mut _FILE_COMPRESSION_INFORMATION;
#[repr(C)]
pub struct _FILE_DISPOSITION_INFORMATION {
   pub DeleteFileW: BOOLEAN,
}
impl Default for _FILE_DISPOSITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_DISPOSITION_INFORMATION = _FILE_DISPOSITION_INFORMATION;
pub type PFILE_DISPOSITION_INFORMATION = *mut _FILE_DISPOSITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION {
   pub EndOfFile: LARGE_INTEGER,
}
impl Default for _FILE_END_OF_FILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_END_OF_FILE_INFORMATION = _FILE_END_OF_FILE_INFORMATION;
pub type PFILE_END_OF_FILE_INFORMATION = *mut _FILE_END_OF_FILE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION_EX {
   pub EndOfFile: LARGE_INTEGER,
   pub PagingFileSizeInMM: LARGE_INTEGER,
   pub PagingFileMaxSize: LARGE_INTEGER,
   pub Flags: ULONG,
}
impl Default for _FILE_END_OF_FILE_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_END_OF_FILE_INFORMATION_EX = _FILE_END_OF_FILE_INFORMATION_EX;
pub type PFILE_END_OF_FILE_INFORMATION_EX = *mut _FILE_END_OF_FILE_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_VALID_DATA_LENGTH_INFORMATION {
   pub ValidDataLength: LARGE_INTEGER,
}
impl Default for _FILE_VALID_DATA_LENGTH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_VALID_DATA_LENGTH_INFORMATION = _FILE_VALID_DATA_LENGTH_INFORMATION;
pub type PFILE_VALID_DATA_LENGTH_INFORMATION = *mut _FILE_VALID_DATA_LENGTH_INFORMATION;
#[repr(C)]
pub struct _FILE_LINK_INFORMATION {
   pub ReplaceIfExists: BOOLEAN,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_LINK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_LINK_INFORMATION = _FILE_LINK_INFORMATION;
pub type PFILE_LINK_INFORMATION = *mut _FILE_LINK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINK_INFORMATION_EX {
   pub Flags: ULONG,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_LINK_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_LINK_INFORMATION_EX = _FILE_LINK_INFORMATION_EX;
pub type PFILE_LINK_INFORMATION_EX = *mut _FILE_LINK_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MOVE_CLUSTER_INFORMATION {
   pub ClusterCount: ULONG,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_MOVE_CLUSTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_MOVE_CLUSTER_INFORMATION = _FILE_MOVE_CLUSTER_INFORMATION;
pub type PFILE_MOVE_CLUSTER_INFORMATION = *mut _FILE_MOVE_CLUSTER_INFORMATION;
#[repr(C)]
pub struct _FILE_RENAME_INFORMATION {
   pub ReplaceIfExists: BOOLEAN,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_RENAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_RENAME_INFORMATION = _FILE_RENAME_INFORMATION;
pub type PFILE_RENAME_INFORMATION = *mut _FILE_RENAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_RENAME_INFORMATION_EX {
   pub Flags: ULONG,
   pub RootDirectory: HANDLE,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_RENAME_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_RENAME_INFORMATION_EX = _FILE_RENAME_INFORMATION_EX;
pub type PFILE_RENAME_INFORMATION_EX = *mut _FILE_RENAME_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub StreamNameLength: ULONG,
   pub StreamSize: LARGE_INTEGER,
   pub StreamAllocationSize: LARGE_INTEGER,
   pub StreamName: [WCHAR; 1usize],
}
impl Default for _FILE_STREAM_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STREAM_INFORMATION = _FILE_STREAM_INFORMATION;
pub type PFILE_STREAM_INFORMATION = *mut _FILE_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TRACKING_INFORMATION {
   pub DestinationFile: HANDLE,
   pub ObjectInformationLength: ULONG,
   pub ObjectInformation: [CHAR; 1usize],
}
impl Default for _FILE_TRACKING_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_TRACKING_INFORMATION = _FILE_TRACKING_INFORMATION;
pub type PFILE_TRACKING_INFORMATION = *mut _FILE_TRACKING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_COMPLETION_INFORMATION {
   pub Port: HANDLE,
   pub Key: PVOID,
}
impl Default for _FILE_COMPLETION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_COMPLETION_INFORMATION = _FILE_COMPLETION_INFORMATION;
pub type PFILE_COMPLETION_INFORMATION = *mut _FILE_COMPLETION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_INFORMATION {
   pub ReadMode: ULONG,
   pub CompletionMode: ULONG,
}
pub type FILE_PIPE_INFORMATION = _FILE_PIPE_INFORMATION;
pub type PFILE_PIPE_INFORMATION = *mut _FILE_PIPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_LOCAL_INFORMATION {
   pub NamedPipeType: ULONG,
   pub NamedPipeConfiguration: ULONG,
   pub MaximumInstances: ULONG,
   pub CurrentInstances: ULONG,
   pub InboundQuota: ULONG,
   pub ReadDataAvailable: ULONG,
   pub OutboundQuota: ULONG,
   pub WriteQuotaAvailable: ULONG,
   pub NamedPipeState: ULONG,
   pub NamedPipeEnd: ULONG,
}
pub type FILE_PIPE_LOCAL_INFORMATION = _FILE_PIPE_LOCAL_INFORMATION;
pub type PFILE_PIPE_LOCAL_INFORMATION = *mut _FILE_PIPE_LOCAL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_PIPE_REMOTE_INFORMATION {
   pub CollectDataTime: LARGE_INTEGER,
   pub MaximumCollectionCount: ULONG,
}
impl Default for _FILE_PIPE_REMOTE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_REMOTE_INFORMATION = _FILE_PIPE_REMOTE_INFORMATION;
pub type PFILE_PIPE_REMOTE_INFORMATION = *mut _FILE_PIPE_REMOTE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MAILSLOT_QUERY_INFORMATION {
   pub MaximumMessageSize: ULONG,
   pub MailslotQuota: ULONG,
   pub NextMessageSize: ULONG,
   pub MessagesAvailable: ULONG,
   pub ReadTimeout: LARGE_INTEGER,
}
impl Default for _FILE_MAILSLOT_QUERY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_MAILSLOT_QUERY_INFORMATION = _FILE_MAILSLOT_QUERY_INFORMATION;
pub type PFILE_MAILSLOT_QUERY_INFORMATION = *mut _FILE_MAILSLOT_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAILSLOT_SET_INFORMATION {
   pub ReadTimeout: PLARGE_INTEGER,
}
impl Default for _FILE_MAILSLOT_SET_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_MAILSLOT_SET_INFORMATION = _FILE_MAILSLOT_SET_INFORMATION;
pub type PFILE_MAILSLOT_SET_INFORMATION = *mut _FILE_MAILSLOT_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REPARSE_POINT_INFORMATION {
   pub FileReference: LONGLONG,
   pub Tag: ULONG,
}
pub type FILE_REPARSE_POINT_INFORMATION = _FILE_REPARSE_POINT_INFORMATION;
pub type PFILE_REPARSE_POINT_INFORMATION = *mut _FILE_REPARSE_POINT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_LINK_ENTRY_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub ParentFileId: LONGLONG,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_LINK_ENTRY_INFORMATION = _FILE_LINK_ENTRY_INFORMATION;
pub type PFILE_LINK_ENTRY_INFORMATION = *mut _FILE_LINK_ENTRY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_LINKS_INFORMATION {
   pub BytesNeeded: ULONG,
   pub EntriesReturned: ULONG,
   pub Entry: FILE_LINK_ENTRY_INFORMATION,
}
pub type FILE_LINKS_INFORMATION = _FILE_LINKS_INFORMATION;
pub type PFILE_LINKS_INFORMATION = *mut _FILE_LINKS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_NETWORK_PHYSICAL_NAME_INFORMATION = _FILE_NETWORK_PHYSICAL_NAME_INFORMATION;
pub type PFILE_NETWORK_PHYSICAL_NAME_INFORMATION = *mut _FILE_NETWORK_PHYSICAL_NAME_INFORMATION;
#[repr(C)]
pub struct _FILE_STANDARD_LINK_INFORMATION {
   pub NumberOfAccessibleLinks: ULONG,
   pub TotalNumberOfLinks: ULONG,
   pub DeletePending: BOOLEAN,
   pub Directory: BOOLEAN,
}
impl Default for _FILE_STANDARD_LINK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STANDARD_LINK_INFORMATION = _FILE_STANDARD_LINK_INFORMATION;
pub type PFILE_STANDARD_LINK_INFORMATION = *mut _FILE_STANDARD_LINK_INFORMATION;
#[repr(C)]
pub struct _FILE_SFIO_RESERVE_INFORMATION {
   pub RequestsPerPeriod: ULONG,
   pub Period: ULONG,
   pub RetryFailures: BOOLEAN,
   pub Discardable: BOOLEAN,
   pub RequestSize: ULONG,
   pub NumOutstandingRequests: ULONG,
}
impl Default for _FILE_SFIO_RESERVE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_SFIO_RESERVE_INFORMATION = _FILE_SFIO_RESERVE_INFORMATION;
pub type PFILE_SFIO_RESERVE_INFORMATION = *mut _FILE_SFIO_RESERVE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_SFIO_VOLUME_INFORMATION {
   pub MaximumRequestsPerPeriod: ULONG,
   pub MinimumPeriod: ULONG,
   pub MinimumTransferSize: ULONG,
}
pub type FILE_SFIO_VOLUME_INFORMATION = _FILE_SFIO_VOLUME_INFORMATION;
pub type PFILE_SFIO_VOLUME_INFORMATION = *mut _FILE_SFIO_VOLUME_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_PRIORITY_HINT {
   IoPriorityVeryLow = 0,
   IoPriorityLow = 1,
   IoPriorityNormal = 2,
   IoPriorityHigh = 3,
   IoPriorityCritical = 4,
   MaxIoPriorityTypes = 5,
}
pub use self::_IO_PRIORITY_HINT as IO_PRIORITY_HINT;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION {
   pub PriorityHint: IO_PRIORITY_HINT,
}
impl Default for _FILE_IO_PRIORITY_HINT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IO_PRIORITY_HINT_INFORMATION = _FILE_IO_PRIORITY_HINT_INFORMATION;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION = *mut _FILE_IO_PRIORITY_HINT_INFORMATION;
#[repr(C)]
pub struct _FILE_IO_PRIORITY_HINT_INFORMATION_EX {
   pub PriorityHint: IO_PRIORITY_HINT,
   pub BoostOutstanding: BOOLEAN,
}
impl Default for _FILE_IO_PRIORITY_HINT_INFORMATION_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IO_PRIORITY_HINT_INFORMATION_EX = _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
pub type PFILE_IO_PRIORITY_HINT_INFORMATION_EX = *mut _FILE_IO_PRIORITY_HINT_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
   pub Flags: ULONG,
}
pub type FILE_IO_COMPLETION_NOTIFICATION_INFORMATION = _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
pub type PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION =
   *mut _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION {
   pub NumberOfProcessIdsInList: ULONG,
   pub ProcessIdList: [ULONG_PTR; 1usize],
}
pub type FILE_PROCESS_IDS_USING_FILE_INFORMATION = _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
pub type PFILE_PROCESS_IDS_USING_FILE_INFORMATION = *mut _FILE_PROCESS_IDS_USING_FILE_INFORMATION;
#[doc = "The FILE_IS_REMOTE_DEVICE_INFORMATION structure indicates whether the file system that contains the file is a remote file system."]
#[repr(C)]
pub struct _FILE_IS_REMOTE_DEVICE_INFORMATION {
   pub IsRemote: BOOLEAN,
}
impl Default for _FILE_IS_REMOTE_DEVICE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "The FILE_IS_REMOTE_DEVICE_INFORMATION structure indicates whether the file system that contains the file is a remote file system."]
pub type FILE_IS_REMOTE_DEVICE_INFORMATION = _FILE_IS_REMOTE_DEVICE_INFORMATION;
#[doc = "The FILE_IS_REMOTE_DEVICE_INFORMATION structure indicates whether the file system that contains the file is a remote file system."]
pub type PFILE_IS_REMOTE_DEVICE_INFORMATION = *mut _FILE_IS_REMOTE_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NUMA_NODE_INFORMATION {
   pub NodeNumber: USHORT,
}
pub type FILE_NUMA_NODE_INFORMATION = _FILE_NUMA_NODE_INFORMATION;
pub type PFILE_NUMA_NODE_INFORMATION = *mut _FILE_NUMA_NODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
   pub IoStatusBlockRange: PUCHAR,
   pub Length: ULONG,
}
impl Default for _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_IOSTATUSBLOCK_RANGE_INFORMATION = _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
pub type PFILE_IOSTATUSBLOCK_RANGE_INFORMATION = *mut _FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION {
   pub StructureVersion: USHORT,
   pub StructureSize: USHORT,
   pub Protocol: ULONG,
   pub ProtocolMajorVersion: USHORT,
   pub ProtocolMinorVersion: USHORT,
   pub ProtocolRevision: USHORT,
   pub Reserved: USHORT,
   pub Flags: ULONG,
   pub GenericReserved: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_1,
   pub ProtocolSpecific: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_1 {
   pub Reserved: [ULONG; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2 {
   pub Smb2: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1,
   pub Reserved: [ULONG; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1 {
   pub Server: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
   pub Share: _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
   pub Capabilities: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
   pub Capabilities: ULONG,
   pub ShareFlags: ULONG,
   pub ShareType: UCHAR,
   pub Reserved0: [UCHAR; 3usize],
   pub Reserved1: ULONG,
}
impl Default for _FILE_REMOTE_PROTOCOL_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_REMOTE_PROTOCOL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_REMOTE_PROTOCOL_INFORMATION = _FILE_REMOTE_PROTOCOL_INFORMATION;
pub type PFILE_REMOTE_PROTOCOL_INFORMATION = *mut _FILE_REMOTE_PROTOCOL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_INTEGRITY_STREAM_INFORMATION {
   pub ChecksumAlgorithm: USHORT,
   pub ChecksumChunkShift: UCHAR,
   pub ClusterShift: UCHAR,
   pub Flags: ULONG,
}
pub type FILE_INTEGRITY_STREAM_INFORMATION = _FILE_INTEGRITY_STREAM_INFORMATION;
pub type PFILE_INTEGRITY_STREAM_INFORMATION = *mut _FILE_INTEGRITY_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_VOLUME_NAME_INFORMATION {
   pub DeviceNameLength: ULONG,
   pub DeviceName: [WCHAR; 1usize],
}
pub type FILE_VOLUME_NAME_INFORMATION = _FILE_VOLUME_NAME_INFORMATION;
pub type PFILE_VOLUME_NAME_INFORMATION = *mut _FILE_VOLUME_NAME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_INFORMATION {
   pub VolumeSerialNumber: ULONGLONG,
   pub __bindgen_anon_1: _FILE_ID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_ID_INFORMATION__bindgen_ty_1 {
   pub FileId: FILE_ID_128,
   pub __bindgen_anon_1: _FILE_ID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_ID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _FILE_ID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn FileIdLowPart(&self) -> LONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 64u8) as u64) }
   }
   #[inline]
   pub fn set_FileIdLowPart(&mut self, val: LONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 64u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FileIdLowPart_raw(this: *const Self) -> LONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            64u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_FileIdLowPart_raw(this: *mut Self, val: LONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            64u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn FileIdHighPart(&self) -> LONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 64u8) as u64) }
   }
   #[inline]
   pub fn set_FileIdHighPart(&mut self, val: LONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(64usize, 64u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FileIdHighPart_raw(this: *const Self) -> LONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 16usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            64usize,
            64u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_FileIdHighPart_raw(this: *mut Self, val: LONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 16usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            64usize,
            64u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FileIdLowPart: LONGLONG,
      FileIdHighPart: LONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 64u8, {
         let FileIdLowPart: u64 = unsafe { ::core::mem::transmute(FileIdLowPart) };
         FileIdLowPart as u64
      });
      __bindgen_bitfield_unit.set(64usize, 64u8, {
         let FileIdHighPart: u64 = unsafe { ::core::mem::transmute(FileIdHighPart) };
         FileIdHighPart as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _FILE_ID_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_ID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_INFORMATION = _FILE_ID_INFORMATION;
pub type PFILE_ID_INFORMATION = *mut _FILE_ID_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ReparsePointTag: ULONG,
   pub FileId: FILE_ID_128,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_EXTD_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_EXTD_DIR_INFORMATION = _FILE_ID_EXTD_DIR_INFORMATION;
pub type PFILE_ID_EXTD_DIR_INFORMATION = *mut _FILE_ID_EXTD_DIR_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_LINK_ENTRY_FULL_ID_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub ParentFileId: FILE_ID_128,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_LINK_ENTRY_FULL_ID_INFORMATION = _FILE_LINK_ENTRY_FULL_ID_INFORMATION;
pub type PFILE_LINK_ENTRY_FULL_ID_INFORMATION = *mut _FILE_LINK_ENTRY_FULL_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_LINKS_FULL_ID_INFORMATION {
   pub BytesNeeded: ULONG,
   pub EntriesReturned: ULONG,
   pub Entry: FILE_LINK_ENTRY_FULL_ID_INFORMATION,
}
pub type FILE_LINKS_FULL_ID_INFORMATION = _FILE_LINKS_FULL_ID_INFORMATION;
pub type PFILE_LINKS_FULL_ID_INFORMATION = *mut _FILE_LINKS_FULL_ID_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_BOTH_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ReparsePointTag: ULONG,
   pub FileId: FILE_ID_128,
   pub ShortNameLength: CCHAR,
   pub ShortName: [WCHAR; 12usize],
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_EXTD_BOTH_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_EXTD_BOTH_DIR_INFORMATION = _FILE_ID_EXTD_BOTH_DIR_INFORMATION;
pub type PFILE_ID_EXTD_BOTH_DIR_INFORMATION = *mut _FILE_ID_EXTD_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_64_EXTD_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ReparsePointTag: ULONG,
   pub FileId: LARGE_INTEGER,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_64_EXTD_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_64_EXTD_DIR_INFORMATION = _FILE_ID_64_EXTD_DIR_INFORMATION;
pub type PFILE_ID_64_EXTD_DIR_INFORMATION = *mut _FILE_ID_64_EXTD_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_64_EXTD_BOTH_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ReparsePointTag: ULONG,
   pub FileId: LARGE_INTEGER,
   pub ShortNameLength: CCHAR,
   pub ShortName: [WCHAR; 12usize],
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_64_EXTD_BOTH_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_64_EXTD_BOTH_DIR_INFORMATION = _FILE_ID_64_EXTD_BOTH_DIR_INFORMATION;
pub type PFILE_ID_64_EXTD_BOTH_DIR_INFORMATION = *mut _FILE_ID_64_EXTD_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_ALL_EXTD_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ReparsePointTag: ULONG,
   pub FileId: LARGE_INTEGER,
   pub FileId128: FILE_ID_128,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_ALL_EXTD_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_ALL_EXTD_DIR_INFORMATION = _FILE_ID_ALL_EXTD_DIR_INFORMATION;
pub type PFILE_ID_ALL_EXTD_DIR_INFORMATION = *mut _FILE_ID_ALL_EXTD_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ReparsePointTag: ULONG,
   pub FileId: LARGE_INTEGER,
   pub FileId128: FILE_ID_128,
   pub ShortNameLength: CCHAR,
   pub ShortName: [WCHAR; 12usize],
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION = _FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION;
pub type PFILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION = *mut _FILE_ID_ALL_EXTD_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STAT_INFORMATION {
   pub FileId: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub ReparseTag: ULONG,
   pub NumberOfLinks: ULONG,
   pub EffectiveAccess: ACCESS_MASK,
}
impl Default for _FILE_STAT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STAT_INFORMATION = _FILE_STAT_INFORMATION;
pub type PFILE_STAT_INFORMATION = *mut _FILE_STAT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STAT_BASIC_INFORMATION {
   pub FileId: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub ReparseTag: ULONG,
   pub NumberOfLinks: ULONG,
   pub DeviceType: ULONG,
   pub DeviceCharacteristics: ULONG,
   pub Reserved: ULONG,
   pub VolumeSerialNumber: LARGE_INTEGER,
   pub FileId128: FILE_ID_128,
}
impl Default for _FILE_STAT_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STAT_BASIC_INFORMATION = _FILE_STAT_BASIC_INFORMATION;
pub type PFILE_STAT_BASIC_INFORMATION = *mut _FILE_STAT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MEMORY_PARTITION_INFORMATION {
   pub OwnerPartitionHandle: HANDLE,
   pub Flags: _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub AllFlags: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub NoCrossPartitionAccess: UCHAR,
   pub Spare: [UCHAR; 3usize],
}
impl Default for _FILE_MEMORY_PARTITION_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_MEMORY_PARTITION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_MEMORY_PARTITION_INFORMATION = _FILE_MEMORY_PARTITION_INFORMATION;
pub type PFILE_MEMORY_PARTITION_INFORMATION = *mut _FILE_MEMORY_PARTITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STAT_LX_INFORMATION {
   pub FileId: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub ReparseTag: ULONG,
   pub NumberOfLinks: ULONG,
   pub EffectiveAccess: ACCESS_MASK,
   pub LxFlags: ULONG,
   pub LxUid: ULONG,
   pub LxGid: ULONG,
   pub LxMode: ULONG,
   pub LxDeviceIdMajor: ULONG,
   pub LxDeviceIdMinor: ULONG,
}
impl Default for _FILE_STAT_LX_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STAT_LX_INFORMATION = _FILE_STAT_LX_INFORMATION;
pub type PFILE_STAT_LX_INFORMATION = *mut _FILE_STAT_LX_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_RESERVE_ID_INFORMATION {
   pub StorageReserveId: STORAGE_RESERVE_ID,
}
impl Default for _FILE_STORAGE_RESERVE_ID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_STORAGE_RESERVE_ID_INFORMATION = _FILE_STORAGE_RESERVE_ID_INFORMATION;
pub type PFILE_STORAGE_RESERVE_ID_INFORMATION = *mut _FILE_STORAGE_RESERVE_ID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_CASE_SENSITIVE_INFORMATION {
   pub Flags: ULONG,
}
pub type FILE_CASE_SENSITIVE_INFORMATION = _FILE_CASE_SENSITIVE_INFORMATION;
pub type PFILE_CASE_SENSITIVE_INFORMATION = *mut _FILE_CASE_SENSITIVE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_KNOWN_FOLDER_TYPE {
   KnownFolderNone = 0,
   KnownFolderDesktop = 1,
   KnownFolderDocuments = 2,
   KnownFolderDownloads = 3,
   KnownFolderMusic = 4,
   KnownFolderPictures = 5,
   KnownFolderVideos = 6,
   KnownFolderOther = 7,
   KnownFolderMax = 8,
}
pub use self::_FILE_KNOWN_FOLDER_TYPE as FILE_KNOWN_FOLDER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_KNOWN_FOLDER_INFORMATION {
   pub Type: FILE_KNOWN_FOLDER_TYPE,
}
impl Default for _FILE_KNOWN_FOLDER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_KNOWN_FOLDER_INFORMATION = _FILE_KNOWN_FOLDER_INFORMATION;
pub type PFILE_KNOWN_FOLDER_INFORMATION = *mut _FILE_KNOWN_FOLDER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_STREAM_RESERVATION_INFORMATION {
   pub TrackedReservation: ULONG_PTR,
   pub EnforcedReservation: ULONG_PTR,
}
pub type FILE_STREAM_RESERVATION_INFORMATION = _FILE_STREAM_RESERVATION_INFORMATION;
pub type PFILE_STREAM_RESERVATION_INFORMATION = *mut _FILE_STREAM_RESERVATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MUP_PROVIDER_INFORMATION {
   pub Level: ULONG,
   pub Buffer: PVOID,
   pub BufferSize: PULONG,
}
impl Default for _MUP_PROVIDER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MUP_PROVIDER_INFORMATION = _MUP_PROVIDER_INFORMATION;
pub type PMUP_PROVIDER_INFORMATION = *mut _MUP_PROVIDER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_INFORMATION_DEFINITION {
   pub Class: FILE_INFORMATION_CLASS,
   pub NextEntryOffset: ULONG,
   pub FileNameOffset: ULONG,
   pub FileNameLengthOffset: ULONG,
}
impl Default for _FILE_INFORMATION_DEFINITION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_INFORMATION_DEFINITION = _FILE_INFORMATION_DEFINITION;
pub type PFILE_INFORMATION_DEFINITION = *mut _FILE_INFORMATION_DEFINITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_DIRECTORY_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_DIRECTORY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_DIRECTORY_INFORMATION = _FILE_DIRECTORY_INFORMATION;
pub type PFILE_DIRECTORY_INFORMATION = *mut _FILE_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_FULL_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FULL_DIR_INFORMATION = _FILE_FULL_DIR_INFORMATION;
pub type PFILE_FULL_DIR_INFORMATION = *mut _FILE_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_FULL_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub FileId: LARGE_INTEGER,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_FULL_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_FULL_DIR_INFORMATION = _FILE_ID_FULL_DIR_INFORMATION;
pub type PFILE_ID_FULL_DIR_INFORMATION = *mut _FILE_ID_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BOTH_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ShortNameLength: CCHAR,
   pub ShortName: [WCHAR; 12usize],
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_BOTH_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_BOTH_DIR_INFORMATION = _FILE_BOTH_DIR_INFORMATION;
pub type PFILE_BOTH_DIR_INFORMATION = *mut _FILE_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_BOTH_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub EaSize: ULONG,
   pub ShortNameLength: CCHAR,
   pub ShortName: [WCHAR; 12usize],
   pub FileId: LARGE_INTEGER,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_BOTH_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_BOTH_DIR_INFORMATION = _FILE_ID_BOTH_DIR_INFORMATION;
pub type PFILE_ID_BOTH_DIR_INFORMATION = *mut _FILE_ID_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NAMES_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub FileNameLength: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type FILE_NAMES_INFORMATION = _FILE_NAMES_INFORMATION;
pub type PFILE_NAMES_INFORMATION = *mut _FILE_NAMES_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub FileIndex: ULONG,
   pub CreationTime: LARGE_INTEGER,
   pub LastAccessTime: LARGE_INTEGER,
   pub LastWriteTime: LARGE_INTEGER,
   pub ChangeTime: LARGE_INTEGER,
   pub EndOfFile: LARGE_INTEGER,
   pub AllocationSize: LARGE_INTEGER,
   pub FileAttributes: ULONG,
   pub FileNameLength: ULONG,
   pub FileId: LARGE_INTEGER,
   pub LockingTransactionId: GUID,
   pub TxInfoFlags: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _FILE_ID_GLOBAL_TX_DIR_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_ID_GLOBAL_TX_DIR_INFORMATION = _FILE_ID_GLOBAL_TX_DIR_INFORMATION;
pub type PFILE_ID_GLOBAL_TX_DIR_INFORMATION = *mut _FILE_ID_GLOBAL_TX_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION {
   pub FileReference: ULONGLONG,
   pub ObjectId: [UCHAR; 16usize],
   pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub BirthVolumeId: [UCHAR; 16usize],
   pub BirthObjectId: [UCHAR; 16usize],
   pub DomainId: [UCHAR; 16usize],
}
impl Default for _FILE_OBJECTID_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_OBJECTID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_OBJECTID_INFORMATION = _FILE_OBJECTID_INFORMATION;
pub type PFILE_OBJECTID_INFORMATION = *mut _FILE_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_DIRECTORY_NEXT_INFORMATION {
   pub NextEntryOffset: ULONG,
}
pub type FILE_DIRECTORY_NEXT_INFORMATION = _FILE_DIRECTORY_NEXT_INFORMATION;
pub type PFILE_DIRECTORY_NEXT_INFORMATION = *mut _FILE_DIRECTORY_NEXT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub Flags: UCHAR,
   pub EaNameLength: UCHAR,
   pub EaValueLength: USHORT,
   pub EaName: [CHAR; 1usize],
}
pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_GET_EA_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub EaNameLength: UCHAR,
   pub EaName: [CHAR; 1usize],
}
pub type FILE_GET_EA_INFORMATION = _FILE_GET_EA_INFORMATION;
pub type PFILE_GET_EA_INFORMATION = *mut _FILE_GET_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_GET_QUOTA_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub SidLength: ULONG,
   pub Sid: SID,
}
pub type FILE_GET_QUOTA_INFORMATION = _FILE_GET_QUOTA_INFORMATION;
pub type PFILE_GET_QUOTA_INFORMATION = *mut _FILE_GET_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUOTA_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub SidLength: ULONG,
   pub ChangeTime: LARGE_INTEGER,
   pub QuotaUsed: LARGE_INTEGER,
   pub QuotaThreshold: LARGE_INTEGER,
   pub QuotaLimit: LARGE_INTEGER,
   pub Sid: SID,
}
impl Default for _FILE_QUOTA_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_QUOTA_INFORMATION = _FILE_QUOTA_INFORMATION;
pub type PFILE_QUOTA_INFORMATION = *mut _FILE_QUOTA_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FSINFOCLASS {
   FileFsVolumeInformation = 1,
   FileFsLabelInformation = 2,
   FileFsSizeInformation = 3,
   FileFsDeviceInformation = 4,
   FileFsAttributeInformation = 5,
   FileFsControlInformation = 6,
   FileFsFullSizeInformation = 7,
   FileFsObjectIdInformation = 8,
   FileFsDriverPathInformation = 9,
   FileFsVolumeFlagsInformation = 10,
   FileFsSectorSizeInformation = 11,
   FileFsDataCopyInformation = 12,
   FileFsMetadataSizeInformation = 13,
   FileFsFullSizeInformationEx = 14,
   FileFsGuidInformation = 15,
   FileFsMaximumInformation = 16,
}
pub use self::_FSINFOCLASS as FSINFOCLASS;
pub type PFSINFOCLASS = *mut _FSINFOCLASS;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
#[repr(C)]
pub struct _FILE_FS_VOLUME_INFORMATION {
   pub VolumeCreationTime: LARGE_INTEGER,
   pub VolumeSerialNumber: ULONG,
   pub VolumeLabelLength: ULONG,
   pub SupportsObjects: BOOLEAN,
   pub VolumeLabel: [WCHAR; 1usize],
}
impl Default for _FILE_FS_VOLUME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_VOLUME_INFORMATION = _FILE_FS_VOLUME_INFORMATION;
pub type PFILE_FS_VOLUME_INFORMATION = *mut _FILE_FS_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_LABEL_INFORMATION {
   pub VolumeLabelLength: ULONG,
   pub VolumeLabel: [WCHAR; 1usize],
}
pub type FILE_FS_LABEL_INFORMATION = _FILE_FS_LABEL_INFORMATION;
pub type PFILE_FS_LABEL_INFORMATION = *mut _FILE_FS_LABEL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_SIZE_INFORMATION {
   pub TotalAllocationUnits: LARGE_INTEGER,
   pub AvailableAllocationUnits: LARGE_INTEGER,
   pub SectorsPerAllocationUnit: ULONG,
   pub BytesPerSector: ULONG,
}
impl Default for _FILE_FS_SIZE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_SIZE_INFORMATION = _FILE_FS_SIZE_INFORMATION;
pub type PFILE_FS_SIZE_INFORMATION = *mut _FILE_FS_SIZE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_CONTROL_INFORMATION {
   pub FreeSpaceStartFiltering: LARGE_INTEGER,
   pub FreeSpaceThreshold: LARGE_INTEGER,
   pub FreeSpaceStopFiltering: LARGE_INTEGER,
   pub DefaultQuotaThreshold: LARGE_INTEGER,
   pub DefaultQuotaLimit: LARGE_INTEGER,
   pub FileSystemControlFlags: ULONG,
}
impl Default for _FILE_FS_CONTROL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_CONTROL_INFORMATION = _FILE_FS_CONTROL_INFORMATION;
pub type PFILE_FS_CONTROL_INFORMATION = *mut _FILE_FS_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION {
   pub TotalAllocationUnits: LARGE_INTEGER,
   pub CallerAvailableAllocationUnits: LARGE_INTEGER,
   pub ActualAvailableAllocationUnits: LARGE_INTEGER,
   pub SectorsPerAllocationUnit: ULONG,
   pub BytesPerSector: ULONG,
}
impl Default for _FILE_FS_FULL_SIZE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_FULL_SIZE_INFORMATION = _FILE_FS_FULL_SIZE_INFORMATION;
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut _FILE_FS_FULL_SIZE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION {
   pub ObjectId: [UCHAR; 16usize],
   pub __bindgen_anon_1: _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub BirthVolumeId: [UCHAR; 16usize],
   pub BirthObjectId: [UCHAR; 16usize],
   pub DomainId: [UCHAR; 16usize],
}
impl Default for _FILE_FS_OBJECTID_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _FILE_FS_OBJECTID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_OBJECTID_INFORMATION = _FILE_FS_OBJECTID_INFORMATION;
pub type PFILE_FS_OBJECTID_INFORMATION = *mut _FILE_FS_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_DEVICE_INFORMATION {
   pub DeviceType: DWORD,
   pub Characteristics: ULONG,
}
pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_ATTRIBUTE_INFORMATION {
   pub FileSystemAttributes: ULONG,
   pub MaximumComponentNameLength: LONG,
   pub FileSystemNameLength: ULONG,
   pub FileSystemName: [WCHAR; 1usize],
}
pub type FILE_FS_ATTRIBUTE_INFORMATION = _FILE_FS_ATTRIBUTE_INFORMATION;
pub type PFILE_FS_ATTRIBUTE_INFORMATION = *mut _FILE_FS_ATTRIBUTE_INFORMATION;
#[repr(C)]
pub struct _FILE_FS_DRIVER_PATH_INFORMATION {
   pub DriverInPath: BOOLEAN,
   pub DriverNameLength: ULONG,
   pub DriverName: [WCHAR; 1usize],
}
impl Default for _FILE_FS_DRIVER_PATH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_DRIVER_PATH_INFORMATION = _FILE_FS_DRIVER_PATH_INFORMATION;
pub type PFILE_FS_DRIVER_PATH_INFORMATION = *mut _FILE_FS_DRIVER_PATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_VOLUME_FLAGS_INFORMATION {
   pub Flags: ULONG,
}
pub type FILE_FS_VOLUME_FLAGS_INFORMATION = _FILE_FS_VOLUME_FLAGS_INFORMATION;
pub type PFILE_FS_VOLUME_FLAGS_INFORMATION = *mut _FILE_FS_VOLUME_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_SECTOR_SIZE_INFORMATION {
   pub LogicalBytesPerSector: ULONG,
   pub PhysicalBytesPerSectorForAtomicity: ULONG,
   pub PhysicalBytesPerSectorForPerformance: ULONG,
   pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity: ULONG,
   pub Flags: ULONG,
   pub ByteOffsetForSectorAlignment: ULONG,
   pub ByteOffsetForPartitionAlignment: ULONG,
}
pub type FILE_FS_SECTOR_SIZE_INFORMATION = _FILE_FS_SECTOR_SIZE_INFORMATION;
pub type PFILE_FS_SECTOR_SIZE_INFORMATION = *mut _FILE_FS_SECTOR_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_DATA_COPY_INFORMATION {
   pub NumberOfCopies: ULONG,
}
pub type FILE_FS_DATA_COPY_INFORMATION = _FILE_FS_DATA_COPY_INFORMATION;
pub type PFILE_FS_DATA_COPY_INFORMATION = *mut _FILE_FS_DATA_COPY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_METADATA_SIZE_INFORMATION {
   pub TotalMetadataAllocationUnits: LARGE_INTEGER,
   pub SectorsPerAllocationUnit: ULONG,
   pub BytesPerSector: ULONG,
}
impl Default for _FILE_FS_METADATA_SIZE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_FS_METADATA_SIZE_INFORMATION = _FILE_FS_METADATA_SIZE_INFORMATION;
pub type PFILE_FS_METADATA_SIZE_INFORMATION = *mut _FILE_FS_METADATA_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION_EX {
   pub ActualTotalAllocationUnits: ULONGLONG,
   pub ActualAvailableAllocationUnits: ULONGLONG,
   pub ActualPoolUnavailableAllocationUnits: ULONGLONG,
   pub CallerTotalAllocationUnits: ULONGLONG,
   pub CallerAvailableAllocationUnits: ULONGLONG,
   pub CallerPoolUnavailableAllocationUnits: ULONGLONG,
   pub UsedAllocationUnits: ULONGLONG,
   pub TotalReservedAllocationUnits: ULONGLONG,
   pub VolumeStorageReserveAllocationUnits: ULONGLONG,
   pub AvailableCommittedAllocationUnits: ULONGLONG,
   pub PoolAvailableAllocationUnits: ULONGLONG,
   pub SectorsPerAllocationUnit: ULONG,
   pub BytesPerSector: ULONG,
}
pub type FILE_FS_FULL_SIZE_INFORMATION_EX = _FILE_FS_FULL_SIZE_INFORMATION_EX;
pub type PFILE_FS_FULL_SIZE_INFORMATION_EX = *mut _FILE_FS_FULL_SIZE_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FS_GUID_INFORMATION {
   pub FsGuid: GUID,
}
pub type FILE_FS_GUID_INFORMATION = _FILE_FS_GUID_INFORMATION;
pub type PFILE_FS_GUID_INFORMATION = *mut _FILE_FS_GUID_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DIRECTORY_NOTIFY_INFORMATION_CLASS {
   DirectoryNotifyInformation = 1,
   DirectoryNotifyExtendedInformation = 2,
   DirectoryNotifyFullInformation = 3,
   DirectoryNotifyMaximumInformation = 4,
}
pub use self::_DIRECTORY_NOTIFY_INFORMATION_CLASS as DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub type PDIRECTORY_NOTIFY_INFORMATION_CLASS = *mut _DIRECTORY_NOTIFY_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_COMPLETION_INFORMATION_CLASS {
   IoCompletionBasicInformation = 0,
}
pub use self::_IO_COMPLETION_INFORMATION_CLASS as IO_COMPLETION_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_COMPLETION_BASIC_INFORMATION {
   pub Depth: LONG,
}
pub type IO_COMPLETION_BASIC_INFORMATION = _IO_COMPLETION_BASIC_INFORMATION;
pub type PIO_COMPLETION_BASIC_INFORMATION = *mut _IO_COMPLETION_BASIC_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_SESSION_EVENT {
   IoSessionEventIgnore = 0,
   IoSessionEventCreated = 1,
   IoSessionEventTerminated = 2,
   IoSessionEventConnected = 3,
   IoSessionEventDisconnected = 4,
   IoSessionEventLogon = 5,
   IoSessionEventLogoff = 6,
   IoSessionEventMax = 7,
}
pub use self::_IO_SESSION_EVENT as IO_SESSION_EVENT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_SESSION_STATE {
   IoSessionStateCreated = 1,
   IoSessionStateInitialized = 2,
   IoSessionStateConnected = 3,
   IoSessionStateDisconnected = 4,
   IoSessionStateDisconnectedLoggedOn = 5,
   IoSessionStateLoggedOn = 6,
   IoSessionStateLoggedOff = 7,
   IoSessionStateTerminated = 8,
   IoSessionStateMax = 9,
}
pub use self::_IO_SESSION_STATE as IO_SESSION_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _INTERFACE_TYPE {
   InterfaceTypeUndefined = -1,
   Internal = 0,
   Isa = 1,
   Eisa = 2,
   MicroChannel = 3,
   TurboChannel = 4,
   PCIBus = 5,
   VMEBus = 6,
   NuBus = 7,
   PCMCIABus = 8,
   CBus = 9,
   MPIBus = 10,
   MPSABus = 11,
   ProcessorInternal = 12,
   InternalPowerBus = 13,
   PNPISABus = 14,
   PNPBus = 15,
   Vmcs = 16,
   ACPIBus = 17,
   MaximumInterfaceType = 18,
}
pub use self::_INTERFACE_TYPE as INTERFACE_TYPE;
pub type PINTERFACE_TYPE = *mut _INTERFACE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DMA_WIDTH {
   Width8Bits = 0,
   Width16Bits = 1,
   Width32Bits = 2,
   Width64Bits = 3,
   WidthNoWrap = 4,
   MaximumDmaWidth = 5,
}
pub use self::_DMA_WIDTH as DMA_WIDTH;
pub type PDMA_WIDTH = *mut _DMA_WIDTH;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DMA_SPEED {
   Compatible = 0,
   TypeA = 1,
   TypeB = 2,
   TypeC = 3,
   TypeF = 4,
   MaximumDmaSpeed = 5,
}
pub use self::_DMA_SPEED as DMA_SPEED;
pub type PDMA_SPEED = *mut _DMA_SPEED;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BUS_DATA_TYPE {
   ConfigurationSpaceUndefined = -1,
   Cmos = 0,
   EisaConfiguration = 1,
   Pos = 2,
   CbusConfiguration = 3,
   PCIConfiguration = 4,
   VMEConfiguration = 5,
   NuBusConfiguration = 6,
   PCMCIAConfiguration = 7,
   MPIConfiguration = 8,
   MPSAConfiguration = 9,
   PNPISAConfiguration = 10,
   SgiInternalConfiguration = 11,
   MaximumBusDataType = 12,
}
pub use self::_BUS_DATA_TYPE as BUS_DATA_TYPE;
pub type PBUS_DATA_TYPE = *mut _BUS_DATA_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER {
   pub ReparseTag: ULONG,
   pub ReparseDataLength: USHORT,
   pub Reserved: USHORT,
   pub __bindgen_anon_1: _REPARSE_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REPARSE_DATA_BUFFER__bindgen_ty_1 {
   pub SymbolicLinkReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1,
   pub MountPointReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2,
   pub AppExecLinkReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3,
   pub GenericReparseBuffer: _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1 {
   pub SubstituteNameOffset: USHORT,
   pub SubstituteNameLength: USHORT,
   pub PrintNameOffset: USHORT,
   pub PrintNameLength: USHORT,
   pub Flags: ULONG,
   pub PathBuffer: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2 {
   pub SubstituteNameOffset: USHORT,
   pub SubstituteNameLength: USHORT,
   pub PrintNameOffset: USHORT,
   pub PrintNameLength: USHORT,
   pub PathBuffer: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3 {
   pub StringCount: ULONG,
   pub StringList: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4 {
   pub DataBuffer: [UCHAR; 1usize],
}
impl Default for _REPARSE_DATA_BUFFER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _REPARSE_DATA_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type REPARSE_DATA_BUFFER = _REPARSE_DATA_BUFFER;
pub type PREPARSE_DATA_BUFFER = *mut _REPARSE_DATA_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPARSE_DATA_BUFFER_EX {
   pub Flags: ULONG,
   pub ExistingReparseTag: ULONG,
   pub ExistingReparseGuid: GUID,
   pub Reserved: ULONGLONG,
   pub __bindgen_anon_1: _REPARSE_DATA_BUFFER_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REPARSE_DATA_BUFFER_EX__bindgen_ty_1 {
   pub ReparseDataBuffer: REPARSE_DATA_BUFFER,
   pub ReparseGuidDataBuffer: REPARSE_GUID_DATA_BUFFER,
}
impl Default for _REPARSE_DATA_BUFFER_EX__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _REPARSE_DATA_BUFFER_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type REPARSE_DATA_BUFFER_EX = _REPARSE_DATA_BUFFER_EX;
pub type PREPARSE_DATA_BUFFER_EX = *mut _REPARSE_DATA_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_ASSIGN_EVENT_BUFFER {
   pub EventHandle: HANDLE,
   pub KeyValue: ULONG,
}
impl Default for _FILE_PIPE_ASSIGN_EVENT_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_ASSIGN_EVENT_BUFFER = _FILE_PIPE_ASSIGN_EVENT_BUFFER;
pub type PFILE_PIPE_ASSIGN_EVENT_BUFFER = *mut _FILE_PIPE_ASSIGN_EVENT_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_PEEK_BUFFER {
   pub NamedPipeState: ULONG,
   pub ReadDataAvailable: ULONG,
   pub NumberOfMessages: ULONG,
   pub MessageLength: ULONG,
   pub Data: [CHAR; 1usize],
}
pub type FILE_PIPE_PEEK_BUFFER = _FILE_PIPE_PEEK_BUFFER;
pub type PFILE_PIPE_PEEK_BUFFER = *mut _FILE_PIPE_PEEK_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_EVENT_BUFFER {
   pub NamedPipeState: ULONG,
   pub EntryType: ULONG,
   pub ByteCount: ULONG,
   pub KeyValue: ULONG,
   pub NumberRequests: ULONG,
}
pub type FILE_PIPE_EVENT_BUFFER = _FILE_PIPE_EVENT_BUFFER;
pub type PFILE_PIPE_EVENT_BUFFER = *mut _FILE_PIPE_EVENT_BUFFER;
#[repr(C)]
pub struct _FILE_PIPE_WAIT_FOR_BUFFER {
   pub Timeout: LARGE_INTEGER,
   pub NameLength: ULONG,
   pub TimeoutSpecified: BOOLEAN,
   pub Name: [WCHAR; 1usize],
}
impl Default for _FILE_PIPE_WAIT_FOR_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_WAIT_FOR_BUFFER = _FILE_PIPE_WAIT_FOR_BUFFER;
pub type PFILE_PIPE_WAIT_FOR_BUFFER = *mut _FILE_PIPE_WAIT_FOR_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER {
   pub ClientSession: PVOID,
   pub ClientProcess: PVOID,
}
impl Default for _FILE_PIPE_CLIENT_PROCESS_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER = _FILE_PIPE_CLIENT_PROCESS_BUFFER;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
   pub ClientSession: ULONGLONG,
   pub ClientProcess: PVOID,
}
impl Default for _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 = _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER_V2 = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
   pub ClientSession: PVOID,
   pub ClientProcess: PVOID,
   pub ClientComputerNameLength: USHORT,
   pub ClientComputerBuffer: [WCHAR; 16usize],
}
impl Default for _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_CLIENT_PROCESS_BUFFER_EX = _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX;
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX = *mut _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_SILO_ARRIVAL_INPUT {
   pub JobHandle: HANDLE,
}
impl Default for _FILE_PIPE_SILO_ARRIVAL_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FILE_PIPE_SILO_ARRIVAL_INPUT = _FILE_PIPE_SILO_ARRIVAL_INPUT;
pub type PFILE_PIPE_SILO_ARRIVAL_INPUT = *mut _FILE_PIPE_SILO_ARRIVAL_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_CREATE_SYMLINK_INPUT {
   pub NameOffset: USHORT,
   pub NameLength: USHORT,
   pub SubstituteNameOffset: USHORT,
   pub SubstituteNameLength: USHORT,
   pub Flags: ULONG,
}
pub type FILE_PIPE_CREATE_SYMLINK_INPUT = _FILE_PIPE_CREATE_SYMLINK_INPUT;
pub type PFILE_PIPE_CREATE_SYMLINK_INPUT = *mut _FILE_PIPE_CREATE_SYMLINK_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_PIPE_DELETE_SYMLINK_INPUT {
   pub NameOffset: USHORT,
   pub NameLength: USHORT,
}
pub type FILE_PIPE_DELETE_SYMLINK_INPUT = _FILE_PIPE_DELETE_SYMLINK_INPUT;
pub type PFILE_PIPE_DELETE_SYMLINK_INPUT = *mut _FILE_PIPE_DELETE_SYMLINK_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_MAILSLOT_PEEK_BUFFER {
   pub ReadDataAvailable: ULONG,
   pub NumberOfMessages: ULONG,
   pub MessageLength: ULONG,
}
pub type FILE_MAILSLOT_PEEK_BUFFER = _FILE_MAILSLOT_PEEK_BUFFER;
pub type PFILE_MAILSLOT_PEEK_BUFFER = *mut _FILE_MAILSLOT_PEEK_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_CREATE_POINT_INPUT {
   pub SymbolicLinkNameOffset: USHORT,
   pub SymbolicLinkNameLength: USHORT,
   pub DeviceNameOffset: USHORT,
   pub DeviceNameLength: USHORT,
}
pub type MOUNTMGR_CREATE_POINT_INPUT = _MOUNTMGR_CREATE_POINT_INPUT;
pub type PMOUNTMGR_CREATE_POINT_INPUT = *mut _MOUNTMGR_CREATE_POINT_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_MOUNT_POINT {
   pub SymbolicLinkNameOffset: ULONG,
   pub SymbolicLinkNameLength: USHORT,
   pub Reserved1: USHORT,
   pub UniqueIdOffset: ULONG,
   pub UniqueIdLength: USHORT,
   pub Reserved2: USHORT,
   pub DeviceNameOffset: ULONG,
   pub DeviceNameLength: USHORT,
   pub Reserved3: USHORT,
}
pub type MOUNTMGR_MOUNT_POINT = _MOUNTMGR_MOUNT_POINT;
pub type PMOUNTMGR_MOUNT_POINT = *mut _MOUNTMGR_MOUNT_POINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_MOUNT_POINTS {
   pub Size: ULONG,
   pub NumberOfMountPoints: ULONG,
   pub MountPoints: [MOUNTMGR_MOUNT_POINT; 1usize],
}
pub type MOUNTMGR_MOUNT_POINTS = _MOUNTMGR_MOUNT_POINTS;
pub type PMOUNTMGR_MOUNT_POINTS = *mut _MOUNTMGR_MOUNT_POINTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_DRIVE_LETTER_TARGET {
   pub DeviceNameLength: USHORT,
   pub DeviceName: [WCHAR; 1usize],
}
pub type MOUNTMGR_DRIVE_LETTER_TARGET = _MOUNTMGR_DRIVE_LETTER_TARGET;
pub type PMOUNTMGR_DRIVE_LETTER_TARGET = *mut _MOUNTMGR_DRIVE_LETTER_TARGET;
#[repr(C)]
pub struct _MOUNTMGR_DRIVE_LETTER_INFORMATION {
   pub DriveLetterWasAssigned: BOOLEAN,
   pub CurrentDriveLetter: UCHAR,
}
impl Default for _MOUNTMGR_DRIVE_LETTER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOUNTMGR_DRIVE_LETTER_INFORMATION = _MOUNTMGR_DRIVE_LETTER_INFORMATION;
pub type PMOUNTMGR_DRIVE_LETTER_INFORMATION = *mut _MOUNTMGR_DRIVE_LETTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_VOLUME_MOUNT_POINT {
   pub SourceVolumeNameOffset: USHORT,
   pub SourceVolumeNameLength: USHORT,
   pub TargetVolumeNameOffset: USHORT,
   pub TargetVolumeNameLength: USHORT,
}
pub type MOUNTMGR_VOLUME_MOUNT_POINT = _MOUNTMGR_VOLUME_MOUNT_POINT;
pub type PMOUNTMGR_VOLUME_MOUNT_POINT = *mut _MOUNTMGR_VOLUME_MOUNT_POINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_CHANGE_NOTIFY_INFO {
   pub EpicNumber: ULONG,
}
pub type MOUNTMGR_CHANGE_NOTIFY_INFO = _MOUNTMGR_CHANGE_NOTIFY_INFO;
pub type PMOUNTMGR_CHANGE_NOTIFY_INFO = *mut _MOUNTMGR_CHANGE_NOTIFY_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_TARGET_NAME {
   pub DeviceNameLength: USHORT,
   pub DeviceName: [WCHAR; 1usize],
}
pub type MOUNTMGR_TARGET_NAME = _MOUNTMGR_TARGET_NAME;
pub type PMOUNTMGR_TARGET_NAME = *mut _MOUNTMGR_TARGET_NAME;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MOUNTMGR_AUTO_MOUNT_STATE {
   Disabled = 0,
   Enabled = 1,
}
pub use self::_MOUNTMGR_AUTO_MOUNT_STATE as MOUNTMGR_AUTO_MOUNT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOUNTMGR_QUERY_AUTO_MOUNT {
   pub CurrentState: MOUNTMGR_AUTO_MOUNT_STATE,
}
impl Default for _MOUNTMGR_QUERY_AUTO_MOUNT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOUNTMGR_QUERY_AUTO_MOUNT = _MOUNTMGR_QUERY_AUTO_MOUNT;
pub type PMOUNTMGR_QUERY_AUTO_MOUNT = *mut _MOUNTMGR_QUERY_AUTO_MOUNT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOUNTMGR_SET_AUTO_MOUNT {
   pub NewState: MOUNTMGR_AUTO_MOUNT_STATE,
}
impl Default for _MOUNTMGR_SET_AUTO_MOUNT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOUNTMGR_SET_AUTO_MOUNT = _MOUNTMGR_SET_AUTO_MOUNT;
pub type PMOUNTMGR_SET_AUTO_MOUNT = *mut _MOUNTMGR_SET_AUTO_MOUNT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOUNTMGR_SILO_ARRIVAL_INPUT {
   pub JobHandle: HANDLE,
}
impl Default for _MOUNTMGR_SILO_ARRIVAL_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOUNTMGR_SILO_ARRIVAL_INPUT = _MOUNTMGR_SILO_ARRIVAL_INPUT;
pub type PMOUNTMGR_SILO_ARRIVAL_INPUT = *mut _MOUNTMGR_SILO_ARRIVAL_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTDEV_NAME {
   pub NameLength: USHORT,
   pub Name: [WCHAR; 1usize],
}
pub type MOUNTDEV_NAME = _MOUNTDEV_NAME;
pub type PMOUNTDEV_NAME = *mut _MOUNTDEV_NAME;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MOUNTMGR_VOLUME_PATHS {
   pub MultiSzLength: ULONG,
   pub MultiSz: [WCHAR; 1usize],
}
pub type MOUNTMGR_VOLUME_PATHS = _MOUNTMGR_VOLUME_PATHS;
pub type PMOUNTMGR_VOLUME_PATHS = *mut _MOUNTMGR_VOLUME_PATHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_CONNECT_CONTEXT {
   pub PortName: PUNICODE_STRING,
   pub PortName64: PUNICODE_STRING64,
   pub SizeOfContext: USHORT,
   pub Padding: [UCHAR; 6usize],
   pub Context: [UCHAR; 1usize],
}
impl Default for _FLT_CONNECT_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FLT_CONNECT_CONTEXT = _FLT_CONNECT_CONTEXT;
pub type PFLT_CONNECT_CONTEXT = *mut _FLT_CONNECT_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PORT_FULL_EA {
   pub NextEntryOffset: ULONG,
   pub Flags: UCHAR,
   pub EaNameLength: UCHAR,
   pub EaValueLength: USHORT,
   pub EaName: [CHAR; 8usize],
   pub EaValue: FLT_CONNECT_CONTEXT,
}
impl Default for _FLT_PORT_FULL_EA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FLT_PORT_FULL_EA = _FLT_PORT_FULL_EA;
pub type PFLT_PORT_FULL_EA = *mut _FLT_PORT_FULL_EA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_LOAD_PARAMETERS {
   pub FilterNameSize: USHORT,
   pub FilterName: [WCHAR; 1usize],
}
pub type FLT_LOAD_PARAMETERS = _FLT_LOAD_PARAMETERS;
pub type PFLT_LOAD_PARAMETERS = *mut _FLT_LOAD_PARAMETERS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FLT_LINK_TYPE {
   FILTER = 0,
   FILTER_INSTANCE = 1,
   FILTER_VOLUME = 2,
   FILTER_MANAGER = 3,
   FILTER_MANAGER_VOLUME = 4,
}
pub use self::_FLT_LINK_TYPE as FLT_LINK_TYPE;
pub type PFLT_LINK_TYPE = *mut _FLT_LINK_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_LINK {
   pub Type: FLT_LINK_TYPE,
   pub ParametersOffset: ULONG,
}
impl Default for _FLT_LINK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FLT_LINK = _FLT_LINK;
pub type PFLT_LINK = *mut _FLT_LINK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_FILTER_PARAMETERS {
   pub FilterNameSize: USHORT,
   pub FilterNameOffset: USHORT,
}
pub type FLT_FILTER_PARAMETERS = _FLT_FILTER_PARAMETERS;
pub type PFLT_FILTER_PARAMETERS = *mut _FLT_FILTER_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_INSTANCE_PARAMETERS {
   pub FilterNameSize: USHORT,
   pub FilterNameOffset: USHORT,
   pub VolumeNameSize: USHORT,
   pub VolumeNameOffset: USHORT,
   pub InstanceNameSize: USHORT,
   pub InstanceNameOffset: USHORT,
}
pub type FLT_INSTANCE_PARAMETERS = _FLT_INSTANCE_PARAMETERS;
pub type PFLT_INSTANCE_PARAMETERS = *mut _FLT_INSTANCE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_VOLUME_PARAMETERS {
   pub VolumeNameSize: USHORT,
   pub VolumeNameOffset: USHORT,
}
pub type FLT_VOLUME_PARAMETERS = _FLT_VOLUME_PARAMETERS;
pub type PFLT_VOLUME_PARAMETERS = *mut _FLT_VOLUME_PARAMETERS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ATTACH_TYPE {
   AltitudeBased = 0,
   InstanceNameBased = 1,
}
pub use self::_ATTACH_TYPE as ATTACH_TYPE;
pub type PATTACH_TYPE = *mut _ATTACH_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_ATTACH {
   pub FilterNameSize: USHORT,
   pub FilterNameOffset: USHORT,
   pub VolumeNameSize: USHORT,
   pub VolumeNameOffset: USHORT,
   pub Type: ATTACH_TYPE,
   pub InstanceNameSize: USHORT,
   pub InstanceNameOffset: USHORT,
   pub AltitudeSize: USHORT,
   pub AltitudeOffset: USHORT,
}
impl Default for _FLT_ATTACH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type FLT_ATTACH = _FLT_ATTACH;
pub type PFLT_ATTACH = *mut _FLT_ATTACH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_UNC_CACHE_ENTRY {
   pub TotalLength: ULONG,
   pub UncNameOffset: ULONG,
   pub UncNameLength: USHORT,
   pub ProviderNameOffset: ULONG,
   pub ProviderNameLength: USHORT,
   pub SurrogateNameOffset: ULONG,
   pub SurrogateNameLength: USHORT,
   pub ProviderPriority: ULONG,
   pub EntryTtl: ULONG,
   pub Strings: [WCHAR; 1usize],
}
pub type MUP_FSCTL_UNC_CACHE_ENTRY = _MUP_FSCTL_UNC_CACHE_ENTRY;
pub type PMUP_FSCTL_UNC_CACHE_ENTRY = *mut _MUP_FSCTL_UNC_CACHE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_UNC_CACHE_INFORMATION {
   pub MaxCacheSize: ULONG,
   pub CurrentCacheSize: ULONG,
   pub EntryTimeout: ULONG,
   pub TotalEntries: ULONG,
   pub CacheEntry: [MUP_FSCTL_UNC_CACHE_ENTRY; 1usize],
}
pub type MUP_FSCTL_UNC_CACHE_INFORMATION = _MUP_FSCTL_UNC_CACHE_INFORMATION;
pub type PMUP_FSCTL_UNC_CACHE_INFORMATION = *mut _MUP_FSCTL_UNC_CACHE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_UNC_PROVIDER_ENTRY {
   pub TotalLength: ULONG,
   pub ReferenceCount: LONG,
   pub ProviderPriority: ULONG,
   pub ProviderState: ULONG,
   pub ProviderId: ULONG,
   pub ProviderNameLength: USHORT,
   pub ProviderName: [WCHAR; 1usize],
}
pub type MUP_FSCTL_UNC_PROVIDER_ENTRY = _MUP_FSCTL_UNC_PROVIDER_ENTRY;
pub type PMUP_FSCTL_UNC_PROVIDER_ENTRY = *mut _MUP_FSCTL_UNC_PROVIDER_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_UNC_PROVIDER_INFORMATION {
   pub TotalEntries: ULONG,
   pub ProviderEntry: [MUP_FSCTL_UNC_PROVIDER_ENTRY; 1usize],
}
pub type MUP_FSCTL_UNC_PROVIDER_INFORMATION = _MUP_FSCTL_UNC_PROVIDER_INFORMATION;
pub type PMUP_FSCTL_UNC_PROVIDER_INFORMATION = *mut _MUP_FSCTL_UNC_PROVIDER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_SURROGATE_PROVIDER_ENTRY {
   pub TotalLength: ULONG,
   pub ReferenceCount: LONG,
   pub SurrogateType: ULONG,
   pub SurrogateState: ULONG,
   pub SurrogatePriority: ULONG,
   pub SurrogateNameLength: USHORT,
   pub SurrogateName: [WCHAR; 1usize],
}
pub type MUP_FSCTL_SURROGATE_PROVIDER_ENTRY = _MUP_FSCTL_SURROGATE_PROVIDER_ENTRY;
pub type PMUP_FSCTL_SURROGATE_PROVIDER_ENTRY = *mut _MUP_FSCTL_SURROGATE_PROVIDER_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_SURROGATE_PROVIDER_INFORMATION {
   pub TotalEntries: ULONG,
   pub SurrogateEntry: [MUP_FSCTL_SURROGATE_PROVIDER_ENTRY; 1usize],
}
pub type MUP_FSCTL_SURROGATE_PROVIDER_INFORMATION = _MUP_FSCTL_SURROGATE_PROVIDER_INFORMATION;
pub type PMUP_FSCTL_SURROGATE_PROVIDER_INFORMATION = *mut _MUP_FSCTL_SURROGATE_PROVIDER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY {
   pub NextOffset: ULONG,
   pub PrefixNameOffset: ULONG,
   pub PrefixNameCbLength: USHORT,
   pub __bindgen_anon_1: _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY__bindgen_ty_1,
   pub OpenCount: ULONGLONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY__bindgen_ty_1 {
   pub RequiredHardeningCapabilities: ULONG,
   pub __bindgen_anon_1: _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn RequiresMutualAuth(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RequiresMutualAuth(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RequiresMutualAuth_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RequiresMutualAuth_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RequiresIntegrity(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RequiresIntegrity(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RequiresIntegrity_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RequiresIntegrity_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RequiresPrivacy(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RequiresPrivacy(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RequiresPrivacy_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RequiresPrivacy_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      RequiresMutualAuth: ULONG,
      RequiresIntegrity: ULONG,
      RequiresPrivacy: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let RequiresMutualAuth: u32 = unsafe { ::core::mem::transmute(RequiresMutualAuth) };
         RequiresMutualAuth as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let RequiresIntegrity: u32 = unsafe { ::core::mem::transmute(RequiresIntegrity) };
         RequiresIntegrity as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let RequiresPrivacy: u32 = unsafe { ::core::mem::transmute(RequiresPrivacy) };
         RequiresPrivacy as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY = _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY;
pub type PMUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY =
   *mut _MUP_FSCTL_UNC_HARDENING_PREFIX_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_IN {
   pub Size: ULONG,
   pub UncPathOffset: ULONG,
   pub UncPathCbLength: USHORT,
}
pub type MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_IN =
   _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_IN;
pub type PMUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_IN =
   *mut _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_IN;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT {
   pub Size: ULONG,
   pub __bindgen_anon_1: _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT__bindgen_ty_1 {
   pub RequiredHardeningCapabilities: ULONG,
   pub __bindgen_anon_1:
      _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn RequiresMutualAuth(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RequiresMutualAuth(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RequiresMutualAuth_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RequiresMutualAuth_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RequiresIntegrity(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RequiresIntegrity(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RequiresIntegrity_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RequiresIntegrity_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RequiresPrivacy(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_RequiresPrivacy(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RequiresPrivacy_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_RequiresPrivacy_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      RequiresMutualAuth: ULONG,
      RequiresIntegrity: ULONG,
      RequiresPrivacy: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let RequiresMutualAuth: u32 = unsafe { ::core::mem::transmute(RequiresMutualAuth) };
         RequiresMutualAuth as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let RequiresIntegrity: u32 = unsafe { ::core::mem::transmute(RequiresIntegrity) };
         RequiresIntegrity as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let RequiresPrivacy: u32 = unsafe { ::core::mem::transmute(RequiresPrivacy) };
         RequiresPrivacy as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT =
   _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT;
pub type PMUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT =
   *mut _MUP_FSCTL_QUERY_UNC_HARDENING_CONFIGURATION_OUT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FS_FILTER_SECTION_SYNC_TYPE {
   SyncTypeOther = 0,
   SyncTypeCreateSection = 1,
}
pub use self::_FS_FILTER_SECTION_SYNC_TYPE as FS_FILTER_SECTION_SYNC_TYPE;
pub type PFS_FILTER_SECTION_SYNC_TYPE = *mut _FS_FILTER_SECTION_SYNC_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CREATE_FILE_TYPE {
   CreateFileTypeNone = 0,
   CreateFileTypeNamedPipe = 1,
   CreateFileTypeMailslot = 2,
}
pub use self::_CREATE_FILE_TYPE as CREATE_FILE_TYPE;
#[repr(C)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
   pub NamedPipeType: ULONG,
   pub ReadMode: ULONG,
   pub CompletionMode: ULONG,
   pub MaximumInstances: ULONG,
   pub InboundQuota: ULONG,
   pub OutboundQuota: ULONG,
   pub DefaultTimeout: LARGE_INTEGER,
   pub TimeoutSpecified: BOOLEAN,
}
impl Default for _NAMED_PIPE_CREATE_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NAMED_PIPE_CREATE_PARAMETERS = _NAMED_PIPE_CREATE_PARAMETERS;
pub type PNAMED_PIPE_CREATE_PARAMETERS = *mut _NAMED_PIPE_CREATE_PARAMETERS;
#[repr(C)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
   pub MailslotQuota: ULONG,
   pub MaximumMessageSize: ULONG,
   pub ReadTimeout: LARGE_INTEGER,
   pub TimeoutSpecified: BOOLEAN,
}
impl Default for _MAILSLOT_CREATE_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MAILSLOT_CREATE_PARAMETERS = _MAILSLOT_CREATE_PARAMETERS;
pub type PMAILSLOT_CREATE_PARAMETERS = *mut _MAILSLOT_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OPLOCK_KEY_ECP_CONTEXT {
   pub OplockKey: GUID,
   pub Reserved: ULONG,
}
pub type OPLOCK_KEY_ECP_CONTEXT = _OPLOCK_KEY_ECP_CONTEXT;
pub type POPLOCK_KEY_ECP_CONTEXT = *mut _OPLOCK_KEY_ECP_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OPLOCK_KEY_CONTEXT {
   pub Version: USHORT,
   pub Flags: USHORT,
   pub ParentOplockKey: GUID,
   pub TargetOplockKey: GUID,
   pub Reserved: ULONG,
}
pub type OPLOCK_KEY_CONTEXT = _OPLOCK_KEY_CONTEXT;
pub type POPLOCK_KEY_CONTEXT = *mut _OPLOCK_KEY_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PORT_MESSAGE {
   pub u1: _PORT_MESSAGE__bindgen_ty_1,
   pub u2: _PORT_MESSAGE__bindgen_ty_2,
   pub __bindgen_anon_1: _PORT_MESSAGE__bindgen_ty_3,
   pub MessageId: ULONG,
   pub __bindgen_anon_2: _PORT_MESSAGE__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_1 {
   pub s1: _PORT_MESSAGE__bindgen_ty_1__bindgen_ty_1,
   pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
   pub DataLength: CSHORT,
   pub TotalLength: CSHORT,
}
impl Default for _PORT_MESSAGE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_2 {
   pub s2: _PORT_MESSAGE__bindgen_ty_2__bindgen_ty_1,
   pub ZeroInit: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE__bindgen_ty_2__bindgen_ty_1 {
   pub Type: CSHORT,
   pub DataInfoOffset: CSHORT,
}
impl Default for _PORT_MESSAGE__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_3 {
   pub ClientId: CLIENT_ID,
   pub DoNotUseThisField: f64,
}
impl Default for _PORT_MESSAGE__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE__bindgen_ty_4 {
   pub ClientViewSize: SIZE_T,
   pub CallbackId: ULONG,
}
impl Default for _PORT_MESSAGE__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PORT_MESSAGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_MESSAGE = _PORT_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_DATA_ENTRY {
   pub Base: PVOID,
   pub Size: ULONG,
}
impl Default for _PORT_DATA_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_DATA_ENTRY = _PORT_DATA_ENTRY;
pub type PPORT_DATA_ENTRY = *mut _PORT_DATA_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_DATA_INFORMATION {
   pub CountDataEntries: ULONG,
   pub DataEntries: [PORT_DATA_ENTRY; 1usize],
}
impl Default for _PORT_DATA_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_DATA_INFORMATION = _PORT_DATA_INFORMATION;
pub type PPORT_DATA_INFORMATION = *mut _PORT_DATA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPC_CLIENT_DIED_MSG {
   pub PortMsg: PORT_MESSAGE,
   pub CreateTime: LARGE_INTEGER,
}
impl Default for _LPC_CLIENT_DIED_MSG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LPC_CLIENT_DIED_MSG = _LPC_CLIENT_DIED_MSG;
pub type PLPC_CLIENT_DIED_MSG = *mut _LPC_CLIENT_DIED_MSG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_VIEW {
   pub Length: ULONG,
   pub SectionHandle: HANDLE,
   pub SectionOffset: ULONG,
   pub ViewSize: SIZE_T,
   pub ViewBase: PVOID,
   pub ViewRemoteBase: PVOID,
}
impl Default for _PORT_VIEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_VIEW = _PORT_VIEW;
pub type PPORT_VIEW = *mut _PORT_VIEW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REMOTE_PORT_VIEW {
   pub Length: ULONG,
   pub ViewSize: SIZE_T,
   pub ViewBase: PVOID,
}
impl Default for _REMOTE_PORT_VIEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type REMOTE_PORT_VIEW = _REMOTE_PORT_VIEW;
pub type PREMOTE_PORT_VIEW = *mut _REMOTE_PORT_VIEW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PORT_MESSAGE64 {
   pub u1: _PORT_MESSAGE64__bindgen_ty_1,
   pub u2: _PORT_MESSAGE64__bindgen_ty_2,
   pub __bindgen_anon_1: _PORT_MESSAGE64__bindgen_ty_3,
   pub MessageId: ULONG,
   pub __bindgen_anon_2: _PORT_MESSAGE64__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE64__bindgen_ty_1 {
   pub s1: _PORT_MESSAGE64__bindgen_ty_1__bindgen_ty_1,
   pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE64__bindgen_ty_1__bindgen_ty_1 {
   pub DataLength: CSHORT,
   pub TotalLength: CSHORT,
}
impl Default for _PORT_MESSAGE64__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE64__bindgen_ty_2 {
   pub s2: _PORT_MESSAGE64__bindgen_ty_2__bindgen_ty_1,
   pub ZeroInit: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_MESSAGE64__bindgen_ty_2__bindgen_ty_1 {
   pub Type: CSHORT,
   pub DataInfoOffset: CSHORT,
}
impl Default for _PORT_MESSAGE64__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE64__bindgen_ty_3 {
   pub ClientId: CLIENT_ID64,
   pub DoNotUseThisField: f64,
}
impl Default for _PORT_MESSAGE64__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PORT_MESSAGE64__bindgen_ty_4 {
   pub ClientViewSize: ULONGLONG,
   pub CallbackId: ULONG,
}
impl Default for _PORT_MESSAGE64__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PORT_MESSAGE64 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PORT_MESSAGE64 = _PORT_MESSAGE64;
pub type PPORT_MESSAGE64 = *mut _PORT_MESSAGE64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LPC_CLIENT_DIED_MSG64 {
   pub PortMsg: PORT_MESSAGE64,
   pub CreateTime: LARGE_INTEGER,
}
impl Default for _LPC_CLIENT_DIED_MSG64 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LPC_CLIENT_DIED_MSG64 = _LPC_CLIENT_DIED_MSG64;
pub type PLPC_CLIENT_DIED_MSG64 = *mut _LPC_CLIENT_DIED_MSG64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PORT_VIEW64 {
   pub Length: ULONG,
   pub SectionHandle: ULONGLONG,
   pub SectionOffset: ULONG,
   pub ViewSize: ULONGLONG,
   pub ViewBase: ULONGLONG,
   pub ViewRemoteBase: ULONGLONG,
}
pub type PORT_VIEW64 = _PORT_VIEW64;
pub type PPORT_VIEW64 = *mut _PORT_VIEW64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _REMOTE_PORT_VIEW64 {
   pub Length: ULONG,
   pub ViewSize: ULONGLONG,
   pub ViewBase: ULONGLONG,
}
pub type REMOTE_PORT_VIEW64 = _REMOTE_PORT_VIEW64;
pub type PREMOTE_PORT_VIEW64 = *mut _REMOTE_PORT_VIEW64;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PORT_INFORMATION_CLASS {
   PortBasicInformation = 0,
   PortDumpInformation = 1,
}
pub use self::_PORT_INFORMATION_CLASS as PORT_INFORMATION_CLASS;
pub type ALPC_HANDLE = HANDLE;
pub type PALPC_HANDLE = *mut HANDLE;
#[repr(C)]
pub struct _ALPC_PORT_ATTRIBUTES {
   pub Flags: ULONG,
   pub SecurityQos: SECURITY_QUALITY_OF_SERVICE,
   pub MaxMessageLength: SIZE_T,
   pub MemoryBandwidth: SIZE_T,
   pub MaxPoolUsage: SIZE_T,
   pub MaxSectionSize: SIZE_T,
   pub MaxViewSize: SIZE_T,
   pub MaxTotalSectionSize: SIZE_T,
   pub DupObjectTypes: ULONG,
   pub Reserved: ULONG,
}
impl Default for _ALPC_PORT_ATTRIBUTES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_PORT_ATTRIBUTES = _ALPC_PORT_ATTRIBUTES;
pub type PALPC_PORT_ATTRIBUTES = *mut _ALPC_PORT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_MESSAGE_ATTRIBUTES {
   pub AllocatedAttributes: ULONG,
   pub ValidAttributes: ULONG,
}
pub type ALPC_MESSAGE_ATTRIBUTES = _ALPC_MESSAGE_ATTRIBUTES;
pub type PALPC_MESSAGE_ATTRIBUTES = *mut _ALPC_MESSAGE_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_STATE {
   pub u1: _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1 {
   pub s1: _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1,
   pub Value: ULONG64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Head(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u64) }
   }
   #[inline]
   pub fn set_Head(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Head_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            24u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Head_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Tail(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 24u8) as u64) }
   }
   #[inline]
   pub fn set_Tail(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 24u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Tail_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            24u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Tail_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            24u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ActiveThreadCount(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u64) }
   }
   #[inline]
   pub fn set_ActiveThreadCount(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(48usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ActiveThreadCount_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            48usize,
            16u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ActiveThreadCount_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            48usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Head: ULONG64,
      Tail: ULONG64,
      ActiveThreadCount: ULONG64,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 24u8, {
         let Head: u64 = unsafe { ::core::mem::transmute(Head) };
         Head as u64
      });
      __bindgen_bitfield_unit.set(24usize, 24u8, {
         let Tail: u64 = unsafe { ::core::mem::transmute(Tail) };
         Tail as u64
      });
      __bindgen_bitfield_unit.set(48usize, 16u8, {
         let ActiveThreadCount: u64 = unsafe { ::core::mem::transmute(ActiveThreadCount) };
         ActiveThreadCount as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _ALPC_COMPLETION_LIST_STATE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ALPC_COMPLETION_LIST_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_COMPLETION_LIST_STATE = _ALPC_COMPLETION_LIST_STATE;
pub type PALPC_COMPLETION_LIST_STATE = *mut _ALPC_COMPLETION_LIST_STATE;
#[repr(C)]
#[repr(align(128))]
#[derive(Copy, Clone)]
pub struct _ALPC_COMPLETION_LIST_HEADER {
   pub StartMagic: ULONG64,
   pub TotalSize: ULONG,
   pub ListOffset: ULONG,
   pub ListSize: ULONG,
   pub BitmapOffset: ULONG,
   pub BitmapSize: ULONG,
   pub DataOffset: ULONG,
   pub DataSize: ULONG,
   pub AttributeFlags: ULONG,
   pub AttributeSize: ULONG,
   pub __bindgen_padding_0: [u64; 10usize],
   pub State: ALPC_COMPLETION_LIST_STATE,
   pub LastMessageId: ULONG,
   pub LastCallbackId: ULONG,
   pub __bindgen_padding_1: [u32; 28usize],
   pub PostCount: ULONG,
   pub __bindgen_padding_2: [u32; 31usize],
   pub ReturnCount: ULONG,
   pub __bindgen_padding_3: [u32; 31usize],
   pub LogSequenceNumber: ULONG,
   pub __bindgen_padding_4: [u64; 15usize],
   pub UserLock: RTL_SRWLOCK,
   pub EndMagic: ULONG64,
}
impl Default for _ALPC_COMPLETION_LIST_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_COMPLETION_LIST_HEADER = _ALPC_COMPLETION_LIST_HEADER;
pub type PALPC_COMPLETION_LIST_HEADER = *mut _ALPC_COMPLETION_LIST_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_CONTEXT_ATTR {
   pub PortContext: PVOID,
   pub MessageContext: PVOID,
   pub Sequence: ULONG,
   pub MessageId: ULONG,
   pub CallbackId: ULONG,
}
impl Default for _ALPC_CONTEXT_ATTR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_CONTEXT_ATTR = _ALPC_CONTEXT_ATTR;
pub type PALPC_CONTEXT_ATTR = *mut _ALPC_CONTEXT_ATTR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_HANDLE_ATTR32 {
   pub Flags: ULONG,
   pub Reserved0: ULONG,
   pub SameAccess: ULONG,
   pub SameAttributes: ULONG,
   pub Indirect: ULONG,
   pub Inherit: ULONG,
   pub Reserved1: ULONG,
   pub Handle: ULONG,
   pub ObjectType: ULONG,
   pub DesiredAccess: ACCESS_MASK,
   pub GrantedAccess: ACCESS_MASK,
}
pub type ALPC_HANDLE_ATTR32 = _ALPC_HANDLE_ATTR32;
pub type PALPC_HANDLE_ATTR32 = *mut _ALPC_HANDLE_ATTR32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_HANDLE_ATTR {
   pub Flags: ULONG,
   pub Reserved0: ULONG,
   pub SameAccess: ULONG,
   pub SameAttributes: ULONG,
   pub Indirect: ULONG,
   pub Inherit: ULONG,
   pub Reserved1: ULONG,
   pub Handle: HANDLE,
   pub HandleAttrArray: PALPC_HANDLE_ATTR32,
   pub ObjectType: ULONG,
   pub HandleCount: ULONG,
   pub DesiredAccess: ACCESS_MASK,
   pub GrantedAccess: ACCESS_MASK,
}
impl Default for _ALPC_HANDLE_ATTR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_HANDLE_ATTR = _ALPC_HANDLE_ATTR;
pub type PALPC_HANDLE_ATTR = *mut _ALPC_HANDLE_ATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_SECURITY_ATTR {
   pub Flags: ULONG,
   pub QoS: PSECURITY_QUALITY_OF_SERVICE,
   pub ContextHandle: ALPC_HANDLE,
}
impl Default for _ALPC_SECURITY_ATTR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_SECURITY_ATTR = _ALPC_SECURITY_ATTR;
pub type PALPC_SECURITY_ATTR = *mut _ALPC_SECURITY_ATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_DATA_VIEW_ATTR {
   pub Flags: ULONG,
   pub SectionHandle: ALPC_HANDLE,
   pub ViewBase: PVOID,
   pub ViewSize: SIZE_T,
}
impl Default for _ALPC_DATA_VIEW_ATTR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_DATA_VIEW_ATTR = _ALPC_DATA_VIEW_ATTR;
pub type PALPC_DATA_VIEW_ATTR = *mut _ALPC_DATA_VIEW_ATTR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALPC_PORT_INFORMATION_CLASS {
   AlpcBasicInformation = 0,
   AlpcPortInformation = 1,
   AlpcAssociateCompletionPortInformation = 2,
   AlpcConnectedSIDInformation = 3,
   AlpcServerInformation = 4,
   AlpcMessageZoneInformation = 5,
   AlpcRegisterCompletionListInformation = 6,
   AlpcUnregisterCompletionListInformation = 7,
   AlpcAdjustCompletionListConcurrencyCountInformation = 8,
   AlpcRegisterCallbackInformation = 9,
   AlpcCompletionListRundownInformation = 10,
   AlpcWaitForPortReferences = 11,
   AlpcServerSessionInformation = 12,
}
pub use self::_ALPC_PORT_INFORMATION_CLASS as ALPC_PORT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_BASIC_INFORMATION {
   pub Flags: ULONG,
   pub SequenceNo: ULONG,
   pub PortContext: PVOID,
}
impl Default for _ALPC_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_BASIC_INFORMATION = _ALPC_BASIC_INFORMATION;
pub type PALPC_BASIC_INFORMATION = *mut _ALPC_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_PORT_ASSOCIATE_COMPLETION_PORT {
   pub CompletionKey: PVOID,
   pub CompletionPort: HANDLE,
}
impl Default for _ALPC_PORT_ASSOCIATE_COMPLETION_PORT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_PORT_ASSOCIATE_COMPLETION_PORT = _ALPC_PORT_ASSOCIATE_COMPLETION_PORT;
pub type PALPC_PORT_ASSOCIATE_COMPLETION_PORT = *mut _ALPC_PORT_ASSOCIATE_COMPLETION_PORT;
#[repr(C)]
pub struct _ALPC_SERVER_INFORMATION {
   pub __bindgen_anon_1: _ALPC_SERVER_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
pub union _ALPC_SERVER_INFORMATION__bindgen_ty_1 {
   pub In: ::core::mem::ManuallyDrop<_ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_1>,
   pub Out: ::core::mem::ManuallyDrop<_ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_2>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub ThreadHandle: HANDLE,
}
impl Default for _ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
pub struct _ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
   pub ThreadBlocked: BOOLEAN,
   pub ConnectedProcessId: HANDLE,
   pub ConnectionPortName: UNICODE_STRING,
}
impl Default for _ALPC_SERVER_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ALPC_SERVER_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ALPC_SERVER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_SERVER_INFORMATION = _ALPC_SERVER_INFORMATION;
pub type PALPC_SERVER_INFORMATION = *mut _ALPC_SERVER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_PORT_MESSAGE_ZONE_INFORMATION {
   pub Buffer: PVOID,
   pub Size: ULONG,
}
impl Default for _ALPC_PORT_MESSAGE_ZONE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_PORT_MESSAGE_ZONE_INFORMATION = _ALPC_PORT_MESSAGE_ZONE_INFORMATION;
pub type PALPC_PORT_MESSAGE_ZONE_INFORMATION = *mut _ALPC_PORT_MESSAGE_ZONE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_PORT_COMPLETION_LIST_INFORMATION {
   pub Buffer: PVOID,
   pub Size: ULONG,
   pub ConcurrencyCount: ULONG,
   pub AttributeFlags: ULONG,
}
impl Default for _ALPC_PORT_COMPLETION_LIST_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_PORT_COMPLETION_LIST_INFORMATION = _ALPC_PORT_COMPLETION_LIST_INFORMATION;
pub type PALPC_PORT_COMPLETION_LIST_INFORMATION = *mut _ALPC_PORT_COMPLETION_LIST_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALPC_REGISTER_CALLBACK {
   pub CallbackObject: PVOID,
   pub CallbackContext: PVOID,
}
impl Default for _ALPC_REGISTER_CALLBACK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALPC_REGISTER_CALLBACK = _ALPC_REGISTER_CALLBACK;
pub type PALPC_REGISTER_CALLBACK = *mut _ALPC_REGISTER_CALLBACK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_SERVER_SESSION_INFORMATION {
   pub SessionId: ULONG,
   pub ProcessId: ULONG,
}
pub type ALPC_SERVER_SESSION_INFORMATION = _ALPC_SERVER_SESSION_INFORMATION;
pub type PALPC_SERVER_SESSION_INFORMATION = *mut _ALPC_SERVER_SESSION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALPC_MESSAGE_INFORMATION_CLASS {
   AlpcMessageSidInformation = 0,
   AlpcMessageTokenModifiedIdInformation = 1,
   AlpcMessageDirectStatusInformation = 2,
   AlpcMessageHandleInformation = 3,
   MaxAlpcMessageInfoClass = 4,
}
pub use self::_ALPC_MESSAGE_INFORMATION_CLASS as ALPC_MESSAGE_INFORMATION_CLASS;
pub type PALPC_MESSAGE_INFORMATION_CLASS = *mut _ALPC_MESSAGE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ALPC_MESSAGE_HANDLE_INFORMATION {
   pub Index: ULONG,
   pub Flags: ULONG,
   pub Handle: ULONG,
   pub ObjectType: ULONG,
   pub GrantedAccess: ACCESS_MASK,
}
pub type ALPC_MESSAGE_HANDLE_INFORMATION = _ALPC_MESSAGE_HANDLE_INFORMATION;
pub type PALPC_MESSAGE_HANDLE_INFORMATION = *mut _ALPC_MESSAGE_HANDLE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_BOOT_PHASE_ID {
   PfKernelInitPhase = 0,
   PfBootDriverInitPhase = 90,
   PfSystemDriverInitPhase = 120,
   PfSessionManagerInitPhase = 150,
   PfSMRegistryInitPhase = 180,
   PfVideoInitPhase = 210,
   PfPostVideoInitPhase = 240,
   PfBootAcceptedRegistryInitPhase = 270,
   PfUserShellReadyPhase = 300,
   PfMaxBootPhaseId = 900,
}
pub use self::_PF_BOOT_PHASE_ID as PF_BOOT_PHASE_ID;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_ENABLE_STATUS {
   PfSvNotSpecified = 0,
   PfSvEnabled = 1,
   PfSvDisabled = 2,
   PfSvMaxEnableStatus = 3,
}
pub use self::_PF_ENABLE_STATUS as PF_ENABLE_STATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_TRACE_LIMITS {
   pub MaxNumPages: ULONG,
   pub MaxNumSections: ULONG,
   pub TimerPeriod: LONGLONG,
}
pub type PF_TRACE_LIMITS = _PF_TRACE_LIMITS;
pub type PPF_TRACE_LIMITS = *mut _PF_TRACE_LIMITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_SYSTEM_PREFETCH_PARAMETERS {
   pub EnableStatus: [PF_ENABLE_STATUS; 2usize],
   pub TraceLimits: [PF_TRACE_LIMITS; 2usize],
   pub MaxNumActiveTraces: ULONG,
   pub MaxNumSavedTraces: ULONG,
   pub RootDirPath: [WCHAR; 32usize],
   pub HostingApplicationList: [WCHAR; 128usize],
}
impl Default for _PF_SYSTEM_PREFETCH_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_SYSTEM_PREFETCH_PARAMETERS = _PF_SYSTEM_PREFETCH_PARAMETERS;
pub type PPF_SYSTEM_PREFETCH_PARAMETERS = *mut _PF_SYSTEM_PREFETCH_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_BOOT_CONTROL {
   pub Version: ULONG,
   pub DisableBootPrefetching: ULONG,
}
pub type PF_BOOT_CONTROL = _PF_BOOT_CONTROL;
pub type PPF_BOOT_CONTROL = *mut _PF_BOOT_CONTROL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PREFETCHER_INFORMATION_CLASS {
   PrefetcherRetrieveTrace = 1,
   PrefetcherSystemParameters = 2,
   PrefetcherBootPhase = 3,
   PrefetcherSpare1 = 4,
   PrefetcherBootControl = 5,
   PrefetcherScenarioPolicyControl = 6,
   PrefetcherSpare2 = 7,
   PrefetcherAppLaunchScenarioControl = 8,
   PrefetcherInformationMax = 9,
}
pub use self::_PREFETCHER_INFORMATION_CLASS as PREFETCHER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFETCHER_INFORMATION {
   pub Version: ULONG,
   pub Magic: ULONG,
   pub PrefetcherInformationClass: PREFETCHER_INFORMATION_CLASS,
   pub PrefetcherInformation: PVOID,
   pub PrefetcherInformationLength: ULONG,
}
impl Default for _PREFETCHER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PREFETCHER_INFORMATION = _PREFETCHER_INFORMATION;
pub type PPREFETCHER_INFORMATION = *mut _PREFETCHER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_SYSTEM_SUPERFETCH_PARAMETERS {
   pub EnabledComponents: ULONG,
   pub BootID: ULONG,
   pub SavedSectInfoTracesMax: ULONG,
   pub SavedPageAccessTracesMax: ULONG,
   pub ScenarioPrefetchTimeoutStandby: ULONG,
   pub ScenarioPrefetchTimeoutHibernate: ULONG,
   pub ScenarioPrefetchTimeoutHiberBoot: ULONG,
}
pub type PF_SYSTEM_SUPERFETCH_PARAMETERS = _PF_SYSTEM_SUPERFETCH_PARAMETERS;
pub type PPF_SYSTEM_SUPERFETCH_PARAMETERS = *mut _PF_SYSTEM_SUPERFETCH_PARAMETERS;
impl _PF_EVENT_TYPE {
   pub const PfEventTypeUtilization: _PF_EVENT_TYPE = _PF_EVENT_TYPE::PfEventTypeUnmap;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_EVENT_TYPE {
   PfEventTypeImageLoad = 0,
   PfEventTypeAppLaunch = 1,
   PfEventTypeStartTrace = 2,
   PfEventTypeEndTrace = 3,
   PfEventTypeTimestamp = 4,
   PfEventTypeOperation = 5,
   PfEventTypeRepurpose = 6,
   PfEventTypeForegroundProcess = 7,
   PfEventTypeTimeRange = 8,
   PfEventTypeUserInput = 9,
   PfEventTypeFileAccess = 10,
   PfEventTypeUnmap = 11,
   PfEventTypeMemInfo = 12,
   PfEventTypeFileDelete = 13,
   PfEventTypeAppExit = 14,
   PfEventTypeSystemTime = 15,
   PfEventTypePower = 16,
   PfEventTypeSessionChange = 17,
   PfEventTypeHardFaultTimeStamp = 18,
   PfEventTypeVirtualFree = 19,
   PfEventTypePerfInfo = 20,
   PfEventTypeProcessSnapshot = 21,
   PfEventTypeUserSnapshot = 22,
   PfEventTypeStreamSequenceNumber = 23,
   PfEventTypeFileTruncate = 24,
   PfEventTypeFileRename = 25,
   PfEventTypeFileCreate = 26,
   PfEventTypeAgCxContext = 27,
   PfEventTypePowerAction = 28,
   PfEventTypeHardFaultTS = 29,
   PfEventTypeRobustInfo = 30,
   PfEventTypeFileDefrag = 31,
   PfEventTypeMax = 32,
}
pub use self::_PF_EVENT_TYPE as PF_EVENT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_LOG_EVENT_DATA {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub EventData: PVOID,
}
impl Default for _PF_LOG_EVENT_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PF_LOG_EVENT_DATA {
   #[inline]
   pub fn EventType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
   }
   #[inline]
   pub fn set_EventType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EventType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            5u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EventType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            5u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Flags(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Flags(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Flags_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Flags_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DataSize(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
   }
   #[inline]
   pub fn set_DataSize(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 25u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DataSize_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            25u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DataSize_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            25u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      EventType: ULONG,
      Flags: ULONG,
      DataSize: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 5u8, {
         let EventType: u32 = unsafe { ::core::mem::transmute(EventType) };
         EventType as u64
      });
      __bindgen_bitfield_unit.set(5usize, 2u8, {
         let Flags: u32 = unsafe { ::core::mem::transmute(Flags) };
         Flags as u64
      });
      __bindgen_bitfield_unit.set(7usize, 25u8, {
         let DataSize: u32 = unsafe { ::core::mem::transmute(DataSize) };
         DataSize as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PF_LOG_EVENT_DATA = _PF_LOG_EVENT_DATA;
pub type PPF_LOG_EVENT_DATA = *mut _PF_LOG_EVENT_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_PFN_PRIO_REQUEST {
   pub Version: ULONG,
   pub RequestFlags: ULONG,
   pub PfnCount: ULONG_PTR,
   pub MemInfo: SYSTEM_MEMORY_LIST_INFORMATION,
   pub PageData: [MMPFN_IDENTITY; 256usize],
}
impl Default for _PF_PFN_PRIO_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_PFN_PRIO_REQUEST = _PF_PFN_PRIO_REQUEST;
pub type PPF_PFN_PRIO_REQUEST = *mut _PF_PFN_PRIO_REQUEST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PFS_PRIVATE_PAGE_SOURCE_TYPE {
   PfsPrivateSourceKernel = 0,
   PfsPrivateSourceSession = 1,
   PfsPrivateSourceProcess = 2,
   PfsPrivateSourceMax = 3,
}
pub use self::_PFS_PRIVATE_PAGE_SOURCE_TYPE as PFS_PRIVATE_PAGE_SOURCE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PFS_PRIVATE_PAGE_SOURCE {
   pub Type: PFS_PRIVATE_PAGE_SOURCE_TYPE,
   pub __bindgen_anon_1: _PFS_PRIVATE_PAGE_SOURCE__bindgen_ty_1,
   pub ImagePathHash: ULONG,
   pub UniqueProcessHash: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PFS_PRIVATE_PAGE_SOURCE__bindgen_ty_1 {
   pub SessionId: ULONG,
   pub ProcessId: ULONG,
}
impl Default for _PFS_PRIVATE_PAGE_SOURCE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PFS_PRIVATE_PAGE_SOURCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PFS_PRIVATE_PAGE_SOURCE = _PFS_PRIVATE_PAGE_SOURCE;
pub type PPFS_PRIVATE_PAGE_SOURCE = *mut _PFS_PRIVATE_PAGE_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_PRIVSOURCE_INFO {
   pub DbInfo: PFS_PRIVATE_PAGE_SOURCE,
   pub EProcess: PVOID,
   pub WsPrivatePages: SIZE_T,
   pub TotalPrivatePages: SIZE_T,
   pub SessionID: ULONG,
   pub ImageName: [CHAR; 16usize],
   pub __bindgen_anon_1: _PF_PRIVSOURCE_INFO__bindgen_ty_1,
   pub WsTotalPages: ULONG_PTR,
   pub DeepFreezeTimeMs: ULONG,
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PF_PRIVSOURCE_INFO__bindgen_ty_1 {
   pub WsSwapPages: ULONG_PTR,
   pub SessionPagedPoolPages: ULONG_PTR,
   pub StoreSizePages: ULONG_PTR,
}
impl Default for _PF_PRIVSOURCE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PF_PRIVSOURCE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PF_PRIVSOURCE_INFO {
   #[inline]
   pub fn ModernApp(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ModernApp(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ModernApp_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ModernApp_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DeepFrozen(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DeepFrozen(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DeepFrozen_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DeepFrozen_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Foreground(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Foreground(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Foreground_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Foreground_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PerProcessStore(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PerProcessStore(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PerProcessStore_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PerProcessStore_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ModernApp: ULONG,
      DeepFrozen: ULONG,
      Foreground: ULONG,
      PerProcessStore: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ModernApp: u32 = unsafe { ::core::mem::transmute(ModernApp) };
         ModernApp as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DeepFrozen: u32 = unsafe { ::core::mem::transmute(DeepFrozen) };
         DeepFrozen as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let Foreground: u32 = unsafe { ::core::mem::transmute(Foreground) };
         Foreground as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let PerProcessStore: u32 = unsafe { ::core::mem::transmute(PerProcessStore) };
         PerProcessStore as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PF_PRIVSOURCE_INFO = _PF_PRIVSOURCE_INFO;
pub type PPF_PRIVSOURCE_INFO = *mut _PF_PRIVSOURCE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_PRIVSOURCE_QUERY_REQUEST {
   pub Version: ULONG,
   pub Flags: ULONG,
   pub InfoCount: ULONG,
   pub InfoArray: [PF_PRIVSOURCE_INFO; 1usize],
}
impl Default for _PF_PRIVSOURCE_QUERY_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_PRIVSOURCE_QUERY_REQUEST = _PF_PRIVSOURCE_QUERY_REQUEST;
pub type PPF_PRIVSOURCE_QUERY_REQUEST = *mut _PF_PRIVSOURCE_QUERY_REQUEST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_PHASED_SCENARIO_TYPE {
   PfScenarioTypeNone = 0,
   PfScenarioTypeStandby = 1,
   PfScenarioTypeHibernate = 2,
   PfScenarioTypeFUS = 3,
   PfScenarioTypeMax = 4,
}
pub use self::_PF_PHASED_SCENARIO_TYPE as PF_PHASED_SCENARIO_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_SCENARIO_PHASE_INFO {
   pub Version: ULONG,
   pub ScenType: PF_PHASED_SCENARIO_TYPE,
   pub PhaseId: ULONG,
   pub SequenceNumber: ULONG,
   pub Flags: ULONG,
   pub FUSUserId: ULONG,
}
impl Default for _PF_SCENARIO_PHASE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_SCENARIO_PHASE_INFO = _PF_SCENARIO_PHASE_INFO;
pub type PPF_SCENARIO_PHASE_INFO = *mut _PF_SCENARIO_PHASE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_MEMORY_LIST_NODE {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
   pub StandbyLowPageCount: ULONGLONG,
   pub StandbyMediumPageCount: ULONGLONG,
   pub StandbyHighPageCount: ULONGLONG,
   pub FreePageCount: ULONGLONG,
   pub ModifiedPageCount: ULONGLONG,
}
impl _PF_MEMORY_LIST_NODE {
   #[inline]
   pub fn Node(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
   }
   #[inline]
   pub fn set_Node(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Node_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Node_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 56u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            56u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            56u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Node: ULONGLONG, Spare: ULONGLONG) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Node: u64 = unsafe { ::core::mem::transmute(Node) };
         Node as u64
      });
      __bindgen_bitfield_unit.set(8usize, 56u8, {
         let Spare: u64 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PF_MEMORY_LIST_NODE = _PF_MEMORY_LIST_NODE;
pub type PPF_MEMORY_LIST_NODE = *mut _PF_MEMORY_LIST_NODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_ROBUST_PROCESS_ENTRY {
   pub ImagePathHash: ULONG,
   pub Pid: ULONG,
   pub Alignment: ULONG,
}
pub type PF_ROBUST_PROCESS_ENTRY = _PF_ROBUST_PROCESS_ENTRY;
pub type PPF_ROBUST_PROCESS_ENTRY = *mut _PF_ROBUST_PROCESS_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_ROBUST_FILE_ENTRY {
   pub FilePathHash: ULONG,
}
pub type PF_ROBUST_FILE_ENTRY = _PF_ROBUST_FILE_ENTRY;
pub type PPF_ROBUST_FILE_ENTRY = *mut _PF_ROBUST_FILE_ENTRY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PF_ROBUSTNESS_CONTROL_COMMAND {
   PfRpControlUpdate = 0,
   PfRpControlReset = 1,
   PfRpControlRobustAllStart = 2,
   PfRpControlRobustAllStop = 3,
   PfRpControlCommandMax = 4,
}
pub use self::_PF_ROBUSTNESS_CONTROL_COMMAND as PF_ROBUSTNESS_CONTROL_COMMAND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_ROBUSTNESS_CONTROL {
   pub Version: ULONG,
   pub Command: PF_ROBUSTNESS_CONTROL_COMMAND,
   pub DeprioProcessCount: ULONG,
   pub ExemptProcessCount: ULONG,
   pub DeprioFileCount: ULONG,
   pub ExemptFileCount: ULONG,
   pub ProcessEntries: [PF_ROBUST_PROCESS_ENTRY; 1usize],
   pub FileEntries: [PF_ROBUST_FILE_ENTRY; 1usize],
}
impl Default for _PF_ROBUSTNESS_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_ROBUSTNESS_CONTROL = _PF_ROBUSTNESS_CONTROL;
pub type PPF_ROBUSTNESS_CONTROL = *mut _PF_ROBUSTNESS_CONTROL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_TIME_CONTROL {
   pub TimeAdjustment: LONG,
}
pub type PF_TIME_CONTROL = _PF_TIME_CONTROL;
pub type PPF_TIME_CONTROL = *mut _PF_TIME_CONTROL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_MEMORY_LIST_INFO {
   pub Version: ULONG,
   pub Size: ULONG,
   pub NodeCount: ULONG,
   pub Nodes: [PF_MEMORY_LIST_NODE; 1usize],
}
pub type PF_MEMORY_LIST_INFO = _PF_MEMORY_LIST_INFO;
pub type PPF_MEMORY_LIST_INFO = *mut _PF_MEMORY_LIST_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_PHYSICAL_MEMORY_RANGE {
   pub BasePfn: ULONG_PTR,
   pub PageCount: ULONG_PTR,
}
pub type PF_PHYSICAL_MEMORY_RANGE = _PF_PHYSICAL_MEMORY_RANGE;
pub type PPF_PHYSICAL_MEMORY_RANGE = *mut _PF_PHYSICAL_MEMORY_RANGE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_PHYSICAL_MEMORY_RANGE_INFO_V1 {
   pub Version: ULONG,
   pub RangeCount: ULONG,
   pub Ranges: [PF_PHYSICAL_MEMORY_RANGE; 1usize],
}
pub type PF_PHYSICAL_MEMORY_RANGE_INFO_V1 = _PF_PHYSICAL_MEMORY_RANGE_INFO_V1;
pub type PPF_PHYSICAL_MEMORY_RANGE_INFO_V1 = *mut _PF_PHYSICAL_MEMORY_RANGE_INFO_V1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_PHYSICAL_MEMORY_RANGE_INFO_V2 {
   pub Version: ULONG,
   pub Flags: ULONG,
   pub RangeCount: ULONG,
   pub Ranges: [PF_PHYSICAL_MEMORY_RANGE; 1usize],
}
pub type PF_PHYSICAL_MEMORY_RANGE_INFO_V2 = _PF_PHYSICAL_MEMORY_RANGE_INFO_V2;
pub type PPF_PHYSICAL_MEMORY_RANGE_INFO_V2 = *mut _PF_PHYSICAL_MEMORY_RANGE_INFO_V2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_REPURPOSED_BY_PREFETCH_INFO {
   pub Version: ULONG,
   pub RepurposedByPrefetch: SIZE_T,
}
pub type PF_REPURPOSED_BY_PREFETCH_INFO = _PF_REPURPOSED_BY_PREFETCH_INFO;
pub type PPF_REPURPOSED_BY_PREFETCH_INFO = *mut _PF_REPURPOSED_BY_PREFETCH_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_VIRTUAL_QUERY {
   pub Version: ULONG,
   pub __bindgen_anon_1: _PF_VIRTUAL_QUERY__bindgen_ty_1,
   pub QueryBuffer: PVOID,
   pub QueryBufferSize: SIZE_T,
   pub ProcessHandle: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PF_VIRTUAL_QUERY__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PF_VIRTUAL_QUERY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_VIRTUAL_QUERY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PF_VIRTUAL_QUERY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn FaultInPageTables(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_FaultInPageTables(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn FaultInPageTables_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_FaultInPageTables_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReportPageTables(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReportPageTables(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReportPageTables_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReportPageTables_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      FaultInPageTables: ULONG,
      ReportPageTables: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let FaultInPageTables: u32 = unsafe { ::core::mem::transmute(FaultInPageTables) };
         FaultInPageTables as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ReportPageTables: u32 = unsafe { ::core::mem::transmute(ReportPageTables) };
         ReportPageTables as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PF_VIRTUAL_QUERY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PF_VIRTUAL_QUERY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_VIRTUAL_QUERY = _PF_VIRTUAL_QUERY;
pub type PPF_VIRTUAL_QUERY = *mut _PF_VIRTUAL_QUERY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_MIN_WS_AGE_RATE_CONTROL {
   pub Version: ULONG,
   pub SecondsToOldestAge: ULONG,
}
pub type PF_MIN_WS_AGE_RATE_CONTROL = _PF_MIN_WS_AGE_RATE_CONTROL;
pub type PPF_MIN_WS_AGE_RATE_CONTROL = *mut _PF_MIN_WS_AGE_RATE_CONTROL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PF_DEPRIORITIZE_OLD_PAGES {
   pub Version: ULONG,
   pub ProcessHandle: HANDLE,
   pub __bindgen_anon_1: _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn TargetPriority(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_TargetPriority(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TargetPriority_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TargetPriority_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TrimPages(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_TrimPages(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TrimPages_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TrimPages_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 26u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            26u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            26u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      TargetPriority: ULONG,
      TrimPages: ULONG,
      Spare: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let TargetPriority: u32 = unsafe { ::core::mem::transmute(TargetPriority) };
         TargetPriority as u64
      });
      __bindgen_bitfield_unit.set(4usize, 2u8, {
         let TrimPages: u32 = unsafe { ::core::mem::transmute(TrimPages) };
         TrimPages as u64
      });
      __bindgen_bitfield_unit.set(6usize, 26u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PF_DEPRIORITIZE_OLD_PAGES__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PF_DEPRIORITIZE_OLD_PAGES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PF_DEPRIORITIZE_OLD_PAGES = _PF_DEPRIORITIZE_OLD_PAGES;
pub type PPF_DEPRIORITIZE_OLD_PAGES = *mut _PF_DEPRIORITIZE_OLD_PAGES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PF_GPU_UTILIZATION_INFO {
   pub Version: ULONG,
   pub SessionId: ULONG,
   pub GpuTime: ULONGLONG,
}
pub type PF_GPU_UTILIZATION_INFO = _PF_GPU_UTILIZATION_INFO;
pub type PPF_GPU_UTILIZATION_INFO = *mut _PF_GPU_UTILIZATION_INFO;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SUPERFETCH_INFORMATION_CLASS {
   SuperfetchRetrieveTrace = 1,
   SuperfetchSystemParameters = 2,
   SuperfetchLogEvent = 3,
   SuperfetchGenerateTrace = 4,
   SuperfetchPrefetch = 5,
   SuperfetchPfnQuery = 6,
   SuperfetchPfnSetPriority = 7,
   SuperfetchPrivSourceQuery = 8,
   SuperfetchSequenceNumberQuery = 9,
   SuperfetchScenarioPhase = 10,
   SuperfetchWorkerPriority = 11,
   SuperfetchScenarioQuery = 12,
   SuperfetchScenarioPrefetch = 13,
   SuperfetchRobustnessControl = 14,
   SuperfetchTimeControl = 15,
   SuperfetchMemoryListQuery = 16,
   SuperfetchMemoryRangesQuery = 17,
   SuperfetchTracingControl = 18,
   SuperfetchTrimWhileAgingControl = 19,
   SuperfetchRepurposedByPrefetch = 20,
   SuperfetchChannelPowerRequest = 21,
   SuperfetchMovePages = 22,
   SuperfetchVirtualQuery = 23,
   SuperfetchCombineStatsQuery = 24,
   SuperfetchSetMinWsAgeRate = 25,
   SuperfetchDeprioritizeOldPagesInWs = 26,
   SuperfetchFileExtentsQuery = 27,
   SuperfetchGpuUtilizationQuery = 28,
   SuperfetchPfnSet = 29,
   SuperfetchInformationMax = 30,
}
pub use self::_SUPERFETCH_INFORMATION_CLASS as SUPERFETCH_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SUPERFETCH_INFORMATION {
   pub Version: ULONG,
   pub Magic: ULONG,
   pub SuperfetchInformationClass: SUPERFETCH_INFORMATION_CLASS,
   pub SuperfetchInformation: PVOID,
   pub SuperfetchInformationLength: ULONG,
}
impl Default for _SUPERFETCH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SUPERFETCH_INFORMATION = _SUPERFETCH_INFORMATION;
pub type PSUPERFETCH_INFORMATION = *mut _SUPERFETCH_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PNP_VETO_TYPE {
   PNP_VetoTypeUnknown = 0,
   PNP_VetoLegacyDevice = 1,
   PNP_VetoPendingClose = 2,
   PNP_VetoWindowsApp = 3,
   PNP_VetoWindowsService = 4,
   PNP_VetoOutstandingOpen = 5,
   PNP_VetoDevice = 6,
   PNP_VetoDriver = 7,
   PNP_VetoIllegalDeviceRequest = 8,
   PNP_VetoInsufficientPower = 9,
   PNP_VetoNonDisableable = 10,
   PNP_VetoLegacyDriver = 11,
   PNP_VetoInsufficientRights = 12,
   PNP_VetoAlreadyRemoved = 13,
}
pub use self::_PNP_VETO_TYPE as PNP_VETO_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PLUGPLAY_EVENT_CATEGORY {
   HardwareProfileChangeEvent = 0,
   TargetDeviceChangeEvent = 1,
   DeviceClassChangeEvent = 2,
   CustomDeviceEvent = 3,
   DeviceInstallEvent = 4,
   DeviceArrivalEvent = 5,
   PowerEvent = 6,
   VetoEvent = 7,
   BlockedDriverEvent = 8,
   InvalidIDEvent = 9,
   MaxPlugEventCategory = 10,
}
pub use self::_PLUGPLAY_EVENT_CATEGORY as PLUGPLAY_EVENT_CATEGORY;
pub type PPLUGPLAY_EVENT_CATEGORY = *mut _PLUGPLAY_EVENT_CATEGORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK {
   pub EventGuid: GUID,
   pub EventCategory: PLUGPLAY_EVENT_CATEGORY,
   pub Result: PULONG,
   pub Flags: ULONG,
   pub TotalSize: ULONG,
   pub DeviceObject: PVOID,
   pub u: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1 {
   pub DeviceClass: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_1,
   pub TargetDevice: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_2,
   pub InstallDevice: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_3,
   pub CustomNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4,
   pub ProfileNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5,
   pub PowerNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_6,
   pub VetoNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7,
   pub BlockedDriverNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_8,
   pub InvalidIDNotification: _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_9,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
   pub ClassGuid: GUID,
   pub SymbolicLinkName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_2 {
   pub DeviceIds: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_3 {
   pub DeviceId: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4 {
   pub NotificationStructure: PVOID,
   pub DeviceIds: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5 {
   pub Notification: PVOID,
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_6 {
   pub NotificationCode: ULONG,
   pub NotificationData: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7 {
   pub VetoType: PNP_VETO_TYPE,
   pub DeviceIdVetoNameBuffer: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_7 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_8 {
   pub BlockedDriverGuid: GUID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1__bindgen_ty_9 {
   pub ParentId: [WCHAR; 1usize],
}
impl Default for _PLUGPLAY_EVENT_BLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PLUGPLAY_EVENT_BLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PLUGPLAY_EVENT_BLOCK = _PLUGPLAY_EVENT_BLOCK;
pub type PPLUGPLAY_EVENT_BLOCK = *mut _PLUGPLAY_EVENT_BLOCK;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PLUGPLAY_CONTROL_CLASS {
   PlugPlayControlEnumerateDevice = 0,
   PlugPlayControlRegisterNewDevice = 1,
   PlugPlayControlDeregisterDevice = 2,
   PlugPlayControlInitializeDevice = 3,
   PlugPlayControlStartDevice = 4,
   PlugPlayControlUnlockDevice = 5,
   PlugPlayControlQueryAndRemoveDevice = 6,
   PlugPlayControlUserResponse = 7,
   PlugPlayControlGenerateLegacyDevice = 8,
   PlugPlayControlGetInterfaceDeviceList = 9,
   PlugPlayControlProperty = 10,
   PlugPlayControlDeviceClassAssociation = 11,
   PlugPlayControlGetRelatedDevice = 12,
   PlugPlayControlGetInterfaceDeviceAlias = 13,
   PlugPlayControlDeviceStatus = 14,
   PlugPlayControlGetDeviceDepth = 15,
   PlugPlayControlQueryDeviceRelations = 16,
   PlugPlayControlTargetDeviceRelation = 17,
   PlugPlayControlQueryConflictList = 18,
   PlugPlayControlRetrieveDock = 19,
   PlugPlayControlResetDevice = 20,
   PlugPlayControlHaltDevice = 21,
   PlugPlayControlGetBlockedDriverList = 22,
   PlugPlayControlGetDeviceInterfaceEnabled = 23,
   MaxPlugPlayControl = 24,
}
pub use self::_PLUGPLAY_CONTROL_CLASS as PLUGPLAY_CONTROL_CLASS;
pub type PPLUGPLAY_CONTROL_CLASS = *mut _PLUGPLAY_CONTROL_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_RELATION_TYPE {
   BusRelations = 0,
   EjectionRelations = 1,
   PowerRelations = 2,
   RemovalRelations = 3,
   TargetDeviceRelation = 4,
   SingleBusRelations = 5,
   TransportRelations = 6,
}
pub use self::_DEVICE_RELATION_TYPE as DEVICE_RELATION_TYPE;
pub type PDEVICE_RELATION_TYPE = *mut _DEVICE_RELATION_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BUS_QUERY_ID_TYPE {
   BusQueryDeviceID = 0,
   BusQueryHardwareIDs = 1,
   BusQueryCompatibleIDs = 2,
   BusQueryInstanceID = 3,
   BusQueryDeviceSerialNumber = 4,
   BusQueryContainerID = 5,
}
pub use self::_BUS_QUERY_ID_TYPE as BUS_QUERY_ID_TYPE;
pub type PBUS_QUERY_ID_TYPE = *mut _BUS_QUERY_ID_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_TEXT_TYPE {
   DeviceTextDescription = 0,
   DeviceTextLocationInformation = 1,
}
pub use self::_DEVICE_TEXT_TYPE as DEVICE_TEXT_TYPE;
pub type PDEVICE_TEXT_TYPE = *mut _DEVICE_TEXT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_USAGE_NOTIFICATION_TYPE {
   DeviceUsageTypeUndefined = 0,
   DeviceUsageTypePaging = 1,
   DeviceUsageTypeHibernation = 2,
   DeviceUsageTypeDumpFile = 3,
   DeviceUsageTypeBoot = 4,
   DeviceUsageTypePostDisplay = 5,
   DeviceUsageTypeGuestAssigned = 6,
}
pub use self::_DEVICE_USAGE_NOTIFICATION_TYPE as DEVICE_USAGE_NOTIFICATION_TYPE;
pub type PDEVICE_USAGE_NOTIFICATION_TYPE = *mut _DEVICE_USAGE_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_POWER_INFORMATION {
   pub Number: ULONG,
   pub MaxMhz: ULONG,
   pub CurrentMhz: ULONG,
   pub MhzLimit: ULONG,
   pub MaxIdleState: ULONG,
   pub CurrentIdleState: ULONG,
}
pub type PROCESSOR_POWER_INFORMATION = _PROCESSOR_POWER_INFORMATION;
pub type PPROCESSOR_POWER_INFORMATION = *mut _PROCESSOR_POWER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POWER_INFORMATION {
   pub MaxIdlenessAllowed: ULONG,
   pub Idleness: ULONG,
   pub TimeRemaining: ULONG,
   pub CoolingMode: UCHAR,
}
pub type SYSTEM_POWER_INFORMATION = _SYSTEM_POWER_INFORMATION;
pub type PSYSTEM_POWER_INFORMATION = *mut _SYSTEM_POWER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_HIBERFILE_INFORMATION {
   pub NumberOfMcbPairs: ULONG,
   pub Mcb: [LARGE_INTEGER; 1usize],
}
impl Default for _SYSTEM_HIBERFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_HIBERFILE_INFORMATION = _SYSTEM_HIBERFILE_INFORMATION;
pub type PSYSTEM_HIBERFILE_INFORMATION = *mut _SYSTEM_HIBERFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POWER_LOGGING_ENTRY {
   pub Reason: ULONG,
   pub States: ULONG,
}
pub type SYSTEM_POWER_LOGGING_ENTRY = _SYSTEM_POWER_LOGGING_ENTRY;
pub type PSYSTEM_POWER_LOGGING_ENTRY = *mut _SYSTEM_POWER_LOGGING_ENTRY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_STATE_DISABLED_TYPE {
   PoDisabledStateSleeping1 = 0,
   PoDisabledStateSleeping2 = 1,
   PoDisabledStateSleeping3 = 2,
   PoDisabledStateSleeping4 = 3,
   PoDisabledStateSleeping0Idle = 4,
   PoDisabledStateReserved5 = 5,
   PoDisabledStateSleeping4Firmware = 6,
   PoDisabledStateMaximum = 7,
}
pub use self::_POWER_STATE_DISABLED_TYPE as POWER_STATE_DISABLED_TYPE;
pub type PPOWER_STATE_DISABLED_TYPE = *mut _POWER_STATE_DISABLED_TYPE;
#[repr(C)]
pub struct _SYSTEM_POWER_STATE_DISABLE_REASON {
   pub AffectedState: [BOOLEAN; 8usize],
   pub PowerReasonCode: ULONG,
   pub PowerReasonLength: ULONG,
}
impl Default for _SYSTEM_POWER_STATE_DISABLE_REASON {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POWER_STATE_DISABLE_REASON = _SYSTEM_POWER_STATE_DISABLE_REASON;
pub type PSYSTEM_POWER_STATE_DISABLE_REASON = *mut _SYSTEM_POWER_STATE_DISABLE_REASON;
#[repr(C)]
pub struct _COUNTED_REASON_CONTEXT {
   pub Version: ULONG,
   pub Flags: ULONG,
   pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
pub union _COUNTED_REASON_CONTEXT__bindgen_ty_1 {
   pub __bindgen_anon_1:
      ::core::mem::ManuallyDrop<_COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1>,
   pub SimpleString: ::core::mem::ManuallyDrop<UNICODE_STRING>,
}
#[repr(C)]
pub struct _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   pub ResourceFileName: UNICODE_STRING,
   pub ResourceReasonId: USHORT,
   pub StringCount: ULONG,
   pub ReasonStrings: PUNICODE_STRING,
}
impl Default for _COUNTED_REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _COUNTED_REASON_CONTEXT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _COUNTED_REASON_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COUNTED_REASON_CONTEXT = _COUNTED_REASON_CONTEXT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_REQUEST_TYPE_INTERNAL {
   PowerRequestDisplayRequiredInternal = 0,
   PowerRequestSystemRequiredInternal = 1,
   PowerRequestAwayModeRequiredInternal = 2,
   PowerRequestExecutionRequiredInternal = 3,
   PowerRequestPerfBoostRequiredInternal = 4,
   PowerRequestActiveLockScreenInternal = 5,
   PowerRequestInternalInvalid = 6,
   PowerRequestInternalUnknown = 7,
   PowerRequestFullScreenVideoRequired = 8,
}
pub use self::_POWER_REQUEST_TYPE_INTERNAL as POWER_REQUEST_TYPE_INTERNAL;
#[repr(C)]
pub struct _POWER_REQUEST_ACTION {
   pub PowerRequestHandle: HANDLE,
   pub RequestType: POWER_REQUEST_TYPE_INTERNAL,
   pub SetAction: BOOLEAN,
   pub ProcessHandle: HANDLE,
}
impl Default for _POWER_REQUEST_ACTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_REQUEST_ACTION = _POWER_REQUEST_ACTION;
pub type PPOWER_REQUEST_ACTION = *mut _POWER_REQUEST_ACTION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
   pub SystemState: SYSTEM_POWER_STATE,
   pub DeviceState: DEVICE_POWER_STATE,
}
impl Default for _POWER_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_STATE = _POWER_STATE;
pub type PPOWER_STATE = *mut _POWER_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_STATE_TYPE {
   SystemPowerState = 0,
   DevicePowerState = 1,
}
pub use self::_POWER_STATE_TYPE as POWER_STATE_TYPE;
pub type PPOWER_STATE_TYPE = *mut _POWER_STATE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
   pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
   pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
   pub ContextAsUlong: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Reserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TargetSystemState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_TargetSystemState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TargetSystemState_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TargetSystemState_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EffectiveSystemState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EffectiveSystemState_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EffectiveSystemState_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CurrentSystemState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_CurrentSystemState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CurrentSystemState_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CurrentSystemState_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IgnoreHibernationPath(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IgnoreHibernationPath_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IgnoreHibernationPath_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn PseudoTransition(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PseudoTransition(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PseudoTransition_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            21usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PseudoTransition_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            21usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KernelSoftReboot(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_KernelSoftReboot(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KernelSoftReboot_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            22usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_KernelSoftReboot_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            22usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DirectedDripsTransition(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DirectedDripsTransition(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DirectedDripsTransition_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            23usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DirectedDripsTransition_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            23usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved2(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved2(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Reserved1: ULONG,
      TargetSystemState: ULONG,
      EffectiveSystemState: ULONG,
      CurrentSystemState: ULONG,
      IgnoreHibernationPath: ULONG,
      PseudoTransition: ULONG,
      KernelSoftReboot: ULONG,
      DirectedDripsTransition: ULONG,
      Reserved2: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit.set(8usize, 4u8, {
         let TargetSystemState: u32 = unsafe { ::core::mem::transmute(TargetSystemState) };
         TargetSystemState as u64
      });
      __bindgen_bitfield_unit.set(12usize, 4u8, {
         let EffectiveSystemState: u32 = unsafe { ::core::mem::transmute(EffectiveSystemState) };
         EffectiveSystemState as u64
      });
      __bindgen_bitfield_unit.set(16usize, 4u8, {
         let CurrentSystemState: u32 = unsafe { ::core::mem::transmute(CurrentSystemState) };
         CurrentSystemState as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let IgnoreHibernationPath: u32 = unsafe { ::core::mem::transmute(IgnoreHibernationPath) };
         IgnoreHibernationPath as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let PseudoTransition: u32 = unsafe { ::core::mem::transmute(PseudoTransition) };
         PseudoTransition as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let KernelSoftReboot: u32 = unsafe { ::core::mem::transmute(KernelSoftReboot) };
         KernelSoftReboot as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let DirectedDripsTransition: u32 =
            unsafe { ::core::mem::transmute(DirectedDripsTransition) };
         DirectedDripsTransition as u64
      });
      __bindgen_bitfield_unit.set(24usize, 8u8, {
         let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
         Reserved2 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_POWER_STATE_CONTEXT = _SYSTEM_POWER_STATE_CONTEXT;
pub type PSYSTEM_POWER_STATE_CONTEXT = *mut _SYSTEM_POWER_STATE_CONTEXT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REQUESTER_TYPE {
   KernelRequester = 0,
   UserProcessRequester = 1,
   UserSharedServiceRequester = 2,
}
pub use self::_REQUESTER_TYPE as REQUESTER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _COUNTED_REASON_CONTEXT_RELATIVE {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1 {
   pub __bindgen_anon_1: _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1__bindgen_ty_1,
   pub SimpleStringOffset: SIZE_T,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1__bindgen_ty_1 {
   pub ResourceFileNameOffset: SIZE_T,
   pub ResourceReasonId: USHORT,
   pub StringCount: ULONG,
   pub SubstitutionStringsOffset: SIZE_T,
}
impl Default for _COUNTED_REASON_CONTEXT_RELATIVE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _COUNTED_REASON_CONTEXT_RELATIVE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type COUNTED_REASON_CONTEXT_RELATIVE = _COUNTED_REASON_CONTEXT_RELATIVE;
pub type PCOUNTED_REASON_CONTEXT_RELATIVE = *mut _COUNTED_REASON_CONTEXT_RELATIVE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER {
   pub Size: SIZE_T,
   pub CallerType: REQUESTER_TYPE,
   pub __bindgen_anon_1: _DIAGNOSTIC_BUFFER__bindgen_ty_1,
   pub ReasonOffset: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DIAGNOSTIC_BUFFER__bindgen_ty_1 {
   pub __bindgen_anon_1: _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_1,
   pub __bindgen_anon_2: _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_1 {
   pub ProcessImageNameOffset: SIZE_T,
   pub ProcessId: ULONG,
   pub ServiceTag: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DIAGNOSTIC_BUFFER__bindgen_ty_1__bindgen_ty_2 {
   pub DeviceDescriptionOffset: SIZE_T,
   pub DevicePathOffset: SIZE_T,
}
impl Default for _DIAGNOSTIC_BUFFER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _DIAGNOSTIC_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DIAGNOSTIC_BUFFER = _DIAGNOSTIC_BUFFER;
pub type PDIAGNOSTIC_BUFFER = *mut _DIAGNOSTIC_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WAKE_TIMER_INFO {
   pub OffsetToNext: SIZE_T,
   pub DueTime: LARGE_INTEGER,
   pub Period: ULONG,
   pub ReasonContext: DIAGNOSTIC_BUFFER,
}
impl Default for _WAKE_TIMER_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WAKE_TIMER_INFO = _WAKE_TIMER_INFO;
pub type PWAKE_TIMER_INFO = *mut _WAKE_TIMER_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_PERF_CAP_HV {
   pub Version: ULONG,
   pub InitialApicId: ULONG,
   pub Ppc: ULONG,
   pub Tpc: ULONG,
   pub ThermalCap: ULONG,
}
pub type PROCESSOR_PERF_CAP_HV = _PROCESSOR_PERF_CAP_HV;
pub type PPROCESSOR_PERF_CAP_HV = *mut _PROCESSOR_PERF_CAP_HV;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PROCESSOR_IDLE_TIMES {
   pub StartTime: ULONG64,
   pub EndTime: ULONG64,
   pub Reserved: [ULONG; 4usize],
}
pub type PPROCESSOR_IDLE_TIMES = *mut PROCESSOR_IDLE_TIMES;
pub type PROCESSOR_IDLE_HANDLER = ::core::option::Option<
   unsafe extern "C" fn(Context: ULONG_PTR, IdleTimes: PPROCESSOR_IDLE_TIMES) -> NTSTATUS,
>;
pub type PPROCESSOR_IDLE_HANDLER = PROCESSOR_IDLE_HANDLER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_IDLE_STATE {
   pub StateType: UCHAR,
   pub StateFlags: ULONG,
   pub HardwareLatency: ULONG,
   pub Power: ULONG,
   pub Context: ULONG_PTR,
   pub Handler: PPROCESSOR_IDLE_HANDLER,
}
pub type PROCESSOR_IDLE_STATE = _PROCESSOR_IDLE_STATE;
pub type PPROCESSOR_IDLE_STATE = *mut _PROCESSOR_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_IDLE_STATES {
   pub Size: ULONG,
   pub Revision: ULONG,
   pub Count: ULONG,
   pub Type: ULONG,
   pub TargetProcessors: KAFFINITY,
   pub State: [PROCESSOR_IDLE_STATE; 1usize],
}
pub type PROCESSOR_IDLE_STATES = _PROCESSOR_IDLE_STATES;
pub type PPROCESSOR_IDLE_STATES = *mut _PROCESSOR_IDLE_STATES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_LOAD {
   pub ProcessorNumber: PROCESSOR_NUMBER,
   pub BusyPercentage: UCHAR,
   pub FrequencyPercentage: UCHAR,
   pub Padding: USHORT,
}
pub type PROCESSOR_LOAD = _PROCESSOR_LOAD;
pub type PPROCESSOR_LOAD = *mut _PROCESSOR_LOAD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_CAP {
   pub Version: ULONG,
   pub ProcessorNumber: PROCESSOR_NUMBER,
   pub PlatformCap: ULONG,
   pub ThermalCap: ULONG,
   pub LimitReasons: ULONG,
}
pub type PROCESSOR_CAP = _PROCESSOR_CAP;
pub type PPROCESSOR_CAP = *mut _PROCESSOR_CAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_INFO {
   pub Count: ULONG,
   pub Offsets: [ULONG; 1usize],
}
pub type PO_WAKE_SOURCE_INFO = _PO_WAKE_SOURCE_INFO;
pub type PPO_WAKE_SOURCE_INFO = *mut _PO_WAKE_SOURCE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_HISTORY {
   pub Count: ULONG,
   pub Offsets: [ULONG; 1usize],
}
pub type PO_WAKE_SOURCE_HISTORY = _PO_WAKE_SOURCE_HISTORY;
pub type PPO_WAKE_SOURCE_HISTORY = *mut _PO_WAKE_SOURCE_HISTORY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_WAKE_SOURCE_TYPE {
   DeviceWakeSourceType = 0,
   FixedWakeSourceType = 1,
   TimerWakeSourceType = 2,
   TimerPresumedWakeSourceType = 3,
   InternalWakeSourceType = 4,
}
pub use self::_PO_WAKE_SOURCE_TYPE as PO_WAKE_SOURCE_TYPE;
pub type PPO_WAKE_SOURCE_TYPE = *mut _PO_WAKE_SOURCE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_INTERNAL_WAKE_SOURCE_TYPE {
   InternalWakeSourceDozeToHibernate = 0,
   InternalWakeSourcePredictedUserPresence = 1,
}
pub use self::_PO_INTERNAL_WAKE_SOURCE_TYPE as PO_INTERNAL_WAKE_SOURCE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PO_FIXED_WAKE_SOURCE_TYPE {
   FixedWakeSourcePowerButton = 0,
   FixedWakeSourceSleepButton = 1,
   FixedWakeSourceRtc = 2,
   FixedWakeSourceDozeToHibernate = 3,
}
pub use self::_PO_FIXED_WAKE_SOURCE_TYPE as PO_FIXED_WAKE_SOURCE_TYPE;
pub type PPO_FIXED_WAKE_SOURCE_TYPE = *mut _PO_FIXED_WAKE_SOURCE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_HEADER {
   pub Type: PO_WAKE_SOURCE_TYPE,
   pub Size: ULONG,
}
impl Default for _PO_WAKE_SOURCE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_HEADER = _PO_WAKE_SOURCE_HEADER;
pub type PPO_WAKE_SOURCE_HEADER = *mut _PO_WAKE_SOURCE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_DEVICE {
   pub Header: PO_WAKE_SOURCE_HEADER,
   pub InstancePath: [WCHAR; 1usize],
}
impl Default for _PO_WAKE_SOURCE_DEVICE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_DEVICE = _PO_WAKE_SOURCE_DEVICE;
pub type PPO_WAKE_SOURCE_DEVICE = *mut _PO_WAKE_SOURCE_DEVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_FIXED {
   pub Header: PO_WAKE_SOURCE_HEADER,
   pub FixedWakeSourceType: PO_FIXED_WAKE_SOURCE_TYPE,
}
impl Default for _PO_WAKE_SOURCE_FIXED {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_FIXED = _PO_WAKE_SOURCE_FIXED;
pub type PPO_WAKE_SOURCE_FIXED = *mut _PO_WAKE_SOURCE_FIXED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PO_WAKE_SOURCE_INTERNAL {
   pub Header: PO_WAKE_SOURCE_HEADER,
   pub InternalWakeSourceType: PO_INTERNAL_WAKE_SOURCE_TYPE,
}
impl Default for _PO_WAKE_SOURCE_INTERNAL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_INTERNAL = _PO_WAKE_SOURCE_INTERNAL;
pub type PPO_WAKE_SOURCE_INTERNAL = *mut _PO_WAKE_SOURCE_INTERNAL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PO_WAKE_SOURCE_TIMER {
   pub Header: PO_WAKE_SOURCE_HEADER,
   pub Reason: DIAGNOSTIC_BUFFER,
}
impl Default for _PO_WAKE_SOURCE_TIMER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PO_WAKE_SOURCE_TIMER = _PO_WAKE_SOURCE_TIMER;
pub type PPO_WAKE_SOURCE_TIMER = *mut _PO_WAKE_SOURCE_TIMER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST {
   pub __bindgen_anon_1: _POWER_REQUEST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_REQUEST__bindgen_ty_1 {
   pub V1: _POWER_REQUEST__bindgen_ty_1__bindgen_ty_1,
   pub V2: _POWER_REQUEST__bindgen_ty_1__bindgen_ty_2,
   pub V3: _POWER_REQUEST__bindgen_ty_1__bindgen_ty_3,
   pub V4: _POWER_REQUEST__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST__bindgen_ty_1__bindgen_ty_1 {
   pub SupportedRequestMask: ULONG,
   pub PowerRequestCount: [ULONG; 3usize],
   pub DiagnosticBuffer: DIAGNOSTIC_BUFFER,
}
impl Default for _POWER_REQUEST__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST__bindgen_ty_1__bindgen_ty_2 {
   pub SupportedRequestMask: ULONG,
   pub PowerRequestCount: [ULONG; 9usize],
   pub DiagnosticBuffer: DIAGNOSTIC_BUFFER,
}
impl Default for _POWER_REQUEST__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST__bindgen_ty_1__bindgen_ty_3 {
   pub SupportedRequestMask: ULONG,
   pub PowerRequestCount: [ULONG; 5usize],
   pub DiagnosticBuffer: DIAGNOSTIC_BUFFER,
}
impl Default for _POWER_REQUEST__bindgen_ty_1__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_REQUEST__bindgen_ty_1__bindgen_ty_4 {
   pub SupportedRequestMask: ULONG,
   pub PowerRequestCount: [ULONG; 6usize],
   pub DiagnosticBuffer: DIAGNOSTIC_BUFFER,
}
impl Default for _POWER_REQUEST__bindgen_ty_1__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _POWER_REQUEST__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _POWER_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_REQUEST = _POWER_REQUEST;
pub type PPOWER_REQUEST = *mut _POWER_REQUEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_REQUEST_LIST {
   pub Count: ULONG_PTR,
   pub PowerRequestOffsets: [ULONG_PTR; 1usize],
}
pub type POWER_REQUEST_LIST = _POWER_REQUEST_LIST;
pub type PPOWER_REQUEST_LIST = *mut _POWER_REQUEST_LIST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_STATE_HANDLER_TYPE {
   PowerStateSleeping1 = 0,
   PowerStateSleeping2 = 1,
   PowerStateSleeping3 = 2,
   PowerStateSleeping4 = 3,
   PowerStateShutdownOff = 4,
   PowerStateShutdownReset = 5,
   PowerStateSleeping4Firmware = 6,
   PowerStateMaximum = 7,
}
pub use self::_POWER_STATE_HANDLER_TYPE as POWER_STATE_HANDLER_TYPE;
pub type PPOWER_STATE_HANDLER_TYPE = *mut _POWER_STATE_HANDLER_TYPE;
pub type PENTER_STATE_SYSTEM_HANDLER =
   ::core::option::Option<unsafe extern "C" fn(SystemContext: PVOID) -> NTSTATUS>;
pub type PENTER_STATE_HANDLER = ::core::option::Option<
   unsafe extern "C" fn(
      Context: PVOID,
      SystemHandler: PENTER_STATE_SYSTEM_HANDLER,
      SystemContext: PVOID,
      NumberProcessors: LONG,
      Number: *mut LONG,
   ) -> NTSTATUS,
>;
#[repr(C)]
pub struct _POWER_STATE_HANDLER {
   pub Type: POWER_STATE_HANDLER_TYPE,
   pub RtcWake: BOOLEAN,
   pub Spare: [UCHAR; 3usize],
   pub Handler: PENTER_STATE_HANDLER,
   pub Context: PVOID,
}
impl Default for _POWER_STATE_HANDLER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_STATE_HANDLER = _POWER_STATE_HANDLER;
pub type PPOWER_STATE_HANDLER = *mut _POWER_STATE_HANDLER;
pub type PENTER_STATE_NOTIFY_HANDLER = ::core::option::Option<
   unsafe extern "C" fn(
      State: POWER_STATE_HANDLER_TYPE,
      Context: PVOID,
      Entering: BOOLEAN,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_STATE_NOTIFY_HANDLER {
   pub Handler: PENTER_STATE_NOTIFY_HANDLER,
   pub Context: PVOID,
}
impl Default for _POWER_STATE_NOTIFY_HANDLER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_STATE_NOTIFY_HANDLER = _POWER_STATE_NOTIFY_HANDLER;
pub type PPOWER_STATE_NOTIFY_HANDLER = *mut _POWER_STATE_NOTIFY_HANDLER;
#[repr(C)]
pub struct _POWER_REQUEST_ACTION_INTERNAL {
   pub PowerRequestPointer: PVOID,
   pub RequestType: POWER_REQUEST_TYPE_INTERNAL,
   pub SetAction: BOOLEAN,
}
impl Default for _POWER_REQUEST_ACTION_INTERNAL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_REQUEST_ACTION_INTERNAL = _POWER_REQUEST_ACTION_INTERNAL;
pub type PPOWER_REQUEST_ACTION_INTERNAL = *mut _POWER_REQUEST_ACTION_INTERNAL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_INFORMATION_LEVEL_INTERNAL {
   PowerInternalAcpiInterfaceRegister = 0,
   PowerInternalS0LowPowerIdleInfo = 1,
   PowerInternalReapplyBrightnessSettings = 2,
   PowerInternalUserAbsencePrediction = 3,
   PowerInternalUserAbsencePredictionCapability = 4,
   PowerInternalPoProcessorLatencyHint = 5,
   PowerInternalStandbyNetworkRequest = 6,
   PowerInternalDirtyTransitionInformation = 7,
   PowerInternalSetBackgroundTaskState = 8,
   PowerInternalTtmOpenTerminal = 9,
   PowerInternalTtmCreateTerminal = 10,
   PowerInternalTtmEvacuateDevices = 11,
   PowerInternalTtmCreateTerminalEventQueue = 12,
   PowerInternalTtmGetTerminalEvent = 13,
   PowerInternalTtmSetDefaultDeviceAssignment = 14,
   PowerInternalTtmAssignDevice = 15,
   PowerInternalTtmSetDisplayState = 16,
   PowerInternalTtmSetDisplayTimeouts = 17,
   PowerInternalBootSessionStandbyActivationInformation = 18,
   PowerInternalSessionPowerState = 19,
   PowerInternalSessionTerminalInput = 20,
   PowerInternalSetWatchdog = 21,
   PowerInternalPhysicalPowerButtonPressInfoAtBoot = 22,
   PowerInternalExternalMonitorConnected = 23,
   PowerInternalHighPrecisionBrightnessSettings = 24,
   PowerInternalWinrtScreenToggle = 25,
   PowerInternalPpmQosDisable = 26,
   PowerInternalTransitionCheckpoint = 27,
   PowerInternalInputControllerState = 28,
   PowerInternalFirmwareResetReason = 29,
   PowerInternalPpmSchedulerQosSupport = 30,
   PowerInternalBootStatGet = 31,
   PowerInternalBootStatSet = 32,
   PowerInternalCallHasNotReturnedWatchdog = 33,
   PowerInternalBootStatCheckIntegrity = 34,
   PowerInternalBootStatRestoreDefaults = 35,
   PowerInternalHostEsStateUpdate = 36,
   PowerInternalGetPowerActionState = 37,
   PowerInternalBootStatUnlock = 38,
   PowerInternalWakeOnVoiceState = 39,
   PowerInternalDeepSleepBlock = 40,
   PowerInternalIsPoFxDevice = 41,
   PowerInternalPowerTransitionExtensionAtBoot = 42,
   PowerInternalProcessorBrandedFrequency = 43,
   PowerInternalTimeBrokerExpirationReason = 44,
   PowerInternalNotifyUserShutdownStatus = 45,
   PowerInternalPowerRequestTerminalCoreWindow = 46,
   PowerInternalProcessorIdleVeto = 47,
   PowerInternalPlatformIdleVeto = 48,
   PowerInternalIsLongPowerButtonBugcheckEnabled = 49,
   PowerInternalAutoChkCausedReboot = 50,
   PowerInternalSetWakeAlarmOverride = 51,
   PowerInternalDirectedFxAddTestDevice = 53,
   PowerInternalDirectedFxRemoveTestDevice = 54,
   PowerInternalDirectedFxSetMode = 56,
   PowerInternalRegisterPowerPlane = 57,
   PowerInternalSetDirectedDripsFlags = 58,
   PowerInternalClearDirectedDripsFlags = 59,
   PowerInternalRetrieveHiberFileResumeContext = 60,
   PowerInternalReadHiberFilePage = 61,
   PowerInternalLastBootSucceeded = 62,
   PowerInternalQuerySleepStudyHelperRoutineBlock = 63,
   PowerInternalDirectedDripsQueryCapabilities = 64,
   PowerInternalClearConstraints = 65,
   PowerInternalSoftParkVelocityEnabled = 66,
   PowerInternalQueryIntelPepCapabilities = 67,
   PowerInternalGetSystemIdleLoopEnablement = 68,
   PowerInternalGetVmPerfControlSupport = 69,
   PowerInternalGetVmPerfControlConfig = 70,
   PowerInternalSleepDetailedDiagUpdate = 71,
   PowerInternalProcessorClassFrequencyBandsStats = 72,
   PowerInternalHostGlobalUserPresenceStateUpdate = 73,
   PowerInternalCpuNodeIdleIntervalStats = 74,
   PowerInternalClassIdleIntervalStats = 75,
   PowerInternalCpuNodeConcurrencyStats = 76,
   PowerInternalClassConcurrencyStats = 77,
   PowerInternalQueryProcMeasurementCapabilities = 78,
   PowerInternalQueryProcMeasurementValues = 79,
   PowerInternalPrepareForSystemInitiatedReboot = 80,
   PowerInternalGetAdaptiveSessionState = 81,
   PowerInternalSetConsoleLockedState = 82,
   PowerInternalOverrideSystemInitiatedRebootState = 83,
   PowerInternalFanImpactStats = 84,
   PowerInternalFanRpmBuckets = 85,
   PowerInternalPowerBootAppDiagInfo = 86,
   PowerInternalUnregisterShutdownNotification = 87,
   PowerInternalManageTransitionStateRecord = 88,
   PowerInternalGetAcpiTimeAndAlarmCapabilities = 89,
   PowerInternalSuspendResumeRequest = 90,
   PowerInternalEnergyEstimationInfo = 91,
   PowerInternalProvSocIdentifierOperation = 92,
   PowerInternalGetVmPerfPrioritySupport = 93,
   PowerInternalGetVmPerfPriorityConfig = 94,
   PowerInternalNotifyWin32kPowerRequestQueued = 95,
   PowerInternalNotifyWin32kPowerRequestCompleted = 96,
   PowerInformationInternalMaximum = 97,
}
pub use self::_POWER_INFORMATION_LEVEL_INTERNAL as POWER_INFORMATION_LEVEL_INTERNAL;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_S0_DISCONNECTED_REASON {
   PoS0DisconnectedReasonNone = 0,
   PoS0DisconnectedReasonNonCompliantNic = 1,
   PoS0DisconnectedReasonSettingPolicy = 2,
   PoS0DisconnectedReasonEnforceDsPolicy = 3,
   PoS0DisconnectedReasonCsChecksFailed = 4,
   PoS0DisconnectedReasonSmartStandby = 5,
   PoS0DisconnectedReasonMaximum = 6,
}
pub use self::_POWER_S0_DISCONNECTED_REASON as POWER_S0_DISCONNECTED_REASON;
#[repr(C)]
pub struct _POWER_S0_LOW_POWER_IDLE_INFO {
   pub DisconnectedReason: POWER_S0_DISCONNECTED_REASON,
   pub CsDeviceCompliance: _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_1,
   pub Policy: _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_2,
}
#[repr(C)]
pub union _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub AsUCHAR: UCHAR,
}
impl Default for _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_1 {
   #[inline]
   pub fn Storage(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Storage(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Storage_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Storage_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn WiFi(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WiFi(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn WiFi_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_WiFi_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Mbn(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Mbn(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Mbn_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Mbn_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Ethernet(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Ethernet(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Ethernet_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Ethernet_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            4u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Storage: BOOLEAN,
      WiFi: BOOLEAN,
      Mbn: BOOLEAN,
      Ethernet: BOOLEAN,
      Reserved: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Storage: u8 = unsafe { ::core::mem::transmute(Storage) };
         Storage as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let WiFi: u8 = unsafe { ::core::mem::transmute(WiFi) };
         WiFi as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let Mbn: u8 = unsafe { ::core::mem::transmute(Mbn) };
         Mbn as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let Ethernet: u8 = unsafe { ::core::mem::transmute(Ethernet) };
         Ethernet as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
pub union _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_2 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub AsUCHAR: UCHAR,
}
impl Default for _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _POWER_S0_LOW_POWER_IDLE_INFO__bindgen_ty_2 {
   #[inline]
   pub fn DisconnectInStandby(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DisconnectInStandby(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisconnectInStandby_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_DisconnectInStandby_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnforceDs(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_EnforceDs(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnforceDs_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_EnforceDs_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            6u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DisconnectInStandby: BOOLEAN,
      EnforceDs: BOOLEAN,
      Reserved: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let DisconnectInStandby: u8 = unsafe { ::core::mem::transmute(DisconnectInStandby) };
         DisconnectInStandby as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let EnforceDs: u8 = unsafe { ::core::mem::transmute(EnforceDs) };
         EnforceDs as u64
      });
      __bindgen_bitfield_unit.set(2usize, 6u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _POWER_S0_LOW_POWER_IDLE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_S0_LOW_POWER_IDLE_INFO = _POWER_S0_LOW_POWER_IDLE_INFO;
pub type PPOWER_S0_LOW_POWER_IDLE_INFO = *mut _POWER_S0_LOW_POWER_IDLE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_INFORMATION_INTERNAL_HEADER {
   pub InternalType: POWER_INFORMATION_LEVEL_INTERNAL,
   pub Version: ULONG,
}
impl Default for _POWER_INFORMATION_INTERNAL_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_INFORMATION_INTERNAL_HEADER = _POWER_INFORMATION_INTERNAL_HEADER;
pub type PPOWER_INFORMATION_INTERNAL_HEADER = *mut _POWER_INFORMATION_INTERNAL_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _POWER_USER_ABSENCE_PREDICTION {
   pub Header: POWER_INFORMATION_INTERNAL_HEADER,
   pub ReturnTime: LARGE_INTEGER,
}
impl Default for _POWER_USER_ABSENCE_PREDICTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_USER_ABSENCE_PREDICTION = _POWER_USER_ABSENCE_PREDICTION;
pub type PPOWER_USER_ABSENCE_PREDICTION = *mut _POWER_USER_ABSENCE_PREDICTION;
#[repr(C)]
pub struct _POWER_USER_ABSENCE_PREDICTION_CAPABILITY {
   pub AbsencePredictionCapability: BOOLEAN,
}
impl Default for _POWER_USER_ABSENCE_PREDICTION_CAPABILITY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_USER_ABSENCE_PREDICTION_CAPABILITY = _POWER_USER_ABSENCE_PREDICTION_CAPABILITY;
pub type PPOWER_USER_ABSENCE_PREDICTION_CAPABILITY = *mut _POWER_USER_ABSENCE_PREDICTION_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_PROCESSOR_LATENCY_HINT {
   pub PowerInformationInternalHeader: POWER_INFORMATION_INTERNAL_HEADER,
   pub Type: ULONG,
}
impl Default for _POWER_PROCESSOR_LATENCY_HINT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_PROCESSOR_LATENCY_HINT = _POWER_PROCESSOR_LATENCY_HINT;
pub type PPOWER_PROCESSOR_LATENCY_HINT = *mut _POWER_PROCESSOR_LATENCY_HINT;
#[repr(C)]
pub struct _POWER_STANDBY_NETWORK_REQUEST {
   pub PowerInformationInternalHeader: POWER_INFORMATION_INTERNAL_HEADER,
   pub Active: BOOLEAN,
}
impl Default for _POWER_STANDBY_NETWORK_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_STANDBY_NETWORK_REQUEST = _POWER_STANDBY_NETWORK_REQUEST;
pub type PPOWER_STANDBY_NETWORK_REQUEST = *mut _POWER_STANDBY_NETWORK_REQUEST;
#[repr(C)]
pub struct _POWER_SET_BACKGROUND_TASK_STATE {
   pub PowerInformationInternalHeader: POWER_INFORMATION_INTERNAL_HEADER,
   pub Engaged: BOOLEAN,
}
impl Default for _POWER_SET_BACKGROUND_TASK_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_SET_BACKGROUND_TASK_STATE = _POWER_SET_BACKGROUND_TASK_STATE;
pub type PPOWER_SET_BACKGROUND_TASK_STATE = *mut _POWER_SET_BACKGROUND_TASK_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO {
   pub StandbyTotalTime: ULONG,
   pub DripsTotalTime: ULONG,
   pub ActivatorClientTotalActiveTime: ULONG,
   pub PerActivatorClientTotalActiveTime: [ULONG; 98usize],
}
impl Default for _POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO = _POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO;
pub type PPOWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO =
   *mut _POWER_BOOT_SESSION_STANDBY_ACTIVATION_INFO;
#[repr(C)]
pub struct _POWER_SESSION_POWER_STATE {
   pub Header: POWER_INFORMATION_INTERNAL_HEADER,
   pub SessionId: ULONG,
   pub On: BOOLEAN,
   pub IsConsole: BOOLEAN,
   pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
impl Default for _POWER_SESSION_POWER_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_SESSION_POWER_STATE = _POWER_SESSION_POWER_STATE;
pub type PPOWER_SESSION_POWER_STATE = *mut _POWER_SESSION_POWER_STATE;
#[repr(C)]
pub struct _POWER_INTERNAL_PROCESSOR_QOS_SUPPORT {
   pub QosSupportedAndConfigured: BOOLEAN,
   pub SchedulerDirectedPerfStatesSupported: BOOLEAN,
   pub QosGroupPolicyDisable: BOOLEAN,
}
impl Default for _POWER_INTERNAL_PROCESSOR_QOS_SUPPORT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_INTERNAL_PROCESSOR_QOS_SUPPORT = _POWER_INTERNAL_PROCESSOR_QOS_SUPPORT;
pub type PPOWER_INTERNAL_PROCESSOR_QOS_SUPPORT = *mut _POWER_INTERNAL_PROCESSOR_QOS_SUPPORT;
#[repr(C)]
pub struct _POWER_INTERNAL_HOST_ENERGY_SAVER_STATE {
   pub Header: POWER_INFORMATION_INTERNAL_HEADER,
   pub EsEnabledOnHost: BOOLEAN,
}
impl Default for _POWER_INTERNAL_HOST_ENERGY_SAVER_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_INTERNAL_HOST_ENERGY_SAVER_STATE = _POWER_INTERNAL_HOST_ENERGY_SAVER_STATE;
pub type PPOWER_INTERNAL_HOST_ENERGY_SAVER_STATE = *mut _POWER_INTERNAL_HOST_ENERGY_SAVER_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_INPUT {
   pub InternalType: POWER_INFORMATION_LEVEL_INTERNAL,
   pub ProcessorNumber: PROCESSOR_NUMBER,
}
impl Default for _POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_INPUT =
   _POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_INPUT;
pub type PPOWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_INPUT =
   *mut _POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_OUTPUT {
   pub Version: ULONG,
   pub NominalFrequency: ULONG,
}
pub type POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_OUTPUT =
   _POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_OUTPUT;
pub type PPOWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_OUTPUT =
   *mut _POWER_INTERNAL_PROCESSOR_BRANDED_FREQUENCY_OUTPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESSOR_IDLE_VETO {
   pub Version: ULONG,
   pub ProcessorNumber: PROCESSOR_NUMBER,
   pub StateIndex: ULONG,
   pub VetoReason: ULONG,
   pub Increment: UCHAR,
}
pub type PROCESSOR_IDLE_VETO = _PROCESSOR_IDLE_VETO;
pub type PPROCESSOR_IDLE_VETO = *mut _PROCESSOR_IDLE_VETO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PLATFORM_IDLE_VETO {
   pub Version: ULONG,
   pub StateIndex: ULONG,
   pub VetoReason: ULONG,
   pub Increment: UCHAR,
}
pub type PLATFORM_IDLE_VETO = _PLATFORM_IDLE_VETO;
pub type PPLATFORM_IDLE_VETO = *mut _PLATFORM_IDLE_VETO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_INTERNAL_BOOTAPP_DIAGNOSTIC {
   pub BootAppErrorDiagCode: ULONG,
   pub BootAppFailureStatus: ULONG,
}
pub type POWER_INTERNAL_BOOTAPP_DIAGNOSTIC = _POWER_INTERNAL_BOOTAPP_DIAGNOSTIC;
pub type PPOWER_INTERNAL_BOOTAPP_DIAGNOSTIC = *mut _POWER_INTERNAL_BOOTAPP_DIAGNOSTIC;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KEY_INFORMATION_CLASS {
   KeyBasicInformation = 0,
   KeyNodeInformation = 1,
   KeyFullInformation = 2,
   KeyNameInformation = 3,
   KeyCachedInformation = 4,
   KeyFlagsInformation = 5,
   KeyVirtualizationInformation = 6,
   KeyHandleTagsInformation = 7,
   KeyTrustInformation = 8,
   KeyLayerInformation = 9,
   MaxKeyInfoClass = 10,
}
pub use self::_KEY_INFORMATION_CLASS as KEY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_BASIC_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
   pub TitleIndex: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
impl Default for _KEY_BASIC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_BASIC_INFORMATION = _KEY_BASIC_INFORMATION;
pub type PKEY_BASIC_INFORMATION = *mut _KEY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_NODE_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
   pub TitleIndex: ULONG,
   pub ClassOffset: ULONG,
   pub ClassLength: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
impl Default for _KEY_NODE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_NODE_INFORMATION = _KEY_NODE_INFORMATION;
pub type PKEY_NODE_INFORMATION = *mut _KEY_NODE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_FULL_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
   pub TitleIndex: ULONG,
   pub ClassOffset: ULONG,
   pub ClassLength: ULONG,
   pub SubKeys: ULONG,
   pub MaxNameLength: ULONG,
   pub MaxClassLength: ULONG,
   pub Values: ULONG,
   pub MaxValueNameLength: ULONG,
   pub MaxValueDataLength: ULONG,
   pub Class: [WCHAR; 1usize],
}
impl Default for _KEY_FULL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_FULL_INFORMATION = _KEY_FULL_INFORMATION;
pub type PKEY_FULL_INFORMATION = *mut _KEY_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_NAME_INFORMATION {
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
pub type KEY_NAME_INFORMATION = _KEY_NAME_INFORMATION;
pub type PKEY_NAME_INFORMATION = *mut _KEY_NAME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_CACHED_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
   pub TitleIndex: ULONG,
   pub SubKeys: ULONG,
   pub MaxNameLength: ULONG,
   pub Values: ULONG,
   pub MaxValueNameLength: ULONG,
   pub MaxValueDataLength: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
impl Default for _KEY_CACHED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_CACHED_INFORMATION = _KEY_CACHED_INFORMATION;
pub type PKEY_CACHED_INFORMATION = *mut _KEY_CACHED_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_FLAGS_INFORMATION {
   pub Wow64Flags: ULONG,
   pub KeyFlags: ULONG,
   pub ControlFlags: ULONG,
}
pub type KEY_FLAGS_INFORMATION = _KEY_FLAGS_INFORMATION;
pub type PKEY_FLAGS_INFORMATION = *mut _KEY_FLAGS_INFORMATION;
#[doc = "The KEY_VIRTUALIZATION_INFORMATION structure contains information about the virtualization state of a key.\nThe flags include:\n- VirtualizationCandidate: The key is part of the virtualization namespace scope (only HKLM\\Software for now).\n- VirtualizationEnabled: Virtualization is enabled on this key. Can be 1 only if VirtualizationCandidate is 1.\n- VirtualTarget: The key is a virtual key. Can be 1 only if VirtualizationCandidate and VirtualizationEnabled are 0. Valid only on the virtual store key handles.\n- VirtualStore: The key is a part of the virtual store path. Valid only on the virtual store key handles.\n- VirtualSource: The key has ever been virtualized, can be 1 only if VirtualizationCandidate is 1.\n- Reserved: Reserved bits."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VIRTUALIZATION_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_VIRTUALIZATION_INFORMATION {
   #[inline]
   pub fn VirtualizationCandidate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualizationCandidate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualizationCandidate_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualizationCandidate_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualizationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualizationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualizationEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualizationEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualTarget(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualTarget(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualTarget_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualTarget_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualStore(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualStore(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualStore_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualStore_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualSource(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualSource(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualSource_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualSource_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      VirtualizationCandidate: ULONG,
      VirtualizationEnabled: ULONG,
      VirtualTarget: ULONG,
      VirtualStore: ULONG,
      VirtualSource: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let VirtualizationCandidate: u32 =
            unsafe { ::core::mem::transmute(VirtualizationCandidate) };
         VirtualizationCandidate as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let VirtualizationEnabled: u32 = unsafe { ::core::mem::transmute(VirtualizationEnabled) };
         VirtualizationEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let VirtualTarget: u32 = unsafe { ::core::mem::transmute(VirtualTarget) };
         VirtualTarget as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let VirtualStore: u32 = unsafe { ::core::mem::transmute(VirtualStore) };
         VirtualStore as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let VirtualSource: u32 = unsafe { ::core::mem::transmute(VirtualSource) };
         VirtualSource as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[doc = "The KEY_VIRTUALIZATION_INFORMATION structure contains information about the virtualization state of a key.\nThe flags include:\n- VirtualizationCandidate: The key is part of the virtualization namespace scope (only HKLM\\Software for now).\n- VirtualizationEnabled: Virtualization is enabled on this key. Can be 1 only if VirtualizationCandidate is 1.\n- VirtualTarget: The key is a virtual key. Can be 1 only if VirtualizationCandidate and VirtualizationEnabled are 0. Valid only on the virtual store key handles.\n- VirtualStore: The key is a part of the virtual store path. Valid only on the virtual store key handles.\n- VirtualSource: The key has ever been virtualized, can be 1 only if VirtualizationCandidate is 1.\n- Reserved: Reserved bits."]
pub type KEY_VIRTUALIZATION_INFORMATION = _KEY_VIRTUALIZATION_INFORMATION;
#[doc = "The KEY_VIRTUALIZATION_INFORMATION structure contains information about the virtualization state of a key.\nThe flags include:\n- VirtualizationCandidate: The key is part of the virtualization namespace scope (only HKLM\\Software for now).\n- VirtualizationEnabled: Virtualization is enabled on this key. Can be 1 only if VirtualizationCandidate is 1.\n- VirtualTarget: The key is a virtual key. Can be 1 only if VirtualizationCandidate and VirtualizationEnabled are 0. Valid only on the virtual store key handles.\n- VirtualStore: The key is a part of the virtual store path. Valid only on the virtual store key handles.\n- VirtualSource: The key has ever been virtualized, can be 1 only if VirtualizationCandidate is 1.\n- Reserved: Reserved bits."]
pub type PKEY_VIRTUALIZATION_INFORMATION = *mut _KEY_VIRTUALIZATION_INFORMATION;
#[doc = "The KEY_TRUST_INFORMATION structure contains information about the trust status of a key.\nThe flags include:\n- TrustedKey: Indicates whether the key is trusted. When set, this flag signifies that the key is considered\nto be secure and reliable.\n- Reserved: Reserved bits."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_TRUST_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_TRUST_INFORMATION {
   #[inline]
   pub fn TrustedKey(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_TrustedKey(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TrustedKey_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TrustedKey_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      TrustedKey: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let TrustedKey: u32 = unsafe { ::core::mem::transmute(TrustedKey) };
         TrustedKey as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[doc = "The KEY_TRUST_INFORMATION structure contains information about the trust status of a key.\nThe flags include:\n- TrustedKey: Indicates whether the key is trusted. When set, this flag signifies that the key is considered\nto be secure and reliable.\n- Reserved: Reserved bits."]
pub type KEY_TRUST_INFORMATION = _KEY_TRUST_INFORMATION;
#[doc = "The KEY_TRUST_INFORMATION structure contains information about the trust status of a key.\nThe flags include:\n- TrustedKey: Indicates whether the key is trusted. When set, this flag signifies that the key is considered\nto be secure and reliable.\n- Reserved: Reserved bits."]
pub type PKEY_TRUST_INFORMATION = *mut _KEY_TRUST_INFORMATION;
#[doc = "The KEY_LAYER_INFORMATION structure contains information about a key layer.\nThe flags include:\n- IsTombstone: Indicates whether the key layer is a tombstone. A tombstone is a marker that indicates\nthat the key has been deleted but not yet purged from the registry. It is used to maintain the\nintegrity of the registry and ensure that deleted keys are not immediately reused.\n- IsSupersedeLocal: Indicates whether the key layer supersedes the local key. When set, this flag\nindicates that the key layer should replace the local key's information, effectively overriding\nany local changes or settings.\n- IsSupersedeTree: Indicates whether the key layer supersedes the entire key tree. When set, this flag\nindicates that the key layer should replace the entire subtree of keys, overriding any changes or\nsettings in the subtree.\n- ClassIsInherited: Indicates whether the key layer's class is inherited. When set, this flag indicates\nthat the class information of the key layer is inherited from its parent key, rather than being\nexplicitly defined.\n- Reserved: Reserved bits."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_LAYER_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_LAYER_INFORMATION {
   #[inline]
   pub fn IsTombstone(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTombstone(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsTombstone_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsTombstone_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsSupersedeLocal(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSupersedeLocal(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsSupersedeLocal_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsSupersedeLocal_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsSupersedeTree(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSupersedeTree(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsSupersedeTree_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsSupersedeTree_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ClassIsInherited(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ClassIsInherited(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ClassIsInherited_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ClassIsInherited_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsTombstone: ULONG,
      IsSupersedeLocal: ULONG,
      IsSupersedeTree: ULONG,
      ClassIsInherited: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
         IsTombstone as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsSupersedeLocal: u32 = unsafe { ::core::mem::transmute(IsSupersedeLocal) };
         IsSupersedeLocal as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsSupersedeTree: u32 = unsafe { ::core::mem::transmute(IsSupersedeTree) };
         IsSupersedeTree as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ClassIsInherited: u32 = unsafe { ::core::mem::transmute(ClassIsInherited) };
         ClassIsInherited as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[doc = "The KEY_LAYER_INFORMATION structure contains information about a key layer.\nThe flags include:\n- IsTombstone: Indicates whether the key layer is a tombstone. A tombstone is a marker that indicates\nthat the key has been deleted but not yet purged from the registry. It is used to maintain the\nintegrity of the registry and ensure that deleted keys are not immediately reused.\n- IsSupersedeLocal: Indicates whether the key layer supersedes the local key. When set, this flag\nindicates that the key layer should replace the local key's information, effectively overriding\nany local changes or settings.\n- IsSupersedeTree: Indicates whether the key layer supersedes the entire key tree. When set, this flag\nindicates that the key layer should replace the entire subtree of keys, overriding any changes or\nsettings in the subtree.\n- ClassIsInherited: Indicates whether the key layer's class is inherited. When set, this flag indicates\nthat the class information of the key layer is inherited from its parent key, rather than being\nexplicitly defined.\n- Reserved: Reserved bits."]
pub type KEY_LAYER_INFORMATION = _KEY_LAYER_INFORMATION;
#[doc = "The KEY_LAYER_INFORMATION structure contains information about a key layer.\nThe flags include:\n- IsTombstone: Indicates whether the key layer is a tombstone. A tombstone is a marker that indicates\nthat the key has been deleted but not yet purged from the registry. It is used to maintain the\nintegrity of the registry and ensure that deleted keys are not immediately reused.\n- IsSupersedeLocal: Indicates whether the key layer supersedes the local key. When set, this flag\nindicates that the key layer should replace the local key's information, effectively overriding\nany local changes or settings.\n- IsSupersedeTree: Indicates whether the key layer supersedes the entire key tree. When set, this flag\nindicates that the key layer should replace the entire subtree of keys, overriding any changes or\nsettings in the subtree.\n- ClassIsInherited: Indicates whether the key layer's class is inherited. When set, this flag indicates\nthat the class information of the key layer is inherited from its parent key, rather than being\nexplicitly defined.\n- Reserved: Reserved bits."]
pub type PKEY_LAYER_INFORMATION = *mut _KEY_LAYER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KEY_SET_INFORMATION_CLASS {
   KeyWriteTimeInformation = 0,
   KeyWow64FlagsInformation = 1,
   KeyControlFlagsInformation = 2,
   KeySetVirtualizationInformation = 3,
   KeySetDebugInformation = 4,
   KeySetHandleTagsInformation = 5,
   KeySetLayerInformation = 6,
   MaxKeySetInfoClass = 7,
}
pub use self::_KEY_SET_INFORMATION_CLASS as KEY_SET_INFORMATION_CLASS;
#[doc = "Structure representing the last write time of a registry key.\nThe values include:\n- LastWriteTime: Contains the timestamp of the last write operation performed on a registry key."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_WRITE_TIME_INFORMATION {
   pub LastWriteTime: LARGE_INTEGER,
}
impl Default for _KEY_WRITE_TIME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[doc = "Structure representing the last write time of a registry key.\nThe values include:\n- LastWriteTime: Contains the timestamp of the last write operation performed on a registry key."]
pub type KEY_WRITE_TIME_INFORMATION = _KEY_WRITE_TIME_INFORMATION;
#[doc = "Structure representing the last write time of a registry key.\nThe values include:\n- LastWriteTime: Contains the timestamp of the last write operation performed on a registry key."]
pub type PKEY_WRITE_TIME_INFORMATION = *mut _KEY_WRITE_TIME_INFORMATION;
#[doc = "The KEY_WOW64_FLAGS_INFORMATION structure contains information about the WOW64 flags for a key.\nThe fields include:\n- UserFlags: A set of user-defined flags associated with the key. These flags are used to store\nadditional information about the key in the context of WOW64 (Windows 32-bit on Windows 64-bit)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_WOW64_FLAGS_INFORMATION {
   pub UserFlags: ULONG,
}
#[doc = "The KEY_WOW64_FLAGS_INFORMATION structure contains information about the WOW64 flags for a key.\nThe fields include:\n- UserFlags: A set of user-defined flags associated with the key. These flags are used to store\nadditional information about the key in the context of WOW64 (Windows 32-bit on Windows 64-bit)."]
pub type KEY_WOW64_FLAGS_INFORMATION = _KEY_WOW64_FLAGS_INFORMATION;
#[doc = "The KEY_WOW64_FLAGS_INFORMATION structure contains information about the WOW64 flags for a key.\nThe fields include:\n- UserFlags: A set of user-defined flags associated with the key. These flags are used to store\nadditional information about the key in the context of WOW64 (Windows 32-bit on Windows 64-bit)."]
pub type PKEY_WOW64_FLAGS_INFORMATION = *mut _KEY_WOW64_FLAGS_INFORMATION;
#[doc = "The KEY_HANDLE_TAGS_INFORMATION structure contains information about the handle tags for a key.\nThe fields include:\n- HandleTags: A set of tags associated with the key handle. These tags are used to store additional\nmetadata or state information about the key handle."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_HANDLE_TAGS_INFORMATION {
   pub HandleTags: ULONG,
}
#[doc = "The KEY_HANDLE_TAGS_INFORMATION structure contains information about the handle tags for a key.\nThe fields include:\n- HandleTags: A set of tags associated with the key handle. These tags are used to store additional\nmetadata or state information about the key handle."]
pub type KEY_HANDLE_TAGS_INFORMATION = _KEY_HANDLE_TAGS_INFORMATION;
#[doc = "The KEY_HANDLE_TAGS_INFORMATION structure contains information about the handle tags for a key.\nThe fields include:\n- HandleTags: A set of tags associated with the key handle. These tags are used to store additional\nmetadata or state information about the key handle."]
pub type PKEY_HANDLE_TAGS_INFORMATION = *mut _KEY_HANDLE_TAGS_INFORMATION;
#[doc = "The KEY_SET_LAYER_INFORMATION structure contains information about a key layer.\nThe flags include:\n- IsTombstone: Indicates whether the key layer is a tombstone. A tombstone is a marker that indicates\nthat the key has been deleted but not yet purged from the registry. It is used to maintain the\nintegrity of the registry and ensure that deleted keys are not immediately reused.\n- IsSupersedeLocal: Indicates whether the key layer supersedes the local key. When set, this flag\nindicates that the key layer should replace the local key's information, effectively overriding\nany local changes or settings.\n- IsSupersedeTree: Indicates whether the key layer supersedes the entire key tree. When set, this flag\nindicates that the key layer should replace the entire subtree of keys, overriding any changes or\nsettings in the subtree.\n- ClassIsInherited: Indicates whether the key layer's class is inherited. When set, this flag indicates\nthat the class information of the key layer is inherited from its parent key, rather than being\nexplicitly defined.\n- Reserved: Reserved bits."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_SET_LAYER_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_SET_LAYER_INFORMATION {
   #[inline]
   pub fn IsTombstone(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTombstone(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsTombstone_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsTombstone_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsSupersedeLocal(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSupersedeLocal(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsSupersedeLocal_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsSupersedeLocal_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsSupersedeTree(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsSupersedeTree(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsSupersedeTree_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsSupersedeTree_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ClassIsInherited(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ClassIsInherited(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ClassIsInherited_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ClassIsInherited_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsTombstone: ULONG,
      IsSupersedeLocal: ULONG,
      IsSupersedeTree: ULONG,
      ClassIsInherited: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
         IsTombstone as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsSupersedeLocal: u32 = unsafe { ::core::mem::transmute(IsSupersedeLocal) };
         IsSupersedeLocal as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsSupersedeTree: u32 = unsafe { ::core::mem::transmute(IsSupersedeTree) };
         IsSupersedeTree as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ClassIsInherited: u32 = unsafe { ::core::mem::transmute(ClassIsInherited) };
         ClassIsInherited as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[doc = "The KEY_SET_LAYER_INFORMATION structure contains information about a key layer.\nThe flags include:\n- IsTombstone: Indicates whether the key layer is a tombstone. A tombstone is a marker that indicates\nthat the key has been deleted but not yet purged from the registry. It is used to maintain the\nintegrity of the registry and ensure that deleted keys are not immediately reused.\n- IsSupersedeLocal: Indicates whether the key layer supersedes the local key. When set, this flag\nindicates that the key layer should replace the local key's information, effectively overriding\nany local changes or settings.\n- IsSupersedeTree: Indicates whether the key layer supersedes the entire key tree. When set, this flag\nindicates that the key layer should replace the entire subtree of keys, overriding any changes or\nsettings in the subtree.\n- ClassIsInherited: Indicates whether the key layer's class is inherited. When set, this flag indicates\nthat the class information of the key layer is inherited from its parent key, rather than being\nexplicitly defined.\n- Reserved: Reserved bits."]
pub type KEY_SET_LAYER_INFORMATION = _KEY_SET_LAYER_INFORMATION;
#[doc = "The KEY_SET_LAYER_INFORMATION structure contains information about a key layer.\nThe flags include:\n- IsTombstone: Indicates whether the key layer is a tombstone. A tombstone is a marker that indicates\nthat the key has been deleted but not yet purged from the registry. It is used to maintain the\nintegrity of the registry and ensure that deleted keys are not immediately reused.\n- IsSupersedeLocal: Indicates whether the key layer supersedes the local key. When set, this flag\nindicates that the key layer should replace the local key's information, effectively overriding\nany local changes or settings.\n- IsSupersedeTree: Indicates whether the key layer supersedes the entire key tree. When set, this flag\nindicates that the key layer should replace the entire subtree of keys, overriding any changes or\nsettings in the subtree.\n- ClassIsInherited: Indicates whether the key layer's class is inherited. When set, this flag indicates\nthat the class information of the key layer is inherited from its parent key, rather than being\nexplicitly defined.\n- Reserved: Reserved bits."]
pub type PKEY_SET_LAYER_INFORMATION = *mut _KEY_SET_LAYER_INFORMATION;
#[doc = "The KEY_CONTROL_FLAGS_INFORMATION structure contains control flags for a key.\nThe fields include:\n- ControlFlags: A set of control flags associated with the key. These flags are used to store\nadditional control information about the key, which can affect its behavior or state."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_CONTROL_FLAGS_INFORMATION {
   pub ControlFlags: ULONG,
}
#[doc = "The KEY_CONTROL_FLAGS_INFORMATION structure contains control flags for a key.\nThe fields include:\n- ControlFlags: A set of control flags associated with the key. These flags are used to store\nadditional control information about the key, which can affect its behavior or state."]
pub type KEY_CONTROL_FLAGS_INFORMATION = _KEY_CONTROL_FLAGS_INFORMATION;
#[doc = "The KEY_CONTROL_FLAGS_INFORMATION structure contains control flags for a key.\nThe fields include:\n- ControlFlags: A set of control flags associated with the key. These flags are used to store\nadditional control information about the key, which can affect its behavior or state."]
pub type PKEY_CONTROL_FLAGS_INFORMATION = *mut _KEY_CONTROL_FLAGS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_SET_VIRTUALIZATION_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_SET_VIRTUALIZATION_INFORMATION {
   #[inline]
   pub fn VirtualTarget(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualTarget(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualTarget_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualTarget_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualStore(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualStore(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualStore_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualStore_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualSource(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualSource(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualSource_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualSource_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            29u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            29u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      VirtualTarget: ULONG,
      VirtualStore: ULONG,
      VirtualSource: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let VirtualTarget: u32 = unsafe { ::core::mem::transmute(VirtualTarget) };
         VirtualTarget as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let VirtualStore: u32 = unsafe { ::core::mem::transmute(VirtualStore) };
         VirtualStore as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let VirtualSource: u32 = unsafe { ::core::mem::transmute(VirtualSource) };
         VirtualSource as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type KEY_SET_VIRTUALIZATION_INFORMATION = _KEY_SET_VIRTUALIZATION_INFORMATION;
pub type PKEY_SET_VIRTUALIZATION_INFORMATION = *mut _KEY_SET_VIRTUALIZATION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KEY_VALUE_INFORMATION_CLASS {
   KeyValueBasicInformation = 0,
   KeyValueFullInformation = 1,
   KeyValuePartialInformation = 2,
   KeyValueFullInformationAlign64 = 3,
   KeyValuePartialInformationAlign64 = 4,
   KeyValueLayerInformation = 5,
   MaxKeyValueInfoClass = 6,
}
pub use self::_KEY_VALUE_INFORMATION_CLASS as KEY_VALUE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_BASIC_INFORMATION {
   pub TitleIndex: ULONG,
   pub Type: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
pub type KEY_VALUE_BASIC_INFORMATION = _KEY_VALUE_BASIC_INFORMATION;
pub type PKEY_VALUE_BASIC_INFORMATION = *mut _KEY_VALUE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_FULL_INFORMATION {
   pub TitleIndex: ULONG,
   pub Type: ULONG,
   pub DataOffset: ULONG,
   pub DataLength: ULONG,
   pub NameLength: ULONG,
   pub Name: [WCHAR; 1usize],
}
pub type KEY_VALUE_FULL_INFORMATION = _KEY_VALUE_FULL_INFORMATION;
pub type PKEY_VALUE_FULL_INFORMATION = *mut _KEY_VALUE_FULL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION {
   pub TitleIndex: ULONG,
   pub Type: ULONG,
   pub DataLength: ULONG,
   pub Data: [UCHAR; 1usize],
}
pub type KEY_VALUE_PARTIAL_INFORMATION = _KEY_VALUE_PARTIAL_INFORMATION;
pub type PKEY_VALUE_PARTIAL_INFORMATION = *mut _KEY_VALUE_PARTIAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
   pub Type: ULONG,
   pub DataLength: ULONG,
   pub Data: [UCHAR; 1usize],
}
pub type KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
pub type PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 = *mut _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KEY_VALUE_LAYER_INFORMATION {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _KEY_VALUE_LAYER_INFORMATION {
   #[inline]
   pub fn IsTombstone(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsTombstone(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsTombstone_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsTombstone_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IsTombstone: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IsTombstone: u32 = unsafe { ::core::mem::transmute(IsTombstone) };
         IsTombstone as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type KEY_VALUE_LAYER_INFORMATION = _KEY_VALUE_LAYER_INFORMATION;
pub type PKEY_VALUE_LAYER_INFORMATION = *mut _KEY_VALUE_LAYER_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CM_EXTENDED_PARAMETER_TYPE {
   CmExtendedParameterInvalidType = 0,
   CmExtendedParameterTrustClassKey = 1,
   CmExtendedParameterEvent = 2,
   CmExtendedParameterFileAccessToken = 3,
   CmExtendedParameterMax = 4,
}
pub use self::_CM_EXTENDED_PARAMETER_TYPE as CM_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_EXTENDED_PARAMETER {
   pub __bindgen_anon_1: _CM_EXTENDED_PARAMETER__bindgen_ty_1,
   pub __bindgen_anon_2: _CM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_EXTENDED_PARAMETER__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _CM_EXTENDED_PARAMETER__bindgen_ty_1 {
   #[inline]
   pub fn Type(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Type_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Type_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 56u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            56u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            56u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Type: ULONG64, Reserved: ULONG64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let Type: u64 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(8usize, 56u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_EXTENDED_PARAMETER__bindgen_ty_2 {
   pub ULong64: ULONG64,
   pub Pointer: PVOID,
   pub Size: SIZE_T,
   pub Handle: HANDLE,
   pub ULong: ULONG,
   pub AccessMask: ACCESS_MASK,
}
impl Default for _CM_EXTENDED_PARAMETER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _CM_EXTENDED_PARAMETER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CM_EXTENDED_PARAMETER = _CM_EXTENDED_PARAMETER;
pub type PCM_EXTENDED_PARAMETER = *mut _CM_EXTENDED_PARAMETER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_ENTRY {
   pub ValueName: PUNICODE_STRING,
   pub DataLength: ULONG,
   pub DataOffset: ULONG,
   pub Type: ULONG,
}
impl Default for _KEY_VALUE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_VALUE_ENTRY = _KEY_VALUE_ENTRY;
pub type PKEY_VALUE_ENTRY = *mut _KEY_VALUE_ENTRY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REG_ACTION {
   KeyAdded = 0,
   KeyRemoved = 1,
   KeyModified = 2,
}
pub use self::_REG_ACTION as REG_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REG_NOTIFY_INFORMATION {
   pub NextEntryOffset: ULONG,
   pub Action: REG_ACTION,
   pub KeyLength: ULONG,
   pub Key: [WCHAR; 1usize],
}
impl Default for _REG_NOTIFY_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type REG_NOTIFY_INFORMATION = _REG_NOTIFY_INFORMATION;
pub type PREG_NOTIFY_INFORMATION = *mut _REG_NOTIFY_INFORMATION;
#[repr(C)]
pub struct _KEY_PID_ARRAY {
   pub ProcessId: HANDLE,
   pub KeyName: UNICODE_STRING,
}
impl Default for _KEY_PID_ARRAY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_PID_ARRAY = _KEY_PID_ARRAY;
pub type PKEY_PID_ARRAY = *mut _KEY_PID_ARRAY;
#[repr(C)]
pub struct _KEY_OPEN_SUBKEYS_INFORMATION {
   pub Count: ULONG,
   pub KeyArray: [KEY_PID_ARRAY; 1usize],
}
impl Default for _KEY_OPEN_SUBKEYS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KEY_OPEN_SUBKEYS_INFORMATION = _KEY_OPEN_SUBKEYS_INFORMATION;
pub type PKEY_OPEN_SUBKEYS_INFORMATION = *mut _KEY_OPEN_SUBKEYS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_INITIALIZE_JOB_FOR_VREG {
   pub Job: HANDLE,
}
impl Default for _VR_INITIALIZE_JOB_FOR_VREG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_INITIALIZE_JOB_FOR_VREG = _VR_INITIALIZE_JOB_FOR_VREG;
pub type PVR_INITIALIZE_JOB_FOR_VREG = *mut _VR_INITIALIZE_JOB_FOR_VREG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_LOAD_DIFFERENCING_HIVE {
   pub Job: HANDLE,
   pub NextLayerIsHost: ULONG,
   pub Flags: ULONG,
   pub LoadFlags: ULONG,
   pub KeyPathLength: USHORT,
   pub HivePathLength: USHORT,
   pub NextLayerKeyPathLength: USHORT,
   pub FileAccessToken: HANDLE,
   pub Strings: [WCHAR; 1usize],
}
impl Default for _VR_LOAD_DIFFERENCING_HIVE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_LOAD_DIFFERENCING_HIVE = _VR_LOAD_DIFFERENCING_HIVE;
pub type PVR_LOAD_DIFFERENCING_HIVE = *mut _VR_LOAD_DIFFERENCING_HIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_CREATE_NAMESPACE_NODE {
   pub Job: HANDLE,
   pub ContainerPathLength: USHORT,
   pub HostPathLength: USHORT,
   pub Flags: ULONG,
   pub AccessMask: ACCESS_MASK,
   pub Strings: [WCHAR; 1usize],
}
impl Default for _VR_CREATE_NAMESPACE_NODE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_CREATE_NAMESPACE_NODE = _VR_CREATE_NAMESPACE_NODE;
pub type PVR_CREATE_NAMESPACE_NODE = *mut _VR_CREATE_NAMESPACE_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_MODIFY_FLAGS {
   pub Job: HANDLE,
   pub AddFlags: ULONG,
   pub RemoveFlags: ULONG,
}
impl Default for _VR_MODIFY_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_MODIFY_FLAGS = _VR_MODIFY_FLAGS;
pub type PVR_MODIFY_FLAGS = *mut _VR_MODIFY_FLAGS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _NAMESPACE_NODE_DATA {
   pub AccessMask: ACCESS_MASK,
   pub ContainerPathLength: USHORT,
   pub HostPathLength: USHORT,
   pub Flags: ULONG,
   pub Strings: [WCHAR; 1usize],
}
pub type NAMESPACE_NODE_DATA = _NAMESPACE_NODE_DATA;
pub type PNAMESPACE_NODE_DATA = *mut _NAMESPACE_NODE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_CREATE_MULTIPLE_NAMESPACE_NODES {
   pub Job: HANDLE,
   pub NumNewKeys: ULONG,
   pub Keys: [NAMESPACE_NODE_DATA; 1usize],
}
impl Default for _VR_CREATE_MULTIPLE_NAMESPACE_NODES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_CREATE_MULTIPLE_NAMESPACE_NODES = _VR_CREATE_MULTIPLE_NAMESPACE_NODES;
pub type PVR_CREATE_MULTIPLE_NAMESPACE_NODES = *mut _VR_CREATE_MULTIPLE_NAMESPACE_NODES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_UNLOAD_DYNAMICALLY_LOADED_HIVES {
   pub Job: HANDLE,
}
impl Default for _VR_UNLOAD_DYNAMICALLY_LOADED_HIVES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_UNLOAD_DYNAMICALLY_LOADED_HIVES = _VR_UNLOAD_DYNAMICALLY_LOADED_HIVES;
pub type PVR_UNLOAD_DYNAMICALLY_LOADED_HIVES = *mut _VR_UNLOAD_DYNAMICALLY_LOADED_HIVES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_GET_VIRTUAL_ROOT {
   pub Job: HANDLE,
   pub Index: ULONG,
}
impl Default for _VR_GET_VIRTUAL_ROOT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_GET_VIRTUAL_ROOT = _VR_GET_VIRTUAL_ROOT;
pub type PVR_GET_VIRTUAL_ROOT = *mut _VR_GET_VIRTUAL_ROOT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_GET_VIRTUAL_ROOT_RESULT {
   pub Key: HANDLE,
}
impl Default for _VR_GET_VIRTUAL_ROOT_RESULT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_GET_VIRTUAL_ROOT_RESULT = _VR_GET_VIRTUAL_ROOT_RESULT;
pub type PVR_GET_VIRTUAL_ROOT_RESULT = *mut _VR_GET_VIRTUAL_ROOT_RESULT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VR_LOAD_DIFFERENCING_HIVE_FOR_HOST {
   pub LoadFlags: ULONG,
   pub Flags: ULONG,
   pub KeyPathLength: USHORT,
   pub HivePathLength: USHORT,
   pub NextLayerKeyPathLength: USHORT,
   pub FileAccessToken: HANDLE,
   pub Strings: [WCHAR; 1usize],
}
impl Default for _VR_LOAD_DIFFERENCING_HIVE_FOR_HOST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VR_LOAD_DIFFERENCING_HIVE_FOR_HOST = _VR_LOAD_DIFFERENCING_HIVE_FOR_HOST;
pub type PVR_LOAD_DIFFERENCING_HIVE_FOR_HOST = *mut _VR_LOAD_DIFFERENCING_HIVE_FOR_HOST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST {
   pub Reserved: ULONG,
   pub TargetKeyPathLength: USHORT,
   pub TargetKeyPath: [WCHAR; 1usize],
}
pub type VR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST = _VR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST;
pub type PVR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST = *mut _VR_UNLOAD_DIFFERENCING_HIVE_FOR_HOST;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TABLE_SEARCH_RESULT {
   TableEmptyTree = 0,
   TableFoundNode = 1,
   TableInsertAsLeft = 2,
   TableInsertAsRight = 3,
}
pub use self::_TABLE_SEARCH_RESULT as TABLE_SEARCH_RESULT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_GENERIC_COMPARE_RESULTS {
   GenericLessThan = 0,
   GenericGreaterThan = 1,
   GenericEqual = 2,
}
pub use self::_RTL_GENERIC_COMPARE_RESULTS as RTL_GENERIC_COMPARE_RESULTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_AVL_TABLE {
   _unused: [u8; 0],
}
pub type PRTL_AVL_COMPARE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      Table: *mut _RTL_AVL_TABLE,
      FirstStruct: PVOID,
      SecondStruct: PVOID,
   ) -> RTL_GENERIC_COMPARE_RESULTS,
>;
pub type PRTL_AVL_ALLOCATE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(Table: *mut _RTL_AVL_TABLE, ByteSize: CLONG) -> PVOID,
>;
pub type PRTL_AVL_FREE_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(Table: *mut _RTL_AVL_TABLE, Buffer: PVOID)>;
pub type PRTL_AVL_MATCH_FUNCTION = ::core::option::Option<
   unsafe extern "C" fn(Table: *mut _RTL_AVL_TABLE, UserData: PVOID, MatchData: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BALANCED_LINKS {
   pub Parent: *mut _RTL_BALANCED_LINKS,
   pub LeftChild: *mut _RTL_BALANCED_LINKS,
   pub RightChild: *mut _RTL_BALANCED_LINKS,
   pub Balance: CHAR,
   pub Reserved: [UCHAR; 3usize],
}
impl Default for _RTL_BALANCED_LINKS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BALANCED_LINKS = _RTL_BALANCED_LINKS;
pub type PRTL_BALANCED_LINKS = *mut _RTL_BALANCED_LINKS;
pub type RTL_AVL_TABLE = _RTL_AVL_TABLE;
pub type PRTL_AVL_TABLE = *mut _RTL_AVL_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SPLAY_LINKS {
   pub Parent: *mut _RTL_SPLAY_LINKS,
   pub LeftChild: *mut _RTL_SPLAY_LINKS,
   pub RightChild: *mut _RTL_SPLAY_LINKS,
}
impl Default for _RTL_SPLAY_LINKS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SPLAY_LINKS = _RTL_SPLAY_LINKS;
pub type PRTL_SPLAY_LINKS = *mut _RTL_SPLAY_LINKS;
pub type PRTL_GENERIC_COMPARE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      Table: *mut _RTL_GENERIC_TABLE,
      FirstStruct: PVOID,
      SecondStruct: PVOID,
   ) -> RTL_GENERIC_COMPARE_RESULTS,
>;
pub type PRTL_GENERIC_ALLOCATE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(Table: *mut _RTL_GENERIC_TABLE, ByteSize: CLONG) -> PVOID,
>;
pub type PRTL_GENERIC_FREE_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(Table: *mut _RTL_GENERIC_TABLE, Buffer: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_GENERIC_TABLE {
   pub TableRoot: PRTL_SPLAY_LINKS,
   pub InsertOrderList: LIST_ENTRY,
   pub OrderedPointer: PLIST_ENTRY,
   pub WhichOrderedElement: ULONG,
   pub NumberGenericTableElements: ULONG,
   pub CompareRoutine: PRTL_GENERIC_COMPARE_ROUTINE,
   pub AllocateRoutine: PRTL_GENERIC_ALLOCATE_ROUTINE,
   pub FreeRoutine: PRTL_GENERIC_FREE_ROUTINE,
   pub TableContext: PVOID,
}
impl Default for _RTL_GENERIC_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_GENERIC_TABLE = _RTL_GENERIC_TABLE;
pub type PRTL_GENERIC_TABLE = *mut _RTL_GENERIC_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_RB_TREE {
   pub Root: PRTL_BALANCED_NODE,
   pub Min: PRTL_BALANCED_NODE,
}
impl Default for _RTL_RB_TREE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_RB_TREE = _RTL_RB_TREE;
pub type PRTL_RB_TREE = *mut _RTL_RB_TREE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENTRY {
   pub Linkage: LIST_ENTRY,
   pub Signature: ULONG_PTR,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DYNAMIC_HASH_TABLE_ENTRY = _RTL_DYNAMIC_HASH_TABLE_ENTRY;
pub type PRTL_DYNAMIC_HASH_TABLE_ENTRY = *mut _RTL_DYNAMIC_HASH_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
   pub ChainHead: PLIST_ENTRY,
   pub PrevLinkage: PLIST_ENTRY,
   pub Signature: ULONG_PTR,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DYNAMIC_HASH_TABLE_CONTEXT = _RTL_DYNAMIC_HASH_TABLE_CONTEXT;
pub type PRTL_DYNAMIC_HASH_TABLE_CONTEXT = *mut _RTL_DYNAMIC_HASH_TABLE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
   pub HashEntry: RTL_DYNAMIC_HASH_TABLE_ENTRY,
   pub ChainHead: PLIST_ENTRY,
   pub BucketIndex: ULONG,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DYNAMIC_HASH_TABLE_ENUMERATOR = _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;
pub type PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR = *mut _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DYNAMIC_HASH_TABLE {
   pub Flags: ULONG,
   pub Shift: ULONG,
   pub TableSize: ULONG,
   pub Pivot: ULONG,
   pub DivisorMask: ULONG,
   pub NumEntries: ULONG,
   pub NonEmptyBuckets: ULONG,
   pub NumEnumerators: ULONG,
   pub Directory: PVOID,
}
impl Default for _RTL_DYNAMIC_HASH_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DYNAMIC_HASH_TABLE = _RTL_DYNAMIC_HASH_TABLE;
pub type PRTL_DYNAMIC_HASH_TABLE = *mut _RTL_DYNAMIC_HASH_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_RESOURCE {
   pub CriticalSection: RTL_CRITICAL_SECTION,
   pub SharedSemaphore: HANDLE,
   pub NumberOfWaitingShared: ULONG,
   pub ExclusiveSemaphore: HANDLE,
   pub NumberOfWaitingExclusive: ULONG,
   pub NumberOfActive: LONG,
   pub ExclusiveOwnerThread: HANDLE,
   pub Flags: ULONG,
   pub DebugInfo: PRTL_RESOURCE_DEBUG,
}
impl Default for _RTL_RESOURCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_RESOURCE = _RTL_RESOURCE;
pub type PRTL_RESOURCE = *mut _RTL_RESOURCE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_NORM_FORM {
   NormOther = 0,
   NormC = 1,
   NormD = 2,
   NormKC = 5,
   NormKD = 6,
   NormIdna = 13,
   DisallowUnassigned = 256,
   NormCDisallowUnassigned = 257,
   NormDDisallowUnassigned = 258,
   NormKCDisallowUnassigned = 261,
   NormKDDisallowUnassigned = 262,
   NormIdnaDisallowUnassigned = 269,
}
pub use self::_RTL_NORM_FORM as RTL_NORM_FORM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFIX_TABLE_ENTRY {
   pub NodeTypeCode: CSHORT,
   pub NameLength: CSHORT,
   pub NextPrefixTree: *mut _PREFIX_TABLE_ENTRY,
   pub Links: RTL_SPLAY_LINKS,
   pub Prefix: PSTRING,
}
impl Default for _PREFIX_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PREFIX_TABLE_ENTRY = _PREFIX_TABLE_ENTRY;
pub type PPREFIX_TABLE_ENTRY = *mut _PREFIX_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREFIX_TABLE {
   pub NodeTypeCode: CSHORT,
   pub NameLength: CSHORT,
   pub NextPrefixTree: PPREFIX_TABLE_ENTRY,
}
impl Default for _PREFIX_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PREFIX_TABLE = _PREFIX_TABLE;
pub type PPREFIX_TABLE = *mut _PREFIX_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_PREFIX_TABLE_ENTRY {
   pub NodeTypeCode: CSHORT,
   pub NameLength: CSHORT,
   pub NextPrefixTree: *mut _UNICODE_PREFIX_TABLE_ENTRY,
   pub CaseMatch: *mut _UNICODE_PREFIX_TABLE_ENTRY,
   pub Links: RTL_SPLAY_LINKS,
   pub Prefix: PUNICODE_STRING,
}
impl Default for _UNICODE_PREFIX_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type UNICODE_PREFIX_TABLE_ENTRY = _UNICODE_PREFIX_TABLE_ENTRY;
pub type PUNICODE_PREFIX_TABLE_ENTRY = *mut _UNICODE_PREFIX_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_PREFIX_TABLE {
   pub NodeTypeCode: CSHORT,
   pub NameLength: CSHORT,
   pub NextPrefixTree: PUNICODE_PREFIX_TABLE_ENTRY,
   pub LastNextEntry: PUNICODE_PREFIX_TABLE_ENTRY,
}
impl Default for _UNICODE_PREFIX_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type UNICODE_PREFIX_TABLE = _UNICODE_PREFIX_TABLE;
pub type PUNICODE_PREFIX_TABLE = *mut _UNICODE_PREFIX_TABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _COMPRESSED_DATA_INFO {
   pub CompressionFormatAndEngine: USHORT,
   pub CompressionUnitShift: UCHAR,
   pub ChunkShift: UCHAR,
   pub ClusterShift: UCHAR,
   pub Reserved: UCHAR,
   pub NumberOfChunks: USHORT,
   pub CompressedChunkSizes: [ULONG; 1usize],
}
pub type COMPRESSED_DATA_INFO = _COMPRESSED_DATA_INFO;
pub type PCOMPRESSED_DATA_INFO = *mut _COMPRESSED_DATA_INFO;
#[repr(C)]
pub struct _CURDIR {
   pub DosPath: UNICODE_STRING,
   pub Handle: HANDLE,
}
impl Default for _CURDIR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CURDIR = _CURDIR;
pub type PCURDIR = *mut _CURDIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_DRIVE_LETTER_CURDIR {
   pub Flags: USHORT,
   pub Length: USHORT,
   pub TimeStamp: ULONG,
   pub DosPath: STRING,
}
impl Default for _RTL_DRIVE_LETTER_CURDIR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DRIVE_LETTER_CURDIR = _RTL_DRIVE_LETTER_CURDIR;
pub type PRTL_DRIVE_LETTER_CURDIR = *mut _RTL_DRIVE_LETTER_CURDIR;
#[repr(C)]
pub struct _RTL_USER_PROCESS_PARAMETERS {
   pub MaximumLength: ULONG,
   pub Length: ULONG,
   pub Flags: ULONG,
   pub DebugFlags: ULONG,
   pub ConsoleHandle: HANDLE,
   pub ConsoleFlags: ULONG,
   pub StandardInput: HANDLE,
   pub StandardOutput: HANDLE,
   pub StandardError: HANDLE,
   pub CurrentDirectory: CURDIR,
   pub DllPath: UNICODE_STRING,
   pub ImagePathName: UNICODE_STRING,
   pub CommandLine: UNICODE_STRING,
   pub Environment: PVOID,
   pub StartingX: ULONG,
   pub StartingY: ULONG,
   pub CountX: ULONG,
   pub CountY: ULONG,
   pub CountCharsX: ULONG,
   pub CountCharsY: ULONG,
   pub FillAttribute: ULONG,
   pub WindowFlags: ULONG,
   pub ShowWindowFlags: ULONG,
   pub WindowTitle: UNICODE_STRING,
   pub DesktopInfo: UNICODE_STRING,
   pub ShellInfo: UNICODE_STRING,
   pub RuntimeData: UNICODE_STRING,
   pub CurrentDirectories: [RTL_DRIVE_LETTER_CURDIR; 32usize],
   pub EnvironmentSize: ULONG_PTR,
   pub EnvironmentVersion: ULONG_PTR,
   pub PackageDependencyData: PVOID,
   pub ProcessGroupId: ULONG,
   pub LoaderThreads: ULONG,
   pub RedirectionDllName: UNICODE_STRING,
   pub HeapPartitionName: UNICODE_STRING,
   pub DefaultThreadpoolCpuSetMasks: PULONGLONG,
   pub DefaultThreadpoolCpuSetMaskCount: ULONG,
   pub DefaultThreadpoolThreadMaximum: ULONG,
   pub HeapMemoryTypeMask: ULONG,
}
impl Default for _RTL_USER_PROCESS_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_USER_PROCESS_PARAMETERS = _RTL_USER_PROCESS_PARAMETERS;
#[repr(C)]
pub struct _RTL_USER_PROCESS_INFORMATION {
   pub Length: ULONG,
   pub ProcessHandle: HANDLE,
   pub ThreadHandle: HANDLE,
   pub ClientId: CLIENT_ID,
   pub ImageInformation: SECTION_IMAGE_INFORMATION,
}
impl Default for _RTL_USER_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_USER_PROCESS_INFORMATION = _RTL_USER_PROCESS_INFORMATION;
pub type PRTL_USER_PROCESS_INFORMATION = *mut _RTL_USER_PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_USER_PROCESS_EXTENDED_PARAMETERS {
   pub Version: USHORT,
   pub NodeNumber: USHORT,
   pub ProcessSecurityDescriptor: PSECURITY_DESCRIPTOR,
   pub ThreadSecurityDescriptor: PSECURITY_DESCRIPTOR,
   pub ParentProcess: HANDLE,
   pub DebugPort: HANDLE,
   pub TokenHandle: HANDLE,
   pub JobHandle: HANDLE,
}
impl Default for _RTL_USER_PROCESS_EXTENDED_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_USER_PROCESS_EXTENDED_PARAMETERS = _RTL_USER_PROCESS_EXTENDED_PARAMETERS;
pub type PRTL_USER_PROCESS_EXTENDED_PARAMETERS = *mut _RTL_USER_PROCESS_EXTENDED_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION {
   pub ReflectionProcessHandle: HANDLE,
   pub ReflectionThreadHandle: HANDLE,
   pub ReflectionClientId: CLIENT_ID,
}
impl Default for _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION =
   _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;
pub type PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION =
   *mut _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;
pub type PROCESS_REFLECTION_INFORMATION = RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;
pub type PPROCESS_REFLECTION_INFORMATION = *mut RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CONTEXT_CHUNK {
   pub Offset: LONG,
   pub Length: ULONG,
}
pub type CONTEXT_CHUNK = _CONTEXT_CHUNK;
pub type PCONTEXT_CHUNK = *mut _CONTEXT_CHUNK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CONTEXT_EX {
   pub All: CONTEXT_CHUNK,
   pub Legacy: CONTEXT_CHUNK,
   pub XState: CONTEXT_CHUNK,
   pub KernelCet: CONTEXT_CHUNK,
}
pub type CONTEXT_EX = _CONTEXT_EX;
pub type PCONTEXT_EX = *mut _CONTEXT_EX;
pub type PRTLP_UNHANDLED_EXCEPTION_FILTER =
   ::core::option::Option<unsafe extern "C" fn(ExceptionInfo: PEXCEPTION_POINTERS) -> ULONG>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FUNCTION_TABLE_TYPE {
   RF_SORTED = 0,
   RF_UNSORTED = 1,
   RF_CALLBACK = 2,
   RF_KERNEL_DYNAMIC = 3,
}
pub use self::_FUNCTION_TABLE_TYPE as FUNCTION_TABLE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DYNAMIC_FUNCTION_TABLE {
   pub ListEntry: LIST_ENTRY,
   pub FunctionTable: PRUNTIME_FUNCTION,
   pub TimeStamp: LARGE_INTEGER,
   pub MinimumAddress: ULONG64,
   pub MaximumAddress: ULONG64,
   pub BaseAddress: ULONG64,
   pub Callback: PGET_RUNTIME_FUNCTION_CALLBACK,
   pub Context: PVOID,
   pub OutOfProcessCallbackDll: PWSTR,
   pub Type: FUNCTION_TABLE_TYPE,
   pub EntryCount: ULONG,
   pub TreeNodeMin: RTL_BALANCED_NODE,
   pub TreeNodeMax: RTL_BALANCED_NODE,
}
impl Default for _DYNAMIC_FUNCTION_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DYNAMIC_FUNCTION_TABLE = _DYNAMIC_FUNCTION_TABLE;
pub type PDYNAMIC_FUNCTION_TABLE = *mut _DYNAMIC_FUNCTION_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_CURDIR_REF {
   pub ReferenceCount: LONG,
   pub DirectoryHandle: HANDLE,
}
impl Default for _RTLP_CURDIR_REF {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_CURDIR_REF = _RTLP_CURDIR_REF;
pub type PRTLP_CURDIR_REF = *mut _RTLP_CURDIR_REF;
#[repr(C)]
pub struct _RTL_RELATIVE_NAME_U {
   pub RelativeName: UNICODE_STRING,
   pub ContainingDirectory: HANDLE,
   pub CurDirRef: PRTLP_CURDIR_REF,
}
impl Default for _RTL_RELATIVE_NAME_U {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_RELATIVE_NAME_U = _RTL_RELATIVE_NAME_U;
pub type PRTL_RELATIVE_NAME_U = *mut _RTL_RELATIVE_NAME_U;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_PATH_TYPE {
   RtlPathTypeUnknown = 0,
   RtlPathTypeUncAbsolute = 1,
   RtlPathTypeDriveAbsolute = 2,
   RtlPathTypeDriveRelative = 3,
   RtlPathTypeRooted = 4,
   RtlPathTypeRelative = 5,
   RtlPathTypeLocalDevice = 6,
   RtlPathTypeRootLocalDevice = 7,
}
pub use self::_RTL_PATH_TYPE as RTL_PATH_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BUFFER {
   pub Buffer: PUCHAR,
   pub StaticBuffer: PUCHAR,
   pub Size: SIZE_T,
   pub StaticSize: SIZE_T,
}
impl Default for _RTL_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BUFFER = _RTL_BUFFER;
pub type PRTL_BUFFER = *mut _RTL_BUFFER;
#[repr(C)]
pub struct _RTL_UNICODE_STRING_BUFFER {
   pub String: UNICODE_STRING,
   pub ByteBuffer: RTL_BUFFER,
   pub MinimumStaticBufferForTerminalNul: [UCHAR; 2usize],
}
impl Default for _RTL_UNICODE_STRING_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_UNICODE_STRING_BUFFER = _RTL_UNICODE_STRING_BUFFER;
pub type PRTL_UNICODE_STRING_BUFFER = *mut _RTL_UNICODE_STRING_BUFFER;
#[repr(C)]
pub struct _GENERATE_NAME_CONTEXT {
   pub Checksum: USHORT,
   pub CheckSumInserted: BOOLEAN,
   pub NameLength: UCHAR,
   pub NameBuffer: [WCHAR; 8usize],
   pub ExtensionLength: ULONG,
   pub ExtensionBuffer: [WCHAR; 4usize],
   pub LastIndexValue: ULONG,
}
impl Default for _GENERATE_NAME_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GENERATE_NAME_CONTEXT = _GENERATE_NAME_CONTEXT;
pub type PGENERATE_NAME_CONTEXT = *mut _GENERATE_NAME_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_HEAP_ENTRY {
   pub Size: SIZE_T,
   pub Flags: USHORT,
   pub AllocatorBackTraceIndex: USHORT,
   pub u: _RTL_HEAP_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_HEAP_ENTRY__bindgen_ty_1 {
   pub s1: _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1,
   pub s2: _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub Settable: SIZE_T,
   pub Tag: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   pub CommittedSize: SIZE_T,
   pub FirstBlock: PVOID,
}
impl Default for _RTL_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HEAP_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HEAP_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_ENTRY = _RTL_HEAP_ENTRY;
pub type PRTL_HEAP_ENTRY = *mut _RTL_HEAP_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_TAG {
   pub NumberOfAllocations: ULONG,
   pub NumberOfFrees: ULONG,
   pub BytesAllocated: SIZE_T,
   pub TagIndex: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub TagName: [WCHAR; 24usize],
}
pub type RTL_HEAP_TAG = _RTL_HEAP_TAG;
pub type PRTL_HEAP_TAG = *mut _RTL_HEAP_TAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_INFORMATION_V1 {
   pub BaseAddress: PVOID,
   pub Flags: ULONG,
   pub EntryOverhead: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub BytesAllocated: SIZE_T,
   pub BytesCommitted: SIZE_T,
   pub NumberOfTags: ULONG,
   pub NumberOfEntries: ULONG,
   pub NumberOfPseudoTags: ULONG,
   pub PseudoTagGranularity: ULONG,
   pub Reserved: [ULONG; 5usize],
   pub Tags: PRTL_HEAP_TAG,
   pub Entries: PRTL_HEAP_ENTRY,
}
impl Default for _RTL_HEAP_INFORMATION_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_INFORMATION_V1 = _RTL_HEAP_INFORMATION_V1;
pub type PRTL_HEAP_INFORMATION_V1 = *mut _RTL_HEAP_INFORMATION_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_INFORMATION_V2 {
   pub BaseAddress: PVOID,
   pub Flags: ULONG,
   pub EntryOverhead: USHORT,
   pub CreatorBackTraceIndex: USHORT,
   pub BytesAllocated: SIZE_T,
   pub BytesCommitted: SIZE_T,
   pub NumberOfTags: ULONG,
   pub NumberOfEntries: ULONG,
   pub NumberOfPseudoTags: ULONG,
   pub PseudoTagGranularity: ULONG,
   pub Reserved: [ULONG; 5usize],
   pub Tags: PRTL_HEAP_TAG,
   pub Entries: PRTL_HEAP_ENTRY,
   pub HeapTag: ULONG64,
}
impl Default for _RTL_HEAP_INFORMATION_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_INFORMATION_V2 = _RTL_HEAP_INFORMATION_V2;
pub type PRTL_HEAP_INFORMATION_V2 = *mut _RTL_HEAP_INFORMATION_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_HEAPS_V1 {
   pub NumberOfHeaps: ULONG,
   pub Heaps: [RTL_HEAP_INFORMATION_V1; 1usize],
}
impl Default for _RTL_PROCESS_HEAPS_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_HEAPS_V1 = _RTL_PROCESS_HEAPS_V1;
pub type PRTL_PROCESS_HEAPS_V1 = *mut _RTL_PROCESS_HEAPS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_PROCESS_HEAPS_V2 {
   pub NumberOfHeaps: ULONG,
   pub Heaps: [RTL_HEAP_INFORMATION_V2; 1usize],
}
impl Default for _RTL_PROCESS_HEAPS_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_PROCESS_HEAPS_V2 = _RTL_PROCESS_HEAPS_V2;
pub type PRTL_PROCESS_HEAPS_V2 = *mut _RTL_PROCESS_HEAPS_V2;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_MEMORY_TYPE {
   MemoryTypePaged = 0,
   MemoryTypeNonPaged = 1,
   MemoryType64KPage = 2,
   MemoryTypeLargePage = 3,
   MemoryTypeHugePage = 4,
   MemoryTypeCustom = 5,
   MemoryTypeMax = 6,
}
pub use self::_RTL_MEMORY_TYPE as RTL_MEMORY_TYPE;
pub type PRTL_MEMORY_TYPE = *mut _RTL_MEMORY_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HEAP_MEMORY_INFO_CLASS {
   HeapMemoryBasicInformation = 0,
}
pub use self::_HEAP_MEMORY_INFO_CLASS as HEAP_MEMORY_INFO_CLASS;
pub type ALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      CallbackContext: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS,
>;
pub type PALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK = ALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK;
pub type FREE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      CallbackContext: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      FreeType: ULONG,
   ) -> NTSTATUS,
>;
pub type PFREE_VIRTUAL_MEMORY_EX_CALLBACK = FREE_VIRTUAL_MEMORY_EX_CALLBACK;
pub type QUERY_VIRTUAL_MEMORY_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      CallbackContext: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      MemoryInformationClass: HEAP_MEMORY_INFO_CLASS,
      MemoryInformation: PVOID,
      MemoryInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS,
>;
pub type PQUERY_VIRTUAL_MEMORY_CALLBACK = QUERY_VIRTUAL_MEMORY_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_VA_CALLBACKS {
   pub CallbackContext: HANDLE,
   pub AllocateVirtualMemory: PALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK,
   pub FreeVirtualMemory: PFREE_VIRTUAL_MEMORY_EX_CALLBACK,
   pub QueryVirtualMemory: PQUERY_VIRTUAL_MEMORY_CALLBACK,
}
impl Default for _RTL_SEGMENT_HEAP_VA_CALLBACKS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SEGMENT_HEAP_VA_CALLBACKS = _RTL_SEGMENT_HEAP_VA_CALLBACKS;
pub type PRTL_SEGMENT_HEAP_VA_CALLBACKS = *mut _RTL_SEGMENT_HEAP_VA_CALLBACKS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_MEMORY_SOURCE {
   pub Flags: ULONG,
   pub MemoryTypeMask: ULONG,
   pub NumaNode: ULONG,
   pub __bindgen_anon_1: _RTL_SEGMENT_HEAP_MEMORY_SOURCE__bindgen_ty_1,
   pub Reserved: [SIZE_T; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_SEGMENT_HEAP_MEMORY_SOURCE__bindgen_ty_1 {
   pub PartitionHandle: HANDLE,
   pub Callbacks: *mut RTL_SEGMENT_HEAP_VA_CALLBACKS,
}
impl Default for _RTL_SEGMENT_HEAP_MEMORY_SOURCE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_SEGMENT_HEAP_MEMORY_SOURCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SEGMENT_HEAP_MEMORY_SOURCE = _RTL_SEGMENT_HEAP_MEMORY_SOURCE;
pub type PRTL_SEGMENT_HEAP_MEMORY_SOURCE = *mut _RTL_SEGMENT_HEAP_MEMORY_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_SEGMENT_HEAP_PARAMETERS {
   pub Version: USHORT,
   pub Size: USHORT,
   pub Flags: ULONG,
   pub MemorySource: RTL_SEGMENT_HEAP_MEMORY_SOURCE,
   pub Reserved: [SIZE_T; 4usize],
}
impl Default for _RTL_SEGMENT_HEAP_PARAMETERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_SEGMENT_HEAP_PARAMETERS = _RTL_SEGMENT_HEAP_PARAMETERS;
pub type PRTL_SEGMENT_HEAP_PARAMETERS = *mut _RTL_SEGMENT_HEAP_PARAMETERS;
pub type PRTL_HEAP_COMMIT_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(arg1: PVOID, arg2: *mut PVOID, arg3: PSIZE_T) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_PARAMETERS {
   pub Length: ULONG,
   pub SegmentReserve: SIZE_T,
   pub SegmentCommit: SIZE_T,
   pub DeCommitFreeBlockThreshold: SIZE_T,
   pub DeCommitTotalFreeThreshold: SIZE_T,
   pub MaximumAllocationSize: SIZE_T,
   pub VirtualMemoryThreshold: SIZE_T,
   pub InitialCommit: SIZE_T,
   pub InitialReserve: SIZE_T,
   pub CommitRoutine: PRTL_HEAP_COMMIT_ROUTINE,
   pub Reserved: [SIZE_T; 2usize],
}
pub type RTL_HEAP_PARAMETERS = _RTL_HEAP_PARAMETERS;
pub type PRTL_HEAP_PARAMETERS = *mut _RTL_HEAP_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_TAG_INFO {
   pub NumberOfAllocations: ULONG,
   pub NumberOfFrees: ULONG,
   pub BytesAllocated: SIZE_T,
}
pub type RTL_HEAP_TAG_INFO = _RTL_HEAP_TAG_INFO;
pub type PRTL_HEAP_TAG_INFO = *mut _RTL_HEAP_TAG_INFO;
pub type PRTL_ENUM_HEAPS_ROUTINE =
   ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: PVOID) -> NTSTATUS>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_USAGE_ENTRY {
   pub Next: *mut _RTL_HEAP_USAGE_ENTRY,
   pub Address: PVOID,
   pub Size: SIZE_T,
   pub AllocatorBackTraceIndex: USHORT,
   pub TagIndex: USHORT,
}
impl Default for _RTL_HEAP_USAGE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_USAGE_ENTRY = _RTL_HEAP_USAGE_ENTRY;
pub type PRTL_HEAP_USAGE_ENTRY = *mut _RTL_HEAP_USAGE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_USAGE {
   pub Length: ULONG,
   pub BytesAllocated: SIZE_T,
   pub BytesCommitted: SIZE_T,
   pub BytesReserved: SIZE_T,
   pub BytesReservedMaximum: SIZE_T,
   pub Entries: PRTL_HEAP_USAGE_ENTRY,
   pub AddedEntries: PRTL_HEAP_USAGE_ENTRY,
   pub RemovedEntries: PRTL_HEAP_USAGE_ENTRY,
   pub Reserved: [ULONG_PTR; 8usize],
}
impl Default for _RTL_HEAP_USAGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_USAGE = _RTL_HEAP_USAGE;
pub type PRTL_HEAP_USAGE = *mut _RTL_HEAP_USAGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_HEAP_WALK_ENTRY {
   pub DataAddress: PVOID,
   pub DataSize: SIZE_T,
   pub OverheadBytes: UCHAR,
   pub SegmentIndex: UCHAR,
   pub Flags: USHORT,
   pub __bindgen_anon_1: _RTL_HEAP_WALK_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_HEAP_WALK_ENTRY__bindgen_ty_1 {
   pub Block: _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_1,
   pub Segment: _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub Settable: SIZE_T,
   pub TagIndex: USHORT,
   pub AllocatorBackTraceIndex: USHORT,
   pub Reserved: [ULONG; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   pub CommittedSize: ULONG,
   pub UnCommittedSize: ULONG,
   pub FirstEntry: PVOID,
   pub LastEntry: PVOID,
}
impl Default for _RTL_HEAP_WALK_ENTRY__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HEAP_WALK_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HEAP_WALK_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_WALK_ENTRY = _RTL_HEAP_WALK_ENTRY;
pub type PRTL_HEAP_WALK_ENTRY = *mut _RTL_HEAP_WALK_ENTRY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HEAP_COMPATIBILITY_MODE {
   HEAP_COMPATIBILITY_STANDARD = 0,
   HEAP_COMPATIBILITY_LAL = 1,
   HEAP_COMPATIBILITY_LFH = 2,
}
pub use self::_HEAP_COMPATIBILITY_MODE as HEAP_COMPATIBILITY_MODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTLP_TAG_INFO {
   pub Id: GUID,
   pub CurrentAllocatedBytes: ULONG_PTR,
}
pub type RTLP_TAG_INFO = _RTLP_TAG_INFO;
pub type PRTLP_TAG_INFO = *mut _RTLP_TAG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_HEAP_TAGGING_INFO {
   pub Version: USHORT,
   pub Flags: USHORT,
   pub ProcessHandle: PVOID,
   pub EntriesCount: ULONG_PTR,
   pub Entries: [RTLP_TAG_INFO; 1usize],
}
impl Default for _RTLP_HEAP_TAGGING_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_HEAP_TAGGING_INFO = _RTLP_HEAP_TAGGING_INFO;
pub type PRTLP_HEAP_TAGGING_INFO = *mut _RTLP_HEAP_TAGGING_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PROCESS_HEAP_INFORMATION {
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub NumberOfHeaps: ULONG,
   pub FirstHeapInformationOffset: ULONG_PTR,
}
pub type PROCESS_HEAP_INFORMATION = _PROCESS_HEAP_INFORMATION;
pub type PPROCESS_HEAP_INFORMATION = *mut _PROCESS_HEAP_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_REGION_INFORMATION {
   pub Address: PVOID,
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub FirstRangeInformationOffset: ULONG_PTR,
   pub NextRegionInformationOffset: ULONG_PTR,
}
impl Default for _HEAP_REGION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_REGION_INFORMATION = _HEAP_REGION_INFORMATION;
pub type PHEAP_REGION_INFORMATION = *mut _HEAP_REGION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_RANGE_INFORMATION {
   pub Address: PVOID,
   pub Size: SIZE_T,
   pub Type: ULONG,
   pub Protection: ULONG,
   pub FirstBlockInformationOffset: ULONG_PTR,
   pub NextRangeInformationOffset: ULONG_PTR,
}
impl Default for _HEAP_RANGE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_RANGE_INFORMATION = _HEAP_RANGE_INFORMATION;
pub type PHEAP_RANGE_INFORMATION = *mut _HEAP_RANGE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_BLOCK_INFORMATION {
   pub Address: PVOID,
   pub Flags: ULONG,
   pub DataSize: SIZE_T,
   pub OverheadSize: ULONG_PTR,
   pub NextBlockInformationOffset: ULONG_PTR,
}
impl Default for _HEAP_BLOCK_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_BLOCK_INFORMATION = _HEAP_BLOCK_INFORMATION;
pub type PHEAP_BLOCK_INFORMATION = *mut _HEAP_BLOCK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_INFORMATION {
   pub Address: PVOID,
   pub Mode: ULONG,
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub FirstRegionInformationOffset: ULONG_PTR,
   pub NextHeapInformationOffset: ULONG_PTR,
}
impl Default for _HEAP_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_INFORMATION = _HEAP_INFORMATION;
pub type PHEAP_INFORMATION = *mut _HEAP_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION {
   pub SegmentReserveSize: SIZE_T,
   pub SegmentCommitSize: SIZE_T,
   pub SegmentCount: ULONG_PTR,
   pub AllocatedSize: SIZE_T,
   pub LargeAllocReserveSize: SIZE_T,
   pub LargeAllocCommitSize: SIZE_T,
}
pub type SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION =
   _SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION;
pub type PSEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION =
   *mut _SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_PERFORMANCE_COUNTERS_INFORMATION {
   pub Size: ULONG,
   pub Version: ULONG,
   pub HeapIndex: ULONG,
   pub LastHeapIndex: ULONG,
   pub BaseAddress: PVOID,
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub SegmentCount: ULONG,
   pub LargeUCRMemory: SIZE_T,
   pub UCRLength: ULONG,
   pub AllocatedSpace: SIZE_T,
   pub FreeSpace: SIZE_T,
   pub FreeListLength: ULONG,
   pub Contention: ULONG,
   pub VirtualBlocks: ULONG,
   pub CommitRate: ULONG,
   pub DecommitRate: ULONG,
   pub SegmentHeapPerfInformation: SEGMENT_HEAP_PERFORMANCE_COUNTER_INFORMATION,
}
impl Default for _HEAP_PERFORMANCE_COUNTERS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_PERFORMANCE_COUNTERS_INFORMATION = _HEAP_PERFORMANCE_COUNTERS_INFORMATION;
pub type PHEAP_PERFORMANCE_COUNTERS_INFORMATION = *mut _HEAP_PERFORMANCE_COUNTERS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_INFORMATION_ITEM {
   pub Level: ULONG,
   pub Size: SIZE_T,
   pub __bindgen_anon_1: _HEAP_INFORMATION_ITEM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_INFORMATION_ITEM__bindgen_ty_1 {
   pub ProcessHeapInformation: PROCESS_HEAP_INFORMATION,
   pub HeapInformation: HEAP_INFORMATION,
   pub HeapRegionInformation: HEAP_REGION_INFORMATION,
   pub HeapRangeInformation: HEAP_RANGE_INFORMATION,
   pub HeapBlockInformation: HEAP_BLOCK_INFORMATION,
   pub HeapPerfInformation: HEAP_PERFORMANCE_COUNTERS_INFORMATION,
   pub DynamicStart: ULONG_PTR,
}
impl Default for _HEAP_INFORMATION_ITEM__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _HEAP_INFORMATION_ITEM {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_INFORMATION_ITEM = _HEAP_INFORMATION_ITEM;
pub type PHEAP_INFORMATION_ITEM = *mut _HEAP_INFORMATION_ITEM;
pub type PRTL_HEAP_EXTENDED_ENUMERATION_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(Information: PHEAP_INFORMATION_ITEM, Context: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_EXTENDED_INFORMATION {
   pub ProcessHandle: HANDLE,
   pub HeapHandle: PVOID,
   pub Level: ULONG,
   pub CallbackRoutine: PRTL_HEAP_EXTENDED_ENUMERATION_ROUTINE,
   pub CallbackContext: PVOID,
   pub __bindgen_anon_1: _HEAP_EXTENDED_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HEAP_EXTENDED_INFORMATION__bindgen_ty_1 {
   pub ProcessHeapInformation: PROCESS_HEAP_INFORMATION,
   pub HeapInformation: HEAP_INFORMATION,
}
impl Default for _HEAP_EXTENDED_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _HEAP_EXTENDED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_EXTENDED_INFORMATION = _HEAP_EXTENDED_INFORMATION;
pub type PHEAP_EXTENDED_INFORMATION = *mut _HEAP_EXTENDED_INFORMATION;
pub type RTL_HEAP_STACK_WRITE_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(Information: PVOID, Size: ULONG, Context: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT {
   pub Count: ULONG,
   pub Total: ULONG,
   pub Flags: ULONG,
}
pub type RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT = _RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT;
pub type PRTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT = *mut _RTLP_HEAP_STACK_TRACE_SERIALIZATION_INIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER {
   pub Version: USHORT,
   pub PointerSize: USHORT,
   pub Heap: PVOID,
   pub TotalCommit: SIZE_T,
   pub TotalReserve: SIZE_T,
}
impl Default for _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER = _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER;
pub type PRTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER =
   *mut _RTLP_HEAP_STACK_TRACE_SERIALIZATION_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION {
   pub Address: PVOID,
   pub Flags: ULONG,
   pub DataSize: SIZE_T,
}
impl Default for _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION =
   _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION;
pub type PRTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION =
   *mut _RTLP_HEAP_STACK_TRACE_SERIALIZATION_ALLOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME {
   pub StackFrame: [PVOID; 8usize],
}
impl Default for _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME =
   _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME;
pub type PRTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME =
   *mut _RTLP_HEAP_STACK_TRACE_SERIALIZATION_STACKFRAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_STACK_QUERY {
   pub Version: ULONG,
   pub ProcessHandle: HANDLE,
   pub WriteRoutine: RTL_HEAP_STACK_WRITE_ROUTINE,
   pub SerializationContext: PVOID,
   pub QueryLevel: UCHAR,
   pub Flags: UCHAR,
}
impl Default for _RTL_HEAP_STACK_QUERY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_STACK_QUERY = _RTL_HEAP_STACK_QUERY;
pub type PRTL_HEAP_STACK_QUERY = *mut _RTL_HEAP_STACK_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_STACK_CONTROL {
   pub Version: USHORT,
   pub Flags: USHORT,
   pub ProcessHandle: HANDLE,
}
impl Default for _RTL_HEAP_STACK_CONTROL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HEAP_STACK_CONTROL = _RTL_HEAP_STACK_CONTROL;
pub type PRTL_HEAP_STACK_CONTROL = *mut _RTL_HEAP_STACK_CONTROL;
pub type PRTL_HEAP_DEBUGGING_INTERCEPTOR_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      HeapHandle: PVOID,
      Action: ULONG,
      StackFramesToCapture: ULONG,
      StackTrace: *mut PVOID,
   ) -> NTSTATUS,
>;
pub type PRTL_HEAP_LEAK_ENUMERATION_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      Reserved: LONG,
      HeapHandle: PVOID,
      BaseAddress: PVOID,
      BlockSize: SIZE_T,
      StackTraceDepth: ULONG,
      StackTrace: *mut PVOID,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _HEAP_DEBUGGING_INFORMATION {
   pub InterceptorFunction: PRTL_HEAP_DEBUGGING_INTERCEPTOR_ROUTINE,
   pub InterceptorValue: USHORT,
   pub ExtendedOptions: ULONG,
   pub StackTraceDepth: ULONG,
   pub MinTotalBlockSize: SIZE_T,
   pub MaxTotalBlockSize: SIZE_T,
   pub HeapLeakEnumerationRoutine: PRTL_HEAP_LEAK_ENUMERATION_ROUTINE,
}
pub type HEAP_DEBUGGING_INFORMATION = _HEAP_DEBUGGING_INFORMATION;
pub type PHEAP_DEBUGGING_INFORMATION = *mut _HEAP_DEBUGGING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_MEMORY_ZONE_SEGMENT {
   pub NextSegment: *mut _RTL_MEMORY_ZONE_SEGMENT,
   pub Size: SIZE_T,
   pub Next: PVOID,
   pub Limit: PVOID,
}
impl Default for _RTL_MEMORY_ZONE_SEGMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_MEMORY_ZONE_SEGMENT = _RTL_MEMORY_ZONE_SEGMENT;
pub type PRTL_MEMORY_ZONE_SEGMENT = *mut _RTL_MEMORY_ZONE_SEGMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_MEMORY_ZONE {
   pub Segment: RTL_MEMORY_ZONE_SEGMENT,
   pub Lock: RTL_SRWLOCK,
   pub LockCount: ULONG,
   pub FirstSegment: PRTL_MEMORY_ZONE_SEGMENT,
}
impl Default for _RTL_MEMORY_ZONE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_MEMORY_ZONE = _RTL_MEMORY_ZONE;
pub type PRTL_MEMORY_ZONE = *mut _RTL_MEMORY_ZONE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_PROCESS_VERIFIER_OPTIONS {
   pub SizeStruct: ULONG,
   pub Option: ULONG,
   pub OptionData: [UCHAR; 1usize],
}
pub type RTL_PROCESS_VERIFIER_OPTIONS = _RTL_PROCESS_VERIFIER_OPTIONS;
pub type PRTL_PROCESS_VERIFIER_OPTIONS = *mut _RTL_PROCESS_VERIFIER_OPTIONS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_DEBUG_INFORMATION {
   pub SectionHandleClient: HANDLE,
   pub ViewBaseClient: PVOID,
   pub ViewBaseTarget: PVOID,
   pub ViewBaseDelta: ULONG_PTR,
   pub EventPairClient: HANDLE,
   pub EventPairTarget: HANDLE,
   pub TargetProcessId: HANDLE,
   pub TargetThreadHandle: HANDLE,
   pub Flags: ULONG,
   pub OffsetFree: SIZE_T,
   pub CommitSize: SIZE_T,
   pub ViewSize: SIZE_T,
   pub __bindgen_anon_1: _RTL_DEBUG_INFORMATION__bindgen_ty_1,
   pub BackTraces: PRTL_PROCESS_BACKTRACES,
   pub Heaps: PVOID,
   pub Locks: PRTL_PROCESS_LOCKS,
   pub SpecificHeap: PVOID,
   pub TargetProcessHandle: HANDLE,
   pub VerifierOptions: PRTL_PROCESS_VERIFIER_OPTIONS,
   pub ProcessHeap: PVOID,
   pub CriticalSectionHandle: HANDLE,
   pub CriticalSectionOwnerThread: HANDLE,
   pub Reserved: [PVOID; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_DEBUG_INFORMATION__bindgen_ty_1 {
   pub Modules: PRTL_PROCESS_MODULES,
   pub ModulesEx: PRTL_PROCESS_MODULE_INFORMATION_EX,
}
impl Default for _RTL_DEBUG_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_DEBUG_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_DEBUG_INFORMATION = _RTL_DEBUG_INFORMATION;
pub type PRTL_DEBUG_INFORMATION = *mut _RTL_DEBUG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PARSE_MESSAGE_CONTEXT {
   pub fFlags: ULONG,
   pub cwSavColumn: ULONG,
   pub iwSrc: SIZE_T,
   pub iwDst: SIZE_T,
   pub iwDstSpace: SIZE_T,
   pub lpvArgStart: va_list,
}
impl Default for _PARSE_MESSAGE_CONTEXT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PARSE_MESSAGE_CONTEXT = _PARSE_MESSAGE_CONTEXT;
pub type PPARSE_MESSAGE_CONTEXT = *mut _PARSE_MESSAGE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
   _unused: [u8; 0],
}
pub type IN_ADDR = in_addr;
pub type PIN_ADDR = *mut in_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in6_addr {
   _unused: [u8; 0],
}
pub type IN6_ADDR = in6_addr;
pub type PIN6_ADDR = *mut in6_addr;
pub type PCIN_ADDR = *const IN_ADDR;
pub type PCIN6_ADDR = *const IN6_ADDR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TIME_FIELDS {
   pub Year: CSHORT,
   pub Month: CSHORT,
   pub Day: CSHORT,
   pub Hour: CSHORT,
   pub Minute: CSHORT,
   pub Second: CSHORT,
   pub Milliseconds: CSHORT,
   pub Weekday: CSHORT,
}
pub type TIME_FIELDS = _TIME_FIELDS;
pub type PTIME_FIELDS = *mut _TIME_FIELDS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_TIME_ZONE_INFORMATION {
   pub Bias: LONG,
   pub StandardName: [WCHAR; 32usize],
   pub StandardStart: TIME_FIELDS,
   pub StandardBias: LONG,
   pub DaylightName: [WCHAR; 32usize],
   pub DaylightStart: TIME_FIELDS,
   pub DaylightBias: LONG,
}
pub type RTL_TIME_ZONE_INFORMATION = _RTL_TIME_ZONE_INFORMATION;
pub type PRTL_TIME_ZONE_INFORMATION = *mut _RTL_TIME_ZONE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP {
   pub SizeOfBitMap: ULONG,
   pub Buffer: PULONG,
}
impl Default for _RTL_BITMAP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BITMAP = _RTL_BITMAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BITMAP_RUN {
   pub StartingIndex: ULONG,
   pub NumberOfBits: ULONG,
}
pub type RTL_BITMAP_RUN = _RTL_BITMAP_RUN;
pub type PRTL_BITMAP_RUN = *mut _RTL_BITMAP_RUN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BITMAP_EX {
   pub SizeOfBitMap: ULONG64,
   pub Buffer: PULONG64,
}
impl Default for _RTL_BITMAP_EX {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BITMAP_EX = _RTL_BITMAP_EX;
pub type PRTL_BITMAP_EX = *mut _RTL_BITMAP_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_HANDLE_TABLE_ENTRY {
   pub __bindgen_anon_1: _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1 {
   pub Flags: ULONG,
   pub NextFree: *mut _RTL_HANDLE_TABLE_ENTRY,
}
impl Default for _RTL_HANDLE_TABLE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_HANDLE_TABLE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HANDLE_TABLE_ENTRY = _RTL_HANDLE_TABLE_ENTRY;
pub type PRTL_HANDLE_TABLE_ENTRY = *mut _RTL_HANDLE_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HANDLE_TABLE {
   pub MaximumNumberOfHandles: ULONG,
   pub SizeOfHandleTableEntry: ULONG,
   pub Reserved: [ULONG; 2usize],
   pub FreeHandles: PRTL_HANDLE_TABLE_ENTRY,
   pub CommittedHandles: PRTL_HANDLE_TABLE_ENTRY,
   pub UnCommittedHandles: PRTL_HANDLE_TABLE_ENTRY,
   pub MaxReservedHandles: PRTL_HANDLE_TABLE_ENTRY,
}
impl Default for _RTL_HANDLE_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_HANDLE_TABLE = _RTL_HANDLE_TABLE;
pub type PRTL_HANDLE_TABLE = *mut _RTL_HANDLE_TABLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _COMPOUND_ACCESS_ALLOWED_ACE {
   pub Header: ACE_HEADER,
   pub Mask: ACCESS_MASK,
   pub CompoundAceType: USHORT,
   pub Reserved: USHORT,
   pub SidStart: ULONG,
}
pub type COMPOUND_ACCESS_ALLOWED_ACE = _COMPOUND_ACCESS_ALLOWED_ACE;
pub type PCOMPOUND_ACCESS_ALLOWED_ACE = *mut _COMPOUND_ACCESS_ALLOWED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_ACE_DATA {
   pub AceType: UCHAR,
   pub InheritFlags: UCHAR,
   pub AceFlags: UCHAR,
   pub AccessMask: ACCESS_MASK,
   pub Sid: *mut PSID,
}
impl Default for _RTL_ACE_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_ACE_DATA = _RTL_ACE_DATA;
pub type PRTL_ACE_DATA = *mut _RTL_ACE_DATA;
pub type PRTL_START_POOL_THREAD = ::core::option::Option<
   unsafe extern "C" fn(arg1: PTHREAD_START_ROUTINE, arg2: PVOID, arg3: PHANDLE) -> NTSTATUS,
>;
pub type PRTL_EXIT_POOL_THREAD =
   ::core::option::Option<unsafe extern "C" fn(arg1: NTSTATUS) -> NTSTATUS>;
pub type PRTL_QUERY_REGISTRY_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      arg1: PCWSTR,
      arg2: ULONG,
      arg3: PVOID,
      arg4: ULONG,
      arg5: PVOID,
      arg6: PVOID,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_QUERY_REGISTRY_TABLE {
   pub QueryRoutine: PRTL_QUERY_REGISTRY_ROUTINE,
   pub Flags: ULONG,
   pub Name: PWSTR,
   pub EntryContext: PVOID,
   pub DefaultType: ULONG,
   pub DefaultData: PVOID,
   pub DefaultLength: ULONG,
}
impl Default for _RTL_QUERY_REGISTRY_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_QUERY_REGISTRY_TABLE = _RTL_QUERY_REGISTRY_TABLE;
pub type PRTL_QUERY_REGISTRY_TABLE = *mut _RTL_QUERY_REGISTRY_TABLE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_ELEVATION_FLAGS {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _RTL_ELEVATION_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_ELEVATION_FLAGS__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RTL_ELEVATION_FLAGS__bindgen_ty_1 {
   #[inline]
   pub fn ElevationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ElevationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ElevationEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ElevationEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VirtualizationEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_VirtualizationEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VirtualizationEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VirtualizationEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InstallerDetectEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InstallerDetectEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InstallerDetectEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InstallerDetectEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AdminApprovalModeType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_AdminApprovalModeType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AdminApprovalModeType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AdminApprovalModeType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedBits_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedBits_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ElevationEnabled: ULONG,
      VirtualizationEnabled: ULONG,
      InstallerDetectEnabled: ULONG,
      AdminApprovalModeType: ULONG,
      ReservedBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ElevationEnabled: u32 = unsafe { ::core::mem::transmute(ElevationEnabled) };
         ElevationEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let VirtualizationEnabled: u32 = unsafe { ::core::mem::transmute(VirtualizationEnabled) };
         VirtualizationEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let InstallerDetectEnabled: u32 =
            unsafe { ::core::mem::transmute(InstallerDetectEnabled) };
         InstallerDetectEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 2u8, {
         let AdminApprovalModeType: u32 = unsafe { ::core::mem::transmute(AdminApprovalModeType) };
         AdminApprovalModeType as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedBits: u32 = unsafe { ::core::mem::transmute(ReservedBits) };
         ReservedBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_ELEVATION_FLAGS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_ELEVATION_FLAGS = _RTL_ELEVATION_FLAGS;
pub type PRTL_ELEVATION_FLAGS = *mut _RTL_ELEVATION_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_UNLOAD_EVENT_TRACE {
   pub BaseAddress: PVOID,
   pub SizeOfImage: SIZE_T,
   pub Sequence: ULONG,
   pub TimeDateStamp: ULONG,
   pub CheckSum: ULONG,
   pub ImageName: [WCHAR; 32usize],
   pub Version: [ULONG; 2usize],
}
impl Default for _RTL_UNLOAD_EVENT_TRACE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_UNLOAD_EVENT_TRACE = _RTL_UNLOAD_EVENT_TRACE;
pub type PRTL_UNLOAD_EVENT_TRACE = *mut _RTL_UNLOAD_EVENT_TRACE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_UNLOAD_EVENT_TRACE32 {
   pub BaseAddress: ULONG,
   pub SizeOfImage: ULONG,
   pub Sequence: ULONG,
   pub TimeDateStamp: ULONG,
   pub CheckSum: ULONG,
   pub ImageName: [WCHAR; 32usize],
   pub Version: [ULONG; 2usize],
}
pub type RTL_UNLOAD_EVENT_TRACE32 = _RTL_UNLOAD_EVENT_TRACE32;
pub type PRTL_UNLOAD_EVENT_TRACE32 = *mut _RTL_UNLOAD_EVENT_TRACE32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IMAGE_MITIGATION_POLICY {
   ImageDepPolicy = 0,
   ImageAslrPolicy = 1,
   ImageDynamicCodePolicy = 2,
   ImageStrictHandleCheckPolicy = 3,
   ImageSystemCallDisablePolicy = 4,
   ImageMitigationOptionsMask = 5,
   ImageExtensionPointDisablePolicy = 6,
   ImageControlFlowGuardPolicy = 7,
   ImageSignaturePolicy = 8,
   ImageFontDisablePolicy = 9,
   ImageImageLoadPolicy = 10,
   ImagePayloadRestrictionPolicy = 11,
   ImageChildProcessPolicy = 12,
   ImageSehopPolicy = 13,
   ImageHeapPolicy = 14,
   ImageUserShadowStackPolicy = 15,
   ImageRedirectionTrustPolicy = 16,
   ImageUserPointerAuthPolicy = 17,
   MaxImageMitigationPolicy = 18,
}
pub use self::_IMAGE_MITIGATION_POLICY as IMAGE_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_IMAGE_MITIGATION_POLICY {
   pub __bindgen_anon_1: _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_1,
   pub __bindgen_anon_2: _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_1 {
   #[inline]
   pub fn AuditState(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_AuditState(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditState_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_AuditState_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditFlag(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_AuditFlag(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditFlag_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_AuditFlag_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableAdditionalAuditingOption(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_EnableAdditionalAuditingOption(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableAdditionalAuditingOption_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_EnableAdditionalAuditingOption_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 60u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            60u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            60u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      AuditState: ULONG64,
      AuditFlag: ULONG64,
      EnableAdditionalAuditingOption: ULONG64,
      Reserved: ULONG64,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let AuditState: u64 = unsafe { ::core::mem::transmute(AuditState) };
         AuditState as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let AuditFlag: u64 = unsafe { ::core::mem::transmute(AuditFlag) };
         AuditFlag as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let EnableAdditionalAuditingOption: u64 =
            unsafe { ::core::mem::transmute(EnableAdditionalAuditingOption) };
         EnableAdditionalAuditingOption as u64
      });
      __bindgen_bitfield_unit.set(4usize, 60u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_2 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _RTL_IMAGE_MITIGATION_POLICY__bindgen_ty_2 {
   #[inline]
   pub fn PolicyState(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
   }
   #[inline]
   pub fn set_PolicyState(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PolicyState_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_PolicyState_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AlwaysInherit(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_AlwaysInherit(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AlwaysInherit_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_AlwaysInherit_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnableAdditionalPolicyOption(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
   }
   #[inline]
   pub fn set_EnableAdditionalPolicyOption(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnableAdditionalPolicyOption_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_EnableAdditionalPolicyOption_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AuditReserved(&self) -> ULONG64 {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 60u8) as u64) }
   }
   #[inline]
   pub fn set_AuditReserved(&mut self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 60u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AuditReserved_raw(this: *const Self) -> ULONG64 {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            60u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_AuditReserved_raw(this: *mut Self, val: ULONG64) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            60u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PolicyState: ULONG64,
      AlwaysInherit: ULONG64,
      EnableAdditionalPolicyOption: ULONG64,
      AuditReserved: ULONG64,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let PolicyState: u64 = unsafe { ::core::mem::transmute(PolicyState) };
         PolicyState as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let AlwaysInherit: u64 = unsafe { ::core::mem::transmute(AlwaysInherit) };
         AlwaysInherit as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let EnableAdditionalPolicyOption: u64 =
            unsafe { ::core::mem::transmute(EnableAdditionalPolicyOption) };
         EnableAdditionalPolicyOption as u64
      });
      __bindgen_bitfield_unit.set(4usize, 60u8, {
         let AuditReserved: u64 = unsafe { ::core::mem::transmute(AuditReserved) };
         AuditReserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_IMAGE_MITIGATION_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_POLICY = _RTL_IMAGE_MITIGATION_POLICY;
pub type PRTL_IMAGE_MITIGATION_POLICY = *mut _RTL_IMAGE_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_DEP_POLICY {
   pub Dep: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_DEP_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_DEP_POLICY = _RTL_IMAGE_MITIGATION_DEP_POLICY;
pub type PRTL_IMAGE_MITIGATION_DEP_POLICY = *mut _RTL_IMAGE_MITIGATION_DEP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_ASLR_POLICY {
   pub ForceRelocateImages: RTL_IMAGE_MITIGATION_POLICY,
   pub BottomUpRandomization: RTL_IMAGE_MITIGATION_POLICY,
   pub HighEntropyRandomization: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_ASLR_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_ASLR_POLICY = _RTL_IMAGE_MITIGATION_ASLR_POLICY;
pub type PRTL_IMAGE_MITIGATION_ASLR_POLICY = *mut _RTL_IMAGE_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY {
   pub BlockDynamicCode: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY = _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY;
pub type PRTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY = *mut _RTL_IMAGE_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
   pub StrictHandleChecks: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
   _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub type PRTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
   *mut _RTL_IMAGE_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
   pub BlockWin32kSystemCalls: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
   _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub type PRTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
   *mut _RTL_IMAGE_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
   pub DisableExtensionPoints: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
   _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub type PRTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
   *mut _RTL_IMAGE_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
   pub ControlFlowGuard: RTL_IMAGE_MITIGATION_POLICY,
   pub StrictControlFlowGuard: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
   _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub type PRTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
   *mut _RTL_IMAGE_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY {
   pub BlockNonMicrosoftSignedBinaries: RTL_IMAGE_MITIGATION_POLICY,
   pub EnforceSigningOnModuleDependencies: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY =
   _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY;
pub type PRTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY =
   *mut _RTL_IMAGE_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY {
   pub DisableNonSystemFonts: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY = _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY;
pub type PRTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY = *mut _RTL_IMAGE_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY {
   pub BlockRemoteImageLoads: RTL_IMAGE_MITIGATION_POLICY,
   pub BlockLowLabelImageLoads: RTL_IMAGE_MITIGATION_POLICY,
   pub PreferSystem32: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY = _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY;
pub type PRTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY = *mut _RTL_IMAGE_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
   pub EnableExportAddressFilter: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableExportAddressFilterPlus: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableImportAddressFilter: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableRopStackPivot: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableRopCallerCheck: RTL_IMAGE_MITIGATION_POLICY,
   pub EnableRopSimExec: RTL_IMAGE_MITIGATION_POLICY,
   pub EafPlusModuleList: [WCHAR; 512usize],
}
impl Default for _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
   _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub type PRTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
   *mut _RTL_IMAGE_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY {
   pub DisallowChildProcessCreation: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY = _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY;
pub type PRTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY =
   *mut _RTL_IMAGE_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_SEHOP_POLICY {
   pub Sehop: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_SEHOP_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_SEHOP_POLICY = _RTL_IMAGE_MITIGATION_SEHOP_POLICY;
pub type PRTL_IMAGE_MITIGATION_SEHOP_POLICY = *mut _RTL_IMAGE_MITIGATION_SEHOP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_HEAP_POLICY {
   pub TerminateOnHeapErrors: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_HEAP_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_HEAP_POLICY = _RTL_IMAGE_MITIGATION_HEAP_POLICY;
pub type PRTL_IMAGE_MITIGATION_HEAP_POLICY = *mut _RTL_IMAGE_MITIGATION_HEAP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY {
   pub UserShadowStack: RTL_IMAGE_MITIGATION_POLICY,
   pub SetContextIpValidation: RTL_IMAGE_MITIGATION_POLICY,
   pub BlockNonCetBinaries: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY =
   _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY;
pub type PRTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY =
   *mut _RTL_IMAGE_MITIGATION_USER_SHADOW_STACK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY {
   pub BlockUntrustedRedirections: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY =
   _RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY;
pub type PRTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY =
   *mut _RTL_IMAGE_MITIGATION_REDIRECTION_TRUST_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY {
   pub PointerAuthUserIp: RTL_IMAGE_MITIGATION_POLICY,
}
impl Default for _RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY =
   _RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY;
pub type PRTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY =
   *mut _RTL_IMAGE_MITIGATION_USER_POINTER_AUTH_POLICY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_IMAGE_MITIGATION_OPTION_STATE {
   RtlMitigationOptionStateNotConfigured = 0,
   RtlMitigationOptionStateOn = 1,
   RtlMitigationOptionStateOff = 2,
   RtlMitigationOptionStateForce = 3,
   RtlMitigationOptionStateOption = 4,
}
pub use self::_RTL_IMAGE_MITIGATION_OPTION_STATE as RTL_IMAGE_MITIGATION_OPTION_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _APPCONTAINER_SID_TYPE {
   NotAppContainerSidType = 0,
   ChildAppContainerSidType = 1,
   ParentAppContainerSidType = 2,
   InvalidAppContainerSidType = 3,
   MaxAppContainerSidType = 4,
}
pub use self::_APPCONTAINER_SID_TYPE as APPCONTAINER_SID_TYPE;
pub type PAPPCONTAINER_SID_TYPE = *mut _APPCONTAINER_SID_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STATE_LOCATION_TYPE {
   LocationTypeRegistry = 0,
   LocationTypeFileSystem = 1,
   LocationTypeMaximum = 2,
}
pub use self::_STATE_LOCATION_TYPE as STATE_LOCATION_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PS_PKG_CLAIM {
   pub Flags: ULONG,
   pub Origin: ULONG,
}
pub type PS_PKG_CLAIM = _PS_PKG_CLAIM;
pub type PPS_PKG_CLAIM = *mut _PS_PKG_CLAIM;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_BSD_ITEM_TYPE {
   RtlBsdItemVersionNumber = 0,
   RtlBsdItemProductType = 1,
   RtlBsdItemAabEnabled = 2,
   RtlBsdItemAabTimeout = 3,
   RtlBsdItemBootGood = 4,
   RtlBsdItemBootShutdown = 5,
   RtlBsdSleepInProgress = 6,
   RtlBsdPowerTransition = 7,
   RtlBsdItemBootAttemptCount = 8,
   RtlBsdItemBootCheckpoint = 9,
   RtlBsdItemBootId = 10,
   RtlBsdItemShutdownBootId = 11,
   RtlBsdItemReportedAbnormalShutdownBootId = 12,
   RtlBsdItemErrorInfo = 13,
   RtlBsdItemPowerButtonPressInfo = 14,
   RtlBsdItemChecksum = 15,
   RtlBsdPowerTransitionExtension = 16,
   RtlBsdItemFeatureConfigurationState = 17,
   RtlBsdItemRevocationListInfo = 18,
   RtlBsdItemMax = 19,
}
pub use self::_RTL_BSD_ITEM_TYPE as RTL_BSD_ITEM_TYPE;
#[repr(C)]
pub struct _RTL_BSD_DATA_POWER_TRANSITION {
   pub PowerButtonTimestamp: LARGE_INTEGER,
   pub Flags: _RTL_BSD_DATA_POWER_TRANSITION__bindgen_ty_1,
   pub ConnectedStandbyScenarioInstanceId: UCHAR,
   pub ConnectedStandbyEntryReason: UCHAR,
   pub ConnectedStandbyExitReason: UCHAR,
   pub SystemSleepTransitionCount: USHORT,
   pub LastReferenceTime: LARGE_INTEGER,
   pub LastReferenceTimeChecksum: ULONG,
   pub LastUpdateBootId: ULONG,
}
#[repr(C)]
pub struct _RTL_BSD_DATA_POWER_TRANSITION__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _RTL_BSD_DATA_POWER_TRANSITION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _RTL_BSD_DATA_POWER_TRANSITION__bindgen_ty_1 {
   #[inline]
   pub fn SystemRunning(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SystemRunning(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SystemRunning_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SystemRunning_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ConnectedStandbyInProgress(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ConnectedStandbyInProgress(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ConnectedStandbyInProgress_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ConnectedStandbyInProgress_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UserShutdownInProgress(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_UserShutdownInProgress(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UserShutdownInProgress_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_UserShutdownInProgress_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SystemShutdownInProgress(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SystemShutdownInProgress(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SystemShutdownInProgress_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SystemShutdownInProgress_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SleepInProgress(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_SleepInProgress(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SleepInProgress_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            4u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SleepInProgress_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SystemRunning: BOOLEAN,
      ConnectedStandbyInProgress: BOOLEAN,
      UserShutdownInProgress: BOOLEAN,
      SystemShutdownInProgress: BOOLEAN,
      SleepInProgress: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SystemRunning: u8 = unsafe { ::core::mem::transmute(SystemRunning) };
         SystemRunning as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ConnectedStandbyInProgress: u8 =
            unsafe { ::core::mem::transmute(ConnectedStandbyInProgress) };
         ConnectedStandbyInProgress as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let UserShutdownInProgress: u8 = unsafe { ::core::mem::transmute(UserShutdownInProgress) };
         UserShutdownInProgress as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SystemShutdownInProgress: u8 =
            unsafe { ::core::mem::transmute(SystemShutdownInProgress) };
         SystemShutdownInProgress as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let SleepInProgress: u8 = unsafe { ::core::mem::transmute(SleepInProgress) };
         SleepInProgress as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_BSD_DATA_POWER_TRANSITION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BSD_DATA_POWER_TRANSITION = _RTL_BSD_DATA_POWER_TRANSITION;
pub type PRTL_BSD_DATA_POWER_TRANSITION = *mut _RTL_BSD_DATA_POWER_TRANSITION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BSD_DATA_ERROR_INFO {
   pub BootId: ULONG,
   pub RepeatCount: ULONG,
   pub OtherErrorCount: ULONG,
   pub Code: ULONG,
   pub OtherErrorCount2: ULONG,
}
pub type RTL_BSD_DATA_ERROR_INFO = _RTL_BSD_DATA_ERROR_INFO;
pub type PRTL_BSD_DATA_ERROR_INFO = *mut _RTL_BSD_DATA_ERROR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BSD_POWER_BUTTON_PRESS_INFO {
   pub LastPressTime: LARGE_INTEGER,
   pub CumulativePressCount: ULONG,
   pub LastPressBootId: USHORT,
   pub LastPowerWatchdogStage: UCHAR,
   pub Flags: _RTL_BSD_POWER_BUTTON_PRESS_INFO__bindgen_ty_1,
   pub LastReleaseTime: LARGE_INTEGER,
   pub CumulativeReleaseCount: ULONG,
   pub LastReleaseBootId: USHORT,
   pub ErrorCount: USHORT,
   pub CurrentConnectedStandbyPhase: UCHAR,
   pub TransitionLatestCheckpointId: ULONG,
   pub TransitionLatestCheckpointType: ULONG,
   pub TransitionLatestCheckpointSequenceNumber: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BSD_POWER_BUTTON_PRESS_INFO__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _RTL_BSD_POWER_BUTTON_PRESS_INFO__bindgen_ty_1 {
   #[inline]
   pub fn WatchdogArmed(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WatchdogArmed(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn WatchdogArmed_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_WatchdogArmed_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ShutdownInProgress(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ShutdownInProgress(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ShutdownInProgress_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ShutdownInProgress_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      WatchdogArmed: UCHAR,
      ShutdownInProgress: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let WatchdogArmed: u8 = unsafe { ::core::mem::transmute(WatchdogArmed) };
         WatchdogArmed as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ShutdownInProgress: u8 = unsafe { ::core::mem::transmute(ShutdownInProgress) };
         ShutdownInProgress as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_BSD_POWER_BUTTON_PRESS_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BSD_POWER_BUTTON_PRESS_INFO = _RTL_BSD_POWER_BUTTON_PRESS_INFO;
pub type PRTL_BSD_POWER_BUTTON_PRESS_INFO = *mut _RTL_BSD_POWER_BUTTON_PRESS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BSD_ITEM {
   pub Type: RTL_BSD_ITEM_TYPE,
   pub DataBuffer: PVOID,
   pub DataLength: ULONG,
}
impl Default for _RTL_BSD_ITEM {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BSD_ITEM = _RTL_BSD_ITEM;
pub type PRTL_BSD_ITEM = *mut _RTL_BSD_ITEM;
pub type PRTL_SECURE_MEMORY_CACHE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: SIZE_T) -> NTSTATUS>;
pub type RTL_FEATURE_ID = ULONG;
pub type RTL_FEATURE_CHANGE_STAMP = ULONGLONG;
pub type PRTL_FEATURE_CHANGE_STAMP = *mut ULONGLONG;
pub type RTL_FEATURE_VARIANT = UCHAR;
pub type RTL_FEATURE_VARIANT_PAYLOAD = ULONG;
pub type RTL_FEATURE_CONFIGURATION_CHANGE_REGISTRATION = PVOID;
pub type PRTL_FEATURE_CONFIGURATION_CHANGE_REGISTRATION = *mut PVOID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_FEATURE_USAGE_REPORT {
   pub FeatureId: ULONG,
   pub ReportingKind: USHORT,
   pub ReportingOptions: USHORT,
}
pub type RTL_FEATURE_USAGE_REPORT = _RTL_FEATURE_USAGE_REPORT;
pub type PRTL_FEATURE_USAGE_REPORT = *mut _RTL_FEATURE_USAGE_REPORT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_FEATURE_CONFIGURATION_TYPE {
   RtlFeatureConfigurationBoot = 0,
   RtlFeatureConfigurationRuntime = 1,
   RtlFeatureConfigurationCount = 2,
}
pub use self::_RTL_FEATURE_CONFIGURATION_TYPE as RTL_FEATURE_CONFIGURATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_FEATURE_CONFIGURATION {
   pub FeatureId: RTL_FEATURE_ID,
   pub __bindgen_anon_1: _RTL_FEATURE_CONFIGURATION__bindgen_ty_1,
   pub VariantPayload: RTL_FEATURE_VARIANT_PAYLOAD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_FEATURE_CONFIGURATION__bindgen_ty_1 {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _RTL_FEATURE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_FEATURE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RTL_FEATURE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Priority(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Priority_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Priority_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EnabledState(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_EnabledState(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EnabledState_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EnabledState_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsWexpConfiguration(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_IsWexpConfiguration(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsWexpConfiguration_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_IsWexpConfiguration_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HasSubscriptions(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HasSubscriptions(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HasSubscriptions_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HasSubscriptions_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Variant(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_Variant(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Variant_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Variant_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn VariantPayloadKind(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_VariantPayloadKind(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn VariantPayloadKind_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_VariantPayloadKind_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            16u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Priority: ULONG,
      EnabledState: ULONG,
      IsWexpConfiguration: ULONG,
      HasSubscriptions: ULONG,
      Variant: ULONG,
      VariantPayloadKind: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let Priority: u32 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit.set(4usize, 2u8, {
         let EnabledState: u32 = unsafe { ::core::mem::transmute(EnabledState) };
         EnabledState as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let IsWexpConfiguration: u32 = unsafe { ::core::mem::transmute(IsWexpConfiguration) };
         IsWexpConfiguration as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let HasSubscriptions: u32 = unsafe { ::core::mem::transmute(HasSubscriptions) };
         HasSubscriptions as u64
      });
      __bindgen_bitfield_unit.set(8usize, 6u8, {
         let Variant: u32 = unsafe { ::core::mem::transmute(Variant) };
         Variant as u64
      });
      __bindgen_bitfield_unit.set(14usize, 2u8, {
         let VariantPayloadKind: u32 = unsafe { ::core::mem::transmute(VariantPayloadKind) };
         VariantPayloadKind as u64
      });
      __bindgen_bitfield_unit.set(16usize, 16u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_FEATURE_CONFIGURATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _RTL_FEATURE_CONFIGURATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_FEATURE_CONFIGURATION = _RTL_FEATURE_CONFIGURATION;
pub type PRTL_FEATURE_CONFIGURATION = *mut _RTL_FEATURE_CONFIGURATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_FEATURE_CONFIGURATION_TABLE {
   pub FeatureCount: ULONG,
   pub Features: [RTL_FEATURE_CONFIGURATION; 1usize],
}
impl Default for _RTL_FEATURE_CONFIGURATION_TABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_FEATURE_CONFIGURATION_TABLE = _RTL_FEATURE_CONFIGURATION_TABLE;
pub type PRTL_FEATURE_CONFIGURATION_TABLE = *mut _RTL_FEATURE_CONFIGURATION_TABLE;
impl _RTL_FEATURE_CONFIGURATION_PRIORITY {
   pub const FeatureConfigurationPriorityPersistent: _RTL_FEATURE_CONFIGURATION_PRIORITY =
      _RTL_FEATURE_CONFIGURATION_PRIORITY::FeatureConfigurationPrioritySafeguard;
}
impl _RTL_FEATURE_CONFIGURATION_PRIORITY {
   pub const FeatureConfigurationPriorityMax: _RTL_FEATURE_CONFIGURATION_PRIORITY =
      _RTL_FEATURE_CONFIGURATION_PRIORITY::FeatureConfigurationPriorityImageOverride;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_FEATURE_CONFIGURATION_PRIORITY {
   FeatureConfigurationPriorityImageDefault = 0,
   FeatureConfigurationPriorityEKB = 1,
   FeatureConfigurationPrioritySafeguard = 2,
   FeatureConfigurationPriorityReserved3 = 3,
   FeatureConfigurationPriorityService = 4,
   FeatureConfigurationPriorityReserved5 = 5,
   FeatureConfigurationPriorityDynamic = 6,
   FeatureConfigurationPriorityReserved7 = 7,
   FeatureConfigurationPriorityUser = 8,
   FeatureConfigurationPrioritySecurity = 9,
   FeatureConfigurationPriorityUserPolicy = 10,
   FeatureConfigurationPriorityReserved11 = 11,
   FeatureConfigurationPriorityTest = 12,
   FeatureConfigurationPriorityReserved13 = 13,
   FeatureConfigurationPriorityReserved14 = 14,
   FeatureConfigurationPriorityImageOverride = 15,
}
pub use self::_RTL_FEATURE_CONFIGURATION_PRIORITY as RTL_FEATURE_CONFIGURATION_PRIORITY;
pub type PRTL_FEATURE_CONFIGURATION_PRIORITY = *mut _RTL_FEATURE_CONFIGURATION_PRIORITY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_FEATURE_ENABLED_STATE {
   FeatureEnabledStateDefault = 0,
   FeatureEnabledStateDisabled = 1,
   FeatureEnabledStateEnabled = 2,
}
pub use self::_RTL_FEATURE_ENABLED_STATE as RTL_FEATURE_ENABLED_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_FEATURE_ENABLED_STATE_OPTIONS {
   FeatureEnabledStateOptionsNone = 0,
   FeatureEnabledStateOptionsWexpConfig = 1,
}
pub use self::_RTL_FEATURE_ENABLED_STATE_OPTIONS as RTL_FEATURE_ENABLED_STATE_OPTIONS;
pub type PRTL_FEATURE_ENABLED_STATE_OPTIONS = *mut _RTL_FEATURE_ENABLED_STATE_OPTIONS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_FEATURE_VARIANT_PAYLOAD_KIND {
   FeatureVariantPayloadKindNone = 0,
   FeatureVariantPayloadKindResident = 1,
   FeatureVariantPayloadKindExternal = 2,
}
pub use self::_RTL_FEATURE_VARIANT_PAYLOAD_KIND as RTL_FEATURE_VARIANT_PAYLOAD_KIND;
pub type PRTL_FEATURE_VARIANT_PAYLOAD_KIND = *mut _RTL_FEATURE_VARIANT_PAYLOAD_KIND;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_FEATURE_CONFIGURATION_OPERATION {
   FeatureConfigurationOperationNone = 0,
   FeatureConfigurationOperationFeatureState = 1,
   FeatureConfigurationOperationVariantState = 2,
   FeatureConfigurationOperationResetState = 4,
}
pub use self::_RTL_FEATURE_CONFIGURATION_OPERATION as RTL_FEATURE_CONFIGURATION_OPERATION;
pub type PRTL_FEATURE_CONFIGURATION_OPERATION = *mut _RTL_FEATURE_CONFIGURATION_OPERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_FEATURE_CONFIGURATION_UPDATE {
   pub FeatureId: RTL_FEATURE_ID,
   pub Priority: RTL_FEATURE_CONFIGURATION_PRIORITY,
   pub EnabledState: RTL_FEATURE_ENABLED_STATE,
   pub EnabledStateOptions: RTL_FEATURE_ENABLED_STATE_OPTIONS,
   pub Variant: RTL_FEATURE_VARIANT,
   pub Reserved: [UCHAR; 3usize],
   pub VariantPayloadKind: RTL_FEATURE_VARIANT_PAYLOAD_KIND,
   pub VariantPayload: RTL_FEATURE_VARIANT_PAYLOAD,
   pub Operation: RTL_FEATURE_CONFIGURATION_OPERATION,
}
impl Default for _RTL_FEATURE_CONFIGURATION_UPDATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_FEATURE_CONFIGURATION_UPDATE = _RTL_FEATURE_CONFIGURATION_UPDATE;
pub type PRTL_FEATURE_CONFIGURATION_UPDATE = *mut _RTL_FEATURE_CONFIGURATION_UPDATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET {
   pub Data: [ULONG; 2usize],
}
pub type RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET = _RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET;
pub type PRTL_FEATURE_USAGE_SUBSCRIPTION_TARGET = *mut _RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_FEATURE_USAGE_DATA {
   pub FeatureId: RTL_FEATURE_ID,
   pub ReportingKind: USHORT,
   pub Reserved: USHORT,
}
pub type RTL_FEATURE_USAGE_DATA = _RTL_FEATURE_USAGE_DATA;
pub type PRTL_FEATURE_USAGE_DATA = *mut _RTL_FEATURE_USAGE_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS {
   pub FeatureId: RTL_FEATURE_ID,
   pub ReportingKind: USHORT,
   pub ReportingOptions: USHORT,
   pub ReportingTarget: RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET,
}
pub type RTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS = _RTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS;
pub type PRTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS = *mut _RTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_FEATURE_USAGE_SUBSCRIPTION_TABLE {
   pub SubscriptionCount: ULONG,
   pub Subscriptions: [RTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS; 1usize],
}
pub type RTL_FEATURE_USAGE_SUBSCRIPTION_TABLE = _RTL_FEATURE_USAGE_SUBSCRIPTION_TABLE;
pub type PRTL_FEATURE_USAGE_SUBSCRIPTION_TABLE = *mut _RTL_FEATURE_USAGE_SUBSCRIPTION_TABLE;
pub type PRTL_FEATURE_CONFIGURATION_CHANGE_CALLBACK =
   ::core::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_QUERY {
   pub ConfigurationType: RTL_FEATURE_CONFIGURATION_TYPE,
   pub FeatureId: RTL_FEATURE_ID,
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_QUERY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FEATURE_CONFIGURATION_QUERY = _SYSTEM_FEATURE_CONFIGURATION_QUERY;
pub type PSYSTEM_FEATURE_CONFIGURATION_QUERY = *mut _SYSTEM_FEATURE_CONFIGURATION_QUERY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_INFORMATION {
   pub ChangeStamp: RTL_FEATURE_CHANGE_STAMP,
   pub Configuration: RTL_FEATURE_CONFIGURATION,
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FEATURE_CONFIGURATION_INFORMATION = _SYSTEM_FEATURE_CONFIGURATION_INFORMATION;
pub type PSYSTEM_FEATURE_CONFIGURATION_INFORMATION = *mut _SYSTEM_FEATURE_CONFIGURATION_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_FEATURE_CONFIGURATION_UPDATE_TYPE {
   SystemFeatureConfigurationUpdateTypeUpdate = 0,
   SystemFeatureConfigurationUpdateTypeOverwrite = 1,
   SystemFeatureConfigurationUpdateTypeCount = 2,
}
pub use self::_SYSTEM_FEATURE_CONFIGURATION_UPDATE_TYPE as SYSTEM_FEATURE_CONFIGURATION_UPDATE_TYPE;
pub type PSYSTEM_FEATURE_CONFIGURATION_UPDATE_TYPE = *mut _SYSTEM_FEATURE_CONFIGURATION_UPDATE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_UPDATE {
   pub UpdateType: SYSTEM_FEATURE_CONFIGURATION_UPDATE_TYPE,
   pub __bindgen_anon_1: _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1 {
   pub Update: _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1__bindgen_ty_1,
   pub Overwrite: _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1__bindgen_ty_1 {
   pub PreviousChangeStamp: RTL_FEATURE_CHANGE_STAMP,
   pub ConfigurationType: RTL_FEATURE_CONFIGURATION_TYPE,
   pub UpdateCount: ULONG,
   pub Updates: [RTL_FEATURE_CONFIGURATION_UPDATE; 1usize],
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1__bindgen_ty_2 {
   pub PreviousChangeStamp: RTL_FEATURE_CHANGE_STAMP,
   pub ConfigurationType: RTL_FEATURE_CONFIGURATION_TYPE,
   pub BufferSize: SIZE_T,
   pub Buffer: PVOID,
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_UPDATE__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_UPDATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FEATURE_CONFIGURATION_UPDATE = _SYSTEM_FEATURE_CONFIGURATION_UPDATE;
pub type PSYSTEM_FEATURE_CONFIGURATION_UPDATE = *mut _SYSTEM_FEATURE_CONFIGURATION_UPDATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY {
   pub ChangeStamp: RTL_FEATURE_CHANGE_STAMP,
   pub Section: PVOID,
   pub Size: SIZE_T,
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY =
   _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY;
pub type PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY =
   *mut _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_FEATURE_CONFIGURATION_SECTION_TYPE {
   SystemFeatureConfigurationSectionTypeBoot = 0,
   SystemFeatureConfigurationSectionTypeRuntime = 1,
   SystemFeatureConfigurationSectionTypeUsageTriggers = 2,
   SystemFeatureConfigurationSectionTypeCount = 3,
}
pub use self::_SYSTEM_FEATURE_CONFIGURATION_SECTION_TYPE as SYSTEM_FEATURE_CONFIGURATION_SECTION_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_REQUEST {
   pub PreviousChangeStamps: [RTL_FEATURE_CHANGE_STAMP; 3usize],
}
pub type SYSTEM_FEATURE_CONFIGURATION_SECTIONS_REQUEST =
   _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_REQUEST;
pub type PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_REQUEST =
   *mut _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION {
   pub OverallChangeStamp: RTL_FEATURE_CHANGE_STAMP,
   pub Descriptors: [SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY; 3usize],
}
impl Default for _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION =
   _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION;
pub type PSYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION =
   *mut _SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS {
   pub FeatureId: RTL_FEATURE_ID,
   pub ReportingKind: USHORT,
   pub ReportingOptions: USHORT,
   pub ReportingTarget: RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET,
}
pub type SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS = _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS;
pub type PSYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS =
   *mut _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE_ENTRY {
   pub Remove: ULONG,
   pub Details: RTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS,
}
pub type SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE_ENTRY =
   _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE_ENTRY;
pub type PSYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE_ENTRY =
   *mut _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE {
   pub UpdateCount: ULONG,
   pub Updates: [SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE_ENTRY; 1usize],
}
pub type SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE = _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE;
pub type PSYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE = *mut _SYSTEM_FEATURE_USAGE_SUBSCRIPTION_UPDATE;
pub type PRTL_RUN_ONCE_INIT_FN = ::core::option::Option<
   unsafe extern "C" fn(arg1: PRTL_RUN_ONCE, arg2: PVOID, arg3: *mut PVOID) -> LOGICAL,
>;
pub type PWNF_USER_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      arg1: WNF_STATE_NAME,
      arg2: WNF_CHANGE_STAMP,
      arg3: PWNF_TYPE_ID,
      arg4: PVOID,
      arg5: *const ::core::ffi::c_void,
      arg6: ULONG,
   ) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DEBUG_POGO_ENTRY {
   pub Rva: ULONG,
   pub Size: ULONG,
   pub Name: [CHAR; 1usize],
}
pub type IMAGE_DEBUG_POGO_ENTRY = _IMAGE_DEBUG_POGO_ENTRY;
pub type PIMAGE_DEBUG_POGO_ENTRY = *mut _IMAGE_DEBUG_POGO_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DEBUG_POGO_SIGNATURE {
   pub Signature: ULONG,
}
pub type IMAGE_DEBUG_POGO_SIGNATURE = _IMAGE_DEBUG_POGO_SIGNATURE;
pub type PIMAGE_DEBUG_POGO_SIGNATURE = *mut _IMAGE_DEBUG_POGO_SIGNATURE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_RELOCATION_RECORD {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IMAGE_RELOCATION_RECORD {
   #[inline]
   pub fn Offset(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
   }
   #[inline]
   pub fn set_Offset(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Offset_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            12u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Offset_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            12u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Type(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Type_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            4u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Type_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Offset: USHORT, Type: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 12u8, {
         let Offset: u16 = unsafe { ::core::mem::transmute(Offset) };
         Offset as u64
      });
      __bindgen_bitfield_unit.set(12usize, 4u8, {
         let Type: u16 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type IMAGE_RELOCATION_RECORD = _IMAGE_RELOCATION_RECORD;
pub type PIMAGE_RELOCATION_RECORD = *mut _IMAGE_RELOCATION_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_CHPE_METADATA_X86 {
   pub Version: ULONG,
   pub CHPECodeAddressRangeOffset: ULONG,
   pub CHPECodeAddressRangeCount: ULONG,
   pub WowA64ExceptionHandlerFunctionPointer: ULONG,
   pub WowA64DispatchCallFunctionPointer: ULONG,
   pub WowA64DispatchIndirectCallFunctionPointer: ULONG,
   pub WowA64DispatchIndirectCallCfgFunctionPointer: ULONG,
   pub WowA64DispatchRetFunctionPointer: ULONG,
   pub WowA64DispatchRetLeafFunctionPointer: ULONG,
   pub WowA64DispatchJumpFunctionPointer: ULONG,
   pub CompilerIATPointer: ULONG,
   pub WowA64RdtscFunctionPointer: ULONG,
}
pub type IMAGE_CHPE_METADATA_X86 = _IMAGE_CHPE_METADATA_X86;
pub type PIMAGE_CHPE_METADATA_X86 = *mut _IMAGE_CHPE_METADATA_X86;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_CHPE_RANGE_ENTRY {
   pub __bindgen_anon_1: _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1,
   pub Length: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1 {
   pub StartOffset: ULONG,
   pub __bindgen_anon_1: _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NativeCode(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_NativeCode(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NativeCode_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NativeCode_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AddressBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_AddressBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddressBits_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AddressBits_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NativeCode: ULONG,
      AddressBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let NativeCode: u32 = unsafe { ::core::mem::transmute(NativeCode) };
         NativeCode as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let AddressBits: u32 = unsafe { ::core::mem::transmute(AddressBits) };
         AddressBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _IMAGE_CHPE_RANGE_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_CHPE_RANGE_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_CHPE_RANGE_ENTRY = _IMAGE_CHPE_RANGE_ENTRY;
pub type PIMAGE_CHPE_RANGE_ENTRY = *mut _IMAGE_CHPE_RANGE_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64EC_METADATA {
   pub Version: ULONG,
   pub CodeMap: ULONG,
   pub CodeMapCount: ULONG,
   pub CodeRangesToEntryPoints: ULONG,
   pub RedirectionMetadata: ULONG,
   pub tbd__os_arm64x_dispatch_call_no_redirect: ULONG,
   pub tbd__os_arm64x_dispatch_ret: ULONG,
   pub tbd__os_arm64x_dispatch_call: ULONG,
   pub tbd__os_arm64x_dispatch_icall: ULONG,
   pub tbd__os_arm64x_dispatch_icall_cfg: ULONG,
   pub AlternateEntryPoint: ULONG,
   pub AuxiliaryIAT: ULONG,
   pub CodeRangesToEntryPointsCount: ULONG,
   pub RedirectionMetadataCount: ULONG,
   pub GetX64InformationFunctionPointer: ULONG,
   pub SetX64InformationFunctionPointer: ULONG,
   pub ExtraRFETable: ULONG,
   pub ExtraRFETableSize: ULONG,
   pub __os_arm64x_dispatch_fptr: ULONG,
   pub AuxiliaryIATCopy: ULONG,
}
pub type IMAGE_ARM64EC_METADATA = _IMAGE_ARM64EC_METADATA;
pub type PIMAGE_ARM64EC_METADATA = *mut _IMAGE_ARM64EC_METADATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM64EC_CODE_MAP_ENTRY {
   pub __bindgen_anon_1: _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1,
   pub Length: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1 {
   pub StartOffset: ULONG,
   pub __bindgen_anon_1: _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Type(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Type_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Type_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn AddressBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_AddressBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AddressBits_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_AddressBits_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Type: ULONG, AddressBits: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let Type: u32 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let AddressBits: u32 = unsafe { ::core::mem::transmute(AddressBits) };
         AddressBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _IMAGE_ARM64EC_CODE_MAP_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _IMAGE_ARM64EC_CODE_MAP_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type IMAGE_ARM64EC_CODE_MAP_ENTRY = _IMAGE_ARM64EC_CODE_MAP_ENTRY;
pub type PIMAGE_ARM64EC_CODE_MAP_ENTRY = *mut _IMAGE_ARM64EC_CODE_MAP_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64EC_REDIRECTION_ENTRY {
   pub Source: ULONG,
   pub Destination: ULONG,
}
pub type IMAGE_ARM64EC_REDIRECTION_ENTRY = _IMAGE_ARM64EC_REDIRECTION_ENTRY;
pub type PIMAGE_ARM64EC_REDIRECTION_ENTRY = *mut _IMAGE_ARM64EC_REDIRECTION_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT {
   pub StartRva: ULONG,
   pub EndRva: ULONG,
   pub EntryPoint: ULONG,
}
pub type IMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT = _IMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT;
pub type PIMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT = *mut _IMAGE_ARM64EC_CODE_RANGE_ENTRY_POINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DVRT_ARM64X_FIXUP_RECORD {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IMAGE_DVRT_ARM64X_FIXUP_RECORD {
   #[inline]
   pub fn Offset(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
   }
   #[inline]
   pub fn set_Offset(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Offset_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            12u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Offset_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            12u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Type(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Type_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            2u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Type_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Size(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_Size(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Size_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            2u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Size_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Offset: USHORT,
      Type: USHORT,
      Size: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 12u8, {
         let Offset: u16 = unsafe { ::core::mem::transmute(Offset) };
         Offset as u64
      });
      __bindgen_bitfield_unit.set(12usize, 2u8, {
         let Type: u16 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(14usize, 2u8, {
         let Size: u16 = unsafe { ::core::mem::transmute(Size) };
         Size as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type IMAGE_DVRT_ARM64X_FIXUP_RECORD = _IMAGE_DVRT_ARM64X_FIXUP_RECORD;
pub type PIMAGE_DVRT_ARM64X_FIXUP_RECORD = *mut _IMAGE_DVRT_ARM64X_FIXUP_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD {
   #[inline]
   pub fn Offset(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
   }
   #[inline]
   pub fn set_Offset(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Offset_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            12u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Offset_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            12u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Type(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_Type(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Type_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            2u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Type_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Sign(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_Sign(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Sign_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Sign_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Scale(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_Scale(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Scale_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_Scale_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      Offset: USHORT,
      Type: USHORT,
      Sign: USHORT,
      Scale: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 12u8, {
         let Offset: u16 = unsafe { ::core::mem::transmute(Offset) };
         Offset as u64
      });
      __bindgen_bitfield_unit.set(12usize, 2u8, {
         let Type: u16 = unsafe { ::core::mem::transmute(Type) };
         Type as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let Sign: u16 = unsafe { ::core::mem::transmute(Sign) };
         Sign as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let Scale: u16 = unsafe { ::core::mem::transmute(Scale) };
         Scale as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD = _IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD;
pub type PIMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD = *mut _IMAGE_DVRT_ARM64X_DELTA_FIXUP_RECORD;
pub type UNALIGNED_PIMAGE_THUNK_DATA32 = *mut IMAGE_THUNK_DATA32;
pub type UNALIGNED_PIMAGE_THUNK_DATA64 = *mut IMAGE_THUNK_DATA64;
#[repr(C)]
pub struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE {
   pub Version: ULONG64,
   pub Name: UNICODE_STRING,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE = _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub type PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
   pub Value: PVOID,
   pub ValueLength: ULONG,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub type PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
   *mut _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
pub struct _TOKEN_SECURITY_ATTRIBUTE_V1 {
   pub Name: UNICODE_STRING,
   pub ValueType: USHORT,
   pub Reserved: USHORT,
   pub Flags: ULONG,
   pub ValueCount: ULONG,
   pub Values: _TOKEN_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TOKEN_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
   pub pInt64: PLONG64,
   pub pUint64: PULONG64,
   pub pString: PUNICODE_STRING,
   pub pFqbn: PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE,
   pub pOctetString: PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTE_V1 = _TOKEN_SECURITY_ATTRIBUTE_V1;
pub type PTOKEN_SECURITY_ATTRIBUTE_V1 = *mut _TOKEN_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
pub struct _TOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1 {
   pub Name: UNICODE_STRING,
   pub ValueType: USHORT,
   pub Reserved: USHORT,
   pub Flags: ULONG,
   pub ValueCount: ULONG,
   pub Values: _TOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
   pub pInt64: [ULONG; 1usize],
   pub pUint64: [ULONG; 1usize],
   pub ppString: [ULONG; 1usize],
   pub pFqbn: [ULONG; 1usize],
   pub pOctetString: [ULONG; 1usize],
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1 = _TOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub type PTOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1 = *mut _TOKEN_SECURITY_ATTRIBUTE_RELATIVE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION {
   pub Version: USHORT,
   pub Reserved: USHORT,
   pub AttributeCount: ULONG,
   pub Attribute: _TOKEN_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TOKEN_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
   pub pAttributeV1: PTOKEN_SECURITY_ATTRIBUTE_V1,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TOKEN_SECURITY_ATTRIBUTES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTES_INFORMATION = _TOKEN_SECURITY_ATTRIBUTES_INFORMATION;
pub type PTOKEN_SECURITY_ATTRIBUTES_INFORMATION = *mut _TOKEN_SECURITY_ATTRIBUTES_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_SECURITY_ATTRIBUTE_OPERATION {
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_NONE = 0,
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_REPLACE_ALL = 1,
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_ADD = 2,
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_DELETE = 3,
   TOKEN_SECURITY_ATTRIBUTE_OPERATION_REPLACE = 4,
}
pub use self::_TOKEN_SECURITY_ATTRIBUTE_OPERATION as TOKEN_SECURITY_ATTRIBUTE_OPERATION;
pub type PTOKEN_SECURITY_ATTRIBUTE_OPERATION = *mut _TOKEN_SECURITY_ATTRIBUTE_OPERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION {
   pub Attributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
   pub Operations: PTOKEN_SECURITY_ATTRIBUTE_OPERATION,
}
impl Default for _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION =
   _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION;
pub type PTOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION =
   *mut _TOKEN_SECURITY_ATTRIBUTES_AND_OPERATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PROCESS_TRUST_LEVEL {
   pub TrustLevelSid: PSID,
}
impl Default for _TOKEN_PROCESS_TRUST_LEVEL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TOKEN_PROCESS_TRUST_LEVEL = _TOKEN_PROCESS_TRUST_LEVEL;
pub type PTOKEN_PROCESS_TRUST_LEVEL = *mut _TOKEN_PROCESS_TRUST_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_FILE_CACHE_CLAIM_INFORMATION {
   pub Size: ULONG,
   pub Claim: PVOID,
}
impl Default for _SE_FILE_CACHE_CLAIM_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SE_FILE_CACHE_CLAIM_INFORMATION = _SE_FILE_CACHE_CLAIM_INFORMATION;
pub type PSE_FILE_CACHE_CLAIM_INFORMATION = *mut _SE_FILE_CACHE_CLAIM_INFORMATION;
#[repr(C)]
pub struct _SE_SET_FILE_CACHE_INFORMATION {
   pub Size: ULONG,
   pub CatalogDirectoryPath: UNICODE_STRING,
   pub OriginClaimInfo: SE_FILE_CACHE_CLAIM_INFORMATION,
}
impl Default for _SE_SET_FILE_CACHE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SE_SET_FILE_CACHE_INFORMATION = _SE_SET_FILE_CACHE_INFORMATION;
pub type PSE_SET_FILE_CACHE_INFORMATION = *mut _SE_SET_FILE_CACHE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_ALPC {
   _unused: [u8; 0],
}
pub type TP_ALPC = _TP_ALPC;
pub type PTP_ALPC = *mut _TP_ALPC;
pub type PTP_ALPC_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Alpc: PTP_ALPC),
>;
pub type PTP_ALPC_CALLBACK_EX = ::core::option::Option<
   unsafe extern "C" fn(
      Instance: PTP_CALLBACK_INSTANCE,
      Context: PVOID,
      Alpc: PTP_ALPC,
      ApcContext: PVOID,
   ),
>;
pub type PTP_IO_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(
      Instance: PTP_CALLBACK_INSTANCE,
      Context: PVOID,
      ApcContext: PVOID,
      IoSB: PIO_STATUS_BLOCK,
      Io: PTP_IO,
   ),
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TP_TRACE_TYPE {
   TpTraceThreadPriority = 1,
   TpTraceThreadAffinity = 2,
   MaxTpTraceType = 3,
}
pub use self::_TP_TRACE_TYPE as TP_TRACE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KCONTINUE_TYPE {
   KCONTINUE_UNWIND = 0,
   KCONTINUE_RESUME = 1,
   KCONTINUE_LONGJUMP = 2,
   KCONTINUE_SET = 3,
   KCONTINUE_LAST = 4,
}
pub use self::_KCONTINUE_TYPE as KCONTINUE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCONTINUE_ARGUMENT {
   pub ContinueType: KCONTINUE_TYPE,
   pub ContinueFlags: ULONG,
   pub Reserved: [ULONGLONG; 2usize],
}
impl Default for _KCONTINUE_ARGUMENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type KCONTINUE_ARGUMENT = _KCONTINUE_ARGUMENT;
pub type PKCONTINUE_ARGUMENT = *mut _KCONTINUE_ARGUMENT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WOW64_SHARED_INFORMATION {
   SharedNtdll32LdrInitializeThunk = 0,
   SharedNtdll32KiUserExceptionDispatcher = 1,
   SharedNtdll32KiUserApcDispatcher = 2,
   SharedNtdll32KiUserCallbackDispatcher = 3,
   SharedNtdll32ExpInterlockedPopEntrySListFault = 4,
   SharedNtdll32ExpInterlockedPopEntrySListResume = 5,
   SharedNtdll32ExpInterlockedPopEntrySListEnd = 6,
   SharedNtdll32RtlUserThreadStart = 7,
   SharedNtdll32pQueryProcessDebugInformationRemote = 8,
   SharedNtdll32BaseAddress = 9,
   SharedNtdll32LdrSystemDllInitBlock = 10,
   Wow64SharedPageEntriesCount = 11,
}
pub use self::_WOW64_SHARED_INFORMATION as WOW64_SHARED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_BALANCED_NODE32 {
   pub __bindgen_anon_1: _RTL_BALANCED_NODE32__bindgen_ty_1,
   pub __bindgen_anon_2: _RTL_BALANCED_NODE32__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE32__bindgen_ty_1 {
   pub Children: [ULONG; 2usize],
   pub __bindgen_anon_1: _RTL_BALANCED_NODE32__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_BALANCED_NODE32__bindgen_ty_1__bindgen_ty_1 {
   pub Left: ULONG,
   pub Right: ULONG,
}
impl Default for _RTL_BALANCED_NODE32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_BALANCED_NODE32__bindgen_ty_2 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub ParentValue: ULONG,
}
impl Default for _RTL_BALANCED_NODE32__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _RTL_BALANCED_NODE32__bindgen_ty_2 {
   #[inline]
   pub fn Red(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Red(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Red_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Red_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Balance(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_Balance(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Balance_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Balance_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Red: ULONG, Balance: ULONG) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let Red: u32 = unsafe { ::core::mem::transmute(Red) };
         Red as u64
      });
      __bindgen_bitfield_unit.set(1usize, 2u8, {
         let Balance: u32 = unsafe { ::core::mem::transmute(Balance) };
         Balance as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _RTL_BALANCED_NODE32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type RTL_BALANCED_NODE32 = _RTL_BALANCED_NODE32;
pub type PRTL_BALANCED_NODE32 = *mut _RTL_BALANCED_NODE32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_RB_TREE32 {
   pub Root: ULONG,
   pub Min: ULONG,
}
pub type RTL_RB_TREE32 = _RTL_RB_TREE32;
pub type PRTL_RB_TREE32 = *mut _RTL_RB_TREE32;
#[repr(C)]
pub struct _PEB_LDR_DATA32 {
   pub Length: ULONG,
   pub Initialized: BOOLEAN,
   pub SsHandle: ULONG,
   pub InLoadOrderModuleList: LIST_ENTRY32,
   pub InMemoryOrderModuleList: LIST_ENTRY32,
   pub InInitializationOrderModuleList: LIST_ENTRY32,
   pub EntryInProgress: ULONG,
   pub ShutdownInProgress: BOOLEAN,
   pub ShutdownThreadId: ULONG,
}
impl Default for _PEB_LDR_DATA32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEB_LDR_DATA32 = _PEB_LDR_DATA32;
pub type PPEB_LDR_DATA32 = *mut _PEB_LDR_DATA32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_SERVICE_TAG_RECORD32 {
   pub Next: ULONG,
   pub ServiceTag: ULONG,
}
pub type LDR_SERVICE_TAG_RECORD32 = _LDR_SERVICE_TAG_RECORD32;
pub type PLDR_SERVICE_TAG_RECORD32 = *mut _LDR_SERVICE_TAG_RECORD32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDRP_CSLIST32 {
   pub Tail: ULONG,
}
pub type LDRP_CSLIST32 = _LDRP_CSLIST32;
pub type PLDRP_CSLIST32 = *mut _LDRP_CSLIST32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DDAG_NODE32 {
   pub Modules: LIST_ENTRY32,
   pub ServiceTagList: ULONG,
   pub LoadCount: ULONG,
   pub LoadWhileUnloadingCount: ULONG,
   pub LowestLink: ULONG,
   pub __bindgen_anon_1: _LDR_DDAG_NODE32__bindgen_ty_1,
   pub IncomingDependencies: LDRP_CSLIST32,
   pub State: LDR_DDAG_STATE,
   pub CondenseLink: SINGLE_LIST_ENTRY32,
   pub PreorderNumber: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DDAG_NODE32__bindgen_ty_1 {
   pub Dependencies: LDRP_CSLIST32,
   pub RemovalLink: SINGLE_LIST_ENTRY32,
}
impl Default for _LDR_DDAG_NODE32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_DDAG_NODE32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DDAG_NODE32 = _LDR_DDAG_NODE32;
pub type PLDR_DDAG_NODE32 = *mut _LDR_DDAG_NODE32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY32 {
   pub InLoadOrderLinks: LIST_ENTRY32,
   pub InMemoryOrderLinks: LIST_ENTRY32,
   pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY32__bindgen_ty_1,
   pub DllBase: ULONG,
   pub EntryPoint: ULONG,
   pub SizeOfImage: ULONG,
   pub FullDllName: UNICODE_STRING32,
   pub BaseDllName: UNICODE_STRING32,
   pub __bindgen_anon_2: _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2,
   pub ObsoleteLoadCount: USHORT,
   pub TlsIndex: USHORT,
   pub HashLinks: LIST_ENTRY32,
   pub TimeDateStamp: ULONG,
   pub EntryPointActivationContext: ULONG,
   pub Lock: ULONG,
   pub DdagNode: ULONG,
   pub NodeModuleLink: LIST_ENTRY32,
   pub LoadContext: ULONG,
   pub ParentDllBase: ULONG,
   pub SwitchBackContext: ULONG,
   pub BaseAddressIndexNode: RTL_BALANCED_NODE32,
   pub MappingInfoIndexNode: RTL_BALANCED_NODE32,
   pub OriginalBase: ULONG,
   pub LoadTime: LARGE_INTEGER,
   pub BaseNameHashValue: ULONG,
   pub LoadReason: LDR_DLL_LOAD_REASON,
   pub ImplicitPathOptions: ULONG,
   pub ReferenceCount: ULONG,
   pub DependentLoadFlags: ULONG,
   pub SigningLevel: UCHAR,
   pub CheckSum: ULONG,
   pub ActivePatchImageBase: ULONG,
   pub HotPatchState: LDR_HOT_PATCH_STATE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY32__bindgen_ty_1 {
   pub InInitializationOrderLinks: LIST_ENTRY32,
   pub InProgressLinks: LIST_ENTRY32,
}
impl Default for _LDR_DATA_TABLE_ENTRY32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2 {
   pub FlagGroup: [UCHAR; 4usize],
   pub Flags: ULONG,
   pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn PackagedBinary(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_PackagedBinary(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn PackagedBinary_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_PackagedBinary_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn MarkedForRemoval(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_MarkedForRemoval(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn MarkedForRemoval_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_MarkedForRemoval_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ImageDll(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ImageDll(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageDll_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ImageDll_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoadNotificationsSent(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadNotificationsSent(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoadNotificationsSent_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LoadNotificationsSent_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TelemetryEntryProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_TelemetryEntryProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TelemetryEntryProcessed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TelemetryEntryProcessed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessStaticImport(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessStaticImport(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessStaticImport_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessStaticImport_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InLegacyLists(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InLegacyLists(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InLegacyLists_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InLegacyLists_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InIndexes(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InIndexes(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InIndexes_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InIndexes_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ShimDll(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ShimDll(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ShimDll_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ShimDll_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InExceptionTable(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_InExceptionTable(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InExceptionTable_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_InExceptionTable_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags1_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags1_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoadInProgress(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadInProgress(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoadInProgress_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LoadInProgress_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoadConfigProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LoadConfigProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoadConfigProcessed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LoadConfigProcessed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn EntryProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_EntryProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn EntryProcessed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_EntryProcessed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProtectDelayLoad(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProtectDelayLoad(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProtectDelayLoad_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProtectDelayLoad_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags3(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags3(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(16usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags3_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            16usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags3_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            16usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DontCallForThreads(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DontCallForThreads(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(18usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DontCallForThreads_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            18usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DontCallForThreads_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            18usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessAttachCalled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessAttachCalled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(19usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessAttachCalled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            19usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessAttachCalled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            19usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessAttachFailed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessAttachFailed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(20usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessAttachFailed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            20usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessAttachFailed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            20usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CorDeferredValidate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorDeferredValidate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(21usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CorDeferredValidate_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            21usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CorDeferredValidate_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            21usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CorImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(22usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CorImage_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            22usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CorImage_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            22usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DontRelocate(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DontRelocate(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(23usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DontRelocate_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            23usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DontRelocate_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            23usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CorILOnly(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CorILOnly(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(24usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CorILOnly_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            24usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CorILOnly_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            24usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ChpeImage(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ChpeImage(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(25usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ChpeImage_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            25usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ChpeImage_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            25usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags5(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags5(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(26usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags5_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            26usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags5_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            26usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Redirected(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Redirected(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Redirected_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Redirected_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedFlags6(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedFlags6(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(29usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedFlags6_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            29usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedFlags6_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            29usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CompatDatabaseProcessed(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CompatDatabaseProcessed(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CompatDatabaseProcessed_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            31usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CompatDatabaseProcessed_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            31usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      PackagedBinary: ULONG,
      MarkedForRemoval: ULONG,
      ImageDll: ULONG,
      LoadNotificationsSent: ULONG,
      TelemetryEntryProcessed: ULONG,
      ProcessStaticImport: ULONG,
      InLegacyLists: ULONG,
      InIndexes: ULONG,
      ShimDll: ULONG,
      InExceptionTable: ULONG,
      ReservedFlags1: ULONG,
      LoadInProgress: ULONG,
      LoadConfigProcessed: ULONG,
      EntryProcessed: ULONG,
      ProtectDelayLoad: ULONG,
      ReservedFlags3: ULONG,
      DontCallForThreads: ULONG,
      ProcessAttachCalled: ULONG,
      ProcessAttachFailed: ULONG,
      CorDeferredValidate: ULONG,
      CorImage: ULONG,
      DontRelocate: ULONG,
      CorILOnly: ULONG,
      ChpeImage: ULONG,
      ReservedFlags5: ULONG,
      Redirected: ULONG,
      ReservedFlags6: ULONG,
      CompatDatabaseProcessed: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let PackagedBinary: u32 = unsafe { ::core::mem::transmute(PackagedBinary) };
         PackagedBinary as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let MarkedForRemoval: u32 = unsafe { ::core::mem::transmute(MarkedForRemoval) };
         MarkedForRemoval as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ImageDll: u32 = unsafe { ::core::mem::transmute(ImageDll) };
         ImageDll as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let LoadNotificationsSent: u32 = unsafe { ::core::mem::transmute(LoadNotificationsSent) };
         LoadNotificationsSent as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let TelemetryEntryProcessed: u32 =
            unsafe { ::core::mem::transmute(TelemetryEntryProcessed) };
         TelemetryEntryProcessed as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let ProcessStaticImport: u32 = unsafe { ::core::mem::transmute(ProcessStaticImport) };
         ProcessStaticImport as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let InLegacyLists: u32 = unsafe { ::core::mem::transmute(InLegacyLists) };
         InLegacyLists as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let InIndexes: u32 = unsafe { ::core::mem::transmute(InIndexes) };
         InIndexes as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let ShimDll: u32 = unsafe { ::core::mem::transmute(ShimDll) };
         ShimDll as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let InExceptionTable: u32 = unsafe { ::core::mem::transmute(InExceptionTable) };
         InExceptionTable as u64
      });
      __bindgen_bitfield_unit.set(10usize, 2u8, {
         let ReservedFlags1: u32 = unsafe { ::core::mem::transmute(ReservedFlags1) };
         ReservedFlags1 as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let LoadInProgress: u32 = unsafe { ::core::mem::transmute(LoadInProgress) };
         LoadInProgress as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let LoadConfigProcessed: u32 = unsafe { ::core::mem::transmute(LoadConfigProcessed) };
         LoadConfigProcessed as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let EntryProcessed: u32 = unsafe { ::core::mem::transmute(EntryProcessed) };
         EntryProcessed as u64
      });
      __bindgen_bitfield_unit.set(15usize, 1u8, {
         let ProtectDelayLoad: u32 = unsafe { ::core::mem::transmute(ProtectDelayLoad) };
         ProtectDelayLoad as u64
      });
      __bindgen_bitfield_unit.set(16usize, 2u8, {
         let ReservedFlags3: u32 = unsafe { ::core::mem::transmute(ReservedFlags3) };
         ReservedFlags3 as u64
      });
      __bindgen_bitfield_unit.set(18usize, 1u8, {
         let DontCallForThreads: u32 = unsafe { ::core::mem::transmute(DontCallForThreads) };
         DontCallForThreads as u64
      });
      __bindgen_bitfield_unit.set(19usize, 1u8, {
         let ProcessAttachCalled: u32 = unsafe { ::core::mem::transmute(ProcessAttachCalled) };
         ProcessAttachCalled as u64
      });
      __bindgen_bitfield_unit.set(20usize, 1u8, {
         let ProcessAttachFailed: u32 = unsafe { ::core::mem::transmute(ProcessAttachFailed) };
         ProcessAttachFailed as u64
      });
      __bindgen_bitfield_unit.set(21usize, 1u8, {
         let CorDeferredValidate: u32 = unsafe { ::core::mem::transmute(CorDeferredValidate) };
         CorDeferredValidate as u64
      });
      __bindgen_bitfield_unit.set(22usize, 1u8, {
         let CorImage: u32 = unsafe { ::core::mem::transmute(CorImage) };
         CorImage as u64
      });
      __bindgen_bitfield_unit.set(23usize, 1u8, {
         let DontRelocate: u32 = unsafe { ::core::mem::transmute(DontRelocate) };
         DontRelocate as u64
      });
      __bindgen_bitfield_unit.set(24usize, 1u8, {
         let CorILOnly: u32 = unsafe { ::core::mem::transmute(CorILOnly) };
         CorILOnly as u64
      });
      __bindgen_bitfield_unit.set(25usize, 1u8, {
         let ChpeImage: u32 = unsafe { ::core::mem::transmute(ChpeImage) };
         ChpeImage as u64
      });
      __bindgen_bitfield_unit.set(26usize, 2u8, {
         let ReservedFlags5: u32 = unsafe { ::core::mem::transmute(ReservedFlags5) };
         ReservedFlags5 as u64
      });
      __bindgen_bitfield_unit.set(28usize, 1u8, {
         let Redirected: u32 = unsafe { ::core::mem::transmute(Redirected) };
         Redirected as u64
      });
      __bindgen_bitfield_unit.set(29usize, 2u8, {
         let ReservedFlags6: u32 = unsafe { ::core::mem::transmute(ReservedFlags6) };
         ReservedFlags6 as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let CompatDatabaseProcessed: u32 =
            unsafe { ::core::mem::transmute(CompatDatabaseProcessed) };
         CompatDatabaseProcessed as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _LDR_DATA_TABLE_ENTRY32__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _LDR_DATA_TABLE_ENTRY32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LDR_DATA_TABLE_ENTRY32 = _LDR_DATA_TABLE_ENTRY32;
pub type PLDR_DATA_TABLE_ENTRY32 = *mut _LDR_DATA_TABLE_ENTRY32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CURDIR32 {
   pub DosPath: UNICODE_STRING32,
   pub Handle: ULONG,
}
pub type CURDIR32 = _CURDIR32;
pub type PCURDIR32 = *mut _CURDIR32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_DRIVE_LETTER_CURDIR32 {
   pub Flags: USHORT,
   pub Length: USHORT,
   pub TimeStamp: ULONG,
   pub DosPath: STRING32,
}
pub type RTL_DRIVE_LETTER_CURDIR32 = _RTL_DRIVE_LETTER_CURDIR32;
pub type PRTL_DRIVE_LETTER_CURDIR32 = *mut _RTL_DRIVE_LETTER_CURDIR32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RTL_USER_PROCESS_PARAMETERS32 {
   pub MaximumLength: ULONG,
   pub Length: ULONG,
   pub Flags: ULONG,
   pub DebugFlags: ULONG,
   pub ConsoleHandle: ULONG,
   pub ConsoleFlags: ULONG,
   pub StandardInput: ULONG,
   pub StandardOutput: ULONG,
   pub StandardError: ULONG,
   pub CurrentDirectory: CURDIR32,
   pub DllPath: UNICODE_STRING32,
   pub ImagePathName: UNICODE_STRING32,
   pub CommandLine: UNICODE_STRING32,
   pub Environment: ULONG,
   pub StartingX: ULONG,
   pub StartingY: ULONG,
   pub CountX: ULONG,
   pub CountY: ULONG,
   pub CountCharsX: ULONG,
   pub CountCharsY: ULONG,
   pub FillAttribute: ULONG,
   pub WindowFlags: ULONG,
   pub ShowWindowFlags: ULONG,
   pub WindowTitle: UNICODE_STRING32,
   pub DesktopInfo: UNICODE_STRING32,
   pub ShellInfo: UNICODE_STRING32,
   pub RuntimeData: UNICODE_STRING32,
   pub CurrentDirectories: [RTL_DRIVE_LETTER_CURDIR32; 32usize],
   pub EnvironmentSize: ULONG,
   pub EnvironmentVersion: ULONG,
   pub PackageDependencyData: ULONG,
   pub ProcessGroupId: ULONG,
   pub LoaderThreads: ULONG,
   pub RedirectionDllName: UNICODE_STRING32,
   pub HeapPartitionName: UNICODE_STRING32,
   pub DefaultThreadpoolCpuSetMasks: ULONG,
   pub DefaultThreadpoolCpuSetMaskCount: ULONG,
   pub DefaultThreadpoolThreadMaximum: ULONG,
}
pub type RTL_USER_PROCESS_PARAMETERS32 = _RTL_USER_PROCESS_PARAMETERS32;
pub type PRTL_USER_PROCESS_PARAMETERS32 = *mut _RTL_USER_PROCESS_PARAMETERS32;
#[repr(C)]
pub struct _PEB32 {
   pub InheritedAddressSpace: BOOLEAN,
   pub ReadImageFileExecOptions: BOOLEAN,
   pub BeingDebugged: BOOLEAN,
   pub __bindgen_anon_1: _PEB32__bindgen_ty_1,
   pub Mutant: ULONG,
   pub ImageBaseAddress: ULONG,
   pub Ldr: ULONG,
   pub ProcessParameters: ULONG,
   pub SubSystemData: ULONG,
   pub ProcessHeap: ULONG,
   pub FastPebLock: ULONG,
   pub AtlThunkSListPtr: ULONG,
   pub IFEOKey: ULONG,
   pub __bindgen_anon_2: _PEB32__bindgen_ty_2,
   pub __bindgen_anon_3: _PEB32__bindgen_ty_3,
   pub SystemReserved: ULONG,
   pub AtlThunkSListPtr32: ULONG,
   pub ApiSetMap: ULONG,
   pub TlsExpansionCounter: ULONG,
   pub TlsBitmap: ULONG,
   pub TlsBitmapBits: [ULONG; 2usize],
   pub ReadOnlySharedMemoryBase: ULONG,
   pub SharedData: ULONG,
   pub ReadOnlyStaticServerData: ULONG,
   pub AnsiCodePageData: ULONG,
   pub OemCodePageData: ULONG,
   pub UnicodeCaseTableData: ULONG,
   pub NumberOfProcessors: ULONG,
   pub NtGlobalFlag: ULONG,
   pub CriticalSectionTimeout: LARGE_INTEGER,
   pub HeapSegmentReserve: ULONG,
   pub HeapSegmentCommit: ULONG,
   pub HeapDeCommitTotalFreeThreshold: ULONG,
   pub HeapDeCommitFreeBlockThreshold: ULONG,
   pub NumberOfHeaps: ULONG,
   pub MaximumNumberOfHeaps: ULONG,
   pub ProcessHeaps: ULONG,
   pub GdiSharedHandleTable: ULONG,
   pub ProcessStarterHelper: ULONG,
   pub GdiDCAttributeList: ULONG,
   pub LoaderLock: ULONG,
   pub OSMajorVersion: ULONG,
   pub OSMinorVersion: ULONG,
   pub OSBuildNumber: USHORT,
   pub OSCSDVersion: USHORT,
   pub OSPlatformId: ULONG,
   pub ImageSubsystem: ULONG,
   pub ImageSubsystemMajorVersion: ULONG,
   pub ImageSubsystemMinorVersion: ULONG,
   pub ActiveProcessAffinityMask: ULONG,
   pub GdiHandleBuffer: GDI_HANDLE_BUFFER32,
   pub PostProcessInitRoutine: ULONG,
   pub TlsExpansionBitmap: ULONG,
   pub TlsExpansionBitmapBits: [ULONG; 32usize],
   pub SessionId: ULONG,
   pub AppCompatFlags: ULARGE_INTEGER,
   pub AppCompatFlagsUser: ULARGE_INTEGER,
   pub pShimData: ULONG,
   pub AppCompatInfo: ULONG,
   pub CSDVersion: UNICODE_STRING32,
   pub ActivationContextData: ULONG,
   pub ProcessAssemblyStorageMap: ULONG,
   pub SystemDefaultActivationContextData: ULONG,
   pub SystemAssemblyStorageMap: ULONG,
   pub MinimumStackCommit: ULONG,
   pub SparePointers: [ULONG; 2usize],
   pub PatchLoaderData: ULONG,
   pub ChpeV2ProcessInfo: ULONG,
   pub AppModelFeatureState: ULONG,
   pub SpareUlongs: [ULONG; 2usize],
   pub ActiveCodePage: USHORT,
   pub OemCodePage: USHORT,
   pub UseCaseMapping: USHORT,
   pub UnusedNlsField: USHORT,
   pub WerRegistrationData: ULONG,
   pub WerShipAssertPtr: ULONG,
   pub __bindgen_anon_4: _PEB32__bindgen_ty_4,
   pub pImageHeaderHash: ULONG,
   pub __bindgen_anon_5: _PEB32__bindgen_ty_5,
   pub CsrServerReadOnlySharedMemoryBase: ULONGLONG,
   pub TppWorkerpListLock: ULONG,
   pub TppWorkerpList: LIST_ENTRY32,
   pub WaitOnAddressHashTable: [ULONG; 128usize],
   pub TelemetryCoverageHeader: ULONG,
   pub CloudFileFlags: ULONG,
   pub CloudFileDiagFlags: ULONG,
   pub PlaceholderCompatibilityMode: CHAR,
   pub PlaceholderCompatibilityModeReserved: [CHAR; 7usize],
   pub LeapSecondData: ULONG,
   pub __bindgen_anon_6: _PEB32__bindgen_ty_6,
   pub NtGlobalFlag2: ULONG,
   pub ExtendedFeatureDisableMask: ULONGLONG,
}
#[repr(C)]
pub union _PEB32__bindgen_ty_1 {
   pub BitField: ::core::mem::ManuallyDrop<BOOLEAN>,
   pub __bindgen_anon_1: ::core::mem::ManuallyDrop<_PEB32__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct _PEB32__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Default for _PEB32__bindgen_ty_1__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PEB32__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ImageUsesLargePages(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ImageUsesLargePages(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ImageUsesLargePages_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ImageUsesLargePages_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsProtectedProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsProtectedProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsProtectedProcess_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsProtectedProcess_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsImageDynamicallyRelocated(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsImageDynamicallyRelocated(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsImageDynamicallyRelocated_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsImageDynamicallyRelocated_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SkipPatchingUser32Forwarders(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_SkipPatchingUser32Forwarders(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SkipPatchingUser32Forwarders_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_SkipPatchingUser32Forwarders_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsPackagedProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsPackagedProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsPackagedProcess_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsPackagedProcess_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsAppContainer(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsAppContainer(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsAppContainer_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsAppContainer_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsProtectedProcessLight(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsProtectedProcessLight(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsProtectedProcessLight_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsProtectedProcessLight_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn IsLongPathAwareProcess(&self) -> BOOLEAN {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_IsLongPathAwareProcess(&mut self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IsLongPathAwareProcess_raw(this: *const Self) -> BOOLEAN {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_IsLongPathAwareProcess_raw(this: *mut Self, val: BOOLEAN) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ImageUsesLargePages: BOOLEAN,
      IsProtectedProcess: BOOLEAN,
      IsImageDynamicallyRelocated: BOOLEAN,
      SkipPatchingUser32Forwarders: BOOLEAN,
      IsPackagedProcess: BOOLEAN,
      IsAppContainer: BOOLEAN,
      IsProtectedProcessLight: BOOLEAN,
      IsLongPathAwareProcess: BOOLEAN,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ImageUsesLargePages: u8 = unsafe { ::core::mem::transmute(ImageUsesLargePages) };
         ImageUsesLargePages as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let IsProtectedProcess: u8 = unsafe { ::core::mem::transmute(IsProtectedProcess) };
         IsProtectedProcess as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let IsImageDynamicallyRelocated: u8 =
            unsafe { ::core::mem::transmute(IsImageDynamicallyRelocated) };
         IsImageDynamicallyRelocated as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SkipPatchingUser32Forwarders: u8 =
            unsafe { ::core::mem::transmute(SkipPatchingUser32Forwarders) };
         SkipPatchingUser32Forwarders as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let IsPackagedProcess: u8 = unsafe { ::core::mem::transmute(IsPackagedProcess) };
         IsPackagedProcess as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let IsAppContainer: u8 = unsafe { ::core::mem::transmute(IsAppContainer) };
         IsAppContainer as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let IsProtectedProcessLight: u8 =
            unsafe { ::core::mem::transmute(IsProtectedProcessLight) };
         IsProtectedProcessLight as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let IsLongPathAwareProcess: u8 = unsafe { ::core::mem::transmute(IsLongPathAwareProcess) };
         IsLongPathAwareProcess as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_2 {
   pub CrossProcessFlags: ULONG,
   pub __bindgen_anon_1: _PEB32__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB32__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB32__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn ProcessInJob(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessInJob(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessInJob_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessInJob_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessInitializing(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessInitializing(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessInitializing_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessInitializing_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessUsingVEH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingVEH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessUsingVEH_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessUsingVEH_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessUsingVCH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingVCH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessUsingVCH_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessUsingVCH_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessUsingFTH(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ProcessUsingFTH(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessUsingFTH_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessUsingFTH_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReservedBits0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_ReservedBits0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReservedBits0_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReservedBits0_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ProcessInJob: ULONG,
      ProcessInitializing: ULONG,
      ProcessUsingVEH: ULONG,
      ProcessUsingVCH: ULONG,
      ProcessUsingFTH: ULONG,
      ReservedBits0: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ProcessInJob: u32 = unsafe { ::core::mem::transmute(ProcessInJob) };
         ProcessInJob as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ProcessInitializing: u32 = unsafe { ::core::mem::transmute(ProcessInitializing) };
         ProcessInitializing as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ProcessUsingVEH: u32 = unsafe { ::core::mem::transmute(ProcessUsingVEH) };
         ProcessUsingVEH as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let ProcessUsingVCH: u32 = unsafe { ::core::mem::transmute(ProcessUsingVCH) };
         ProcessUsingVCH as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let ProcessUsingFTH: u32 = unsafe { ::core::mem::transmute(ProcessUsingFTH) };
         ProcessUsingFTH as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let ReservedBits0: u32 = unsafe { ::core::mem::transmute(ReservedBits0) };
         ReservedBits0 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB32__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_3 {
   pub KernelCallbackTable: ULONG,
   pub UserSharedInfoPtr: ULONG,
}
impl Default for _PEB32__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_4 {
   pub pContextData: ULONG,
   pub pUnused: ULONG,
   pub EcCodeBitMap: ULONG,
}
impl Default for _PEB32__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_5 {
   pub TracingFlags: ULONG,
   pub __bindgen_anon_1: _PEB32__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB32__bindgen_ty_5__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB32__bindgen_ty_5__bindgen_ty_1 {
   #[inline]
   pub fn HeapTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_HeapTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HeapTracingEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_HeapTracingEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CritSecTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_CritSecTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CritSecTracingEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_CritSecTracingEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LibLoaderTracingEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_LibLoaderTracingEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LibLoaderTracingEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_LibLoaderTracingEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareTracingBits(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
   }
   #[inline]
   pub fn set_SpareTracingBits(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 29u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareTracingBits_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            29u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SpareTracingBits_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            29u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      HeapTracingEnabled: ULONG,
      CritSecTracingEnabled: ULONG,
      LibLoaderTracingEnabled: ULONG,
      SpareTracingBits: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let HeapTracingEnabled: u32 = unsafe { ::core::mem::transmute(HeapTracingEnabled) };
         HeapTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let CritSecTracingEnabled: u32 = unsafe { ::core::mem::transmute(CritSecTracingEnabled) };
         CritSecTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let LibLoaderTracingEnabled: u32 =
            unsafe { ::core::mem::transmute(LibLoaderTracingEnabled) };
         LibLoaderTracingEnabled as u64
      });
      __bindgen_bitfield_unit.set(3usize, 29u8, {
         let SpareTracingBits: u32 = unsafe { ::core::mem::transmute(SpareTracingBits) };
         SpareTracingBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB32__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PEB32__bindgen_ty_6 {
   pub LeapSecondFlags: ULONG,
   pub __bindgen_anon_1: _PEB32__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB32__bindgen_ty_6__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PEB32__bindgen_ty_6__bindgen_ty_1 {
   #[inline]
   pub fn SixtySecondEnabled(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_SixtySecondEnabled(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SixtySecondEnabled_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_SixtySecondEnabled_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 31u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            31u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            31u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SixtySecondEnabled: ULONG,
      Reserved: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SixtySecondEnabled: u32 = unsafe { ::core::mem::transmute(SixtySecondEnabled) };
         SixtySecondEnabled as u64
      });
      __bindgen_bitfield_unit.set(1usize, 31u8, {
         let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PEB32__bindgen_ty_6 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PEB32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEB32 = _PEB32;
pub type PPEB32 = *mut _PEB32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDI_TEB_BATCH32 {
   pub Offset: ULONG,
   pub HDC: ULONG,
   pub Buffer: [ULONG; 310usize],
}
impl Default for _GDI_TEB_BATCH32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GDI_TEB_BATCH32 = _GDI_TEB_BATCH32;
pub type PGDI_TEB_BATCH32 = *mut _GDI_TEB_BATCH32;
#[repr(C)]
pub struct _TEB32 {
   pub NtTib: NT_TIB32,
   pub EnvironmentPointer: ULONG,
   pub ClientId: CLIENT_ID32,
   pub ActiveRpcHandle: ULONG,
   pub ThreadLocalStoragePointer: ULONG,
   pub ProcessEnvironmentBlock: ULONG,
   pub LastErrorValue: ULONG,
   pub CountOfOwnedCriticalSections: ULONG,
   pub CsrClientThread: ULONG,
   pub Win32ThreadInfo: ULONG,
   pub User32Reserved: [ULONG; 26usize],
   pub UserReserved: [ULONG; 5usize],
   pub WOW32Reserved: ULONG,
   pub CurrentLocale: LCID,
   pub FpSoftwareStatusRegister: ULONG,
   pub ReservedForDebuggerInstrumentation: [ULONG; 16usize],
   pub SystemReserved1: [ULONG; 36usize],
   pub WorkingOnBehalfTicket: [UCHAR; 8usize],
   pub ExceptionCode: NTSTATUS,
   pub ActivationContextStackPointer: ULONG,
   pub InstrumentationCallbackSp: ULONG,
   pub InstrumentationCallbackPreviousPc: ULONG,
   pub InstrumentationCallbackPreviousSp: ULONG,
   pub InstrumentationCallbackDisabled: BOOLEAN,
   pub SpareBytes: [UCHAR; 23usize],
   pub TxFsContext: ULONG,
   pub GdiTebBatch: GDI_TEB_BATCH32,
   pub RealClientId: CLIENT_ID32,
   pub GdiCachedProcessHandle: ULONG,
   pub GdiClientPID: ULONG,
   pub GdiClientTID: ULONG,
   pub GdiThreadLocalInfo: ULONG,
   pub Win32ClientInfo: [ULONG; 62usize],
   pub glDispatchTable: [ULONG; 233usize],
   pub glReserved1: [ULONG; 29usize],
   pub glReserved2: ULONG,
   pub glSectionInfo: ULONG,
   pub glSection: ULONG,
   pub glTable: ULONG,
   pub glCurrentRC: ULONG,
   pub glContext: ULONG,
   pub LastStatusValue: NTSTATUS,
   pub StaticUnicodeString: UNICODE_STRING32,
   pub StaticUnicodeBuffer: [WCHAR; 261usize],
   pub DeallocationStack: ULONG,
   pub TlsSlots: [ULONG; 64usize],
   pub TlsLinks: LIST_ENTRY32,
   pub Vdm: ULONG,
   pub ReservedForNtRpc: ULONG,
   pub DbgSsReserved: [ULONG; 2usize],
   pub HardErrorMode: ULONG,
   pub Instrumentation: [ULONG; 9usize],
   pub ActivityId: GUID,
   pub SubProcessTag: ULONG,
   pub PerflibData: ULONG,
   pub EtwTraceData: ULONG,
   pub WinSockData: ULONG,
   pub GdiBatchCount: ULONG,
   pub __bindgen_anon_1: _TEB32__bindgen_ty_1,
   pub GuaranteedStackBytes: ULONG,
   pub ReservedForPerf: ULONG,
   pub ReservedForOle: ULONG,
   pub WaitingOnLoaderLock: ULONG,
   pub SavedPriorityState: ULONG,
   pub ReservedForCodeCoverage: ULONG,
   pub ThreadPoolData: ULONG,
   pub TlsExpansionSlots: ULONG,
   pub MuiGeneration: ULONG,
   pub IsImpersonating: ULONG,
   pub NlsCache: ULONG,
   pub pShimData: ULONG,
   pub HeapVirtualAffinity: USHORT,
   pub LowFragHeapDataSlot: USHORT,
   pub CurrentTransactionHandle: ULONG,
   pub ActiveFrame: ULONG,
   pub FlsData: ULONG,
   pub PreferredLanguages: ULONG,
   pub UserPrefLanguages: ULONG,
   pub MergedPrefLanguages: ULONG,
   pub MuiImpersonation: ULONG,
   pub __bindgen_anon_2: _TEB32__bindgen_ty_2,
   pub __bindgen_anon_3: _TEB32__bindgen_ty_3,
   pub TxnScopeEnterCallback: ULONG,
   pub TxnScopeExitCallback: ULONG,
   pub TxnScopeContext: ULONG,
   pub LockCount: ULONG,
   pub WowTebOffset: LONG,
   pub ResourceRetValue: ULONG,
   pub ReservedForWdf: ULONG,
   pub ReservedForCrt: ULONGLONG,
   pub EffectiveContainerId: GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_1 {
   pub CurrentIdealProcessor: PROCESSOR_NUMBER,
   pub IdealProcessorValue: ULONG,
   pub __bindgen_anon_1: _TEB32__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB32__bindgen_ty_1__bindgen_ty_1 {
   pub ReservedPad0: UCHAR,
   pub ReservedPad1: UCHAR,
   pub ReservedPad2: UCHAR,
   pub IdealProcessor: UCHAR,
}
impl Default for _TEB32__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_2 {
   pub CrossTebFlags: USHORT,
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl Default for _TEB32__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _TEB32__bindgen_ty_2 {
   #[inline]
   pub fn SpareCrossTebBits(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
   }
   #[inline]
   pub fn set_SpareCrossTebBits(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 16u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareCrossTebBits_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            16u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SpareCrossTebBits_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            16u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(SpareCrossTebBits: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 16u8, {
         let SpareCrossTebBits: u16 = unsafe { ::core::mem::transmute(SpareCrossTebBits) };
         SpareCrossTebBits as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TEB32__bindgen_ty_3 {
   pub SameTebFlags: USHORT,
   pub __bindgen_anon_1: _TEB32__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TEB32__bindgen_ty_3__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _TEB32__bindgen_ty_3__bindgen_ty_1 {
   #[inline]
   pub fn SafeThunkCall(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SafeThunkCall(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SafeThunkCall_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SafeThunkCall_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InDebugPrint(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_InDebugPrint(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InDebugPrint_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_InDebugPrint_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn HasFiberData(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_HasFiberData(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn HasFiberData_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_HasFiberData_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SkipThreadAttach(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SkipThreadAttach(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SkipThreadAttach_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SkipThreadAttach_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn WerInShipAssertCode(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_WerInShipAssertCode(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn WerInShipAssertCode_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_WerInShipAssertCode_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RanProcessInit(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_RanProcessInit(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RanProcessInit_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_RanProcessInit_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ClonedThread(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_ClonedThread(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ClonedThread_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_ClonedThread_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SuppressDebugMsg(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SuppressDebugMsg(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SuppressDebugMsg_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SuppressDebugMsg_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DisableUserStackWalk(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_DisableUserStackWalk(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisableUserStackWalk_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_DisableUserStackWalk_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn RtlExceptionAttached(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_RtlExceptionAttached(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn RtlExceptionAttached_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_RtlExceptionAttached_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn InitialThread(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_InitialThread(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(10usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn InitialThread_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            10usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_InitialThread_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            10usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SessionAware(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_SessionAware(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(11usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SessionAware_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            11usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SessionAware_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            11usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoadOwner(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_LoadOwner(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoadOwner_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_LoadOwner_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn LoaderWorker(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_LoaderWorker(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn LoaderWorker_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_LoaderWorker_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn SpareSameTebBits(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_SpareSameTebBits(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn SpareSameTebBits_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            2u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_SpareSameTebBits_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      SafeThunkCall: USHORT,
      InDebugPrint: USHORT,
      HasFiberData: USHORT,
      SkipThreadAttach: USHORT,
      WerInShipAssertCode: USHORT,
      RanProcessInit: USHORT,
      ClonedThread: USHORT,
      SuppressDebugMsg: USHORT,
      DisableUserStackWalk: USHORT,
      RtlExceptionAttached: USHORT,
      InitialThread: USHORT,
      SessionAware: USHORT,
      LoadOwner: USHORT,
      LoaderWorker: USHORT,
      SpareSameTebBits: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let SafeThunkCall: u16 = unsafe { ::core::mem::transmute(SafeThunkCall) };
         SafeThunkCall as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let InDebugPrint: u16 = unsafe { ::core::mem::transmute(InDebugPrint) };
         InDebugPrint as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let HasFiberData: u16 = unsafe { ::core::mem::transmute(HasFiberData) };
         HasFiberData as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let SkipThreadAttach: u16 = unsafe { ::core::mem::transmute(SkipThreadAttach) };
         SkipThreadAttach as u64
      });
      __bindgen_bitfield_unit.set(4usize, 1u8, {
         let WerInShipAssertCode: u16 = unsafe { ::core::mem::transmute(WerInShipAssertCode) };
         WerInShipAssertCode as u64
      });
      __bindgen_bitfield_unit.set(5usize, 1u8, {
         let RanProcessInit: u16 = unsafe { ::core::mem::transmute(RanProcessInit) };
         RanProcessInit as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ClonedThread: u16 = unsafe { ::core::mem::transmute(ClonedThread) };
         ClonedThread as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let SuppressDebugMsg: u16 = unsafe { ::core::mem::transmute(SuppressDebugMsg) };
         SuppressDebugMsg as u64
      });
      __bindgen_bitfield_unit.set(8usize, 1u8, {
         let DisableUserStackWalk: u16 = unsafe { ::core::mem::transmute(DisableUserStackWalk) };
         DisableUserStackWalk as u64
      });
      __bindgen_bitfield_unit.set(9usize, 1u8, {
         let RtlExceptionAttached: u16 = unsafe { ::core::mem::transmute(RtlExceptionAttached) };
         RtlExceptionAttached as u64
      });
      __bindgen_bitfield_unit.set(10usize, 1u8, {
         let InitialThread: u16 = unsafe { ::core::mem::transmute(InitialThread) };
         InitialThread as u64
      });
      __bindgen_bitfield_unit.set(11usize, 1u8, {
         let SessionAware: u16 = unsafe { ::core::mem::transmute(SessionAware) };
         SessionAware as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let LoadOwner: u16 = unsafe { ::core::mem::transmute(LoadOwner) };
         LoadOwner as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let LoaderWorker: u16 = unsafe { ::core::mem::transmute(LoaderWorker) };
         LoaderWorker as u64
      });
      __bindgen_bitfield_unit.set(14usize, 2u8, {
         let SpareSameTebBits: u16 = unsafe { ::core::mem::transmute(SpareSameTebBits) };
         SpareSameTebBits as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _TEB32__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _TEB32 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TEB32 = _TEB32;
pub type PTEB32 = *mut _TEB32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WOW64_EXECUTE_OPTIONS {
   pub Flags: ULONG,
   pub __bindgen_anon_1: _WOW64_EXECUTE_OPTIONS__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WOW64_EXECUTE_OPTIONS__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WOW64_EXECUTE_OPTIONS__bindgen_ty_1 {
   #[inline]
   pub fn StackReserveSize(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
   }
   #[inline]
   pub fn set_StackReserveSize(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 8u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StackReserveSize_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            8u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StackReserveSize_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            8u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn StackCommitSize(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_StackCommitSize(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(8usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StackCommitSize_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            8usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StackCommitSize_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            8usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Deprecated0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Deprecated0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(12usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Deprecated0_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            12usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Deprecated0_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            12usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DisableWowAssert(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisableWowAssert(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(13usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisableWowAssert_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            13usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DisableWowAssert_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            13usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DisableTurboDispatch(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_DisableTurboDispatch(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(14usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DisableTurboDispatch_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            14usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DisableTurboDispatch_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            14usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Unused(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 13u8) as u32) }
   }
   #[inline]
   pub fn set_Unused(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 13u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Unused_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            13u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Unused_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            13u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved0(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved0(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(28usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved0_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            28usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved0_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            28usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved1(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved1(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(29usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved1_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            29usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            29usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved2(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved2(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(30usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved2_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            30usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved2_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            30usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved3(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_Reserved3(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(31usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved3_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            31usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved3_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            31usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      StackReserveSize: ULONG,
      StackCommitSize: ULONG,
      Deprecated0: ULONG,
      DisableWowAssert: ULONG,
      DisableTurboDispatch: ULONG,
      Unused: ULONG,
      Reserved0: ULONG,
      Reserved1: ULONG,
      Reserved2: ULONG,
      Reserved3: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 8u8, {
         let StackReserveSize: u32 = unsafe { ::core::mem::transmute(StackReserveSize) };
         StackReserveSize as u64
      });
      __bindgen_bitfield_unit.set(8usize, 4u8, {
         let StackCommitSize: u32 = unsafe { ::core::mem::transmute(StackCommitSize) };
         StackCommitSize as u64
      });
      __bindgen_bitfield_unit.set(12usize, 1u8, {
         let Deprecated0: u32 = unsafe { ::core::mem::transmute(Deprecated0) };
         Deprecated0 as u64
      });
      __bindgen_bitfield_unit.set(13usize, 1u8, {
         let DisableWowAssert: u32 = unsafe { ::core::mem::transmute(DisableWowAssert) };
         DisableWowAssert as u64
      });
      __bindgen_bitfield_unit.set(14usize, 1u8, {
         let DisableTurboDispatch: u32 = unsafe { ::core::mem::transmute(DisableTurboDispatch) };
         DisableTurboDispatch as u64
      });
      __bindgen_bitfield_unit.set(15usize, 13u8, {
         let Unused: u32 = unsafe { ::core::mem::transmute(Unused) };
         Unused as u64
      });
      __bindgen_bitfield_unit.set(28usize, 1u8, {
         let Reserved0: u32 = unsafe { ::core::mem::transmute(Reserved0) };
         Reserved0 as u64
      });
      __bindgen_bitfield_unit.set(29usize, 1u8, {
         let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
         Reserved1 as u64
      });
      __bindgen_bitfield_unit.set(30usize, 1u8, {
         let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
         Reserved2 as u64
      });
      __bindgen_bitfield_unit.set(31usize, 1u8, {
         let Reserved3: u32 = unsafe { ::core::mem::transmute(Reserved3) };
         Reserved3 as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _WOW64_EXECUTE_OPTIONS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64_EXECUTE_OPTIONS = _WOW64_EXECUTE_OPTIONS;
pub type PWOW64_EXECUTE_OPTIONS = *mut _WOW64_EXECUTE_OPTIONS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64INFO {
   pub NativeSystemPageSize: ULONG,
   pub CpuFlags: ULONG,
   pub Wow64ExecuteFlags: WOW64_EXECUTE_OPTIONS,
   pub InstrumentationCallback: ULONG,
}
impl Default for _WOW64INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WOW64INFO = _WOW64INFO;
pub type PWOW64INFO = *mut _WOW64INFO;
#[repr(C)]
pub struct _PEB32_WITH_WOW64INFO {
   pub Peb32: PEB32,
   pub Wow64Info: WOW64INFO,
}
impl Default for _PEB32_WITH_WOW64INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PEB32_WITH_WOW64INFO = _PEB32_WITH_WOW64INFO;
pub type PPEB32_WITH_WOW64INFO = *mut _PEB32_WITH_WOW64INFO;
pub type SAM_HANDLE = PVOID;
pub type PSAM_HANDLE = *mut PVOID;
pub type SAM_ENUMERATE_HANDLE = ULONG;
pub type PSAM_ENUMERATE_HANDLE = *mut ULONG;
#[repr(C)]
pub struct _SAM_RID_ENUMERATION {
   pub RelativeId: ULONG,
   pub Name: UNICODE_STRING,
}
impl Default for _SAM_RID_ENUMERATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_RID_ENUMERATION = _SAM_RID_ENUMERATION;
pub type PSAM_RID_ENUMERATION = *mut _SAM_RID_ENUMERATION;
#[repr(C)]
pub struct _SAM_SID_ENUMERATION {
   pub Sid: PSID,
   pub Name: UNICODE_STRING,
}
impl Default for _SAM_SID_ENUMERATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_SID_ENUMERATION = _SAM_SID_ENUMERATION;
pub type PSAM_SID_ENUMERATION = *mut _SAM_SID_ENUMERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SAM_BYTE_ARRAY {
   pub Size: ULONG,
   pub Data: PUCHAR,
}
impl Default for _SAM_BYTE_ARRAY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_BYTE_ARRAY = _SAM_BYTE_ARRAY;
pub type PSAM_BYTE_ARRAY = *mut _SAM_BYTE_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SAM_BYTE_ARRAY_32K {
   pub Size: ULONG,
   pub Data: PUCHAR,
}
impl Default for _SAM_BYTE_ARRAY_32K {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_BYTE_ARRAY_32K = _SAM_BYTE_ARRAY_32K;
pub type PSAM_BYTE_ARRAY_32K = *mut _SAM_BYTE_ARRAY_32K;
pub type SAM_SHELL_OBJECT_PROPERTIES = SAM_BYTE_ARRAY_32K;
pub type PSAM_SHELL_OBJECT_PROPERTIES = *mut SAM_BYTE_ARRAY_32K;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_AUTH_IDENTITY_HANDLE {
   _unused: [u8; 0],
}
pub type PRPC_AUTH_IDENTITY_HANDLE = *mut _RPC_AUTH_IDENTITY_HANDLE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_INFORMATION_CLASS {
   DomainPasswordInformation = 1,
   DomainGeneralInformation = 2,
   DomainLogoffInformation = 3,
   DomainOemInformation = 4,
   DomainNameInformation = 5,
   DomainReplicationInformation = 6,
   DomainServerRoleInformation = 7,
   DomainModifiedInformation = 8,
   DomainStateInformation = 9,
   DomainUasInformation = 10,
   DomainGeneralInformation2 = 11,
   DomainLockoutInformation = 12,
   DomainModifiedInformation2 = 13,
}
pub use self::_DOMAIN_INFORMATION_CLASS as DOMAIN_INFORMATION_CLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_SERVER_ENABLE_STATE {
   DomainServerEnabled = 1,
   DomainServerDisabled = 2,
}
pub use self::_DOMAIN_SERVER_ENABLE_STATE as DOMAIN_SERVER_ENABLE_STATE;
pub type PDOMAIN_SERVER_ENABLE_STATE = *mut _DOMAIN_SERVER_ENABLE_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_SERVER_ROLE {
   DomainServerRoleBackup = 2,
   DomainServerRolePrimary = 3,
}
pub use self::_DOMAIN_SERVER_ROLE as DOMAIN_SERVER_ROLE;
pub type PDOMAIN_SERVER_ROLE = *mut _DOMAIN_SERVER_ROLE;
#[repr(C, packed(4))]
pub struct _DOMAIN_GENERAL_INFORMATION {
   pub ForceLogoff: LARGE_INTEGER,
   pub OemInformation: UNICODE_STRING,
   pub DomainName: UNICODE_STRING,
   pub ReplicaSourceNodeName: UNICODE_STRING,
   pub DomainModifiedCount: LARGE_INTEGER,
   pub DomainServerState: DOMAIN_SERVER_ENABLE_STATE,
   pub DomainServerRole: DOMAIN_SERVER_ROLE,
   pub UasCompatibilityRequired: BOOLEAN,
   pub UserCount: ULONG,
   pub GroupCount: ULONG,
   pub AliasCount: ULONG,
}
impl Default for _DOMAIN_GENERAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_GENERAL_INFORMATION = _DOMAIN_GENERAL_INFORMATION;
pub type PDOMAIN_GENERAL_INFORMATION = *mut _DOMAIN_GENERAL_INFORMATION;
#[repr(C, packed(4))]
pub struct _DOMAIN_GENERAL_INFORMATION2 {
   pub I1: DOMAIN_GENERAL_INFORMATION,
   pub LockoutDuration: LARGE_INTEGER,
   pub LockoutObservationWindow: LARGE_INTEGER,
   pub LockoutThreshold: USHORT,
}
impl Default for _DOMAIN_GENERAL_INFORMATION2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_GENERAL_INFORMATION2 = _DOMAIN_GENERAL_INFORMATION2;
pub type PDOMAIN_GENERAL_INFORMATION2 = *mut _DOMAIN_GENERAL_INFORMATION2;
#[repr(C)]
pub struct _DOMAIN_UAS_INFORMATION {
   pub UasCompatibilityRequired: BOOLEAN,
}
impl Default for _DOMAIN_UAS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_UAS_INFORMATION = _DOMAIN_UAS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_PASSWORD_INFORMATION {
   pub MinPasswordLength: USHORT,
   pub PasswordHistoryLength: USHORT,
   pub PasswordProperties: ULONG,
   pub MaxPasswordAge: LARGE_INTEGER,
   pub MinPasswordAge: LARGE_INTEGER,
}
impl Default for _DOMAIN_PASSWORD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_PASSWORD_INFORMATION = _DOMAIN_PASSWORD_INFORMATION;
pub type PDOMAIN_PASSWORD_INFORMATION = *mut _DOMAIN_PASSWORD_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_PASSWORD_CONSTRUCTION {
   DomainPasswordSimple = 1,
   DomainPasswordComplex = 2,
}
pub use self::_DOMAIN_PASSWORD_CONSTRUCTION as DOMAIN_PASSWORD_CONSTRUCTION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_LOGOFF_INFORMATION {
   pub ForceLogoff: LARGE_INTEGER,
}
impl Default for _DOMAIN_LOGOFF_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOGOFF_INFORMATION = _DOMAIN_LOGOFF_INFORMATION;
pub type PDOMAIN_LOGOFF_INFORMATION = *mut _DOMAIN_LOGOFF_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_OEM_INFORMATION {
   pub OemInformation: UNICODE_STRING,
}
impl Default for _DOMAIN_OEM_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_OEM_INFORMATION = _DOMAIN_OEM_INFORMATION;
pub type PDOMAIN_OEM_INFORMATION = *mut _DOMAIN_OEM_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_NAME_INFORMATION {
   pub DomainName: UNICODE_STRING,
}
impl Default for _DOMAIN_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_NAME_INFORMATION = _DOMAIN_NAME_INFORMATION;
pub type PDOMAIN_NAME_INFORMATION = *mut _DOMAIN_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_SERVER_ROLE_INFORMATION {
   pub DomainServerRole: DOMAIN_SERVER_ROLE,
}
impl Default for _DOMAIN_SERVER_ROLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_SERVER_ROLE_INFORMATION = _DOMAIN_SERVER_ROLE_INFORMATION;
pub type PDOMAIN_SERVER_ROLE_INFORMATION = *mut _DOMAIN_SERVER_ROLE_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_REPLICATION_INFORMATION {
   pub ReplicaSourceNodeName: UNICODE_STRING,
}
impl Default for _DOMAIN_REPLICATION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_REPLICATION_INFORMATION = _DOMAIN_REPLICATION_INFORMATION;
pub type PDOMAIN_REPLICATION_INFORMATION = *mut _DOMAIN_REPLICATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_MODIFIED_INFORMATION {
   pub DomainModifiedCount: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
}
impl Default for _DOMAIN_MODIFIED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_MODIFIED_INFORMATION = _DOMAIN_MODIFIED_INFORMATION;
pub type PDOMAIN_MODIFIED_INFORMATION = *mut _DOMAIN_MODIFIED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_MODIFIED_INFORMATION2 {
   pub DomainModifiedCount: LARGE_INTEGER,
   pub CreationTime: LARGE_INTEGER,
   pub ModifiedCountAtLastPromotion: LARGE_INTEGER,
}
impl Default for _DOMAIN_MODIFIED_INFORMATION2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_MODIFIED_INFORMATION2 = _DOMAIN_MODIFIED_INFORMATION2;
pub type PDOMAIN_MODIFIED_INFORMATION2 = *mut _DOMAIN_MODIFIED_INFORMATION2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_STATE_INFORMATION {
   pub DomainServerState: DOMAIN_SERVER_ENABLE_STATE,
}
impl Default for _DOMAIN_STATE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_STATE_INFORMATION = _DOMAIN_STATE_INFORMATION;
pub type PDOMAIN_STATE_INFORMATION = *mut _DOMAIN_STATE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DOMAIN_LOCKOUT_INFORMATION {
   pub LockoutDuration: LARGE_INTEGER,
   pub LockoutObservationWindow: LARGE_INTEGER,
   pub LockoutThreshold: USHORT,
}
impl Default for _DOMAIN_LOCKOUT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOCKOUT_INFORMATION = _DOMAIN_LOCKOUT_INFORMATION;
pub type PDOMAIN_LOCKOUT_INFORMATION = *mut _DOMAIN_LOCKOUT_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_DISPLAY_INFORMATION {
   DomainDisplayUser = 1,
   DomainDisplayMachine = 2,
   DomainDisplayGroup = 3,
   DomainDisplayOemUser = 4,
   DomainDisplayOemGroup = 5,
   DomainDisplayServer = 6,
}
pub use self::_DOMAIN_DISPLAY_INFORMATION as DOMAIN_DISPLAY_INFORMATION;
pub type PDOMAIN_DISPLAY_INFORMATION = *mut _DOMAIN_DISPLAY_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_DISPLAY_USER {
   pub Index: ULONG,
   pub Rid: ULONG,
   pub AccountControl: ULONG,
   pub LogonName: UNICODE_STRING,
   pub AdminComment: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
}
impl Default for _DOMAIN_DISPLAY_USER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_USER = _DOMAIN_DISPLAY_USER;
pub type PDOMAIN_DISPLAY_USER = *mut _DOMAIN_DISPLAY_USER;
#[repr(C)]
pub struct _DOMAIN_DISPLAY_MACHINE {
   pub Index: ULONG,
   pub Rid: ULONG,
   pub AccountControl: ULONG,
   pub Machine: UNICODE_STRING,
   pub Comment: UNICODE_STRING,
}
impl Default for _DOMAIN_DISPLAY_MACHINE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_MACHINE = _DOMAIN_DISPLAY_MACHINE;
pub type PDOMAIN_DISPLAY_MACHINE = *mut _DOMAIN_DISPLAY_MACHINE;
#[repr(C)]
pub struct _DOMAIN_DISPLAY_GROUP {
   pub Index: ULONG,
   pub Rid: ULONG,
   pub Attributes: ULONG,
   pub Group: UNICODE_STRING,
   pub Comment: UNICODE_STRING,
}
impl Default for _DOMAIN_DISPLAY_GROUP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_GROUP = _DOMAIN_DISPLAY_GROUP;
pub type PDOMAIN_DISPLAY_GROUP = *mut _DOMAIN_DISPLAY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_DISPLAY_OEM_USER {
   pub Index: ULONG,
   pub User: OEM_STRING,
}
impl Default for _DOMAIN_DISPLAY_OEM_USER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_OEM_USER = _DOMAIN_DISPLAY_OEM_USER;
pub type PDOMAIN_DISPLAY_OEM_USER = *mut _DOMAIN_DISPLAY_OEM_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_DISPLAY_OEM_GROUP {
   pub Index: ULONG,
   pub Group: OEM_STRING,
}
impl Default for _DOMAIN_DISPLAY_OEM_GROUP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_DISPLAY_OEM_GROUP = _DOMAIN_DISPLAY_OEM_GROUP;
pub type PDOMAIN_DISPLAY_OEM_GROUP = *mut _DOMAIN_DISPLAY_OEM_GROUP;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION {
   DomainLocalizableAccountsBasic = 1,
}
pub use self::_DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION as DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION;
pub type PDOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION = *mut _DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION;
#[repr(C)]
pub struct _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY {
   pub Rid: ULONG,
   pub Use: SID_NAME_USE,
   pub Name: UNICODE_STRING,
   pub AdminComment: UNICODE_STRING,
}
impl Default for _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY = _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY;
pub type PDOMAIN_LOCALIZABLE_ACCOUNT_ENTRY = *mut _DOMAIN_LOCALIZABLE_ACCOUNTS_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOMAIN_LOCALIZABLE_ACCOUNTS {
   pub Count: ULONG,
   pub Entries: *mut DOMAIN_LOCALIZABLE_ACCOUNT_ENTRY,
}
impl Default for _DOMAIN_LOCALIZABLE_ACCOUNTS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC = _DOMAIN_LOCALIZABLE_ACCOUNTS;
pub type PDOMAIN_LOCALIZABLE_ACCOUNTS_BASIC = *mut _DOMAIN_LOCALIZABLE_ACCOUNTS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DOMAIN_LOCALIZABLE_INFO_BUFFER {
   pub Basic: DOMAIN_LOCALIZABLE_ACCOUNTS_BASIC,
}
impl Default for _DOMAIN_LOCALIZABLE_INFO_BUFFER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type DOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER = _DOMAIN_LOCALIZABLE_INFO_BUFFER;
pub type PDOMAIN_LOCALIZABLE_ACCOUNTS_INFO_BUFFER = *mut _DOMAIN_LOCALIZABLE_INFO_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GROUP_MEMBERSHIP {
   pub RelativeId: ULONG,
   pub Attributes: ULONG,
}
pub type GROUP_MEMBERSHIP = _GROUP_MEMBERSHIP;
pub type PGROUP_MEMBERSHIP = *mut _GROUP_MEMBERSHIP;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _GROUP_INFORMATION_CLASS {
   GroupGeneralInformation = 1,
   GroupNameInformation = 2,
   GroupAttributeInformation = 3,
   GroupAdminCommentInformation = 4,
   GroupReplicationInformation = 5,
}
pub use self::_GROUP_INFORMATION_CLASS as GROUP_INFORMATION_CLASS;
#[repr(C)]
pub struct _GROUP_GENERAL_INFORMATION {
   pub Name: UNICODE_STRING,
   pub Attributes: ULONG,
   pub MemberCount: ULONG,
   pub AdminComment: UNICODE_STRING,
}
impl Default for _GROUP_GENERAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GROUP_GENERAL_INFORMATION = _GROUP_GENERAL_INFORMATION;
pub type PGROUP_GENERAL_INFORMATION = *mut _GROUP_GENERAL_INFORMATION;
#[repr(C)]
pub struct _GROUP_NAME_INFORMATION {
   pub Name: UNICODE_STRING,
}
impl Default for _GROUP_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GROUP_NAME_INFORMATION = _GROUP_NAME_INFORMATION;
pub type PGROUP_NAME_INFORMATION = *mut _GROUP_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GROUP_ATTRIBUTE_INFORMATION {
   pub Attributes: ULONG,
}
pub type GROUP_ATTRIBUTE_INFORMATION = _GROUP_ATTRIBUTE_INFORMATION;
pub type PGROUP_ATTRIBUTE_INFORMATION = *mut _GROUP_ATTRIBUTE_INFORMATION;
#[repr(C)]
pub struct _GROUP_ADM_COMMENT_INFORMATION {
   pub AdminComment: UNICODE_STRING,
}
impl Default for _GROUP_ADM_COMMENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type GROUP_ADM_COMMENT_INFORMATION = _GROUP_ADM_COMMENT_INFORMATION;
pub type PGROUP_ADM_COMMENT_INFORMATION = *mut _GROUP_ADM_COMMENT_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ALIAS_INFORMATION_CLASS {
   AliasGeneralInformation = 1,
   AliasNameInformation = 2,
   AliasAdminCommentInformation = 3,
   AliasReplicationInformation = 4,
   AliasExtendedInformation = 5,
}
pub use self::_ALIAS_INFORMATION_CLASS as ALIAS_INFORMATION_CLASS;
#[repr(C)]
pub struct _ALIAS_GENERAL_INFORMATION {
   pub Name: UNICODE_STRING,
   pub MemberCount: ULONG,
   pub AdminComment: UNICODE_STRING,
}
impl Default for _ALIAS_GENERAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALIAS_GENERAL_INFORMATION = _ALIAS_GENERAL_INFORMATION;
pub type PALIAS_GENERAL_INFORMATION = *mut _ALIAS_GENERAL_INFORMATION;
#[repr(C)]
pub struct _ALIAS_NAME_INFORMATION {
   pub Name: UNICODE_STRING,
}
impl Default for _ALIAS_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALIAS_NAME_INFORMATION = _ALIAS_NAME_INFORMATION;
pub type PALIAS_NAME_INFORMATION = *mut _ALIAS_NAME_INFORMATION;
#[repr(C)]
pub struct _ALIAS_ADM_COMMENT_INFORMATION {
   pub AdminComment: UNICODE_STRING,
}
impl Default for _ALIAS_ADM_COMMENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALIAS_ADM_COMMENT_INFORMATION = _ALIAS_ADM_COMMENT_INFORMATION;
pub type PALIAS_ADM_COMMENT_INFORMATION = *mut _ALIAS_ADM_COMMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ALIAS_EXTENDED_INFORMATION {
   pub WhichFields: ULONG,
   pub ShellAdminObjectProperties: SAM_SHELL_OBJECT_PROPERTIES,
}
impl Default for _ALIAS_EXTENDED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ALIAS_EXTENDED_INFORMATION = _ALIAS_EXTENDED_INFORMATION;
pub type PALIAS_EXTENDED_INFORMATION = *mut _ALIAS_EXTENDED_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOGON_HOURS {
   pub UnitsPerWeek: USHORT,
   pub LogonHours: PUCHAR,
}
impl Default for _LOGON_HOURS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type LOGON_HOURS = _LOGON_HOURS;
pub type PLOGON_HOURS = *mut _LOGON_HOURS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SR_SECURITY_DESCRIPTOR {
   pub Length: ULONG,
   pub SecurityDescriptor: PUCHAR,
}
impl Default for _SR_SECURITY_DESCRIPTOR {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SR_SECURITY_DESCRIPTOR = _SR_SECURITY_DESCRIPTOR;
pub type PSR_SECURITY_DESCRIPTOR = *mut _SR_SECURITY_DESCRIPTOR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _USER_INFORMATION_CLASS {
   UserGeneralInformation = 1,
   UserPreferencesInformation = 2,
   UserLogonInformation = 3,
   UserLogonHoursInformation = 4,
   UserAccountInformation = 5,
   UserNameInformation = 6,
   UserAccountNameInformation = 7,
   UserFullNameInformation = 8,
   UserPrimaryGroupInformation = 9,
   UserHomeInformation = 10,
   UserScriptInformation = 11,
   UserProfileInformation = 12,
   UserAdminCommentInformation = 13,
   UserWorkStationsInformation = 14,
   UserSetPasswordInformation = 15,
   UserControlInformation = 16,
   UserExpiresInformation = 17,
   UserInternal1Information = 18,
   UserInternal2Information = 19,
   UserParametersInformation = 20,
   UserAllInformation = 21,
   UserInternal3Information = 22,
   UserInternal4Information = 23,
   UserInternal5Information = 24,
   UserInternal4InformationNew = 25,
   UserInternal5InformationNew = 26,
   UserInternal6Information = 27,
   UserExtendedInformation = 28,
   UserLogonUIInformation = 29,
   UserUnknownTodoInformation = 30,
   UserInternal7Information = 31,
   UserInternal8Information = 32,
}
pub use self::_USER_INFORMATION_CLASS as USER_INFORMATION_CLASS;
pub type PUSER_INFORMATION_CLASS = *mut _USER_INFORMATION_CLASS;
#[repr(C)]
pub struct _USER_GENERAL_INFORMATION {
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
   pub PrimaryGroupId: ULONG,
   pub AdminComment: UNICODE_STRING,
   pub UserComment: UNICODE_STRING,
}
impl Default for _USER_GENERAL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_GENERAL_INFORMATION = _USER_GENERAL_INFORMATION;
pub type PUSER_GENERAL_INFORMATION = *mut _USER_GENERAL_INFORMATION;
#[repr(C)]
pub struct _USER_PREFERENCES_INFORMATION {
   pub UserComment: UNICODE_STRING,
   pub Reserved1: UNICODE_STRING,
   pub CountryCode: USHORT,
   pub CodePage: USHORT,
}
impl Default for _USER_PREFERENCES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_PREFERENCES_INFORMATION = _USER_PREFERENCES_INFORMATION;
pub type PUSER_PREFERENCES_INFORMATION = *mut _USER_PREFERENCES_INFORMATION;
#[repr(C, packed(4))]
pub struct _USER_LOGON_INFORMATION {
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
   pub UserId: ULONG,
   pub PrimaryGroupId: ULONG,
   pub HomeDirectory: UNICODE_STRING,
   pub HomeDirectoryDrive: UNICODE_STRING,
   pub ScriptPath: UNICODE_STRING,
   pub ProfilePath: UNICODE_STRING,
   pub WorkStations: UNICODE_STRING,
   pub LastLogon: LARGE_INTEGER,
   pub LastLogoff: LARGE_INTEGER,
   pub PasswordLastSet: LARGE_INTEGER,
   pub PasswordCanChange: LARGE_INTEGER,
   pub PasswordMustChange: LARGE_INTEGER,
   pub LogonHours: LOGON_HOURS,
   pub BadPasswordCount: USHORT,
   pub LogonCount: USHORT,
   pub UserAccountControl: ULONG,
}
impl Default for _USER_LOGON_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_LOGON_INFORMATION = _USER_LOGON_INFORMATION;
pub type PUSER_LOGON_INFORMATION = *mut _USER_LOGON_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USER_LOGON_HOURS_INFORMATION {
   pub LogonHours: LOGON_HOURS,
}
impl Default for _USER_LOGON_HOURS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_LOGON_HOURS_INFORMATION = _USER_LOGON_HOURS_INFORMATION;
pub type PUSER_LOGON_HOURS_INFORMATION = *mut _USER_LOGON_HOURS_INFORMATION;
#[repr(C, packed(4))]
pub struct _USER_ACCOUNT_INFORMATION {
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
   pub UserId: ULONG,
   pub PrimaryGroupId: ULONG,
   pub HomeDirectory: UNICODE_STRING,
   pub HomeDirectoryDrive: UNICODE_STRING,
   pub ScriptPath: UNICODE_STRING,
   pub ProfilePath: UNICODE_STRING,
   pub AdminComment: UNICODE_STRING,
   pub WorkStations: UNICODE_STRING,
   pub LastLogon: LARGE_INTEGER,
   pub LastLogoff: LARGE_INTEGER,
   pub LogonHours: LOGON_HOURS,
   pub BadPasswordCount: USHORT,
   pub LogonCount: USHORT,
   pub PasswordLastSet: LARGE_INTEGER,
   pub AccountExpires: LARGE_INTEGER,
   pub UserAccountControl: ULONG,
}
impl Default for _USER_ACCOUNT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ACCOUNT_INFORMATION = _USER_ACCOUNT_INFORMATION;
pub type PUSER_ACCOUNT_INFORMATION = *mut _USER_ACCOUNT_INFORMATION;
#[repr(C)]
pub struct _USER_NAME_INFORMATION {
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
}
impl Default for _USER_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_NAME_INFORMATION = _USER_NAME_INFORMATION;
pub type PUSER_NAME_INFORMATION = *mut _USER_NAME_INFORMATION;
#[repr(C)]
pub struct _USER_ACCOUNT_NAME_INFORMATION {
   pub UserName: UNICODE_STRING,
}
impl Default for _USER_ACCOUNT_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ACCOUNT_NAME_INFORMATION = _USER_ACCOUNT_NAME_INFORMATION;
pub type PUSER_ACCOUNT_NAME_INFORMATION = *mut _USER_ACCOUNT_NAME_INFORMATION;
#[repr(C)]
pub struct _USER_FULL_NAME_INFORMATION {
   pub FullName: UNICODE_STRING,
}
impl Default for _USER_FULL_NAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_FULL_NAME_INFORMATION = _USER_FULL_NAME_INFORMATION;
pub type PUSER_FULL_NAME_INFORMATION = *mut _USER_FULL_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _USER_PRIMARY_GROUP_INFORMATION {
   pub PrimaryGroupId: ULONG,
}
pub type USER_PRIMARY_GROUP_INFORMATION = _USER_PRIMARY_GROUP_INFORMATION;
pub type PUSER_PRIMARY_GROUP_INFORMATION = *mut _USER_PRIMARY_GROUP_INFORMATION;
#[repr(C)]
pub struct _USER_HOME_INFORMATION {
   pub HomeDirectory: UNICODE_STRING,
   pub HomeDirectoryDrive: UNICODE_STRING,
}
impl Default for _USER_HOME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_HOME_INFORMATION = _USER_HOME_INFORMATION;
pub type PUSER_HOME_INFORMATION = *mut _USER_HOME_INFORMATION;
#[repr(C)]
pub struct _USER_SCRIPT_INFORMATION {
   pub ScriptPath: UNICODE_STRING,
}
impl Default for _USER_SCRIPT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_SCRIPT_INFORMATION = _USER_SCRIPT_INFORMATION;
pub type PUSER_SCRIPT_INFORMATION = *mut _USER_SCRIPT_INFORMATION;
#[repr(C)]
pub struct _USER_PROFILE_INFORMATION {
   pub ProfilePath: UNICODE_STRING,
}
impl Default for _USER_PROFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_PROFILE_INFORMATION = _USER_PROFILE_INFORMATION;
pub type PUSER_PROFILE_INFORMATION = *mut _USER_PROFILE_INFORMATION;
#[repr(C)]
pub struct _USER_ADMIN_COMMENT_INFORMATION {
   pub AdminComment: UNICODE_STRING,
}
impl Default for _USER_ADMIN_COMMENT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ADMIN_COMMENT_INFORMATION = _USER_ADMIN_COMMENT_INFORMATION;
pub type PUSER_ADMIN_COMMENT_INFORMATION = *mut _USER_ADMIN_COMMENT_INFORMATION;
#[repr(C)]
pub struct _USER_WORKSTATIONS_INFORMATION {
   pub WorkStations: UNICODE_STRING,
}
impl Default for _USER_WORKSTATIONS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_WORKSTATIONS_INFORMATION = _USER_WORKSTATIONS_INFORMATION;
pub type PUSER_WORKSTATIONS_INFORMATION = *mut _USER_WORKSTATIONS_INFORMATION;
#[repr(C)]
pub struct _USER_SET_PASSWORD_INFORMATION {
   pub Password: UNICODE_STRING,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_SET_PASSWORD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_SET_PASSWORD_INFORMATION = _USER_SET_PASSWORD_INFORMATION;
pub type PUSER_SET_PASSWORD_INFORMATION = *mut _USER_SET_PASSWORD_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _USER_CONTROL_INFORMATION {
   pub UserAccountControl: ULONG,
}
pub type USER_CONTROL_INFORMATION = _USER_CONTROL_INFORMATION;
pub type PUSER_CONTROL_INFORMATION = *mut _USER_CONTROL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _USER_EXPIRES_INFORMATION {
   pub AccountExpires: LARGE_INTEGER,
}
impl Default for _USER_EXPIRES_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_EXPIRES_INFORMATION = _USER_EXPIRES_INFORMATION;
pub type PUSER_EXPIRES_INFORMATION = *mut _USER_EXPIRES_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CYPHER_BLOCK {
   pub data: [CHAR; 8usize],
}
pub type CYPHER_BLOCK = _CYPHER_BLOCK;
pub type PCYPHER_BLOCK = *mut _CYPHER_BLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ENCRYPTED_NT_OWF_PASSWORD {
   pub data: [CYPHER_BLOCK; 2usize],
}
pub type ENCRYPTED_NT_OWF_PASSWORD = _ENCRYPTED_NT_OWF_PASSWORD;
pub type PENCRYPTED_NT_OWF_PASSWORD = *mut _ENCRYPTED_NT_OWF_PASSWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ENCRYPTED_LM_OWF_PASSWORD {
   pub data: [CYPHER_BLOCK; 2usize],
}
pub type ENCRYPTED_LM_OWF_PASSWORD = _ENCRYPTED_LM_OWF_PASSWORD;
pub type PENCRYPTED_LM_OWF_PASSWORD = *mut _ENCRYPTED_LM_OWF_PASSWORD;
#[repr(C)]
pub struct _USER_INTERNAL1_INFORMATION {
   pub EncryptedNtOwfPassword: ENCRYPTED_NT_OWF_PASSWORD,
   pub EncryptedLmOwfPassword: ENCRYPTED_LM_OWF_PASSWORD,
   pub NtPasswordPresent: BOOLEAN,
   pub LmPasswordPresent: BOOLEAN,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_INTERNAL1_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL1_INFORMATION = _USER_INTERNAL1_INFORMATION;
pub type PUSER_INTERNAL1_INFORMATION = *mut _USER_INTERNAL1_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _USER_INTERNAL2_INFORMATION {
   pub StatisticsToApply: ULONG,
   pub LastLogon: LARGE_INTEGER,
   pub LastLogoff: LARGE_INTEGER,
   pub BadPasswordCount: USHORT,
   pub LogonCount: USHORT,
}
impl Default for _USER_INTERNAL2_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL2_INFORMATION = _USER_INTERNAL2_INFORMATION;
pub type PUSER_INTERNAL2_INFORMATION = *mut _USER_INTERNAL2_INFORMATION;
#[repr(C)]
pub struct _USER_PARAMETERS_INFORMATION {
   pub Parameters: UNICODE_STRING,
}
impl Default for _USER_PARAMETERS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_PARAMETERS_INFORMATION = _USER_PARAMETERS_INFORMATION;
pub type PUSER_PARAMETERS_INFORMATION = *mut _USER_PARAMETERS_INFORMATION;
#[repr(C, packed(4))]
pub struct _USER_ALL_INFORMATION {
   pub LastLogon: LARGE_INTEGER,
   pub LastLogoff: LARGE_INTEGER,
   pub PasswordLastSet: LARGE_INTEGER,
   pub AccountExpires: LARGE_INTEGER,
   pub PasswordCanChange: LARGE_INTEGER,
   pub PasswordMustChange: LARGE_INTEGER,
   pub UserName: UNICODE_STRING,
   pub FullName: UNICODE_STRING,
   pub HomeDirectory: UNICODE_STRING,
   pub HomeDirectoryDrive: UNICODE_STRING,
   pub ScriptPath: UNICODE_STRING,
   pub ProfilePath: UNICODE_STRING,
   pub AdminComment: UNICODE_STRING,
   pub WorkStations: UNICODE_STRING,
   pub UserComment: UNICODE_STRING,
   pub Parameters: UNICODE_STRING,
   pub LmPassword: UNICODE_STRING,
   pub NtPassword: UNICODE_STRING,
   pub PrivateData: UNICODE_STRING,
   pub SecurityDescriptor: SR_SECURITY_DESCRIPTOR,
   pub UserId: ULONG,
   pub PrimaryGroupId: ULONG,
   pub UserAccountControl: ULONG,
   pub WhichFields: ULONG,
   pub LogonHours: LOGON_HOURS,
   pub BadPasswordCount: USHORT,
   pub LogonCount: USHORT,
   pub CountryCode: USHORT,
   pub CodePage: USHORT,
   pub LmPasswordPresent: BOOLEAN,
   pub NtPasswordPresent: BOOLEAN,
   pub PasswordExpired: BOOLEAN,
   pub PrivateDataSensitive: BOOLEAN,
}
impl Default for _USER_ALL_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ALL_INFORMATION = _USER_ALL_INFORMATION;
pub type PUSER_ALL_INFORMATION = *mut _USER_ALL_INFORMATION;
#[repr(C, packed(4))]
pub struct _USER_INTERNAL3_INFORMATION {
   pub I1: USER_ALL_INFORMATION,
   pub LastBadPasswordTime: LARGE_INTEGER,
}
impl Default for _USER_INTERNAL3_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL3_INFORMATION = _USER_INTERNAL3_INFORMATION;
pub type PUSER_INTERNAL3_INFORMATION = *mut _USER_INTERNAL3_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_USER_PASSWORD {
   pub Buffer: [UCHAR; 516usize],
}
impl Default for _ENCRYPTED_USER_PASSWORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ENCRYPTED_USER_PASSWORD = _ENCRYPTED_USER_PASSWORD;
pub type PENCRYPTED_USER_PASSWORD = *mut _ENCRYPTED_USER_PASSWORD;
#[repr(C)]
pub struct _USER_INTERNAL4_INFORMATION {
   pub I1: USER_ALL_INFORMATION,
   pub UserPassword: ENCRYPTED_USER_PASSWORD,
}
impl Default for _USER_INTERNAL4_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL4_INFORMATION = _USER_INTERNAL4_INFORMATION;
pub type PUSER_INTERNAL4_INFORMATION = *mut _USER_INTERNAL4_INFORMATION;
#[repr(C)]
pub struct _USER_INTERNAL5_INFORMATION {
   pub UserPassword: ENCRYPTED_USER_PASSWORD,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_INTERNAL5_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL5_INFORMATION = _USER_INTERNAL5_INFORMATION;
pub type PUSER_INTERNAL5_INFORMATION = *mut _USER_INTERNAL5_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_USER_PASSWORD_NEW {
   pub Buffer: [UCHAR; 532usize],
}
impl Default for _ENCRYPTED_USER_PASSWORD_NEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ENCRYPTED_USER_PASSWORD_NEW = _ENCRYPTED_USER_PASSWORD_NEW;
pub type PENCRYPTED_USER_PASSWORD_NEW = *mut _ENCRYPTED_USER_PASSWORD_NEW;
#[repr(C)]
pub struct _USER_INTERNAL4_INFORMATION_NEW {
   pub I1: USER_ALL_INFORMATION,
   pub UserPassword: ENCRYPTED_USER_PASSWORD_NEW,
}
impl Default for _USER_INTERNAL4_INFORMATION_NEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL4_INFORMATION_NEW = _USER_INTERNAL4_INFORMATION_NEW;
pub type PUSER_INTERNAL4_INFORMATION_NEW = *mut _USER_INTERNAL4_INFORMATION_NEW;
#[repr(C)]
pub struct _USER_INTERNAL5_INFORMATION_NEW {
   pub UserPassword: ENCRYPTED_USER_PASSWORD_NEW,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_INTERNAL5_INFORMATION_NEW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL5_INFORMATION_NEW = _USER_INTERNAL5_INFORMATION_NEW;
pub type PUSER_INTERNAL5_INFORMATION_NEW = *mut _USER_INTERNAL5_INFORMATION_NEW;
#[repr(C)]
pub struct _USER_ALLOWED_TO_DELEGATE_TO_LIST {
   pub Size: ULONG,
   pub NumSPNs: ULONG,
   pub SPNList: [UNICODE_STRING; 1usize],
}
impl Default for _USER_ALLOWED_TO_DELEGATE_TO_LIST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_ALLOWED_TO_DELEGATE_TO_LIST = _USER_ALLOWED_TO_DELEGATE_TO_LIST;
pub type PUSER_ALLOWED_TO_DELEGATE_TO_LIST = *mut _USER_ALLOWED_TO_DELEGATE_TO_LIST;
#[repr(C)]
pub struct _USER_INTERNAL6_INFORMATION {
   pub I1: USER_ALL_INFORMATION,
   pub LastBadPasswordTime: LARGE_INTEGER,
   pub ExtendedFields: ULONG,
   pub UPNDefaulted: BOOLEAN,
   pub UPN: UNICODE_STRING,
   pub A2D2List: PUSER_ALLOWED_TO_DELEGATE_TO_LIST,
}
impl Default for _USER_INTERNAL6_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL6_INFORMATION = _USER_INTERNAL6_INFORMATION;
pub type PUSER_INTERNAL6_INFORMATION = *mut _USER_INTERNAL6_INFORMATION;
pub type SAM_USER_TILE = SAM_BYTE_ARRAY_32K;
pub type PSAM_USER_TILE = *mut SAM_BYTE_ARRAY_32K;
#[repr(C)]
pub struct _USER_EXTENDED_INFORMATION {
   pub ExtendedWhichFields: ULONG,
   pub UserTile: SAM_USER_TILE,
   pub PasswordHint: UNICODE_STRING,
   pub DontShowInLogonUI: BOOLEAN,
   pub ShellAdminObjectProperties: SAM_SHELL_OBJECT_PROPERTIES,
}
impl Default for _USER_EXTENDED_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_EXTENDED_INFORMATION = _USER_EXTENDED_INFORMATION;
pub type PUSER_EXTENDED_INFORMATION = *mut _USER_EXTENDED_INFORMATION;
#[repr(C)]
pub struct _USER_LOGON_UI_INFORMATION {
   pub PasswordIsBlank: BOOLEAN,
   pub AccountIsDisabled: BOOLEAN,
}
impl Default for _USER_LOGON_UI_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_LOGON_UI_INFORMATION = _USER_LOGON_UI_INFORMATION;
pub type PUSER_LOGON_UI_INFORMATION = *mut _USER_LOGON_UI_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_PASSWORD_AES {
   pub AuthData: [UCHAR; 64usize],
   pub Salt: [UCHAR; 16usize],
   pub cbCipher: ULONG,
   pub Cipher: PUCHAR,
   pub PBKDF2Iterations: ULONGLONG,
}
impl Default for _ENCRYPTED_PASSWORD_AES {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ENCRYPTED_PASSWORD_AES = _ENCRYPTED_PASSWORD_AES;
pub type PENCRYPTED_PASSWORD_AES = *mut _ENCRYPTED_PASSWORD_AES;
#[repr(C)]
pub struct _USER_INTERNAL7_INFORMATION {
   pub UserPassword: ENCRYPTED_PASSWORD_AES,
   pub PasswordExpired: BOOLEAN,
}
impl Default for _USER_INTERNAL7_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL7_INFORMATION = _USER_INTERNAL7_INFORMATION;
pub type PUSER_INTERNAL7_INFORMATION = *mut _USER_INTERNAL7_INFORMATION;
#[repr(C)]
pub struct _USER_INTERNAL8_INFORMATION {
   pub I1: USER_ALL_INFORMATION,
   pub UserPassword: ENCRYPTED_PASSWORD_AES,
}
impl Default for _USER_INTERNAL8_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_INTERNAL8_INFORMATION = _USER_INTERNAL8_INFORMATION;
pub type PUSER_INTERNAL8_INFORMATION = *mut _USER_INTERNAL8_INFORMATION;
#[repr(C)]
pub struct _USER_PWD_CHANGE_FAILURE_INFORMATION {
   pub ExtendedFailureReason: ULONG,
   pub FilterModuleName: UNICODE_STRING,
}
impl Default for _USER_PWD_CHANGE_FAILURE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type USER_PWD_CHANGE_FAILURE_INFORMATION = _USER_PWD_CHANGE_FAILURE_INFORMATION;
pub type PUSER_PWD_CHANGE_FAILURE_INFORMATION = *mut _USER_PWD_CHANGE_FAILURE_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_DB_DELTA_TYPE {
   SecurityDbNew = 1,
   SecurityDbRename = 2,
   SecurityDbDelete = 3,
   SecurityDbChangeMemberAdd = 4,
   SecurityDbChangeMemberSet = 5,
   SecurityDbChangeMemberDel = 6,
   SecurityDbChange = 7,
   SecurityDbChangePassword = 8,
}
pub use self::_SECURITY_DB_DELTA_TYPE as SECURITY_DB_DELTA_TYPE;
pub type PSECURITY_DB_DELTA_TYPE = *mut _SECURITY_DB_DELTA_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_DB_OBJECT_TYPE {
   SecurityDbObjectSamDomain = 1,
   SecurityDbObjectSamUser = 2,
   SecurityDbObjectSamGroup = 3,
   SecurityDbObjectSamAlias = 4,
   SecurityDbObjectLsaPolicy = 5,
   SecurityDbObjectLsaTDomain = 6,
   SecurityDbObjectLsaAccount = 7,
   SecurityDbObjectLsaSecret = 8,
}
pub use self::_SECURITY_DB_OBJECT_TYPE as SECURITY_DB_OBJECT_TYPE;
pub type PSECURITY_DB_OBJECT_TYPE = *mut _SECURITY_DB_OBJECT_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SAM_ACCOUNT_TYPE {
   SamObjectUser = 1,
   SamObjectGroup = 2,
   SamObjectAlias = 3,
}
pub use self::_SAM_ACCOUNT_TYPE as SAM_ACCOUNT_TYPE;
pub type PSAM_ACCOUNT_TYPE = *mut _SAM_ACCOUNT_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SAM_GROUP_MEMBER_ID {
   pub MemberRid: ULONG,
}
pub type SAM_GROUP_MEMBER_ID = _SAM_GROUP_MEMBER_ID;
pub type PSAM_GROUP_MEMBER_ID = *mut _SAM_GROUP_MEMBER_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SAM_ALIAS_MEMBER_ID {
   pub MemberSid: PSID,
}
impl Default for _SAM_ALIAS_MEMBER_ID {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_ALIAS_MEMBER_ID = _SAM_ALIAS_MEMBER_ID;
pub type PSAM_ALIAS_MEMBER_ID = *mut _SAM_ALIAS_MEMBER_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SAM_DELTA_DATA {
   pub GroupMemberId: SAM_GROUP_MEMBER_ID,
   pub AliasMemberId: SAM_ALIAS_MEMBER_ID,
   pub AccountControl: ULONG,
}
impl Default for _SAM_DELTA_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_DELTA_DATA = _SAM_DELTA_DATA;
pub type PSAM_DELTA_DATA = *mut _SAM_DELTA_DATA;
pub type PSAM_DELTA_NOTIFICATION_ROUTINE = ::core::option::Option<
   unsafe extern "C" fn(
      DomainSid: PSID,
      DeltaType: SECURITY_DB_DELTA_TYPE,
      ObjectType: SECURITY_DB_OBJECT_TYPE,
      ObjectRid: ULONG,
      ObjectName: PUNICODE_STRING,
      ModifiedCount: PLARGE_INTEGER,
      DeltaData: PSAM_DELTA_DATA,
   ) -> NTSTATUS,
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PASSWORD_POLICY_VALIDATION_TYPE {
   SamValidateAuthentication = 1,
   SamValidatePasswordChange = 2,
   SamValidatePasswordReset = 3,
}
pub use self::_PASSWORD_POLICY_VALIDATION_TYPE as PASSWORD_POLICY_VALIDATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SAM_VALIDATE_PASSWORD_HASH {
   pub Length: ULONG,
   pub Hash: PUCHAR,
}
impl Default for _SAM_VALIDATE_PASSWORD_HASH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_PASSWORD_HASH = _SAM_VALIDATE_PASSWORD_HASH;
pub type PSAM_VALIDATE_PASSWORD_HASH = *mut _SAM_VALIDATE_PASSWORD_HASH;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SAM_VALIDATE_PERSISTED_FIELDS {
   pub PresentFields: ULONG,
   pub PasswordLastSet: LARGE_INTEGER,
   pub BadPasswordTime: LARGE_INTEGER,
   pub LockoutTime: LARGE_INTEGER,
   pub BadPasswordCount: ULONG,
   pub PasswordHistoryLength: ULONG,
   pub PasswordHistory: PSAM_VALIDATE_PASSWORD_HASH,
}
impl Default for _SAM_VALIDATE_PERSISTED_FIELDS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_PERSISTED_FIELDS = _SAM_VALIDATE_PERSISTED_FIELDS;
pub type PSAM_VALIDATE_PERSISTED_FIELDS = *mut _SAM_VALIDATE_PERSISTED_FIELDS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SAM_VALIDATE_VALIDATION_STATUS {
   SamValidateSuccess = 0,
   SamValidatePasswordMustChange = 1,
   SamValidateAccountLockedOut = 2,
   SamValidatePasswordExpired = 3,
   SamValidatePasswordIncorrect = 4,
   SamValidatePasswordIsInHistory = 5,
   SamValidatePasswordTooShort = 6,
   SamValidatePasswordTooLong = 7,
   SamValidatePasswordNotComplexEnough = 8,
   SamValidatePasswordTooRecent = 9,
   SamValidatePasswordFilterError = 10,
}
pub use self::_SAM_VALIDATE_VALIDATION_STATUS as SAM_VALIDATE_VALIDATION_STATUS;
pub type PSAM_VALIDATE_VALIDATION_STATUS = *mut _SAM_VALIDATE_VALIDATION_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SAM_VALIDATE_STANDARD_OUTPUT_ARG {
   pub ChangedPersistedFields: SAM_VALIDATE_PERSISTED_FIELDS,
   pub ValidationStatus: SAM_VALIDATE_VALIDATION_STATUS,
}
impl Default for _SAM_VALIDATE_STANDARD_OUTPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_STANDARD_OUTPUT_ARG = _SAM_VALIDATE_STANDARD_OUTPUT_ARG;
pub type PSAM_VALIDATE_STANDARD_OUTPUT_ARG = *mut _SAM_VALIDATE_STANDARD_OUTPUT_ARG;
#[repr(C)]
pub struct _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG {
   pub InputPersistedFields: SAM_VALIDATE_PERSISTED_FIELDS,
   pub PasswordMatched: BOOLEAN,
}
impl Default for _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_AUTHENTICATION_INPUT_ARG = _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG;
pub type PSAM_VALIDATE_AUTHENTICATION_INPUT_ARG = *mut _SAM_VALIDATE_AUTHENTICATION_INPUT_ARG;
#[repr(C)]
pub struct _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG {
   pub InputPersistedFields: SAM_VALIDATE_PERSISTED_FIELDS,
   pub ClearPassword: UNICODE_STRING,
   pub UserAccountName: UNICODE_STRING,
   pub HashedPassword: SAM_VALIDATE_PASSWORD_HASH,
   pub PasswordMatch: BOOLEAN,
}
impl Default for _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG = _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;
pub type PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG = *mut _SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;
#[repr(C)]
pub struct _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG {
   pub InputPersistedFields: SAM_VALIDATE_PERSISTED_FIELDS,
   pub ClearPassword: UNICODE_STRING,
   pub UserAccountName: UNICODE_STRING,
   pub HashedPassword: SAM_VALIDATE_PASSWORD_HASH,
   pub PasswordMustChangeAtNextLogon: BOOLEAN,
   pub ClearLockout: BOOLEAN,
}
impl Default for _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG = _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG;
pub type PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG = *mut _SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG;
#[repr(C)]
pub union _SAM_VALIDATE_INPUT_ARG {
   pub ValidateAuthenticationInput:
      ::core::mem::ManuallyDrop<SAM_VALIDATE_AUTHENTICATION_INPUT_ARG>,
   pub ValidatePasswordChangeInput:
      ::core::mem::ManuallyDrop<SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG>,
   pub ValidatePasswordResetInput: ::core::mem::ManuallyDrop<SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG>,
}
impl Default for _SAM_VALIDATE_INPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_INPUT_ARG = _SAM_VALIDATE_INPUT_ARG;
pub type PSAM_VALIDATE_INPUT_ARG = *mut _SAM_VALIDATE_INPUT_ARG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SAM_VALIDATE_OUTPUT_ARG {
   pub ValidateAuthenticationOutput: SAM_VALIDATE_STANDARD_OUTPUT_ARG,
   pub ValidatePasswordChangeOutput: SAM_VALIDATE_STANDARD_OUTPUT_ARG,
   pub ValidatePasswordResetOutput: SAM_VALIDATE_STANDARD_OUTPUT_ARG,
}
impl Default for _SAM_VALIDATE_OUTPUT_ARG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_VALIDATE_OUTPUT_ARG = _SAM_VALIDATE_OUTPUT_ARG;
pub type PSAM_VALIDATE_OUTPUT_ARG = *mut _SAM_VALIDATE_OUTPUT_ARG;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SAM_GENERIC_OPERATION_TYPE {
   SamObjectChangeNotificationOperation = 0,
}
pub use self::_SAM_GENERIC_OPERATION_TYPE as SAM_GENERIC_OPERATION_TYPE;
pub type PSAM_GENERIC_OPERATION_TYPE = *mut _SAM_GENERIC_OPERATION_TYPE;
#[repr(C)]
pub struct _SAM_OPERATION_OBJCHG_INPUT {
   pub Register: BOOLEAN,
   pub EventHandle: ULONG64,
   pub ObjectType: SECURITY_DB_OBJECT_TYPE,
   pub ProcessID: ULONG,
}
impl Default for _SAM_OPERATION_OBJCHG_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_OPERATION_OBJCHG_INPUT = _SAM_OPERATION_OBJCHG_INPUT;
pub type PSAM_OPERATION_OBJCHG_INPUT = *mut _SAM_OPERATION_OBJCHG_INPUT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SAM_OPERATION_OBJCHG_OUTPUT {
   pub Reserved: ULONG,
}
pub type SAM_OPERATION_OBJCHG_OUTPUT = _SAM_OPERATION_OBJCHG_OUTPUT;
pub type PSAM_OPERATION_OBJCHG_OUTPUT = *mut _SAM_OPERATION_OBJCHG_OUTPUT;
#[repr(C)]
pub union _SAM_GENERIC_OPERATION_INPUT {
   pub ObjChangeIn: ::core::mem::ManuallyDrop<SAM_OPERATION_OBJCHG_INPUT>,
}
impl Default for _SAM_GENERIC_OPERATION_INPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_GENERIC_OPERATION_INPUT = _SAM_GENERIC_OPERATION_INPUT;
pub type PSAM_GENERIC_OPERATION_INPUT = *mut _SAM_GENERIC_OPERATION_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SAM_GENERIC_OPERATION_OUTPUT {
   pub ObjChangeOut: SAM_OPERATION_OBJCHG_OUTPUT,
}
impl Default for _SAM_GENERIC_OPERATION_OUTPUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SAM_GENERIC_OPERATION_OUTPUT = _SAM_GENERIC_OPERATION_OUTPUT;
pub type PSAM_GENERIC_OPERATION_OUTPUT = *mut _SAM_GENERIC_OPERATION_OUTPUT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _VDMSERVICECLASS {
   VdmStartExecution = 0,
   VdmQueueInterrupt = 1,
   VdmDelayInterrupt = 2,
   VdmInitialize = 3,
   VdmFeatures = 4,
   VdmSetInt21Handler = 5,
   VdmQueryDir = 6,
   VdmPrinterDirectIoOpen = 7,
   VdmPrinterDirectIoClose = 8,
   VdmPrinterInitialize = 9,
   VdmSetLdtEntries = 10,
   VdmSetProcessLdtInfo = 11,
   VdmAdlibEmulation = 12,
   VdmPMCliControl = 13,
   VdmQueryVdmProcess = 14,
   VdmPreInitialize = 15,
}
pub use self::_VDMSERVICECLASS as VDMSERVICECLASS;
pub type PVDMSERVICECLASS = *mut _VDMSERVICECLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURE_SETTING_VALUE_TYPE {
   SecureSettingValueTypeBoolean = 0,
   SecureSettingValueTypeUlong = 1,
   SecureSettingValueTypeBinary = 2,
   SecureSettingValueTypeString = 3,
   SecureSettingValueTypeUnknown = 4,
}
pub use self::_SECURE_SETTING_VALUE_TYPE as SECURE_SETTING_VALUE_TYPE;
pub type PSECURE_SETTING_VALUE_TYPE = *mut _SECURE_SETTING_VALUE_TYPE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_ACTIVITY_TYPE {
   ProcessActivityTypeAudio = 0,
   ProcessActivityTypeMax = 1,
}
pub use self::_PROCESS_ACTIVITY_TYPE as PROCESS_ACTIVITY_TYPE;
pub type PROCESSTRACE_HANDLE = ULONG64;
pub type CONTROLTRACE_ID = ULONG64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_TRACE_PACKET {
   pub Size: USHORT,
   pub __bindgen_anon_1: _WMI_TRACE_PACKET__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_TRACE_PACKET__bindgen_ty_1 {
   pub HookId: USHORT,
   pub __bindgen_anon_1: _WMI_TRACE_PACKET__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_TRACE_PACKET__bindgen_ty_1__bindgen_ty_1 {
   pub Type: UCHAR,
   pub Group: UCHAR,
}
impl Default for _WMI_TRACE_PACKET__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_TRACE_PACKET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_TRACE_PACKET = _WMI_TRACE_PACKET;
pub type PWMI_TRACE_PACKET = *mut _WMI_TRACE_PACKET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EVENT_INSTANCE_GUID_HEADER {
   pub Size: USHORT,
   pub __bindgen_anon_1: _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_1,
   pub __bindgen_anon_2: _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_2,
   pub ThreadId: ULONG,
   pub ProcessId: ULONG,
   pub TimeStamp: LARGE_INTEGER,
   pub __bindgen_anon_3: _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_3,
   pub __bindgen_anon_4: _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_4,
   pub InstanceId: ULONG,
   pub ParentInstanceId: ULONG,
   pub ParentGuid: GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_1 {
   pub FieldTypeFlags: USHORT,
   pub __bindgen_anon_1: _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_1__bindgen_ty_1 {
   pub HeaderType: UCHAR,
   pub MarkerFlags: UCHAR,
}
impl Default for _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_2 {
   pub Version: ULONG,
   pub Class: _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_2__bindgen_ty_1 {
   pub Type: UCHAR,
   pub Level: UCHAR,
   pub Version: USHORT,
}
impl Default for _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_3 {
   pub Guid: GUID,
   pub GuidPtr: ULONGLONG,
}
impl Default for _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_4 {
   pub __bindgen_anon_1: _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_4__bindgen_ty_1,
   pub __bindgen_anon_2: _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_4__bindgen_ty_2,
   pub ProcessorTime: ULONG64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_4__bindgen_ty_1 {
   pub ClientContext: ULONG,
   pub Flags: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_4__bindgen_ty_2 {
   pub KernelTime: ULONG,
   pub UserTime: ULONG,
}
impl Default for _EVENT_INSTANCE_GUID_HEADER__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _EVENT_INSTANCE_GUID_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type EVENT_INSTANCE_GUID_HEADER = _EVENT_INSTANCE_GUID_HEADER;
pub type PEVENT_INSTANCE_GUID_HEADER = *mut _EVENT_INSTANCE_GUID_HEADER;
pub type PERFINFO_TIMESTAMP = ULONGLONG;
pub type PERFINFO_TRACE_ENTRY = _PERFINFO_TRACE_HEADER;
pub type PPERFINFO_TRACE_ENTRY = *mut _PERFINFO_TRACE_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_TRACE_HEADER {
   pub __bindgen_anon_1: _PERFINFO_TRACE_HEADER__bindgen_ty_1,
   pub __bindgen_anon_2: _PERFINFO_TRACE_HEADER__bindgen_ty_2,
   pub __bindgen_anon_3: _PERFINFO_TRACE_HEADER__bindgen_ty_3,
   pub Data: [UCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_TRACE_HEADER__bindgen_ty_1 {
   pub Marker: ULONG,
   pub __bindgen_anon_1: _PERFINFO_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1 {
   pub Version: USHORT,
   pub HeaderType: UCHAR,
   pub Flags: UCHAR,
}
impl Default for _PERFINFO_TRACE_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_TRACE_HEADER__bindgen_ty_2 {
   pub Header: ULONG,
   pub Packet: WMI_TRACE_PACKET,
}
impl Default for _PERFINFO_TRACE_HEADER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_TRACE_HEADER__bindgen_ty_3 {
   pub TS: PERFINFO_TIMESTAMP,
   pub SystemTime: LARGE_INTEGER,
}
impl Default for _PERFINFO_TRACE_HEADER__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PERFINFO_TRACE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_TRACE_HEADER = _PERFINFO_TRACE_HEADER;
pub type PPERFINFO_TRACE_HEADER = *mut _PERFINFO_TRACE_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_TRACE_HEADER {
   pub __bindgen_anon_1: _SYSTEM_TRACE_HEADER__bindgen_ty_1,
   pub __bindgen_anon_2: _SYSTEM_TRACE_HEADER__bindgen_ty_2,
   pub ThreadId: ULONG,
   pub ProcessId: ULONG,
   pub SystemTime: LARGE_INTEGER,
   pub KernelTime: ULONG,
   pub UserTime: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_TRACE_HEADER__bindgen_ty_1 {
   pub Marker: ULONG,
   pub __bindgen_anon_1: _SYSTEM_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1 {
   pub Version: USHORT,
   pub HeaderType: UCHAR,
   pub Flags: UCHAR,
}
impl Default for _SYSTEM_TRACE_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_TRACE_HEADER__bindgen_ty_2 {
   pub Header: ULONG,
   pub Packet: WMI_TRACE_PACKET,
}
impl Default for _SYSTEM_TRACE_HEADER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _SYSTEM_TRACE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type SYSTEM_TRACE_HEADER = _SYSTEM_TRACE_HEADER;
pub type PSYSTEM_TRACE_HEADER = *mut _SYSTEM_TRACE_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_TRACE_MESSAGE_PACKET {
   pub MessageNumber: USHORT,
   pub OptionFlags: USHORT,
}
pub type WMI_TRACE_MESSAGE_PACKET = _WMI_TRACE_MESSAGE_PACKET;
pub type PWMI_TRACE_MESSAGE_PACKET = *mut _WMI_TRACE_MESSAGE_PACKET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MESSAGE_TRACE_HEADER {
   pub __bindgen_anon_1: _MESSAGE_TRACE_HEADER__bindgen_ty_1,
   pub __bindgen_anon_2: _MESSAGE_TRACE_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MESSAGE_TRACE_HEADER__bindgen_ty_1 {
   pub Marker: ULONG,
   pub __bindgen_anon_1: _MESSAGE_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MESSAGE_TRACE_HEADER__bindgen_ty_1__bindgen_ty_1 {
   pub Size: USHORT,
   pub Reserved: UCHAR,
   pub Version: UCHAR,
}
impl Default for _MESSAGE_TRACE_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MESSAGE_TRACE_HEADER__bindgen_ty_2 {
   pub Header: ULONG,
   pub Packet: WMI_TRACE_MESSAGE_PACKET,
}
impl Default for _MESSAGE_TRACE_HEADER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _MESSAGE_TRACE_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MESSAGE_TRACE_HEADER = _MESSAGE_TRACE_HEADER;
pub type PMESSAGE_TRACE_HEADER = *mut _MESSAGE_TRACE_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MESSAGE_TRACE {
   pub MessageHeader: MESSAGE_TRACE_HEADER,
   pub Data: UCHAR,
}
impl Default for _MESSAGE_TRACE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MESSAGE_TRACE = _MESSAGE_TRACE;
pub type PMESSAGE_TRACE = *mut _MESSAGE_TRACE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MESSAGE_TRACE_USER {
   pub MessageHeader: MESSAGE_TRACE_HEADER,
   pub MessageGuid: GUID,
   pub MessageFlags: ULONG,
   pub DataSize: ULONG,
   pub Data: ULONG64,
}
impl Default for _MESSAGE_TRACE_USER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MESSAGE_TRACE_USER = _MESSAGE_TRACE_USER;
pub type PMESSAGE_TRACE_USER = *mut _MESSAGE_TRACE_USER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_REF_CLOCK {
   pub StartTime: LARGE_INTEGER,
   pub StartPerfClock: LARGE_INTEGER,
}
impl Default for _ETW_REF_CLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_REF_CLOCK = _ETW_REF_CLOCK;
pub type PETW_REF_CLOCK = *mut _ETW_REF_CLOCK;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_BUFFER_STATE {
   EtwBufferStateFree = 0,
   EtwBufferStateGeneralLogging = 1,
   EtwBufferStateCSwitch = 2,
   EtwBufferStateFlush = 3,
   EtwBufferStateMaximum = 4,
}
pub use self::_ETW_BUFFER_STATE as ETW_BUFFER_STATE;
pub type PETW_BUFFER_STATE = *mut _ETW_BUFFER_STATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_RT_EVENT_LOSS {
   EtwRtEventNoLoss = 0,
   EtwRtEventLost = 1,
   EtwRtBufferLost = 2,
   EtwRtBackupLost = 3,
   EtwRtEventLossMax = 4,
}
pub use self::_ETW_RT_EVENT_LOSS as ETW_RT_EVENT_LOSS;
pub type PETW_RT_EVENT_LOSS = *mut _ETW_RT_EVENT_LOSS;
pub type PWMI_BUFFER_HEADER = *mut _WMI_BUFFER_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_BUFFER_HEADER {
   pub BufferSize: ULONG,
   pub SavedOffset: ULONG,
   pub CurrentOffset: ULONG,
   pub ReferenceCount: LONG,
   pub TimeStamp: LARGE_INTEGER,
   pub SequenceNumber: LONGLONG,
   pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_1,
   pub ClientContext: ETW_BUFFER_CONTEXT,
   pub State: ETW_BUFFER_STATE,
   pub Offset: ULONG,
   pub BufferFlag: USHORT,
   pub BufferType: USHORT,
   pub __bindgen_anon_2: _WMI_BUFFER_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_1 {
   pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1,
   pub SlistEntry: SINGLE_LIST_ENTRY,
   pub NextBuffer: PWMI_BUFFER_HEADER,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _WMI_BUFFER_HEADER__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ClockType(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u64) }
   }
   #[inline]
   pub fn set_ClockType(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ClockType_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            3u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_ClockType_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Frequency(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
   }
   #[inline]
   pub fn set_Frequency(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 61u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Frequency_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            61u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Frequency_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            61u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ClockType: ULONGLONG,
      Frequency: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 3u8, {
         let ClockType: u64 = unsafe { ::core::mem::transmute(ClockType) };
         ClockType as u64
      });
      __bindgen_bitfield_unit.set(3usize, 61u8, {
         let Frequency: u64 = unsafe { ::core::mem::transmute(Frequency) };
         Frequency as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_BUFFER_HEADER__bindgen_ty_2 {
   pub Padding1: [ULONG; 4usize],
   pub ReferenceTime: ETW_REF_CLOCK,
   pub GlobalEntry: LIST_ENTRY,
   pub __bindgen_anon_1: _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1 {
   pub Pointer0: PVOID,
   pub Pointer1: PVOID,
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_2__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_BUFFER_HEADER__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_BUFFER_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_BUFFER_HEADER = _WMI_BUFFER_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_ENABLE_FLAG_EXTENSION {
   pub Offset: USHORT,
   pub Length: UCHAR,
   pub Flag: UCHAR,
}
pub type TRACE_ENABLE_FLAG_EXTENSION = _TRACE_ENABLE_FLAG_EXTENSION;
pub type PTRACE_ENABLE_FLAG_EXTENSION = *mut _TRACE_ENABLE_FLAG_EXTENSION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_ENABLE_FLAG_EXT_HEADER {
   pub Length: USHORT,
   pub Items: USHORT,
}
pub type TRACE_ENABLE_FLAG_EXT_HEADER = _TRACE_ENABLE_FLAG_EXT_HEADER;
pub type PTRACE_ENABLE_FLAG_EXT_HEADER = *mut _TRACE_ENABLE_FLAG_EXT_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _TRACE_ENABLE_FLAG_EXT_ITEM {
   pub Offset: USHORT,
   pub Type: USHORT,
}
pub type TRACE_ENABLE_FLAG_EXT_ITEM = _TRACE_ENABLE_FLAG_EXT_ITEM;
pub type PTRACE_ENABLE_FLAG_EXT_ITEM = *mut _TRACE_ENABLE_FLAG_EXT_ITEM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_STACK_CACHING_CONFIG {
   pub CacheSize: ULONG,
   pub BucketCount: ULONG,
}
pub type ETW_STACK_CACHING_CONFIG = _ETW_STACK_CACHING_CONFIG;
pub type PETW_STACK_CACHING_CONFIG = *mut _ETW_STACK_CACHING_CONFIG;
pub type PERFINFO_MASK = ULONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_GROUPMASK {
   pub Masks: [ULONG; 8usize],
}
pub type PERFINFO_GROUPMASK = _PERFINFO_GROUPMASK;
pub type PPERFINFO_GROUPMASK = *mut _PERFINFO_GROUPMASK;
#[repr(C)]
pub struct _CPU_CONFIG_RECORD {
   pub ProcessorSpeed: ULONG,
   pub NumberOfProcessors: ULONG,
   pub MemorySize: ULONG,
   pub PageSize: ULONG,
   pub AllocationGranularity: ULONG,
   pub ComputerName: [WCHAR; 256usize],
   pub DomainName: [WCHAR; 134usize],
   pub HyperThreadingFlag: ULONG_PTR,
   pub HighestUserAddress: ULONG_PTR,
   pub ProcessorArchitecture: USHORT,
   pub ProcessorLevel: USHORT,
   pub ProcessorRevision: USHORT,
   pub NxEnabled: BOOLEAN,
   pub PaeEnabled: BOOLEAN,
   pub MemorySpeed: ULONG,
}
impl Default for _CPU_CONFIG_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CPU_CONFIG_RECORD = _CPU_CONFIG_RECORD;
pub type PCPU_CONFIG_RECORD = *mut _CPU_CONFIG_RECORD;
#[repr(C)]
pub struct _PHYSICAL_DISK_RECORD {
   pub DiskNumber: ULONG,
   pub BytesPerSector: ULONG,
   pub SectorsPerTrack: ULONG,
   pub TracksPerCylinder: ULONG,
   pub Cylinders: ULONGLONG,
   pub SCSIPortNumber: ULONG,
   pub SCSIPathId: ULONG,
   pub SCSITargetId: ULONG,
   pub SCSILun: ULONG,
   pub Manufacturer: [WCHAR; 256usize],
   pub PartitionCount: ULONG,
   pub WriteCacheEnabled: BOOLEAN,
   pub BootDriveLetter: [WCHAR; 3usize],
}
impl Default for _PHYSICAL_DISK_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PHYSICAL_DISK_RECORD = _PHYSICAL_DISK_RECORD;
pub type PPHYSICAL_DISK_RECORD = *mut _PHYSICAL_DISK_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LOGICAL_DISK_EXTENTS {
   pub StartingOffset: ULONGLONG,
   pub PartitionSize: ULONGLONG,
   pub DiskNumber: ULONG,
   pub Size: ULONG,
   pub DriveType: ULONG,
   pub DriveLetterString: [WCHAR; 4usize],
   pub Pad: ULONG,
   pub PartitionNumber: ULONG,
   pub SectorsPerCluster: ULONG,
   pub BytesPerSector: ULONG,
   pub NumberOfFreeClusters: LONGLONG,
   pub TotalNumberOfClusters: LONGLONG,
   pub FileSystemType: [WCHAR; 16usize],
   pub VolumeExt: ULONG,
}
pub type LOGICAL_DISK_EXTENTS = _LOGICAL_DISK_EXTENTS;
pub type PLOGICAL_DISK_EXTENTS = *mut _LOGICAL_DISK_EXTENTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OPTICAL_MEDIA_RECORD {
   pub DiskNumber: USHORT,
   pub BusType: USHORT,
   pub DeviceType: USHORT,
   pub MediaType: USHORT,
   pub StartingOffset: ULONGLONG,
   pub Size: ULONGLONG,
   pub NumberOfFreeBlocks: ULONGLONG,
   pub TotalNumberOfBlocks: ULONGLONG,
   pub NextWritableAddress: ULONGLONG,
   pub NumberOfSessions: ULONG,
   pub NumberOfTracks: ULONG,
   pub BytesPerSector: ULONG,
   pub DiscStatus: USHORT,
   pub LastSessionStatus: USHORT,
   pub Data: [WCHAR; 1usize],
}
pub type OPTICAL_MEDIA_RECORD = _OPTICAL_MEDIA_RECORD;
pub type POPTICAL_MEDIA_RECORD = *mut _OPTICAL_MEDIA_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NIC_RECORD {
   pub NICName: [WCHAR; 256usize],
   pub Index: ULONG,
   pub PhysicalAddrLen: ULONG,
   pub PhysicalAddr: [WCHAR; 8usize],
   pub Size: ULONG,
   pub IpAddress: LONG,
   pub SubnetMask: LONG,
   pub DhcpServer: LONG,
   pub Gateway: LONG,
   pub PrimaryWinsServer: LONG,
   pub SecondaryWinsServer: LONG,
   pub DnsServer: [LONG; 4usize],
   pub Data: ULONG,
}
impl Default for _NIC_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type NIC_RECORD = _NIC_RECORD;
pub type PNIC_RECORD = *mut _NIC_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIDEO_RECORD {
   pub MemorySize: ULONG,
   pub XResolution: ULONG,
   pub YResolution: ULONG,
   pub BitsPerPixel: ULONG,
   pub VRefresh: ULONG,
   pub ChipType: [WCHAR; 256usize],
   pub DACType: [WCHAR; 256usize],
   pub AdapterString: [WCHAR; 256usize],
   pub BiosString: [WCHAR; 256usize],
   pub DeviceId: [WCHAR; 256usize],
   pub StateFlags: ULONG,
}
impl Default for _VIDEO_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type VIDEO_RECORD = _VIDEO_RECORD;
pub type PVIDEO_RECORD = *mut _VIDEO_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_DPI_RECORD {
   pub MachineDPI: ULONG,
   pub UserDPI: ULONG,
}
pub type WMI_DPI_RECORD = _WMI_DPI_RECORD;
pub type PWMI_DPI_RECORD = *mut _WMI_DPI_RECORD;
#[repr(C)]
pub struct _WMI_POWER_RECORD {
   pub SystemS1: BOOLEAN,
   pub SystemS2: BOOLEAN,
   pub SystemS3: BOOLEAN,
   pub SystemS4: BOOLEAN,
   pub SystemS5: BOOLEAN,
   pub AoAc: BOOLEAN,
   pub Pad2: CHAR,
   pub Pad3: CHAR,
}
impl Default for _WMI_POWER_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_POWER_RECORD = _WMI_POWER_RECORD;
pub type PWMI_POWER_RECORD = *mut _WMI_POWER_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_IRQ_RECORD {
   pub IRQAffinity: ULONG64,
   pub IRQGroup: USHORT,
   pub Reserved: USHORT,
   pub IRQNum: ULONG,
   pub DeviceDescriptionLen: ULONG,
   pub DeviceDescription: [WCHAR; 1usize],
}
pub type WMI_IRQ_RECORD = _WMI_IRQ_RECORD;
pub type PWMI_IRQ_RECORD = *mut _WMI_IRQ_RECORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_PNP_RECORD_V3 {
   pub IDLength: ULONG,
   pub DescriptionLength: ULONG,
   pub FriendlyNameLength: ULONG,
   pub Strings: [WCHAR; 1usize],
}
pub type WMI_PNP_RECORD_V3 = _WMI_PNP_RECORD_V3;
pub type PWMI_PNP_RECORD_V3 = *mut _WMI_PNP_RECORD_V3;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_PNP_RECORD_V4 {
   pub ClassGuid: GUID,
   pub UpperFilterCount: ULONG,
   pub LowerFilterCount: ULONG,
   pub Strings: [WCHAR; 1usize],
}
pub type WMI_PNP_RECORD_V4 = _WMI_PNP_RECORD_V4;
pub type PWMI_PNP_RECORD_V4 = *mut _WMI_PNP_RECORD_V4;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_PNP_RECORD_V5 {
   pub ClassGuid: GUID,
   pub UpperFilterCount: ULONG,
   pub LowerFilterCount: ULONG,
   pub DevStatus: ULONG,
   pub DevProblem: ULONG,
   pub Strings: [WCHAR; 1usize],
}
pub type WMI_PNP_RECORD_V5 = _WMI_PNP_RECORD_V5;
pub type PWMI_PNP_RECORD_V5 = *mut _WMI_PNP_RECORD_V5;
pub type WMI_PNP_RECORD = WMI_PNP_RECORD_V5;
pub type PWMI_PNP_RECORD = *mut WMI_PNP_RECORD_V5;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_IDE_CHANNEL_RECORD {
   pub TargetId: ULONG,
   pub DeviceType: ULONG,
   pub DeviceTimingMode: ULONG,
   pub LocationInformationLen: ULONG,
   pub LocationInformation: [WCHAR; 1usize],
}
pub type WMI_IDE_CHANNEL_RECORD = _WMI_IDE_CHANNEL_RECORD;
pub type PWMI_IDE_CHANNEL_RECORD = *mut _WMI_IDE_CHANNEL_RECORD;
#[repr(C)]
pub struct _WMI_JOB_INFORMATION {
   pub JobId: GUID,
   pub JobHandle: ULONG,
   pub Flags: ULONG,
   pub Status: NTSTATUS,
}
impl Default for _WMI_JOB_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_JOB_INFORMATION = _WMI_JOB_INFORMATION;
pub type PWMI_JOB_INFORMATION = *mut _WMI_JOB_INFORMATION;
#[repr(C)]
pub struct _WMI_JOB_ASSIGN_PROCESS {
   pub JobId: GUID,
   pub JobHandle: ULONG,
   pub UniqueProcessId: ULONG,
   pub Status: NTSTATUS,
}
impl Default for _WMI_JOB_ASSIGN_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_JOB_ASSIGN_PROCESS = _WMI_JOB_ASSIGN_PROCESS;
pub type PWMI_JOB_ASSIGN_PROCESS = *mut _WMI_JOB_ASSIGN_PROCESS;
#[repr(C)]
pub struct _WMI_JOB_REMOVE_PROCESS {
   pub JobId: GUID,
   pub UniqueProcessId: ULONG,
   pub RemovalFlags: ULONG,
   pub ExitStatus: NTSTATUS,
}
impl Default for _WMI_JOB_REMOVE_PROCESS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_JOB_REMOVE_PROCESS = _WMI_JOB_REMOVE_PROCESS;
pub type PWMI_JOB_REMOVE_PROCESS = *mut _WMI_JOB_REMOVE_PROCESS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_JOB_SET_QUERY_CPU_RATE {
   pub AllFlags: ULONG,
   pub Value: ULONG,
}
pub type WMI_JOB_SET_QUERY_CPU_RATE = _WMI_JOB_SET_QUERY_CPU_RATE;
pub type PWMI_JOB_SET_QUERY_CPU_RATE = *mut _WMI_JOB_SET_QUERY_CPU_RATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_JOB_SET_QUERY_NET_RATE {
   pub Flags: ULONG,
   pub MaxBandwidth: ULONG64,
   pub DscpTag: UCHAR,
}
pub type WMI_JOB_SET_QUERY_NET_RATE = _WMI_JOB_SET_QUERY_NET_RATE;
pub type PWMI_JOB_SET_QUERY_NET_RATE = *mut _WMI_JOB_SET_QUERY_NET_RATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_JOB_SET_QUERY_INFORMATION {
   pub JobId: GUID,
   pub JobHandle: ULONG,
   pub JobObjectInformationClass: ULONG,
}
pub type WMI_JOB_SET_QUERY_INFORMATION = _WMI_JOB_SET_QUERY_INFORMATION;
pub type PWMI_JOB_SET_QUERY_INFORMATION = *mut _WMI_JOB_SET_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_JOB_SEND_NOTIFICATION_INFORMATION {
   pub JobId: GUID,
   pub NotificationId: ULONG,
}
pub type WMI_JOB_SEND_NOTIFICATION_INFORMATION = _WMI_JOB_SEND_NOTIFICATION_INFORMATION;
pub type PWMI_JOB_SEND_NOTIFICATION_INFORMATION = *mut _WMI_JOB_SEND_NOTIFICATION_INFORMATION;
#[repr(C)]
pub struct _WMI_PROCESS_INFORMATION {
   pub UniqueProcessKey: ULONG_PTR,
   pub ProcessId: ULONG,
   pub ParentId: ULONG,
   pub SessionId: ULONG,
   pub ExitStatus: NTSTATUS,
   pub DirectoryTableBase: ULONG_PTR,
   pub Flags: ULONG,
   pub Sid: ULONG,
}
impl Default for _WMI_PROCESS_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_PROCESS_INFORMATION = _WMI_PROCESS_INFORMATION;
pub type PWMI_PROCESS_INFORMATION = *mut _WMI_PROCESS_INFORMATION;
#[repr(C)]
pub struct _WMI_PROCESS_INFORMATION64 {
   pub UniqueProcessKey64: ULONG64,
   pub ProcessId: ULONG,
   pub ParentId: ULONG,
   pub SessionId: ULONG,
   pub ExitStatus: NTSTATUS,
   pub DirectoryTableBase: ULONG64,
   pub Flags: ULONG,
   pub Sid: ULONG,
}
impl Default for _WMI_PROCESS_INFORMATION64 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_PROCESS_INFORMATION64 = _WMI_PROCESS_INFORMATION64;
pub type PWMI_PROCESS_INFORMATION64 = *mut _WMI_PROCESS_INFORMATION64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_THREAD_INFORMATION {
   pub ProcessId: ULONG,
   pub ThreadId: ULONG,
}
pub type WMI_THREAD_INFORMATION = _WMI_THREAD_INFORMATION;
pub type PWMI_THREAD_INFORMATION = *mut _WMI_THREAD_INFORMATION;
pub type SCHAR = ::core::ffi::c_schar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_EXTENDED_THREAD_INFORMATION {
   pub ProcessId: ULONG,
   pub ThreadId: ULONG,
   pub StackBase: PVOID,
   pub StackLimit: PVOID,
   pub UserStackBase: PVOID,
   pub UserStackLimit: PVOID,
   pub __bindgen_anon_1: _WMI_EXTENDED_THREAD_INFORMATION__bindgen_ty_1,
   pub Win32StartAddress: PVOID,
   pub TebBase: PVOID,
   pub SubProcessTag: ULONG,
   pub BasePriority: SCHAR,
   pub PagePriority: UCHAR,
   pub IoPriority: UCHAR,
   pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_EXTENDED_THREAD_INFORMATION__bindgen_ty_1 {
   pub StartAddress: PVOID,
   pub Affinity: KAFFINITY,
}
impl Default for _WMI_EXTENDED_THREAD_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_EXTENDED_THREAD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_EXTENDED_THREAD_INFORMATION = _WMI_EXTENDED_THREAD_INFORMATION;
pub type PWMI_EXTENDED_THREAD_INFORMATION = *mut _WMI_EXTENDED_THREAD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_EXTENDED_THREAD_INFORMATION64 {
   pub ProcessId: ULONG,
   pub ThreadId: ULONG,
   pub StackBase64: ULONG64,
   pub StackLimit64: ULONG64,
   pub UserStackBase64: ULONG64,
   pub UserStackLimit64: ULONG64,
   pub __bindgen_anon_1: _WMI_EXTENDED_THREAD_INFORMATION64__bindgen_ty_1,
   pub Win32StartAddress64: ULONG64,
   pub TebBase64: ULONG64,
   pub SubProcessTag: ULONG,
   pub BasePriority: SCHAR,
   pub PagePriority: UCHAR,
   pub IoPriority: UCHAR,
   pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_EXTENDED_THREAD_INFORMATION64__bindgen_ty_1 {
   pub StartAddress64: ULONG64,
   pub Affinity: ULONG64,
}
impl Default for _WMI_EXTENDED_THREAD_INFORMATION64__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_EXTENDED_THREAD_INFORMATION64 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_EXTENDED_THREAD_INFORMATION64 = _WMI_EXTENDED_THREAD_INFORMATION64;
pub type PWMI_EXTENDED_THREAD_INFORMATION64 = *mut _WMI_EXTENDED_THREAD_INFORMATION64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_IMAGELOAD_INFORMATION {
   pub ImageBase: PVOID,
   pub ImageSize: SIZE_T,
   pub ProcessId: ULONG,
   pub ImageChecksum: ULONG,
   pub TimeDateStamp: ULONG,
   pub SignatureLevel: UCHAR,
   pub SignatureType: UCHAR,
   pub Reserved0: USHORT,
   pub DefaultBase: PVOID,
   pub Reserved1: ULONG,
   pub Reserved2: ULONG,
   pub Reserved3: ULONG,
   pub Reserved4: ULONG,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _WMI_IMAGELOAD_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_IMAGELOAD_INFORMATION = _WMI_IMAGELOAD_INFORMATION;
pub type PWMI_IMAGELOAD_INFORMATION = *mut _WMI_IMAGELOAD_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_IMAGELOAD_INFORMATION32 {
   pub ImageBase32: ULONG32,
   pub ImageSize32: ULONG32,
   pub ProcessId: ULONG,
   pub ImageChecksum: ULONG,
   pub TimeDateStamp: ULONG,
   pub SignatureLevel: UCHAR,
   pub SignatureType: UCHAR,
   pub Reserved0: USHORT,
   pub DefaultBase32: ULONG32,
   pub Reserved1: ULONG,
   pub Reserved2: ULONG,
   pub Reserved3: ULONG,
   pub Reserved4: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type WMI_IMAGELOAD_INFORMATION32 = _WMI_IMAGELOAD_INFORMATION32;
pub type PWMI_IMAGELOAD_INFORMATION32 = *mut _WMI_IMAGELOAD_INFORMATION32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_IMAGELOAD_INFORMATION64 {
   pub ImageBase64: ULONG64,
   pub ImageSize64: ULONG64,
   pub ProcessId: ULONG,
   pub ImageChecksum: ULONG,
   pub TimeDateStamp: ULONG,
   pub SignatureLevel: UCHAR,
   pub SignatureType: UCHAR,
   pub Reserved0: USHORT,
   pub DefaultBase64: ULONG64,
   pub Reserved1: ULONG,
   pub Reserved2: ULONG,
   pub Reserved3: ULONG,
   pub Reserved4: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type WMI_IMAGELOAD_INFORMATION64 = _WMI_IMAGELOAD_INFORMATION64;
pub type PWMI_IMAGELOAD_INFORMATION64 = *mut _WMI_IMAGELOAD_INFORMATION64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_IMAGEID_INFORMATION {
   pub ImageBase: PVOID,
   pub ImageSize: SIZE_T,
   pub ProcessId: ULONG,
   pub TimeDateStamp: ULONG,
   pub OriginalFileName: [WCHAR; 1usize],
}
impl Default for _WMI_IMAGEID_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_IMAGEID_INFORMATION = _WMI_IMAGEID_INFORMATION;
pub type PWMI_IMAGEID_INFORMATION = *mut _WMI_IMAGEID_INFORMATION;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_IMAGEID_INFORMATION32 {
   pub ImageBase32: ULONG32,
   pub ImageSize32: ULONG32,
   pub ProcessId: ULONG,
   pub TimeDateStamp: ULONG,
   pub OriginalFileName: [WCHAR; 1usize],
}
pub type WMI_IMAGEID_INFORMATION32 = _WMI_IMAGEID_INFORMATION32;
pub type PWMI_IMAGEID_INFORMATION32 = *mut _WMI_IMAGEID_INFORMATION32;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_IMAGEID_INFORMATION64 {
   pub ImageBase64: ULONG64,
   pub ImageSize64: ULONG64,
   pub ProcessId: ULONG,
   pub TimeDateStamp: ULONG,
   pub OriginalFileName: [WCHAR; 1usize],
}
pub type WMI_IMAGEID_INFORMATION64 = _WMI_IMAGEID_INFORMATION64;
pub type PWMI_IMAGEID_INFORMATION64 = *mut _WMI_IMAGEID_INFORMATION64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_DISKIO_READWRITE_V2 {
   pub DiskNumber: ULONG,
   pub IrpFlags: ULONG,
   pub Size: ULONG,
   pub Reserved: ULONG,
   pub ByteOffset: ULONGLONG,
   pub FileObject: PVOID,
   pub IrpAddress: PVOID,
   pub HighResResponseTime: ULONGLONG,
}
impl Default for _ETW_DISKIO_READWRITE_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_DISKIO_READWRITE_V2 = _ETW_DISKIO_READWRITE_V2;
pub type PETW_DISKIO_READWRITE_V2 = *mut _ETW_DISKIO_READWRITE_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_DISKIO_READWRITE_V3 {
   pub DiskNumber: ULONG,
   pub IrpFlags: ULONG,
   pub Size: ULONG,
   pub Reserved: ULONG,
   pub ByteOffset: ULONGLONG,
   pub FileObject: PVOID,
   pub IrpAddress: PVOID,
   pub HighResResponseTime: ULONGLONG,
   pub IssuingThreadId: ULONG,
}
impl Default for _ETW_DISKIO_READWRITE_V3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_DISKIO_READWRITE_V3 = _ETW_DISKIO_READWRITE_V3;
pub type PETW_DISKIO_READWRITE_V3 = *mut _ETW_DISKIO_READWRITE_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_DISKIO_FLUSH_BUFFERS_V2 {
   pub DiskNumber: ULONG,
   pub IrpFlags: ULONG,
   pub HighResResponseTime: ULONGLONG,
   pub IrpAddress: PVOID,
}
impl Default for _ETW_DISKIO_FLUSH_BUFFERS_V2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_DISKIO_FLUSH_BUFFERS_V2 = _ETW_DISKIO_FLUSH_BUFFERS_V2;
pub type PETW_DISKIO_FLUSH_BUFFERS_V2 = *mut _ETW_DISKIO_FLUSH_BUFFERS_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_DISKIO_FLUSH_BUFFERS_V3 {
   pub DiskNumber: ULONG,
   pub IrpFlags: ULONG,
   pub HighResResponseTime: ULONGLONG,
   pub IrpAddress: PVOID,
   pub IssuingThreadId: ULONG,
}
impl Default for _ETW_DISKIO_FLUSH_BUFFERS_V3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_DISKIO_FLUSH_BUFFERS_V3 = _ETW_DISKIO_FLUSH_BUFFERS_V3;
pub type PETW_DISKIO_FLUSH_BUFFERS_V3 = *mut _ETW_DISKIO_FLUSH_BUFFERS_V3;
pub type WMI_DISKIO_READWRITE = _ETW_DISKIO_READWRITE_V3;
pub type PWMI_DISKIO_READWRITE = *mut _ETW_DISKIO_READWRITE_V3;
pub type WMI_DISKIO_FLUSH_BUFFERS = _ETW_DISKIO_FLUSH_BUFFERS_V3;
pub type PWMI_DISKIO_FLUSH_BUFFERS = *mut _ETW_DISKIO_FLUSH_BUFFERS_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_DISKIO_READWRITE_INIT {
   pub Irp: PVOID,
   pub IssuingThreadId: ULONG,
}
impl Default for _WMI_DISKIO_READWRITE_INIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_DISKIO_READWRITE_INIT = _WMI_DISKIO_READWRITE_INIT;
pub type PWMI_DISKIO_READWRITE_INIT = *mut _WMI_DISKIO_READWRITE_INIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_DISKIO_IO_REDIRECTED_INIT {
   pub Irp: PVOID,
   pub FileKey: PVOID,
}
impl Default for _WMI_DISKIO_IO_REDIRECTED_INIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_DISKIO_IO_REDIRECTED_INIT = _WMI_DISKIO_IO_REDIRECTED_INIT;
pub type PWMI_DISKIO_IO_REDIRECTED_INIT = *mut _WMI_DISKIO_IO_REDIRECTED_INIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_OPTICALIO_READWRITE {
   pub DiskNumber: ULONG,
   pub IrpFlags: ULONG,
   pub Size: ULONG,
   pub Reserved: ULONG,
   pub ByteOffset: ULONGLONG,
   pub FileObject: PVOID,
   pub IrpAddress: PVOID,
   pub HighResResponseTime: ULONGLONG,
   pub IssuingThreadId: ULONG,
}
impl Default for _ETW_OPTICALIO_READWRITE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_OPTICALIO_READWRITE = _ETW_OPTICALIO_READWRITE;
pub type PETW_OPTICALIO_READWRITE = *mut _ETW_OPTICALIO_READWRITE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_OPTICALIO_FLUSH_BUFFERS {
   pub DiskNumber: ULONG,
   pub IrpFlags: ULONG,
   pub HighResResponseTime: ULONGLONG,
   pub IrpAddress: PVOID,
   pub IssuingThreadId: ULONG,
}
impl Default for _ETW_OPTICALIO_FLUSH_BUFFERS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_OPTICALIO_FLUSH_BUFFERS = _ETW_OPTICALIO_FLUSH_BUFFERS;
pub type PETW_OPTICALIO_FLUSH_BUFFERS = *mut _ETW_OPTICALIO_FLUSH_BUFFERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_OPTICALIO_INIT {
   pub Irp: PVOID,
   pub IssuingThreadId: ULONG,
}
impl Default for _ETW_OPTICALIO_INIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_OPTICALIO_INIT = _ETW_OPTICALIO_INIT;
pub type PETW_OPTICALIO_INIT = *mut _ETW_OPTICALIO_INIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_REGISTRY {
   pub InitialTime: LONGLONG,
   pub Status: ULONG,
   pub __bindgen_anon_1: _WMI_REGISTRY__bindgen_ty_1,
   pub Kcb: PVOID,
   pub Name: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_REGISTRY__bindgen_ty_1 {
   pub Index: ULONG,
   pub InfoClass: ULONG,
}
impl Default for _WMI_REGISTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_REGISTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_REGISTRY = _WMI_REGISTRY;
pub type PWMI_REGISTRY = *mut _WMI_REGISTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_TXR {
   pub InitialTime: LONGLONG,
   pub TxRGUID: GUID,
   pub Status: ULONG,
   pub UowCount: ULONG,
   pub Hive: [WCHAR; 1usize],
}
pub type WMI_TXR = _WMI_TXR;
pub type PWMI_TXR = *mut _WMI_TXR;
#[repr(C)]
pub struct _ETW_REGNOTIF_REGISTER {
   pub Notification: PVOID,
   pub Kcb: PVOID,
   pub Type: UCHAR,
   pub WatchTree: BOOLEAN,
   pub Primary: BOOLEAN,
}
impl Default for _ETW_REGNOTIF_REGISTER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_REGNOTIF_REGISTER = _ETW_REGNOTIF_REGISTER;
pub type PETW_REGNOTIF_REGISTER = *mut _ETW_REGNOTIF_REGISTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_FILE_IO {
   pub FileObject: PVOID,
   pub FileName: [WCHAR; 1usize],
}
impl Default for _WMI_FILE_IO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_FILE_IO = _WMI_FILE_IO;
pub type PWMI_FILE_IO = *mut _WMI_FILE_IO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_TCPIP_V4 {
   pub ProcessId: ULONG,
   pub TransferSize: ULONG,
   pub DestinationAddress: [UCHAR; 4usize],
   pub SourceAddress: [UCHAR; 4usize],
   pub DestinationPort: USHORT,
   pub SourcePort: USHORT,
}
pub type WMI_TCPIP_V4 = _WMI_TCPIP_V4;
pub type PWMI_TCPIP_V4 = *mut _WMI_TCPIP_V4;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_TCPIP_V6 {
   pub ProcessId: ULONG,
   pub TransferSize: ULONG,
   pub DestinationAddress: [UCHAR; 16usize],
   pub SourceAddress: [UCHAR; 16usize],
   pub DestinationPort: USHORT,
   pub SourcePort: USHORT,
}
pub type WMI_TCPIP_V6 = _WMI_TCPIP_V6;
pub type PWMI_TCPIP_V6 = *mut _WMI_TCPIP_V6;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_UDP_V4 {
   pub ProcessId: ULONG,
   pub TransferSize: USHORT,
   pub DestinationAddress: [UCHAR; 4usize],
   pub SourceAddress: [UCHAR; 4usize],
   pub DestinationPort: USHORT,
   pub SourcePort: USHORT,
}
pub type WMI_UDP_V4 = _WMI_UDP_V4;
pub type PWMI_UDP_V4 = *mut _WMI_UDP_V4;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_UDP_V6 {
   pub ProcessId: ULONG,
   pub TransferSize: USHORT,
   pub DestinationAddress: [UCHAR; 16usize],
   pub SourceAddress: [UCHAR; 16usize],
   pub DestinationPort: USHORT,
   pub SourcePort: USHORT,
}
pub type WMI_UDP_V6 = _WMI_UDP_V6;
pub type PWMI_UDP_V6 = *mut _WMI_UDP_V6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_PAGE_FAULT {
   pub VirtualAddress: PVOID,
   pub ProgramCounter: PVOID,
}
impl Default for _WMI_PAGE_FAULT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_PAGE_FAULT = _WMI_PAGE_FAULT;
pub type PWMI_PAGE_FAULT = *mut _WMI_PAGE_FAULT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WMI_CONTEXTSWAP {
   pub NewThreadId: ULONG,
   pub OldThreadId: ULONG,
   pub NewThreadPriority: CHAR,
   pub OldThreadPriority: CHAR,
   pub __bindgen_anon_1: _WMI_CONTEXTSWAP__bindgen_ty_1,
   pub __bindgen_anon_2: _WMI_CONTEXTSWAP__bindgen_ty_2,
   pub OldThreadWaitReason: UCHAR,
   pub OldThreadWaitMode: CHAR,
   pub OldThreadState: UCHAR,
   pub OldThreadIdealProcessor: UCHAR,
   pub NewThreadWaitTime: ULONG,
   pub OldThreadRemainingQuantum: LONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_CONTEXTSWAP__bindgen_ty_1 {
   pub PreviousCState: UCHAR,
   pub OldThreadRank: UCHAR,
}
impl Default for _WMI_CONTEXTSWAP__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_CONTEXTSWAP__bindgen_ty_2 {
   pub NewThreadPriorityDecrement: CHAR,
   pub SpareByte: CHAR,
}
impl Default for _WMI_CONTEXTSWAP__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_CONTEXTSWAP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_CONTEXTSWAP = _WMI_CONTEXTSWAP;
pub type PWMI_CONTEXTSWAP = *mut _WMI_CONTEXTSWAP;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _WMI_SPINLOCK {
   pub SpinLockAddress: PVOID,
   pub CallerAddress: PVOID,
   pub AcquireTime: ULONG64,
   pub ReleaseTime: ULONG64,
   pub WaitTimeInCycles: ULONG,
   pub SpinCount: ULONG,
   pub ThreadId: ULONG,
   pub InterruptCount: ULONG,
   pub Irql: UCHAR,
   pub AcquireDepth: UCHAR,
   pub __bindgen_anon_1: _WMI_SPINLOCK__bindgen_ty_1,
   pub Reserved: [UCHAR; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_SPINLOCK__bindgen_ty_1 {
   pub __bindgen_anon_1: _WMI_SPINLOCK__bindgen_ty_1__bindgen_ty_1,
   pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_SPINLOCK__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _WMI_SPINLOCK__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn AcquireMode(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
   }
   #[inline]
   pub fn set_AcquireMode(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn AcquireMode_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            6u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_AcquireMode_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ExecuteDpc(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ExecuteDpc(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ExecuteDpc_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ExecuteDpc_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ExecuteIsr(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ExecuteIsr(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(7usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ExecuteIsr_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            7usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ExecuteIsr_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            7usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      AcquireMode: UCHAR,
      ExecuteDpc: UCHAR,
      ExecuteIsr: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 6u8, {
         let AcquireMode: u8 = unsafe { ::core::mem::transmute(AcquireMode) };
         AcquireMode as u64
      });
      __bindgen_bitfield_unit.set(6usize, 1u8, {
         let ExecuteDpc: u8 = unsafe { ::core::mem::transmute(ExecuteDpc) };
         ExecuteDpc as u64
      });
      __bindgen_bitfield_unit.set(7usize, 1u8, {
         let ExecuteIsr: u8 = unsafe { ::core::mem::transmute(ExecuteIsr) };
         ExecuteIsr as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _WMI_SPINLOCK__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_SPINLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_SPINLOCK = _WMI_SPINLOCK;
pub type PWMI_SPINLOCK = *mut _WMI_SPINLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_RESOURCE {
   pub AcquireTime: ULONG64,
   pub HoldTime: ULONG64,
   pub WaitTime: ULONG64,
   pub MaxRecursionDepth: ULONG,
   pub ThreadId: ULONG,
   pub Resource: PVOID,
   pub Action: ULONG,
   pub ContentionDelta: ULONG,
}
impl Default for _WMI_RESOURCE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_RESOURCE = _WMI_RESOURCE;
pub type PWMI_RESOURCE = *mut _WMI_RESOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_QUEUE {
   pub Queue: PVOID,
   pub ThreadId: ULONG,
   pub Action: UCHAR,
}
impl Default for _WMI_QUEUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_QUEUE = _WMI_QUEUE;
pub type PWMI_QUEUE = *mut _WMI_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_PUSHLOCK {
   pub PushLock: PVOID,
   pub ThreadId: ULONG,
   pub Action: UCHAR,
}
impl Default for _WMI_PUSHLOCK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_PUSHLOCK = _WMI_PUSHLOCK;
pub type PWMI_PUSHLOCK = *mut _WMI_PUSHLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_WAIT_SINGLE {
   pub ThreadId: ULONG,
   pub Object: PVOID,
   pub ObjectType: UCHAR,
}
impl Default for _WMI_WAIT_SINGLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_WAIT_SINGLE = _WMI_WAIT_SINGLE;
pub type PWMI_WAIT_SINGLE = *mut _WMI_WAIT_SINGLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_WAIT_OBJECT_RECORD {
   pub Object: PVOID,
   pub ObjectType: UCHAR,
}
impl Default for _WMI_WAIT_OBJECT_RECORD {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_WAIT_OBJECT_RECORD = _WMI_WAIT_OBJECT_RECORD;
pub type PWMI_WAIT_OBJECT_RECORD = *mut _WMI_WAIT_OBJECT_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WMI_WAIT_MULTIPLE {
   pub ThreadId: ULONG,
   pub WaitType: UCHAR,
   pub ObjectCount: UCHAR,
   pub ObjectRecord: [WMI_WAIT_OBJECT_RECORD; 64usize],
}
impl Default for _WMI_WAIT_MULTIPLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_WAIT_MULTIPLE = _WMI_WAIT_MULTIPLE;
pub type PWMI_WAIT_MULTIPLE = *mut _WMI_WAIT_MULTIPLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WMI_DELAY_EXECUTION {
   pub ThreadId: ULONG,
   pub Delta: ULONGLONG,
}
pub type WMI_DELAY_EXECUTION = _WMI_DELAY_EXECUTION;
pub type PWMI_DELAY_EXECUTION = *mut _WMI_DELAY_EXECUTION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_READY_THREAD_EVENT {
   pub ThreadId: ULONG,
   pub AdjustReason: UCHAR,
   pub AdjustIncrement: SCHAR,
   pub __bindgen_anon_1: _ETW_READY_THREAD_EVENT__bindgen_ty_1,
   pub SpareByte: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_READY_THREAD_EVENT__bindgen_ty_1 {
   pub __bindgen_anon_1: _ETW_READY_THREAD_EVENT__bindgen_ty_1__bindgen_ty_1,
   pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_READY_THREAD_EVENT__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _ETW_READY_THREAD_EVENT__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ExecutingDpc(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ExecutingDpc(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ExecutingDpc_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ExecutingDpc_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn KernelStackNotResident(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_KernelStackNotResident(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn KernelStackNotResident_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_KernelStackNotResident_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ProcessOutOfMemory(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ProcessOutOfMemory(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ProcessOutOfMemory_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ProcessOutOfMemory_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DirectSwitchAttempt(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_DirectSwitchAttempt(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DirectSwitchAttempt_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_DirectSwitchAttempt_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            4u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ExecutingDpc: UCHAR,
      KernelStackNotResident: UCHAR,
      ProcessOutOfMemory: UCHAR,
      DirectSwitchAttempt: UCHAR,
      Reserved: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ExecutingDpc: u8 = unsafe { ::core::mem::transmute(ExecutingDpc) };
         ExecutingDpc as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let KernelStackNotResident: u8 = unsafe { ::core::mem::transmute(KernelStackNotResident) };
         KernelStackNotResident as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let ProcessOutOfMemory: u8 = unsafe { ::core::mem::transmute(ProcessOutOfMemory) };
         ProcessOutOfMemory as u64
      });
      __bindgen_bitfield_unit.set(3usize, 1u8, {
         let DirectSwitchAttempt: u8 = unsafe { ::core::mem::transmute(DirectSwitchAttempt) };
         DirectSwitchAttempt as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _ETW_READY_THREAD_EVENT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ETW_READY_THREAD_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_READY_THREAD_EVENT = _ETW_READY_THREAD_EVENT;
pub type PETW_READY_THREAD_EVENT = *mut _ETW_READY_THREAD_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_KQUEUE_ENQUEUE_EVENT {
   pub Entry: PVOID,
   pub ThreadId: ULONG,
}
impl Default for _ETW_KQUEUE_ENQUEUE_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_KQUEUE_ENQUEUE_EVENT = _ETW_KQUEUE_ENQUEUE_EVENT;
pub type PETW_KQUEUE_ENQUEUE_EVENT = *mut _ETW_KQUEUE_ENQUEUE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_KQUEUE_DEQUEUE_EVENT {
   pub ThreadId: ULONG,
   pub EntryCount: ULONG,
   pub Entries: [PVOID; 1usize],
}
impl Default for _ETW_KQUEUE_DEQUEUE_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_KQUEUE_DEQUEUE_EVENT = _ETW_KQUEUE_DEQUEUE_EVENT;
pub type PETW_KQUEUE_DEQUEUE_EVENT = *mut _ETW_KQUEUE_DEQUEUE_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_ANTI_STARVATION_BOOST_EVENT {
   pub ThreadId: ULONG,
   pub ProcessorIndex: USHORT,
   pub OldPriority: SCHAR,
   pub SpareByte: UCHAR,
}
pub type ETW_ANTI_STARVATION_BOOST_EVENT = _ETW_ANTI_STARVATION_BOOST_EVENT;
pub type PETW_ANTI_STARVATION_BOOST_EVENT = *mut _ETW_ANTI_STARVATION_BOOST_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT {
   pub Lock: PVOID,
   pub ThreadId: ULONG,
   pub NewCpuPriorityFloor: SCHAR,
   pub OldCpuPriority: SCHAR,
   pub __bindgen_anon_1: _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_1,
   pub __bindgen_anon_2: _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_1 {
   pub __bindgen_anon_1: _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_1__bindgen_ty_1,
   pub IoPriorities: SCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn NewIoPriorityFloor(&self) -> SCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_NewIoPriorityFloor(&mut self, val: SCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NewIoPriorityFloor_raw(this: *const Self) -> SCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            4u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_NewIoPriorityFloor_raw(this: *mut Self, val: SCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn OldIoPriority(&self) -> SCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
   }
   #[inline]
   pub fn set_OldIoPriority(&mut self, val: SCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn OldIoPriority_raw(this: *const Self) -> SCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            4u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_OldIoPriority_raw(this: *mut Self, val: SCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      NewIoPriorityFloor: SCHAR,
      OldIoPriority: SCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let NewIoPriorityFloor: u8 = unsafe { ::core::mem::transmute(NewIoPriorityFloor) };
         NewIoPriorityFloor as u64
      });
      __bindgen_bitfield_unit.set(4usize, 4u8, {
         let OldIoPriority: u8 = unsafe { ::core::mem::transmute(OldIoPriority) };
         OldIoPriority as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_2 {
   pub __bindgen_anon_1: _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_2__bindgen_ty_1,
   pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_2__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_2__bindgen_ty_1 {
   #[inline]
   pub fn ExecutingDpc(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ExecutingDpc(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ExecutingDpc_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ExecutingDpc_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn WakeupBoost(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_WakeupBoost(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn WakeupBoost_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_WakeupBoost_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn BoostedOutstandingIrps(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_BoostedOutstandingIrps(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn BoostedOutstandingIrps_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_BoostedOutstandingIrps_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            5u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            5u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ExecutingDpc: UCHAR,
      WakeupBoost: UCHAR,
      BoostedOutstandingIrps: UCHAR,
      Reserved: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ExecutingDpc: u8 = unsafe { ::core::mem::transmute(ExecutingDpc) };
         ExecutingDpc as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let WakeupBoost: u8 = unsafe { ::core::mem::transmute(WakeupBoost) };
         WakeupBoost as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let BoostedOutstandingIrps: u8 = unsafe { ::core::mem::transmute(BoostedOutstandingIrps) };
         BoostedOutstandingIrps as u64
      });
      __bindgen_bitfield_unit.set(3usize, 5u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT = _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT;
pub type PETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT = *mut _ETW_AUTOBOOST_SET_PRIORITY_FLOOR_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT {
   pub Lock: PVOID,
   pub ThreadId: ULONG,
   pub __bindgen_anon_1: _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT__bindgen_ty_1,
   pub Reserved: USHORT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT__bindgen_ty_1 {
   pub __bindgen_anon_1: _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT__bindgen_ty_1__bindgen_ty_1,
   pub BoostBitmap: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn IoBoost(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_IoBoost(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn IoBoost_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_IoBoost_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn CpuBoostsBitmap(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
   }
   #[inline]
   pub fn set_CpuBoostsBitmap(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 15u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn CpuBoostsBitmap_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            15u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_CpuBoostsBitmap_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            15u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      IoBoost: USHORT,
      CpuBoostsBitmap: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let IoBoost: u16 = unsafe { ::core::mem::transmute(IoBoost) };
         IoBoost as u64
      });
      __bindgen_bitfield_unit.set(1usize, 15u8, {
         let CpuBoostsBitmap: u16 = unsafe { ::core::mem::transmute(CpuBoostsBitmap) };
         CpuBoostsBitmap as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT = _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT;
pub type PETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT = *mut _ETW_AUTOBOOST_CLEAR_PRIORITY_FLOOR_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_AUTOBOOST_NO_ENTRIES_EVENT {
   pub Lock: PVOID,
   pub ThreadId: ULONG,
}
impl Default for _ETW_AUTOBOOST_NO_ENTRIES_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_AUTOBOOST_NO_ENTRIES_EVENT = _ETW_AUTOBOOST_NO_ENTRIES_EVENT;
pub type PETW_AUTOBOOST_NO_ENTRIES_EVENT = *mut _ETW_AUTOBOOST_NO_ENTRIES_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_PRIORITY_EVENT {
   pub ThreadId: ULONG,
   pub OldPriority: SCHAR,
   pub NewPriority: SCHAR,
   pub DynamicPriority: SCHAR,
   pub Reserved: SCHAR,
}
pub type ETW_PRIORITY_EVENT = _ETW_PRIORITY_EVENT;
pub type PETW_PRIORITY_EVENT = *mut _ETW_PRIORITY_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_THREAD_AFFINITY_EVENT {
   pub Mask: KAFFINITY,
   pub ThreadId: ULONG,
   pub Group: USHORT,
   pub Reserved: USHORT,
}
pub type ETW_THREAD_AFFINITY_EVENT = _ETW_THREAD_AFFINITY_EVENT;
pub type PETW_THREAD_AFFINITY_EVENT = *mut _ETW_THREAD_AFFINITY_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_DEBUG_PRINT_EVENT {
   pub Component: ULONG,
   pub Level: ULONG,
   pub Message: [CHAR; 1usize],
}
pub type ETW_DEBUG_PRINT_EVENT = _ETW_DEBUG_PRINT_EVENT;
pub type PETW_DEBUG_PRINT_EVENT = *mut _ETW_DEBUG_PRINT_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_POOL_EVENT {
   pub PoolType: ULONG,
   pub Tag: ULONG,
   pub NumberOfBytes: SIZE_T,
   pub Entry: PVOID,
}
impl Default for _ETW_POOL_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_POOL_EVENT = _ETW_POOL_EVENT;
pub type PETW_POOL_EVENT = *mut _ETW_POOL_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_CREATE_HANDLE_EVENT {
   pub Object: PVOID,
   pub Handle: ULONG,
   pub ObjectType: USHORT,
}
impl Default for _ETW_CREATE_HANDLE_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_CREATE_HANDLE_EVENT = _ETW_CREATE_HANDLE_EVENT;
pub type PETW_CREATE_HANDLE_EVENT = *mut _ETW_CREATE_HANDLE_EVENT;
pub type ETW_CLOSE_HANDLE_EVENT = ETW_CREATE_HANDLE_EVENT;
pub type PETW_CLOSE_HANDLE_EVENT = *mut ETW_CREATE_HANDLE_EVENT;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_DUPLICATE_HANDLE_EVENT {
   pub Object: PVOID,
   pub SourceHandle: ULONG,
   pub TargetHandle: ULONG,
   pub TargetProcessId: ULONG,
   pub ObjectType: USHORT,
   pub SourceProcessId: ULONG,
}
impl Default for _ETW_DUPLICATE_HANDLE_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_DUPLICATE_HANDLE_EVENT = _ETW_DUPLICATE_HANDLE_EVENT;
pub type PETW_DUPLICATE_HANDLE_EVENT = *mut _ETW_DUPLICATE_HANDLE_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_OBJECT_TYPE_EVENT {
   pub ObjectType: USHORT,
   pub Reserved: USHORT,
   pub Name: [WCHAR; 1usize],
}
pub type ETW_OBJECT_TYPE_EVENT = _ETW_OBJECT_TYPE_EVENT;
pub type PETW_OBJECT_TYPE_EVENT = *mut _ETW_OBJECT_TYPE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_OBJECT_HANDLE_EVENT {
   pub Object: PVOID,
   pub ProcessId: ULONG,
   pub Handle: ULONG,
   pub ObjectType: USHORT,
}
impl Default for _ETW_OBJECT_HANDLE_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_OBJECT_HANDLE_EVENT = _ETW_OBJECT_HANDLE_EVENT;
pub type PETW_OBJECT_HANDLE_EVENT = *mut _ETW_OBJECT_HANDLE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_REFDEREF_OBJECT_EVENT {
   pub Object: PVOID,
   pub Tag: ULONG,
   pub Count: ULONG,
}
impl Default for _ETW_REFDEREF_OBJECT_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_REFDEREF_OBJECT_EVENT = _ETW_REFDEREF_OBJECT_EVENT;
pub type PETW_REFDEREF_OBJECT_EVENT = *mut _ETW_REFDEREF_OBJECT_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_CREATEDELETE_OBJECT_EVENT {
   pub Object: PVOID,
   pub ObjectType: USHORT,
}
impl Default for _ETW_CREATEDELETE_OBJECT_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_CREATEDELETE_OBJECT_EVENT = _ETW_CREATEDELETE_OBJECT_EVENT;
pub type PETW_CREATEDELETE_OBJECT_EVENT = *mut _ETW_CREATEDELETE_OBJECT_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_WAKE_COUNTER_EVENT {
   pub Object: PVOID,
   pub Tag: ULONG_PTR,
   pub ProcessId: ULONG,
   pub Count: LONG,
}
impl Default for _ETW_WAKE_COUNTER_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_WAKE_COUNTER_EVENT = _ETW_WAKE_COUNTER_EVENT;
pub type PETW_WAKE_COUNTER_EVENT = *mut _ETW_WAKE_COUNTER_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_COMMON {
   pub Header: SYSTEM_TRACE_HEADER,
   pub Handle: PVOID,
}
impl Default for _ETW_HEAP_EVENT_COMMON {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_COMMON = _ETW_HEAP_EVENT_COMMON;
pub type PETW_HEAP_EVENT_COMMON = *mut _ETW_HEAP_EVENT_COMMON;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_ALLOC {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub Size: SIZE_T,
   pub Address: PVOID,
   pub Source: ULONG,
}
impl Default for _ETW_HEAP_EVENT_ALLOC {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_ALLOC = _ETW_HEAP_EVENT_ALLOC;
pub type PETW_HEAP_EVENT_ALLOC = *mut _ETW_HEAP_EVENT_ALLOC;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_FREE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub Address: PVOID,
   pub Source: ULONG,
}
impl Default for _ETW_HEAP_EVENT_FREE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_FREE = _ETW_HEAP_EVENT_FREE;
pub type PETW_HEAP_EVENT_FREE = *mut _ETW_HEAP_EVENT_FREE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_REALLOC {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub NewAddress: PVOID,
   pub OldAddress: PVOID,
   pub NewSize: SIZE_T,
   pub OldSize: SIZE_T,
   pub Source: ULONG,
}
impl Default for _ETW_HEAP_EVENT_REALLOC {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_REALLOC = _ETW_HEAP_EVENT_REALLOC;
pub type PETW_HEAP_EVENT_REALLOC = *mut _ETW_HEAP_EVENT_REALLOC;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_EXPANSION {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub CommittedSize: SIZE_T,
   pub Address: PVOID,
   pub FreeSpace: SIZE_T,
   pub CommittedSpace: SIZE_T,
   pub ReservedSpace: SIZE_T,
   pub NoOfUCRs: ULONG,
   pub AllocatedSpace: SIZE_T,
}
impl Default for _ETW_HEAP_EVENT_EXPANSION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_EXPANSION = _ETW_HEAP_EVENT_EXPANSION;
pub type PETW_HEAP_EVENT_EXPANSION = *mut _ETW_HEAP_EVENT_EXPANSION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_CONTRACTION {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub DeCommitSize: SIZE_T,
   pub DeCommitAddress: PVOID,
   pub FreeSpace: SIZE_T,
   pub CommittedSpace: SIZE_T,
   pub ReservedSpace: SIZE_T,
   pub NoOfUCRs: ULONG,
   pub AllocatedSpace: SIZE_T,
}
impl Default for _ETW_HEAP_EVENT_CONTRACTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_CONTRACTION = _ETW_HEAP_EVENT_CONTRACTION;
pub type PETW_HEAP_EVENT_CONTRACTION = *mut _ETW_HEAP_EVENT_CONTRACTION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_CREATE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub Flags: ULONG,
   pub ReserveSize: SIZE_T,
   pub CommitSize: SIZE_T,
   pub AllocatedSize: SIZE_T,
}
impl Default for _ETW_HEAP_EVENT_CREATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_CREATE = _ETW_HEAP_EVENT_CREATE;
pub type PETW_HEAP_EVENT_CREATE = *mut _ETW_HEAP_EVENT_CREATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_EVENT_COMMIT_DECOMMIT {
   pub HeapHandle: PVOID,
   pub Block: PVOID,
   pub Size: SIZE_T,
   pub Caller: ULONG,
}
impl Default for _HEAP_EVENT_COMMIT_DECOMMIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_EVENT_COMMIT_DECOMMIT = _HEAP_EVENT_COMMIT_DECOMMIT;
pub type PHEAP_EVENT_COMMIT_DECOMMIT = *mut _HEAP_EVENT_COMMIT_DECOMMIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_COMMIT_DECOMMIT {
   pub Header: SYSTEM_TRACE_HEADER,
   pub Event: HEAP_EVENT_COMMIT_DECOMMIT,
}
impl Default for _HEAP_COMMIT_DECOMMIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_COMMIT_DECOMMIT = _HEAP_COMMIT_DECOMMIT;
pub type PHEAP_COMMIT_DECOMMIT = *mut _HEAP_COMMIT_DECOMMIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_EVENT_SUBSEGMENT_ALLOC_FREE {
   pub HeapHandle: PVOID,
   pub SubSegment: PVOID,
   pub SubSegmentSize: SIZE_T,
   pub BlockSize: SIZE_T,
}
impl Default for _HEAP_EVENT_SUBSEGMENT_ALLOC_FREE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_EVENT_SUBSEGMENT_ALLOC_FREE = _HEAP_EVENT_SUBSEGMENT_ALLOC_FREE;
pub type PHEAP_EVENT_SUBSEGMENT_ALLOC_FREE = *mut _HEAP_EVENT_SUBSEGMENT_ALLOC_FREE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_SUBSEGMENT_FREE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub Event: HEAP_EVENT_SUBSEGMENT_ALLOC_FREE,
}
impl Default for _HEAP_SUBSEGMENT_FREE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_SUBSEGMENT_FREE = _HEAP_SUBSEGMENT_FREE;
pub type PHEAP_SUBSEGMENT_FREE = *mut _HEAP_SUBSEGMENT_FREE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_SUBSEGMENT_ALLOC {
   pub Header: SYSTEM_TRACE_HEADER,
   pub Event: HEAP_EVENT_SUBSEGMENT_ALLOC_FREE,
}
impl Default for _HEAP_SUBSEGMENT_ALLOC {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_SUBSEGMENT_ALLOC = _HEAP_SUBSEGMENT_ALLOC;
pub type PHEAP_SUBSEGMENT_ALLOC = *mut _HEAP_SUBSEGMENT_ALLOC;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _HEAP_SUBSEGMENT_INIT {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub SubSegment: PVOID,
   pub BlockSize: SIZE_T,
   pub BlockCount: SIZE_T,
   pub AffinityIndex: ULONG,
}
impl Default for _HEAP_SUBSEGMENT_INIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_SUBSEGMENT_INIT = _HEAP_SUBSEGMENT_INIT;
pub type PHEAP_SUBSEGMENT_INIT = *mut _HEAP_SUBSEGMENT_INIT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _HEAP_AFFINITY_MANAGER_ENABLE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub BucketIndex: ULONG,
}
impl Default for _HEAP_AFFINITY_MANAGER_ENABLE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_AFFINITY_MANAGER_ENABLE = _HEAP_AFFINITY_MANAGER_ENABLE;
pub type PHEAP_AFFINITY_MANAGER_ENABLE = *mut _HEAP_AFFINITY_MANAGER_ENABLE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _HEAP_AFFINITY_SLOT_ASSIGN {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub SubSegment: PVOID,
   pub SlotIndex: ULONG,
}
impl Default for _HEAP_AFFINITY_SLOT_ASSIGN {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_AFFINITY_SLOT_ASSIGN = _HEAP_AFFINITY_SLOT_ASSIGN;
pub type PHEAP_AFFINITY_SLOT_ASSIGN = *mut _HEAP_AFFINITY_SLOT_ASSIGN;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _HEAP_REUSE_THRESHOLD_ACTIVATED {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub SubSegment: PVOID,
   pub BucketIndex: ULONG,
}
impl Default for _HEAP_REUSE_THRESHOLD_ACTIVATED {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_REUSE_THRESHOLD_ACTIVATED = _HEAP_REUSE_THRESHOLD_ACTIVATED;
pub type PHEAP_REUSE_THRESHOLD_ACTIVATED = *mut _HEAP_REUSE_THRESHOLD_ACTIVATED;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _HEAP_SUBSEGMENT_ACTIVATED {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub SubSegment: PVOID,
}
impl Default for _HEAP_SUBSEGMENT_ACTIVATED {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_SUBSEGMENT_ACTIVATED = _HEAP_SUBSEGMENT_ACTIVATED;
pub type PHEAP_SUBSEGMENT_ACTIVATED = *mut _HEAP_SUBSEGMENT_ACTIVATED;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_SNAPSHOT {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub FreeSpace: SIZE_T,
   pub CommittedSpace: SIZE_T,
   pub ReservedSpace: SIZE_T,
   pub Flags: ULONG,
   pub ProcessId: ULONG,
   pub LargeUCRSpace: SIZE_T,
   pub FreeListLength: ULONG,
   pub UCRLength: ULONG,
   pub AllocatedSpace: SIZE_T,
}
impl Default for _ETW_HEAP_EVENT_SNAPSHOT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_SNAPSHOT = _ETW_HEAP_EVENT_SNAPSHOT;
pub type PETW_HEAP_EVENT_SNAPSHOT = *mut _ETW_HEAP_EVENT_SNAPSHOT;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_HEAP_EVENT_RUNDOWN_RANGE {
   pub Address: PVOID,
   pub Size: SIZE_T,
}
impl Default for _ETW_HEAP_EVENT_RUNDOWN_RANGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_RUNDOWN_RANGE = _ETW_HEAP_EVENT_RUNDOWN_RANGE;
pub type PETW_HEAP_EVENT_RUNDOWN_RANGE = *mut _ETW_HEAP_EVENT_RUNDOWN_RANGE;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_HEAP_EVENT_RUNDOWN {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
   pub Flags: ULONG,
   pub ProcessId: ULONG,
   pub RangeCount: ULONG,
   pub Reserved: ULONG,
   pub Ranges: [ETW_HEAP_EVENT_RUNDOWN_RANGE; 1usize],
}
impl Default for _ETW_HEAP_EVENT_RUNDOWN {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_HEAP_EVENT_RUNDOWN = _ETW_HEAP_EVENT_RUNDOWN;
pub type PETW_HEAP_EVENT_RUNDOWN = *mut _ETW_HEAP_EVENT_RUNDOWN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_EVENT_RANGE_CREATE {
   pub HeapHandle: PVOID,
   pub FirstRangeSize: SIZE_T,
   pub Flags: ULONG,
}
impl Default for _HEAP_EVENT_RANGE_CREATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_EVENT_RANGE_CREATE = _HEAP_EVENT_RANGE_CREATE;
pub type PHEAP_EVENT_RANGE_CREATE = *mut _HEAP_EVENT_RANGE_CREATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_EVENT_RANGE {
   pub HeapHandle: PVOID,
   pub Address: PVOID,
   pub Size: SIZE_T,
}
impl Default for _HEAP_EVENT_RANGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_EVENT_RANGE = _HEAP_EVENT_RANGE;
pub type PHEAP_EVENT_RANGE = *mut _HEAP_EVENT_RANGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_RANGE_CREATE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub Event: HEAP_EVENT_RANGE_CREATE,
}
impl Default for _HEAP_RANGE_CREATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_RANGE_CREATE = _HEAP_RANGE_CREATE;
pub type PHEAP_RANGE_CREATE = *mut _HEAP_RANGE_CREATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_RANGE_DESTROY {
   pub Header: SYSTEM_TRACE_HEADER,
   pub HeapHandle: PVOID,
}
impl Default for _HEAP_RANGE_DESTROY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_RANGE_DESTROY = _HEAP_RANGE_DESTROY;
pub type PHEAP_RANGE_DESTROY = *mut _HEAP_RANGE_DESTROY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HEAP_RANGE_LOG {
   pub Header: SYSTEM_TRACE_HEADER,
   pub Range: HEAP_EVENT_RANGE,
}
impl Default for _HEAP_RANGE_LOG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type HEAP_RANGE_LOG = _HEAP_RANGE_LOG;
pub type PHEAP_RANGE_LOG = *mut _HEAP_RANGE_LOG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_CRITSEC_EVENT_COLLISION {
   pub Header: SYSTEM_TRACE_HEADER,
   pub LockCount: ULONG,
   pub SpinCount: ULONG,
   pub OwningThread: PVOID,
   pub Address: PVOID,
}
impl Default for _ETW_CRITSEC_EVENT_COLLISION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_CRITSEC_EVENT_COLLISION = _ETW_CRITSEC_EVENT_COLLISION;
pub type PETW_CRITSEC_EVENT_COLLISION = *mut _ETW_CRITSEC_EVENT_COLLISION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_CRITSEC_EVENT_INIT {
   pub Header: SYSTEM_TRACE_HEADER,
   pub SpinCount: PVOID,
   pub Address: PVOID,
}
impl Default for _ETW_CRITSEC_EVENT_INIT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_CRITSEC_EVENT_INIT = _ETW_CRITSEC_EVENT_INIT;
pub type PETW_CRITSEC_EVENT_INIT = *mut _ETW_CRITSEC_EVENT_INIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STACK_WALK_EVENT_DATA {
   pub TimeStamp: ULONGLONG,
   pub ProcessId: ULONG,
   pub ThreadId: ULONG,
   pub Addresses: [PVOID; 1usize],
}
impl Default for _STACK_WALK_EVENT_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type STACK_WALK_EVENT_DATA = _STACK_WALK_EVENT_DATA;
pub type PSTACK_WALK_EVENT_DATA = *mut _STACK_WALK_EVENT_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LOAD_DLL_EVENT_DATA {
   pub ImageName: [WCHAR; 1usize],
}
pub type LOAD_DLL_EVENT_DATA = _LOAD_DLL_EVENT_DATA;
pub type PLOAD_DLL_EVENT_DATA = *mut _LOAD_DLL_EVENT_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PERF_COUNTERS {
   pub OpenedKeys: ULONGLONG,
   pub DelayCloseKCBs: ULONGLONG,
   pub PrivateAllocPages: ULONGLONG,
   pub PrivateAllocFree: ULONGLONG,
   pub PrivateAllocUsed: ULONGLONG,
   pub LookupCacheHit: ULONGLONG,
   pub LookupCacheMissFound: ULONGLONG,
   pub LookupCacheMissNotFound: ULONGLONG,
   pub ViewMap: ULONGLONG,
   pub ViewUnMap: ULONGLONG,
   pub HiveShrink: ULONGLONG,
}
pub type CM_PERF_COUNTERS = _CM_PERF_COUNTERS;
pub type PCM_PERF_COUNTERS = *mut _CM_PERF_COUNTERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CI_LOG_SCHEDULER_EVENT {
   pub Header: EVENT_TRACE_HEADER,
   pub ProcessId: ULONG,
   pub ThreadId: ULONG,
   pub Priority: ULONG,
   pub TaskIndex: ULONG,
}
impl Default for _CI_LOG_SCHEDULER_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CI_LOG_SCHEDULER_EVENT = _CI_LOG_SCHEDULER_EVENT;
pub type PCI_LOG_SCHEDULER_EVENT = *mut _CI_LOG_SCHEDULER_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CI_LOG_SCHEDULER_WAKEUP {
   pub Header: EVENT_TRACE_HEADER,
   pub Reason: ULONG,
}
impl Default for _CI_LOG_SCHEDULER_WAKEUP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CI_LOG_SCHEDULER_WAKEUP = _CI_LOG_SCHEDULER_WAKEUP;
pub type PCI_LOG_SCHEDULER_WAKEUP = *mut _CI_LOG_SCHEDULER_WAKEUP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CI_LOG_SCHEDULER_SLEEP {
   pub Header: EVENT_TRACE_HEADER,
}
impl Default for _CI_LOG_SCHEDULER_SLEEP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CI_LOG_SCHEDULER_SLEEP = _CI_LOG_SCHEDULER_SLEEP;
pub type PCI_LOG_SCHEDULER_SLEEP = *mut _CI_LOG_SCHEDULER_SLEEP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CI_LOG_SCHEDULER_SLEEP_RESPONSE {
   pub Header: EVENT_TRACE_HEADER,
}
impl Default for _CI_LOG_SCHEDULER_SLEEP_RESPONSE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CI_LOG_SCHEDULER_SLEEP_RESPONSE = _CI_LOG_SCHEDULER_SLEEP_RESPONSE;
pub type PCI_LOG_SCHEDULER_SLEEP_RESPONSE = *mut _CI_LOG_SCHEDULER_SLEEP_RESPONSE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CI_LOG_MMCSS_START {
   pub Header: EVENT_TRACE_HEADER,
}
impl Default for _CI_LOG_MMCSS_START {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CI_LOG_MMCSS_START = _CI_LOG_MMCSS_START;
pub type PCI_LOG_MMCSS_START = *mut _CI_LOG_MMCSS_START;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CI_LOG_MMCSS_STOP {
   pub Header: EVENT_TRACE_HEADER,
}
impl Default for _CI_LOG_MMCSS_STOP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CI_LOG_MMCSS_STOP = _CI_LOG_MMCSS_STOP;
pub type PCI_LOG_MMCSS_STOP = *mut _CI_LOG_MMCSS_STOP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_UMS_EVENT_DIRECTED_SWITCH_START {
   pub ProcessId: ULONG,
   pub ScheduledThreadId: ULONG,
   pub PrimaryThreadId: ULONG,
   pub SwitchFlags: ULONG,
}
pub type ETW_UMS_EVENT_DIRECTED_SWITCH_START = _ETW_UMS_EVENT_DIRECTED_SWITCH_START;
pub type PETW_UMS_EVENT_DIRECTED_SWITCH_START = *mut _ETW_UMS_EVENT_DIRECTED_SWITCH_START;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_UMS_EVENT_DIRECTED_SWITCH_END {
   pub ProcessId: ULONG,
   pub ScheduledThreadId: ULONG,
   pub PrimaryThreadId: ULONG,
   pub SwitchFlags: ULONG,
}
pub type ETW_UMS_EVENT_DIRECTED_SWITCH_END = _ETW_UMS_EVENT_DIRECTED_SWITCH_END;
pub type PETW_UMS_EVENT_DIRECTED_SWITCH_END = *mut _ETW_UMS_EVENT_DIRECTED_SWITCH_END;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_UMS_EVENT_PARK {
   pub ProcessId: ULONG,
   pub ScheduledThreadId: ULONG,
   pub ParkFlags: ULONG,
}
pub type ETW_UMS_EVENT_PARK = _ETW_UMS_EVENT_PARK;
pub type PETW_UMS_EVENT_PARK = *mut _ETW_UMS_EVENT_PARK;
#[repr(C)]
pub struct _ETW_UMS_EVENT_DISASSOCIATE {
   pub ProcessId: ULONG,
   pub ScheduledThreadId: ULONG,
   pub PrimaryThreadId: ULONG,
   pub UmsApcControlFlags: ULONG,
   pub Status: NTSTATUS,
}
impl Default for _ETW_UMS_EVENT_DISASSOCIATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_UMS_EVENT_DISASSOCIATE = _ETW_UMS_EVENT_DISASSOCIATE;
pub type PETW_UMS_EVENT_DISASSOCIATE = *mut _ETW_UMS_EVENT_DISASSOCIATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_UMS_EVENT_CONTEXT_SWITCH {
   pub Header: SYSTEM_TRACE_HEADER,
   pub ScheduledThreadId: ULONG,
   pub SwitchCount: ULONG,
   pub KernelYieldCount: ULONG,
   pub MixedYieldCount: ULONG,
   pub YieldCount: ULONG,
}
impl Default for _ETW_UMS_EVENT_CONTEXT_SWITCH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_UMS_EVENT_CONTEXT_SWITCH = _ETW_UMS_EVENT_CONTEXT_SWITCH;
pub type PETW_UMS_EVENT_CONTEXT_SWITCH = *mut _ETW_UMS_EVENT_CONTEXT_SWITCH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SET_TIMER_EVENT {
   pub ExpectedDueTime: ULONG64,
   pub TimerAddress: ULONG_PTR,
   pub TargetProcessorGroup: USHORT,
   pub TargetProcessorIndex: UCHAR,
   pub Flags: UCHAR,
   pub Period: ULONG,
   pub EncodedDelay: UCHAR,
   pub Reserved0: UCHAR,
   pub Reserved1: USHORT,
}
pub type ETW_SET_TIMER_EVENT = _ETW_SET_TIMER_EVENT;
pub type PETW_SET_TIMER_EVENT = *mut _ETW_SET_TIMER_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_CANCEL_TIMER_EVENT {
   pub TimerAddress: ULONG_PTR,
}
pub type ETW_CANCEL_TIMER_EVENT = _ETW_CANCEL_TIMER_EVENT;
pub type PETW_CANCEL_TIMER_EVENT = *mut _ETW_CANCEL_TIMER_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_TIMER_EXPIRATION_EVENT {
   pub ExpectedDueTime: ULONG64,
   pub TimerAddress: ULONG_PTR,
   pub DeferredRoutine: ULONG_PTR,
   pub EncodedDelay: UCHAR,
}
pub type ETW_TIMER_EXPIRATION_EVENT = _ETW_TIMER_EXPIRATION_EVENT;
pub type PETW_TIMER_EXPIRATION_EVENT = *mut _ETW_TIMER_EXPIRATION_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_TIMER_EXPIRATION_START_EVENT {
   pub InterruptTime: ULONG64,
}
pub type ETW_TIMER_EXPIRATION_START_EVENT = _ETW_TIMER_EXPIRATION_START_EVENT;
pub type PETW_TIMER_EXPIRATION_START_EVENT = *mut _ETW_TIMER_EXPIRATION_START_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SET_KTIMER2_EVENT {
   pub DueTime: ULONG64,
   pub MaximumDueTime: ULONG64,
   pub Period: ULONG64,
   pub TimerKey: ULONG_PTR,
   pub Callback: ULONG_PTR,
   pub CallbackContextKey: ULONG_PTR,
   pub Flags: UCHAR,
}
pub type ETW_SET_KTIMER2_EVENT = _ETW_SET_KTIMER2_EVENT;
pub type PETW_SET_KTIMER2_EVENT = *mut _ETW_SET_KTIMER2_EVENT;
pub type ETW_KTIMER2_EXPIRATION_EVENT = ETW_SET_KTIMER2_EVENT;
pub type PETW_KTIMER2_EXPIRATION_EVENT = *mut ETW_SET_KTIMER2_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_CANCEL_KTIMER2_EVENT {
   pub TimerKey: ULONG_PTR,
}
pub type ETW_CANCEL_KTIMER2_EVENT = _ETW_CANCEL_KTIMER2_EVENT;
pub type PETW_CANCEL_KTIMER2_EVENT = *mut _ETW_CANCEL_KTIMER2_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_DISABLE_KTIMER2_EVENT {
   pub TimerKey: ULONG_PTR,
   pub DisableCallback: ULONG_PTR,
   pub DisableContextKey: ULONG_PTR,
   pub Flags: UCHAR,
}
pub type ETW_DISABLE_KTIMER2_EVENT = _ETW_DISABLE_KTIMER2_EVENT;
pub type PETW_DISABLE_KTIMER2_EVENT = *mut _ETW_DISABLE_KTIMER2_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_FINALIZE_KTIMER2_EVENT {
   pub TimerKey: ULONG_PTR,
   pub DisableCallback: ULONG_PTR,
   pub DisableContextKey: ULONG_PTR,
}
pub type ETW_FINALIZE_KTIMER2_EVENT = _ETW_FINALIZE_KTIMER2_EVENT;
pub type PETW_FINALIZE_KTIMER2_EVENT = *mut _ETW_FINALIZE_KTIMER2_EVENT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_DYNAMIC_TICK_VETO_REASON {
   DynamicTickVetoNone = 0,
   DynamicTickVetoProcBusy = 1,
   DynamicTickVetoSoftwareTimer = 2,
   DynamicTickVetoClockConstraint = 3,
   DynamicTickVetoClockOutOfSync = 4,
   DynamicTickVetoClockUpdateFailed = 5,
   DynamicTickVetoMax = 6,
}
pub use self::_PERFINFO_DYNAMIC_TICK_VETO_REASON as PERFINFO_DYNAMIC_TICK_VETO_REASON;
pub type PPERFINFO_DYNAMIC_TICK_VETO_REASON = *mut _PERFINFO_DYNAMIC_TICK_VETO_REASON;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_DYNAMIC_TICK_DISABLE_REASON {
   DynamicTickDisableReasonNone = 0,
   DynamicTickDisableReasonBcdOverride = 1,
   DynamicTickDisableReasonNoHwSupport = 2,
   DynamicTickDisableReasonEmOverride = 3,
   DynamicTickDisableReasonMax = 4,
}
pub use self::_PERFINFO_DYNAMIC_TICK_DISABLE_REASON as PERFINFO_DYNAMIC_TICK_DISABLE_REASON;
pub type PPERFINFO_DYNAMIC_TICK_DISABLE_REASON = *mut _PERFINFO_DYNAMIC_TICK_DISABLE_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETW_CLOCK_CONFIGURATION_EVENT {
   pub KnownType: ULONG,
   pub Capabilities: ULONG,
   pub DisableReason: PERFINFO_DYNAMIC_TICK_DISABLE_REASON,
}
impl Default for _ETW_CLOCK_CONFIGURATION_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_CLOCK_CONFIGURATION_EVENT = _ETW_CLOCK_CONFIGURATION_EVENT;
pub type PETW_CLOCK_CONFIGURATION_EVENT = *mut _ETW_CLOCK_CONFIGURATION_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_CLOCK_TIME_UPDATE {
   pub InterruptTime: ULONG64,
   pub ClockOwner: ULONG,
}
pub type ETW_CLOCK_TIME_UPDATE = _ETW_CLOCK_TIME_UPDATE;
pub type PETW_CLOCK_TIME_UPDATE = *mut _ETW_CLOCK_TIME_UPDATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_CLOCK_STATE_CHANGE_EVENT {
   pub NewState: UCHAR,
   pub PrevState: UCHAR,
   pub Reserved: [UCHAR; 6usize],
   pub __bindgen_anon_1: _ETW_CLOCK_STATE_CHANGE_EVENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_CLOCK_STATE_CHANGE_EVENT__bindgen_ty_1 {
   pub __bindgen_anon_1: _ETW_CLOCK_STATE_CHANGE_EVENT__bindgen_ty_1__bindgen_ty_1,
   pub NextClockUpdateTime: ULONG64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_CLOCK_STATE_CHANGE_EVENT__bindgen_ty_1__bindgen_ty_1 {
   pub DeliveredIncrement: ULONG64,
   pub RequestedIncrement: ULONG64,
}
impl Default for _ETW_CLOCK_STATE_CHANGE_EVENT__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ETW_CLOCK_STATE_CHANGE_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_CLOCK_STATE_CHANGE_EVENT = _ETW_CLOCK_STATE_CHANGE_EVENT;
pub type PETW_CLOCK_STATE_CHANGE_EVENT = *mut _ETW_CLOCK_STATE_CHANGE_EVENT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_PER_SESSION_QUOTA {
   pub SessionId: ULONG,
   pub CpuShareWeight: ULONG,
   pub CapturedWeightData: LONGLONG,
   pub CyclesAccumulated: ULONG64,
}
pub type ETW_PER_SESSION_QUOTA = _ETW_PER_SESSION_QUOTA;
pub type PETW_PER_SESSION_QUOTA = *mut _ETW_PER_SESSION_QUOTA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_DFSS_START_NEW_INTERVAL {
   pub CurrentGeneration: ULONG,
   pub SessionCount: ULONG,
   pub TotalCycleCredit: ULONG64,
   pub TotalCyclesAccumulated: ULONG64,
   pub SessionQuota: [ETW_PER_SESSION_QUOTA; 1usize],
}
pub type ETW_DFSS_START_NEW_INTERVAL = _ETW_DFSS_START_NEW_INTERVAL;
pub type PETW_DFSS_START_NEW_INTERVAL = *mut _ETW_DFSS_START_NEW_INTERVAL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_DFSS_RELEASE_THREAD_ON_IDLE {
   pub CurrentGeneration: ULONG,
   pub SessionSelectedToRun: ULONG,
   pub CycleBaseAllowance: ULONG64,
   pub CyclesRemaining: LONG64,
}
pub type ETW_DFSS_RELEASE_THREAD_ON_IDLE = _ETW_DFSS_RELEASE_THREAD_ON_IDLE;
pub type PETW_DFSS_RELEASE_THREAD_ON_IDLE = *mut _ETW_DFSS_RELEASE_THREAD_ON_IDLE;
#[repr(C)]
pub struct _ETW_CPU_CACHE_FLUSH_EVENT {
   pub Address: PVOID,
   pub Bytes: SIZE_T,
   pub Clean: BOOLEAN,
   pub FullFlush: BOOLEAN,
   pub Rectangle: BOOLEAN,
   pub Reserved0: BOOLEAN,
   pub Reserved1: ULONG,
}
impl Default for _ETW_CPU_CACHE_FLUSH_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_CPU_CACHE_FLUSH_EVENT = _ETW_CPU_CACHE_FLUSH_EVENT;
pub type PETW_CPU_CACHE_FLUSH_EVENT = *mut _ETW_CPU_CACHE_FLUSH_EVENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_CALLBACK_ENQUEUE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub PoolId: PVOID,
   pub TaskId: PVOID,
   pub Callback: PVOID,
   pub Context: PVOID,
   pub SubProcessTag: PVOID,
}
impl Default for _ETW_TP_EVENT_CALLBACK_ENQUEUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_CALLBACK_ENQUEUE = _ETW_TP_EVENT_CALLBACK_ENQUEUE;
pub type PETW_TP_EVENT_CALLBACK_ENQUEUE = *mut _ETW_TP_EVENT_CALLBACK_ENQUEUE;
pub type ETW_TP_EVENT_CALLBACK_DEQUEUE = ETW_TP_EVENT_CALLBACK_ENQUEUE;
pub type PETW_TP_EVENT_CALLBACK_DEQUEUE = *mut ETW_TP_EVENT_CALLBACK_ENQUEUE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_CALLBACK_START {
   pub Header: SYSTEM_TRACE_HEADER,
   pub PoolId: PVOID,
   pub TaskId: PVOID,
   pub Callback: PVOID,
   pub Context: PVOID,
   pub SubProcessTag: PVOID,
}
impl Default for _ETW_TP_EVENT_CALLBACK_START {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_CALLBACK_START = _ETW_TP_EVENT_CALLBACK_START;
pub type PETW_TP_EVENT_CALLBACK_START = *mut _ETW_TP_EVENT_CALLBACK_START;
pub type ETW_TP_EVENT_CALLBACK_STOP = ETW_TP_EVENT_CALLBACK_START;
pub type PETW_TP_EVENT_CALLBACK_STOP = *mut ETW_TP_EVENT_CALLBACK_START;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_CALLBACK_CANCEL {
   pub Header: SYSTEM_TRACE_HEADER,
   pub PoolId: PVOID,
   pub TaskId: PVOID,
   pub Callback: PVOID,
   pub Context: PVOID,
   pub SubProcessTag: PVOID,
   pub CancelCount: ULONG,
}
impl Default for _ETW_TP_EVENT_CALLBACK_CANCEL {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_CALLBACK_CANCEL = _ETW_TP_EVENT_CALLBACK_CANCEL;
pub type PETW_TP_EVENT_CALLBACK_CANCEL = *mut _ETW_TP_EVENT_CALLBACK_CANCEL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_POOL_CREATE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub PoolId: PVOID,
}
impl Default for _ETW_TP_EVENT_POOL_CREATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_POOL_CREATE = _ETW_TP_EVENT_POOL_CREATE;
pub type PETW_TP_EVENT_POOL_CREATE = *mut _ETW_TP_EVENT_POOL_CREATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_POOL_CLOSE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub PoolId: PVOID,
}
impl Default for _ETW_TP_EVENT_POOL_CLOSE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_POOL_CLOSE = _ETW_TP_EVENT_POOL_CLOSE;
pub type PETW_TP_EVENT_POOL_CLOSE = *mut _ETW_TP_EVENT_POOL_CLOSE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_POOL_TH_MIN_SET {
   pub Header: SYSTEM_TRACE_HEADER,
   pub PoolId: PVOID,
   pub ThreadNum: ULONG,
}
impl Default for _ETW_TP_EVENT_POOL_TH_MIN_SET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_POOL_TH_MIN_SET = _ETW_TP_EVENT_POOL_TH_MIN_SET;
pub type PETW_TP_EVENT_POOL_TH_MIN_SET = *mut _ETW_TP_EVENT_POOL_TH_MIN_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_POOL_TH_MAX_SET {
   pub Header: SYSTEM_TRACE_HEADER,
   pub PoolId: PVOID,
   pub ThreadNum: ULONG,
}
impl Default for _ETW_TP_EVENT_POOL_TH_MAX_SET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_POOL_TH_MAX_SET = _ETW_TP_EVENT_POOL_TH_MAX_SET;
pub type PETW_TP_EVENT_POOL_TH_MAX_SET = *mut _ETW_TP_EVENT_POOL_TH_MAX_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_WORKER_NUMANODE_SWITCH {
   pub Header: SYSTEM_TRACE_HEADER,
   pub PoolId: PVOID,
   pub CurrentNode: ULONG,
   pub NextNode: ULONG,
   pub CurrentGroup: USHORT,
   pub NextGroup: USHORT,
   pub CurrentWorkerCount: ULONG,
   pub NextWorkerCount: ULONG,
}
impl Default for _ETW_TP_EVENT_WORKER_NUMANODE_SWITCH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_WORKER_NUMANODE_SWITCH = _ETW_TP_EVENT_WORKER_NUMANODE_SWITCH;
pub type PETW_TP_EVENT_WORKER_NUMANODE_SWITCH = *mut _ETW_TP_EVENT_WORKER_NUMANODE_SWITCH;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_TIMER_SET {
   pub Header: SYSTEM_TRACE_HEADER,
   pub DueTime: LONG64,
   pub SubQueue: PVOID,
   pub Timer: PVOID,
   pub Period: ULONG,
   pub WindowLength: ULONG,
   pub Absolute: ULONG,
}
impl Default for _ETW_TP_EVENT_TIMER_SET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_TIMER_SET = _ETW_TP_EVENT_TIMER_SET;
pub type PETW_TP_EVENT_TIMER_SET = *mut _ETW_TP_EVENT_TIMER_SET;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_TIMER_CANCELLED {
   pub Header: SYSTEM_TRACE_HEADER,
   pub SubQueue: PVOID,
   pub Timer: PVOID,
}
impl Default for _ETW_TP_EVENT_TIMER_CANCELLED {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_TIMER_CANCELLED = _ETW_TP_EVENT_TIMER_CANCELLED;
pub type PETW_TP_EVENT_TIMER_CANCELLED = *mut _ETW_TP_EVENT_TIMER_CANCELLED;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_TIMER_SET_NTTIMER {
   pub Header: SYSTEM_TRACE_HEADER,
   pub DueTime: LONG64,
   pub SubQueue: PVOID,
   pub TolerableDelay: ULONG,
}
impl Default for _ETW_TP_EVENT_TIMER_SET_NTTIMER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_TIMER_SET_NTTIMER = _ETW_TP_EVENT_TIMER_SET_NTTIMER;
pub type PETW_TP_EVENT_TIMER_SET_NTTIMER = *mut _ETW_TP_EVENT_TIMER_SET_NTTIMER;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_TIMER_CANCEL_NTTIMER {
   pub Header: SYSTEM_TRACE_HEADER,
   pub SubQueue: PVOID,
}
impl Default for _ETW_TP_EVENT_TIMER_CANCEL_NTTIMER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_TIMER_CANCEL_NTTIMER = _ETW_TP_EVENT_TIMER_CANCEL_NTTIMER;
pub type PETW_TP_EVENT_TIMER_CANCEL_NTTIMER = *mut _ETW_TP_EVENT_TIMER_CANCEL_NTTIMER;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_TIMER_EXPIRATION_BEGIN {
   pub Header: SYSTEM_TRACE_HEADER,
   pub SubQueue: PVOID,
}
impl Default for _ETW_TP_EVENT_TIMER_EXPIRATION_BEGIN {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_TIMER_EXPIRATION_BEGIN = _ETW_TP_EVENT_TIMER_EXPIRATION_BEGIN;
pub type PETW_TP_EVENT_TIMER_EXPIRATION_BEGIN = *mut _ETW_TP_EVENT_TIMER_EXPIRATION_BEGIN;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_TIMER_EXPIRATION_END {
   pub Header: SYSTEM_TRACE_HEADER,
   pub SubQueue: PVOID,
}
impl Default for _ETW_TP_EVENT_TIMER_EXPIRATION_END {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_TIMER_EXPIRATION_END = _ETW_TP_EVENT_TIMER_EXPIRATION_END;
pub type PETW_TP_EVENT_TIMER_EXPIRATION_END = *mut _ETW_TP_EVENT_TIMER_EXPIRATION_END;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _ETW_TP_EVENT_TIMER_EXPIRATION {
   pub Header: SYSTEM_TRACE_HEADER,
   pub DueTime: LONG64,
   pub SubQueue: PVOID,
   pub Timer: PVOID,
   pub Period: ULONG,
   pub WindowLength: ULONG,
}
impl Default for _ETW_TP_EVENT_TIMER_EXPIRATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_TP_EVENT_TIMER_EXPIRATION = _ETW_TP_EVENT_TIMER_EXPIRATION;
pub type PETW_TP_EVENT_TIMER_EXPIRATION = *mut _ETW_TP_EVENT_TIMER_EXPIRATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_THREAD_EVENT_SUBPROCESSTAG {
   pub Header: SYSTEM_TRACE_HEADER,
   pub OldTag: ULONG,
   pub NewTag: ULONG,
}
impl Default for _ETW_THREAD_EVENT_SUBPROCESSTAG {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_THREAD_EVENT_SUBPROCESSTAG = _ETW_THREAD_EVENT_SUBPROCESSTAG;
pub type PETW_THREAD_EVENT_SUBPROCESSTAG = *mut _ETW_THREAD_EVENT_SUBPROCESSTAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_WNF_EVENT_SUBSCRIBE {
   pub Header: SYSTEM_TRACE_HEADER,
   pub StateName: LARGE_INTEGER,
   pub Subscription: PVOID,
   pub NameSub: PVOID,
   pub Callback: PVOID,
   pub RefCount: ULONG,
   pub DeliveryFlags: ULONG,
}
impl Default for _ETW_WNF_EVENT_SUBSCRIBE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_WNF_EVENT_SUBSCRIBE = _ETW_WNF_EVENT_SUBSCRIBE;
pub type PETW_WNF_EVENT_SUBSCRIBE = *mut _ETW_WNF_EVENT_SUBSCRIBE;
pub type ETW_WNF_EVENT_UNSUBSCRIBE = ETW_WNF_EVENT_SUBSCRIBE;
pub type PETW_WNF_EVENT_UNSUBSCRIBE = *mut ETW_WNF_EVENT_SUBSCRIBE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_WNF_EVENT_CALLBACK {
   pub Header: SYSTEM_TRACE_HEADER,
   pub StateName: LARGE_INTEGER,
   pub Subscription: PVOID,
   pub NameSub: PVOID,
   pub Callback: PVOID,
   pub ChangeStamp: ULONG,
   pub DeliveryFlags: ULONG,
   pub Return: ULONG,
}
impl Default for _ETW_WNF_EVENT_CALLBACK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_WNF_EVENT_CALLBACK = _ETW_WNF_EVENT_CALLBACK;
pub type PETW_WNF_EVENT_CALLBACK = *mut _ETW_WNF_EVENT_CALLBACK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_WNF_EVENT_PUBLISH {
   pub Header: SYSTEM_TRACE_HEADER,
   pub StateName: LARGE_INTEGER,
   pub DataLength: ULONG,
}
impl Default for _ETW_WNF_EVENT_PUBLISH {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_WNF_EVENT_PUBLISH = _ETW_WNF_EVENT_PUBLISH;
pub type PETW_WNF_EVENT_PUBLISH = *mut _ETW_WNF_EVENT_PUBLISH;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETW_WNF_EVENT_NAME_SUB_RUNDOWN {
   pub Header: SYSTEM_TRACE_HEADER,
   pub StateName: LARGE_INTEGER,
   pub NameSub: PVOID,
}
impl Default for _ETW_WNF_EVENT_NAME_SUB_RUNDOWN {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_WNF_EVENT_NAME_SUB_RUNDOWN = _ETW_WNF_EVENT_NAME_SUB_RUNDOWN;
pub type PETW_WNF_EVENT_NAME_SUB_RUNDOWN = *mut _ETW_WNF_EVENT_NAME_SUB_RUNDOWN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_MARK_EVENT {
   pub TranId: ULONG,
   pub Level: UCHAR,
   pub AppId: UCHAR,
   pub OpId: USHORT,
   pub Text: [WCHAR; 1usize],
}
pub type PERFINFO_MARK_EVENT = _PERFINFO_MARK_EVENT;
pub type PPERFINFO_MARK_EVENT = *mut _PERFINFO_MARK_EVENT;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_DRIVER_MAJORFUNCTION {
   pub MajorFunction: ULONG,
   pub MinorFunction: ULONG,
   pub RoutineAddr: PVOID,
   pub FileNamePointer: PVOID,
   pub Irp: PVOID,
   pub UniqMatchId: ULONG,
}
impl Default for _PERFINFO_DRIVER_MAJORFUNCTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_DRIVER_MAJORFUNCTION = _PERFINFO_DRIVER_MAJORFUNCTION;
pub type PPERFINFO_DRIVER_MAJORFUNCTION = *mut _PERFINFO_DRIVER_MAJORFUNCTION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_DRIVER_MAJORFUNCTION_RET {
   pub Irp: PVOID,
   pub UniqMatchId: ULONG,
}
impl Default for _PERFINFO_DRIVER_MAJORFUNCTION_RET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_DRIVER_MAJORFUNCTION_RET = _PERFINFO_DRIVER_MAJORFUNCTION_RET;
pub type PPERFINFO_DRIVER_MAJORFUNCTION_RET = *mut _PERFINFO_DRIVER_MAJORFUNCTION_RET;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_DRIVER_COMPLETE_REQUEST {
   pub RoutineAddr: PVOID,
   pub Irp: PVOID,
   pub UniqMatchId: ULONG,
}
impl Default for _PERFINFO_DRIVER_COMPLETE_REQUEST {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_DRIVER_COMPLETE_REQUEST = _PERFINFO_DRIVER_COMPLETE_REQUEST;
pub type PPERFINFO_DRIVER_COMPLETE_REQUEST = *mut _PERFINFO_DRIVER_COMPLETE_REQUEST;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_DRIVER_COMPLETE_REQUEST_RET {
   pub Irp: PVOID,
   pub UniqMatchId: ULONG,
}
impl Default for _PERFINFO_DRIVER_COMPLETE_REQUEST_RET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_DRIVER_COMPLETE_REQUEST_RET = _PERFINFO_DRIVER_COMPLETE_REQUEST_RET;
pub type PPERFINFO_DRIVER_COMPLETE_REQUEST_RET = *mut _PERFINFO_DRIVER_COMPLETE_REQUEST_RET;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_DRIVER_COMPLETIONROUTINE {
   pub Routine: PVOID,
   pub IrpPtr: PVOID,
   pub UniqMatchId: ULONG,
}
impl Default for _PERFINFO_DRIVER_COMPLETIONROUTINE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_DRIVER_COMPLETIONROUTINE = _PERFINFO_DRIVER_COMPLETIONROUTINE;
pub type PPERFINFO_DRIVER_COMPLETIONROUTINE = *mut _PERFINFO_DRIVER_COMPLETIONROUTINE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_BATTERY_LIFE_INFO {
   pub RemainingCapacity: ULONG,
   pub Rate: ULONG,
}
pub type PERFINFO_BATTERY_LIFE_INFO = _PERFINFO_BATTERY_LIFE_INFO;
pub type PPERFINFO_BATTERY_LIFE_INFO = *mut _PERFINFO_BATTERY_LIFE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_IDLE_STATE_CHANGE {
   pub State: ULONG,
   pub Throttle: ULONG,
   pub Direction: ULONG,
}
pub type PERFINFO_IDLE_STATE_CHANGE = _PERFINFO_IDLE_STATE_CHANGE;
pub type PPERFINFO_IDLE_STATE_CHANGE = *mut _PERFINFO_IDLE_STATE_CHANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_SET_POWER_ACTION {
   pub Trigger: PVOID,
   pub PowerAction: ULONG,
   pub LightestState: ULONG,
}
impl Default for _PERFINFO_SET_POWER_ACTION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_SET_POWER_ACTION = _PERFINFO_SET_POWER_ACTION;
pub type PPERFINFO_SET_POWER_ACTION = *mut _PERFINFO_SET_POWER_ACTION;
#[repr(C)]
pub struct _PERFINFO_SET_POWER_ACTION_RET {
   pub Trigger: PVOID,
   pub Status: NTSTATUS,
}
impl Default for _PERFINFO_SET_POWER_ACTION_RET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_SET_POWER_ACTION_RET = _PERFINFO_SET_POWER_ACTION_RET;
pub type PPERFINFO_SET_POWER_ACTION_RET = *mut _PERFINFO_SET_POWER_ACTION_RET;
#[repr(C)]
pub struct _PERFINFO_SET_DEVICES_STATE {
   pub SystemState: ULONG,
   pub Waking: BOOLEAN,
   pub Shutdown: BOOLEAN,
   pub IrpMinor: UCHAR,
}
impl Default for _PERFINFO_SET_DEVICES_STATE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_SET_DEVICES_STATE = _PERFINFO_SET_DEVICES_STATE;
pub type PPERFINFO_SET_DEVICES_STATE = *mut _PERFINFO_SET_DEVICES_STATE;
#[repr(C)]
pub struct _PERFINFO_SET_DEVICES_STATE_RET {
   pub Status: NTSTATUS,
}
impl Default for _PERFINFO_SET_DEVICES_STATE_RET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_SET_DEVICES_STATE_RET = _PERFINFO_SET_DEVICES_STATE_RET;
pub type PPERFINFO_SET_DEVICES_STATE_RET = *mut _PERFINFO_SET_DEVICES_STATE_RET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_PO_NOTIFY_DEVICE {
   pub Irp: PVOID,
   pub DriverStart: PVOID,
   pub OrderLevel: UCHAR,
   pub MajorFunction: UCHAR,
   pub MinorFunction: UCHAR,
   pub Type: POWER_STATE_TYPE,
   pub State: POWER_STATE,
   pub DeviceNameLength: ULONG,
   pub DeviceName: [WCHAR; 1usize],
}
impl Default for _PERFINFO_PO_NOTIFY_DEVICE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PO_NOTIFY_DEVICE = _PERFINFO_PO_NOTIFY_DEVICE;
pub type PPERFINFO_PO_NOTIFY_DEVICE = *mut _PERFINFO_PO_NOTIFY_DEVICE;
#[repr(C)]
pub struct _PERFINFO_PO_NOTIFY_DEVICE_COMPLETE {
   pub Irp: PVOID,
   pub Status: NTSTATUS,
}
impl Default for _PERFINFO_PO_NOTIFY_DEVICE_COMPLETE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PO_NOTIFY_DEVICE_COMPLETE = _PERFINFO_PO_NOTIFY_DEVICE_COMPLETE;
pub type PPERFINFO_PO_NOTIFY_DEVICE_COMPLETE = *mut _PERFINFO_PO_NOTIFY_DEVICE_COMPLETE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_PO_SESSION_CALLOUT {
   pub SystemAction: POWER_ACTION,
   pub MinSystemState: SYSTEM_POWER_STATE,
   pub Flags: ULONG,
   pub PowerStateTask: ULONG,
}
impl Default for _PERFINFO_PO_SESSION_CALLOUT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PO_SESSION_CALLOUT = _PERFINFO_PO_SESSION_CALLOUT;
pub type PPERFINFO_PO_SESSION_CALLOUT = *mut _PERFINFO_PO_SESSION_CALLOUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_PO_PRESLEEP {
   pub PerformanceCounter: LARGE_INTEGER,
   pub PerformanceFrequency: LARGE_INTEGER,
}
impl Default for _PERFINFO_PO_PRESLEEP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PO_PRESLEEP = _PERFINFO_PO_PRESLEEP;
pub type PPERFINFO_PO_PRESLEEP = *mut _PERFINFO_PO_PRESLEEP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_PO_POSTSLEEP {
   pub PerformanceCounter: LARGE_INTEGER,
}
impl Default for _PERFINFO_PO_POSTSLEEP {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PO_POSTSLEEP = _PERFINFO_PO_POSTSLEEP;
pub type PPERFINFO_PO_POSTSLEEP = *mut _PERFINFO_PO_POSTSLEEP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_PO_CALIBRATED_PERFCOUNTER {
   pub PerformanceCounter: LARGE_INTEGER,
}
impl Default for _PERFINFO_PO_CALIBRATED_PERFCOUNTER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PO_CALIBRATED_PERFCOUNTER = _PERFINFO_PO_CALIBRATED_PERFCOUNTER;
pub type PPERFINFO_PO_CALIBRATED_PERFCOUNTER = *mut _PERFINFO_PO_CALIBRATED_PERFCOUNTER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_BOOT_PHASE_START {
   pub Phase: LONG,
}
pub type PERFINFO_BOOT_PHASE_START = _PERFINFO_BOOT_PHASE_START;
pub type PPERFINFO_BOOT_PHASE_START = *mut _PERFINFO_BOOT_PHASE_START;
#[repr(C)]
pub struct _PERFINFO_BOOT_PREFETCH_INFORMATION {
   pub Action: LONG,
   pub Status: NTSTATUS,
   pub Pages: LONG,
}
impl Default for _PERFINFO_BOOT_PREFETCH_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_BOOT_PREFETCH_INFORMATION = _PERFINFO_BOOT_PREFETCH_INFORMATION;
pub type PPERFINFO_BOOT_PREFETCH_INFORMATION = *mut _PERFINFO_BOOT_PREFETCH_INFORMATION;
#[repr(C)]
pub struct _PERFINFO_PO_SESSION_CALLOUT_RET {
   pub Status: NTSTATUS,
}
impl Default for _PERFINFO_PO_SESSION_CALLOUT_RET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PO_SESSION_CALLOUT_RET = _PERFINFO_PO_SESSION_CALLOUT_RET;
pub type PPERFINFO_PO_SESSION_CALLOUT_RET = *mut _PERFINFO_PO_SESSION_CALLOUT_RET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PPM_IDLE_STATE_CHANGE {
   pub NewState: ULONG,
   pub OldState: ULONG,
   pub Processors: ULONG64,
}
pub type PERFINFO_PPM_IDLE_STATE_CHANGE = _PERFINFO_PPM_IDLE_STATE_CHANGE;
pub type PPERFINFO_PPM_IDLE_STATE_CHANGE = *mut _PERFINFO_PPM_IDLE_STATE_CHANGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_PPM_IDLE_STATE_ENTER {
   pub State: ULONG,
   pub __bindgen_anon_1: _PERFINFO_PPM_IDLE_STATE_ENTER__bindgen_ty_1,
   pub ExpectedDuration: ULONG64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_PPM_IDLE_STATE_ENTER__bindgen_ty_1 {
   pub __bindgen_anon_1: _PERFINFO_PPM_IDLE_STATE_ENTER__bindgen_ty_1__bindgen_ty_1,
   pub Flags: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PPM_IDLE_STATE_ENTER__bindgen_ty_1__bindgen_ty_1 {
   pub Properties: USHORT,
   pub ExpectedWakeReason: UCHAR,
   pub Reserved: UCHAR,
}
impl Default for _PERFINFO_PPM_IDLE_STATE_ENTER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PERFINFO_PPM_IDLE_STATE_ENTER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PPM_IDLE_STATE_ENTER = _PERFINFO_PPM_IDLE_STATE_ENTER;
pub type PPERFINFO_PPM_IDLE_STATE_ENTER = *mut _PERFINFO_PPM_IDLE_STATE_ENTER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PPM_IDLE_STATE_EXIT {
   pub State: ULONG,
   pub Status: ULONG,
}
pub type PERFINFO_PPM_IDLE_STATE_EXIT = _PERFINFO_PPM_IDLE_STATE_EXIT;
pub type PPERFINFO_PPM_IDLE_STATE_EXIT = *mut _PERFINFO_PPM_IDLE_STATE_EXIT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PPM_STATE_SELECTION {
   pub SelectedState: ULONG,
   pub VetoedStates: ULONG,
   pub VetoReason: [ULONG; 1usize],
}
pub type PERFINFO_PPM_STATE_SELECTION = _PERFINFO_PPM_STATE_SELECTION;
pub type PPERFINFO_PPM_STATE_SELECTION = *mut _PERFINFO_PPM_STATE_SELECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PPM_IDLE_EXIT_LATENCY {
   pub Flags: ULONG,
   pub PlatformState: ULONG,
   pub ProcessorState: ULONG,
   pub ReturnLatency: ULONG,
   pub TotalLatency: ULONG,
}
pub type PERFINFO_PPM_IDLE_EXIT_LATENCY = _PERFINFO_PPM_IDLE_EXIT_LATENCY;
pub type PPERFINFO_PPM_IDLE_EXIT_LATENCY = *mut _PERFINFO_PPM_IDLE_EXIT_LATENCY;
#[repr(C)]
pub struct _PERFINFO_PPM_PERF_STATE_CHANGE {
   pub Type: ULONG,
   pub NewState: ULONG,
   pub OldState: ULONG,
   pub Result: NTSTATUS,
   pub Processors: ULONG64,
}
impl Default for _PERFINFO_PPM_PERF_STATE_CHANGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PPM_PERF_STATE_CHANGE = _PERFINFO_PPM_PERF_STATE_CHANGE;
pub type PPERFINFO_PPM_PERF_STATE_CHANGE = *mut _PERFINFO_PPM_PERF_STATE_CHANGE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PPM_THERMAL_CONSTRAINT {
   pub Constraint: ULONG,
   pub Processors: ULONG64,
}
pub type PERFINFO_PPM_THERMAL_CONSTRAINT = _PERFINFO_PPM_THERMAL_CONSTRAINT;
pub type PPERFINFO_PPM_THERMAL_CONSTRAINT = *mut _PERFINFO_PPM_THERMAL_CONSTRAINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_FILEOBJECT_INFORMATION {
   pub FileObject: PVOID,
}
impl Default for _PERFINFO_FILEOBJECT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_FILEOBJECT_INFORMATION = _PERFINFO_FILEOBJECT_INFORMATION;
pub type PPERFINFO_FILEOBJECT_INFORMATION = *mut _PERFINFO_FILEOBJECT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_FILENAME_SAME_INFORMATION {
   pub OldFile: PVOID,
   pub NewFile: PVOID,
}
impl Default for _PERFINFO_FILENAME_SAME_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_FILENAME_SAME_INFORMATION = _PERFINFO_FILENAME_SAME_INFORMATION;
pub type PPERFINFO_FILENAME_SAME_INFORMATION = *mut _PERFINFO_FILENAME_SAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_PFMAPPED_SECTION_INFORMATION {
   pub RangeBase: PVOID,
   pub RangeEnd: PVOID,
   pub CreatingProcessId: ULONG,
}
impl Default for _PERFINFO_PFMAPPED_SECTION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PFMAPPED_SECTION_INFORMATION = _PERFINFO_PFMAPPED_SECTION_INFORMATION;
pub type PPERFINFO_PFMAPPED_SECTION_INFORMATION = *mut _PERFINFO_PFMAPPED_SECTION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_PFMAPPED_SECTION_OBJECT_INFORMATION {
   pub SectionObject: PVOID,
   pub RangeBase: PVOID,
}
impl Default for _PERFINFO_PFMAPPED_SECTION_OBJECT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PFMAPPED_SECTION_OBJECT_INFORMATION =
   _PERFINFO_PFMAPPED_SECTION_OBJECT_INFORMATION;
pub type PPERFINFO_PFMAPPED_SECTION_OBJECT_INFORMATION =
   *mut _PERFINFO_PFMAPPED_SECTION_OBJECT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_SAMPLED_PROFILE_INFORMATION {
   pub InstructionPointer: PVOID,
   pub ThreadId: ULONG,
   pub Count: USHORT,
   pub __bindgen_anon_1: _PERFINFO_SAMPLED_PROFILE_INFORMATION__bindgen_ty_1,
   pub Rank: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_SAMPLED_PROFILE_INFORMATION__bindgen_ty_1 {
   pub __bindgen_anon_1: _PERFINFO_SAMPLED_PROFILE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
   pub Flags: UCHAR,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_SAMPLED_PROFILE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _PERFINFO_SAMPLED_PROFILE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ExecutingDpc(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ExecutingDpc(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ExecutingDpc_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ExecutingDpc_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ExecutingIsr(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_ExecutingIsr(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ExecutingIsr_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_ExecutingIsr_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Priority(&self) -> UCHAR {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
   }
   #[inline]
   pub fn set_Priority(&mut self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         self._bitfield_1.set(3usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Priority_raw(this: *const Self) -> UCHAR {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            3usize,
            5u8,
         ) as u8)
      }
   }
   #[inline]
   pub unsafe fn set_Priority_raw(this: *mut Self, val: UCHAR) {
      unsafe {
         let val: u8 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            3usize,
            5u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ExecutingDpc: UCHAR,
      ExecutingIsr: UCHAR,
      Reserved: UCHAR,
      Priority: UCHAR,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ExecutingDpc: u8 = unsafe { ::core::mem::transmute(ExecutingDpc) };
         ExecutingDpc as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ExecutingIsr: u8 = unsafe { ::core::mem::transmute(ExecutingIsr) };
         ExecutingIsr as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit.set(3usize, 5u8, {
         let Priority: u8 = unsafe { ::core::mem::transmute(Priority) };
         Priority as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PERFINFO_SAMPLED_PROFILE_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PERFINFO_SAMPLED_PROFILE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_SAMPLED_PROFILE_INFORMATION = _PERFINFO_SAMPLED_PROFILE_INFORMATION;
pub type PPERFINFO_SAMPLED_PROFILE_INFORMATION = *mut _PERFINFO_SAMPLED_PROFILE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_SAMPLED_PROFILE_CACHE {
   pub Entries: ULONG,
   pub Sample: [PERFINFO_SAMPLED_PROFILE_INFORMATION; 20usize],
}
impl Default for _PERFINFO_SAMPLED_PROFILE_CACHE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_SAMPLED_PROFILE_CACHE = _PERFINFO_SAMPLED_PROFILE_CACHE;
pub type PPERFINFO_SAMPLED_PROFILE_CACHE = *mut _PERFINFO_SAMPLED_PROFILE_CACHE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_SAMPLED_PROFILE_CONFIG {
   pub Source: ULONG,
   pub NewInterval: ULONG,
   pub OldInterval: ULONG,
}
pub type PERFINFO_SAMPLED_PROFILE_CONFIG = _PERFINFO_SAMPLED_PROFILE_CONFIG;
pub type PPERFINFO_SAMPLED_PROFILE_CONFIG = *mut _PERFINFO_SAMPLED_PROFILE_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_PMC_SAMPLE_INFORMATION {
   pub InstructionPointer: PVOID,
   pub ThreadId: ULONG,
   pub ProfileSource: USHORT,
   pub Reserved: USHORT,
}
impl Default for _PERFINFO_PMC_SAMPLE_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PMC_SAMPLE_INFORMATION = _PERFINFO_PMC_SAMPLE_INFORMATION;
pub type PPERFINFO_PMC_SAMPLE_INFORMATION = *mut _PERFINFO_PMC_SAMPLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_DPC_INFORMATION {
   pub InitialTime: ULONGLONG,
   pub DpcRoutine: PVOID,
}
impl Default for _PERFINFO_DPC_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_DPC_INFORMATION = _PERFINFO_DPC_INFORMATION;
pub type PPERFINFO_DPC_INFORMATION = *mut _PERFINFO_DPC_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_DPC_ENQUEUE_INFORMATION {
   pub Key: ULONG_PTR,
   pub DpcQueueDepth: LONG,
   pub DpcCount: ULONG,
   pub TargetProcessorIndex: ULONG,
   pub Importance: UCHAR,
   pub Reserved: [UCHAR; 3usize],
}
pub type PERFINFO_DPC_ENQUEUE_INFORMATION = _PERFINFO_DPC_ENQUEUE_INFORMATION;
pub type PPERFINFO_DPC_ENQUEUE_INFORMATION = *mut _PERFINFO_DPC_ENQUEUE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_DPC_EXECUTION_INFORMATION {
   pub DpcRoutine: PVOID,
   pub Key: ULONG_PTR,
}
impl Default for _PERFINFO_DPC_EXECUTION_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_DPC_EXECUTION_INFORMATION = _PERFINFO_DPC_EXECUTION_INFORMATION;
pub type PPERFINFO_DPC_EXECUTION_INFORMATION = *mut _PERFINFO_DPC_EXECUTION_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_YIELD_PROCESSOR_INFORMATION {
   pub YieldReason: ULONG,
   pub DpcWatchdogCount: ULONG,
   pub DpcTimeCount: ULONG,
}
pub type PERFINFO_YIELD_PROCESSOR_INFORMATION = _PERFINFO_YIELD_PROCESSOR_INFORMATION;
pub type PPERFINFO_YIELD_PROCESSOR_INFORMATION = *mut _PERFINFO_YIELD_PROCESSOR_INFORMATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_INTERRUPT_INFORMATION {
   pub InitialTime: ULONGLONG,
   pub ServiceRoutine: PVOID,
   pub ReturnValue: UCHAR,
   pub Vector: USHORT,
   pub Reserved: UCHAR,
}
impl Default for _PERFINFO_INTERRUPT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_INTERRUPT_INFORMATION = _PERFINFO_INTERRUPT_INFORMATION;
pub type PPERFINFO_INTERRUPT_INFORMATION = *mut _PERFINFO_INTERRUPT_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CLOCK_INTERRUPT_INFORMATION {
   pub InterruptTime: ULONG64,
   pub Flags: SHORT,
}
pub type PERFINFO_CLOCK_INTERRUPT_INFORMATION = _PERFINFO_CLOCK_INTERRUPT_INFORMATION;
pub type PPERFINFO_CLOCK_INTERRUPT_INFORMATION = *mut _PERFINFO_CLOCK_INTERRUPT_INFORMATION;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_SPINLOCK_CONFIG {
   pub SpinLockSpinThreshold: ULONG,
   pub SpinLockContentionSampleRate: ULONG,
   pub SpinLockAcquireSampleRate: ULONG,
   pub SpinLockHoldThreshold: ULONG,
}
pub type PERFINFO_SPINLOCK_CONFIG = _PERFINFO_SPINLOCK_CONFIG;
pub type PPERFINFO_SPINLOCK_CONFIG = *mut _PERFINFO_SPINLOCK_CONFIG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_EXECUTIVE_RESOURCE_CONFIG {
   pub ReleaseSamplingRate: ULONG,
   pub ContentionSamplingRate: ULONG,
   pub NumberOfExcessiveTimeouts: ULONG,
}
pub type PERFINFO_EXECUTIVE_RESOURCE_CONFIG = _PERFINFO_EXECUTIVE_RESOURCE_CONFIG;
pub type PPERFINFO_EXECUTIVE_RESOURCE_CONFIG = *mut _PERFINFO_EXECUTIVE_RESOURCE_CONFIG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_SESSIONCREATE_INFORMATION {
   pub UniqueSessionId: ULONG_PTR,
   pub SessionId: ULONG,
}
pub type PERFINFO_SESSIONCREATE_INFORMATION = _PERFINFO_SESSIONCREATE_INFORMATION;
pub type PPERFINFO_SESSIONCREATE_INFORMATION = *mut _PERFINFO_SESSIONCREATE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_PAGE_RANGE_IDENTITY {
   pub __bindgen_anon_1: _PERFINFO_PAGE_RANGE_IDENTITY__bindgen_ty_1,
   pub __bindgen_anon_2: _PERFINFO_PAGE_RANGE_IDENTITY__bindgen_ty_2,
   pub PageCount: SIZE_T,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PAGE_RANGE_IDENTITY__bindgen_ty_1 {
   pub _bitfield_align_1: [u64; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PERFINFO_PAGE_RANGE_IDENTITY__bindgen_ty_1 {
   #[inline]
   pub fn UseDescription(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u64) }
   }
   #[inline]
   pub fn set_UseDescription(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UseDescription_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            4u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_UseDescription_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn UniqueKey(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 48u8) as u64) }
   }
   #[inline]
   pub fn set_UniqueKey(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 48u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UniqueKey_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            48u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_UniqueKey_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            48u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Reserved(&self) -> ULONGLONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 12u8) as u64) }
   }
   #[inline]
   pub fn set_Reserved(&mut self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         self._bitfield_1.set(52usize, 12u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Reserved_raw(this: *const Self) -> ULONGLONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            52usize,
            12u8,
         ) as u64)
      }
   }
   #[inline]
   pub unsafe fn set_Reserved_raw(this: *mut Self, val: ULONGLONG) {
      unsafe {
         let val: u64 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            52usize,
            12u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      UseDescription: ULONGLONG,
      UniqueKey: ULONGLONG,
      Reserved: ULONGLONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let UseDescription: u64 = unsafe { ::core::mem::transmute(UseDescription) };
         UseDescription as u64
      });
      __bindgen_bitfield_unit.set(4usize, 48u8, {
         let UniqueKey: u64 = unsafe { ::core::mem::transmute(UniqueKey) };
         UniqueKey as u64
      });
      __bindgen_bitfield_unit.set(52usize, 12u8, {
         let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
         Reserved as u64
      });
      __bindgen_bitfield_unit
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_PAGE_RANGE_IDENTITY__bindgen_ty_2 {
   pub ProtoPteAddress: PVOID,
   pub PageFrameIndex: ULONG_PTR,
   pub VirtualAddress: PVOID,
}
impl Default for _PERFINFO_PAGE_RANGE_IDENTITY__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PERFINFO_PAGE_RANGE_IDENTITY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_PAGE_RANGE_IDENTITY = _PERFINFO_PAGE_RANGE_IDENTITY;
pub type PPERFINFO_PAGE_RANGE_IDENTITY = *mut _PERFINFO_PAGE_RANGE_IDENTITY;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_KERNELMEMORY_USAGE_TYPE {
   PerfInfoMemUsagePfnMetadata = 0,
   PerfInfoMemUsageMax = 1,
}
pub use self::_PERFINFO_KERNELMEMORY_USAGE_TYPE as PERFINFO_KERNELMEMORY_USAGE_TYPE;
pub type PPERFINFO_KERNELMEMORY_USAGE_TYPE = *mut _PERFINFO_KERNELMEMORY_USAGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_KERNELMEMORY_RANGE_USAGE {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub VirtualAddress: PVOID,
   pub PageCount: SIZE_T,
}
impl Default for _PERFINFO_KERNELMEMORY_RANGE_USAGE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl _PERFINFO_KERNELMEMORY_RANGE_USAGE {
   #[inline]
   pub fn UsageType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
   }
   #[inline]
   pub fn set_UsageType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn UsageType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            5u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_UsageType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            5u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(5usize, 27u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            5usize,
            27u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            5usize,
            27u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(UsageType: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 5u8, {
         let UsageType: u32 = unsafe { ::core::mem::transmute(UsageType) };
         UsageType as u64
      });
      __bindgen_bitfield_unit.set(5usize, 27u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PERFINFO_KERNELMEMORY_RANGE_USAGE = _PERFINFO_KERNELMEMORY_RANGE_USAGE;
pub type PPERFINFO_KERNELMEMORY_RANGE_USAGE = *mut _PERFINFO_KERNELMEMORY_RANGE_USAGE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_MM_STAT {
   PerfInfoMMStatNotUsed = 0,
   PerfInfoMMStatAggregatePageCombine = 1,
   PerfInfoMMStatIterationPageCombine = 2,
   PerfInfoMMStatMax = 3,
}
pub use self::_PERFINFO_MM_STAT as PERFINFO_MM_STAT;
pub type PPERFINFO_MM_STAT = *mut _PERFINFO_MM_STAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PAGECOMBINE_AGGREGATE_STAT {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub CombineScanCount: ULONG,
   pub PagesScanned: ULONGLONG,
   pub PagesCombined: ULONGLONG,
   pub CombinedBlocksInUse: LONG,
   pub SumCombinedBlocksReferenceCount: LONG,
}
impl _PERFINFO_PAGECOMBINE_AGGREGATE_STAT {
   #[inline]
   pub fn StatType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_StatType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StatType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StatType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 26u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            26u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            26u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(StatType: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 6u8, {
         let StatType: u32 = unsafe { ::core::mem::transmute(StatType) };
         StatType as u64
      });
      __bindgen_bitfield_unit.set(6usize, 26u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PERFINFO_PAGECOMBINE_AGGREGATE_STAT = _PERFINFO_PAGECOMBINE_AGGREGATE_STAT;
pub type PPERFINFO_PAGECOMBINE_AGGREGATE_STAT = *mut _PERFINFO_PAGECOMBINE_AGGREGATE_STAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PAGECOMBINE_ITERATION_STAT {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
   pub PagesScanned: ULONG,
   pub PagesCombined: ULONG,
}
impl _PERFINFO_PAGECOMBINE_ITERATION_STAT {
   #[inline]
   pub fn StatType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_StatType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn StatType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_StatType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 26u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            26u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            26u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(StatType: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 6u8, {
         let StatType: u32 = unsafe { ::core::mem::transmute(StatType) };
         StatType as u64
      });
      __bindgen_bitfield_unit.set(6usize, 26u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PERFINFO_PAGECOMBINE_ITERATION_STAT = _PERFINFO_PAGECOMBINE_ITERATION_STAT;
pub type PPERFINFO_PAGECOMBINE_ITERATION_STAT = *mut _PERFINFO_PAGECOMBINE_ITERATION_STAT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_HARDPAGEFAULT_INFORMATION {
   pub ReadOffset: LARGE_INTEGER,
   pub VirtualAddress: PVOID,
   pub FileObject: PVOID,
   pub ThreadId: ULONG,
   pub ByteCount: ULONG,
}
impl Default for _PERFINFO_HARDPAGEFAULT_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_HARDPAGEFAULT_INFORMATION = _PERFINFO_HARDPAGEFAULT_INFORMATION;
pub type PPERFINFO_HARDPAGEFAULT_INFORMATION = *mut _PERFINFO_HARDPAGEFAULT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_VIRTUAL_ALLOC {
   pub CapturedBase: PVOID,
   pub CapturedRegionSize: SIZE_T,
   pub ProcessId: ULONG,
   pub Flags: ULONG,
}
impl Default for _PERFINFO_VIRTUAL_ALLOC {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_VIRTUAL_ALLOC = _PERFINFO_VIRTUAL_ALLOC;
pub type PPERFINFO_VIRTUAL_ALLOC = *mut _PERFINFO_VIRTUAL_ALLOC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_VAD_ROTATE_INFO {
   pub BaseAddress: PVOID,
   pub SizeInBytes: SIZE_T,
   pub __bindgen_anon_1: _PERFINFO_VAD_ROTATE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_VAD_ROTATE_INFO__bindgen_ty_1 {
   pub __bindgen_anon_1: _PERFINFO_VAD_ROTATE_INFO__bindgen_ty_1__bindgen_ty_1,
   pub Flags: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_VAD_ROTATE_INFO__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PERFINFO_VAD_ROTATE_INFO__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn Direction(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_Direction(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Direction_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Direction_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(4usize, 28u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            4usize,
            28u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            4usize,
            28u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(Direction: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 4u8, {
         let Direction: u32 = unsafe { ::core::mem::transmute(Direction) };
         Direction as u64
      });
      __bindgen_bitfield_unit.set(4usize, 28u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PERFINFO_VAD_ROTATE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PERFINFO_VAD_ROTATE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_VAD_ROTATE_INFO = _PERFINFO_VAD_ROTATE_INFO;
pub type PPERFINFO_VAD_ROTATE_INFO = *mut _PERFINFO_VAD_ROTATE_INFO;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_MEM_RESET_INFO_TYPE {
   PerfInfoMemReset = 0,
   PerfInfoMemResetUndo = 1,
   PerfInfoMemResetUndoFailed = 2,
   PerfInfoMemResetMax = 3,
}
pub use self::_PERFINFO_MEM_RESET_INFO_TYPE as PERFINFO_MEM_RESET_INFO_TYPE;
pub type PPERFINFO_MEM_RESET_INFO_TYPE = *mut _PERFINFO_MEM_RESET_INFO_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_MEM_RESET_INFO {
   pub BaseAddress: PVOID,
   pub SizeInBytes: SIZE_T,
   pub __bindgen_anon_1: _PERFINFO_MEM_RESET_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_MEM_RESET_INFO__bindgen_ty_1 {
   pub __bindgen_anon_1: _PERFINFO_MEM_RESET_INFO__bindgen_ty_1__bindgen_ty_1,
   pub Flags: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_MEM_RESET_INFO__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PERFINFO_MEM_RESET_INFO__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn TypeInfo(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_TypeInfo(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TypeInfo_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TypeInfo_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn Spare(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_Spare(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn Spare_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_Spare_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(TypeInfo: ULONG, Spare: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let TypeInfo: u32 = unsafe { ::core::mem::transmute(TypeInfo) };
         TypeInfo as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let Spare: u32 = unsafe { ::core::mem::transmute(Spare) };
         Spare as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PERFINFO_MEM_RESET_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PERFINFO_MEM_RESET_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_MEM_RESET_INFO = _PERFINFO_MEM_RESET_INFO;
pub type PPERFINFO_MEM_RESET_INFO = *mut _PERFINFO_MEM_RESET_INFO;
#[repr(C)]
pub struct _PERFINFO_CC_WORKITEM_ENQUEUE {
   pub WorkItemKey: ULONG_PTR,
   pub FileObjectKey: ULONG_PTR,
   pub QueueType: UCHAR,
   pub WorkItemType: UCHAR,
   pub Requeue: BOOLEAN,
   pub Reserved: UCHAR,
}
impl Default for _PERFINFO_CC_WORKITEM_ENQUEUE {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_CC_WORKITEM_ENQUEUE = _PERFINFO_CC_WORKITEM_ENQUEUE;
pub type PPERFINFO_CC_WORKITEM_ENQUEUE = *mut _PERFINFO_CC_WORKITEM_ENQUEUE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_WORKITEM_DEQUEUE {
   pub WorkItemKey: ULONG_PTR,
}
pub type PERFINFO_CC_WORKITEM_DEQUEUE = _PERFINFO_CC_WORKITEM_DEQUEUE;
pub type PPERFINFO_CC_WORKITEM_DEQUEUE = *mut _PERFINFO_CC_WORKITEM_DEQUEUE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_WORKITEM_COMPLETE {
   pub WorkItemKey: ULONG_PTR,
}
pub type PERFINFO_CC_WORKITEM_COMPLETE = _PERFINFO_CC_WORKITEM_COMPLETE;
pub type PPERFINFO_CC_WORKITEM_COMPLETE = *mut _PERFINFO_CC_WORKITEM_COMPLETE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_READ_AHEAD {
   pub WorkItemKey: ULONG_PTR,
   pub FileOffset: ULONGLONG,
   pub Size: ULONG,
   pub PagePriority: ULONG,
   pub DetectedPattern: ULONG,
   pub Reserved: ULONG,
}
pub type PERFINFO_CC_READ_AHEAD_COMPLETE = _PERFINFO_CC_READ_AHEAD;
pub type PPERFINFO_CC_READ_AHEAD_COMPLETE = *mut _PERFINFO_CC_READ_AHEAD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_SCHEDULE_READ_AHEAD {
   pub WorkItemKey: ULONG_PTR,
   pub FileObjectKey: ULONG_PTR,
   pub FileOffset: ULONGLONG,
   pub Length: ULONG,
   pub ReadAheadUnit: ULONG,
   pub ReadAheadLength: ULONG,
   pub ReadAheadOffset: ULONGLONG,
   pub ReadAheadBeyondLastByte: ULONGLONG,
   pub ReadPattern: UCHAR,
   pub SequentialReadCount: ULONG,
   pub SharedCacheMapFlags: ULONG,
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: [u8; 3usize],
}
impl _PERFINFO_CC_SCHEDULE_READ_AHEAD {
   #[inline]
   pub fn ReadAheadSettingsChanged(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReadAheadSettingsChanged(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReadAheadSettingsChanged_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReadAheadSettingsChanged_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn ReadAheadActive(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
   }
   #[inline]
   pub fn set_ReadAheadActive(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ReadAheadActive_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_ReadAheadActive_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ReadAheadSettingsChanged: ULONG,
      ReadAheadActive: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ReadAheadSettingsChanged: u32 =
            unsafe { ::core::mem::transmute(ReadAheadSettingsChanged) };
         ReadAheadSettingsChanged as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let ReadAheadActive: u32 = unsafe { ::core::mem::transmute(ReadAheadActive) };
         ReadAheadActive as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PERFINFO_CC_SCHEDULE_READ_AHEAD = _PERFINFO_CC_SCHEDULE_READ_AHEAD;
pub type PPERFINFO_CC_SCHEDULE_READ_AHEAD = *mut _PERFINFO_CC_SCHEDULE_READ_AHEAD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_LAZY_WRITE_SCAN {
   pub WorkItemKey: ULONG_PTR,
   pub ReasonForFlush: ULONG,
   pub PagesToWrite: ULONG,
   pub TotalDirtyPages: SIZE_T,
   pub AvailablePages: SIZE_T,
   pub DirtyPageThreshold: SIZE_T,
   pub NumberOfMappedVacbs: SIZE_T,
   pub TopDirtyPageThreshold: SIZE_T,
   pub BottomDirtyPageThreshold: SIZE_T,
   pub AverageAvailablePages: SIZE_T,
   pub AverageDirtyPages: SIZE_T,
   pub ConsecutiveWorklessLazywriteScans: SIZE_T,
}
pub type PERFINFO_CC_LAZY_WRITE_SCAN = _PERFINFO_CC_LAZY_WRITE_SCAN;
pub type PPERFINFO_CC_LAZY_WRITE_SCAN = *mut _PERFINFO_CC_LAZY_WRITE_SCAN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_CAN_WRITE_FAIL {
   pub FileObjectKey: ULONG_PTR,
   pub TotalDirtyPages: SIZE_T,
   pub DirtyPageThreshold: SIZE_T,
   pub BytesToWrite: ULONG,
}
pub type PERFINFO_CC_CAN_WRITE_FAIL = _PERFINFO_CC_CAN_WRITE_FAIL;
pub type PPERFINFO_CC_CAN_WRITE_FAIL = *mut _PERFINFO_CC_CAN_WRITE_FAIL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_FLUSH_SECTION {
   pub WorkItemKey: ULONG_PTR,
   pub FileObjectKey: ULONG_PTR,
   pub Offset: ULONGLONG,
   pub Length: ULONG,
   pub MmFlushFlags: ULONG,
}
pub type PERFINFO_CC_FLUSH_SECTION = _PERFINFO_CC_FLUSH_SECTION;
pub type PPERFINFO_CC_FLUSH_SECTION = *mut _PERFINFO_CC_FLUSH_SECTION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_FLUSH_CACHE {
   pub WorkItemKey: ULONG_PTR,
   pub FileObjectKey: ULONG_PTR,
   pub Offset: ULONGLONG,
   pub Length: ULONG,
   pub SharedCacheMapFlags: ULONG,
   pub Flags: ULONG,
   pub Reserved: ULONG,
}
pub type PERFINFO_CC_FLUSH_CACHE = _PERFINFO_CC_FLUSH_CACHE;
pub type PPERFINFO_CC_FLUSH_CACHE = *mut _PERFINFO_CC_FLUSH_CACHE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_CC_LOGGED_STREAM_INFO {
   pub FileObjectKey: ULONG_PTR,
   pub ReasonForFlush: ULONG,
   pub PagesToWrite: ULONG,
   pub DirtyLoggedPages: SIZE_T,
   pub DirtyLoggedPageThreshold: SIZE_T,
   pub LargestLsnForLWS: LARGE_INTEGER,
}
impl Default for _PERFINFO_CC_LOGGED_STREAM_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_CC_LOGGED_STREAM_INFO = _PERFINFO_CC_LOGGED_STREAM_INFO;
pub type PPERFINFO_CC_LOGGED_STREAM_INFO = *mut _PERFINFO_CC_LOGGED_STREAM_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CC_EXTRA_WB_THREAD_INFO {
   pub ThreadAction: ULONG,
   pub ActiveExtraWBThreads: ULONG,
   pub TotalDirtyPages: SIZE_T,
   pub DirtyPageThreshold: SIZE_T,
   pub AvailablePages: SIZE_T,
}
pub type PERFINFO_CC_EXTRA_WB_THREAD_INFO = _PERFINFO_CC_EXTRA_WB_THREAD_INFO;
pub type PPERFINFO_CC_EXTRA_WB_THREAD_INFO = *mut _PERFINFO_CC_EXTRA_WB_THREAD_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO {
   pub FileObject: PVOID,
   pub DeviceCharacteristics: ULONG,
   pub FileCharacteristics: USHORT,
   pub Flags: _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO__bindgen_ty_1 {
   pub Flags: USHORT,
   pub __bindgen_anon_1: _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO__bindgen_ty_1__bindgen_ty_1 {
   pub _bitfield_align_1: [u8; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
   pub __bindgen_padding_0: u8,
}
impl _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO__bindgen_ty_1__bindgen_ty_1 {
   #[inline]
   pub fn ActiveDataReference(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_ActiveDataReference(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn ActiveDataReference_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_ActiveDataReference_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn DeviceEjectable(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_DeviceEjectable(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(1usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DeviceEjectable_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            1usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_DeviceEjectable_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            1usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn WritableHandles(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
   }
   #[inline]
   pub fn set_WritableHandles(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 1u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn WritableHandles_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            1u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_WritableHandles_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            1u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      ActiveDataReference: USHORT,
      DeviceEjectable: USHORT,
      WritableHandles: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 1u8, {
         let ActiveDataReference: u16 = unsafe { ::core::mem::transmute(ActiveDataReference) };
         ActiveDataReference as u64
      });
      __bindgen_bitfield_unit.set(1usize, 1u8, {
         let DeviceEjectable: u16 = unsafe { ::core::mem::transmute(DeviceEjectable) };
         DeviceEjectable as u64
      });
      __bindgen_bitfield_unit.set(2usize, 1u8, {
         let WritableHandles: u16 = unsafe { ::core::mem::transmute(WritableHandles) };
         WritableHandles as u64
      });
      __bindgen_bitfield_unit
   }
}
impl Default for _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO = _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO;
pub type PPERFINFO_IMAGELOAD_IN_PAGEFILE_INFO = *mut _PERFINFO_IMAGELOAD_IN_PAGEFILE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_SYSCALL_ENTER_DATA {
   pub SysCallAddr: PVOID,
}
impl Default for _PERFINFO_SYSCALL_ENTER_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_SYSCALL_ENTER_DATA = _PERFINFO_SYSCALL_ENTER_DATA;
pub type PPERFINFO_SYSCALL_ENTER_DATA = *mut _PERFINFO_SYSCALL_ENTER_DATA;
#[repr(C)]
pub struct _PERFINFO_SYSCALL_EXIT_DATA {
   pub ReturnValue: NTSTATUS,
}
impl Default for _PERFINFO_SYSCALL_EXIT_DATA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_SYSCALL_EXIT_DATA = _PERFINFO_SYSCALL_EXIT_DATA;
pub type PPERFINFO_SYSCALL_EXIT_DATA = *mut _PERFINFO_SYSCALL_EXIT_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_MARK_INFORMATION {
   pub Name: [::core::ffi::c_char; 1usize],
}
pub type PERFINFO_MARK_INFORMATION = _PERFINFO_MARK_INFORMATION;
pub type PPERFINFO_MARK_INFORMATION = *mut _PERFINFO_MARK_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_FILE_CREATE {
   pub Irp: ULONG_PTR,
   pub FileObject: ULONG_PTR,
   pub IssuingThreadId: ULONG,
   pub Options: ULONG,
   pub Attributes: ULONG,
   pub ShareAccess: ULONG,
   pub OpenPath: [WCHAR; 1usize],
}
pub type PERFINFO_FILE_CREATE = _PERFINFO_FILE_CREATE;
pub type PPERFINFO_FILE_CREATE = *mut _PERFINFO_FILE_CREATE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_FILE_INFORMATION {
   pub Irp: ULONG_PTR,
   pub FileObject: ULONG_PTR,
   pub FileKey: ULONG_PTR,
   pub ExtraInformation: ULONG_PTR,
   pub IssuingThreadId: ULONG,
   pub InfoClass: ULONG,
}
pub type PERFINFO_FILE_INFORMATION = _PERFINFO_FILE_INFORMATION;
pub type PPERFINFO_FILE_INFORMATION = *mut _PERFINFO_FILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_FILE_DIRENUM {
   pub Irp: ULONG_PTR,
   pub FileObject: ULONG_PTR,
   pub FileKey: ULONG_PTR,
   pub IssuingThreadId: ULONG,
   pub Length: ULONG,
   pub InfoClass: ULONG,
   pub FileIndex: ULONG,
   pub FileName: [WCHAR; 1usize],
}
pub type PERFINFO_FILE_DIRENUM = _PERFINFO_FILE_DIRENUM;
pub type PPERFINFO_FILE_DIRENUM = *mut _PERFINFO_FILE_DIRENUM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_FILE_PATH_OPERATION {
   pub Irp: ULONG_PTR,
   pub FileObject: ULONG_PTR,
   pub FileKey: ULONG_PTR,
   pub ExtraInformation: ULONG_PTR,
   pub IssuingThreadId: ULONG,
   pub InfoClass: ULONG,
   pub Path: [WCHAR; 1usize],
}
pub type PERFINFO_FILE_PATH_OPERATION = _PERFINFO_FILE_PATH_OPERATION;
pub type PPERFINFO_FILE_PATH_OPERATION = *mut _PERFINFO_FILE_PATH_OPERATION;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_FILE_READ_WRITE {
   pub Offset: ULONGLONG,
   pub Irp: ULONG_PTR,
   pub FileObject: ULONG_PTR,
   pub FileKey: ULONG_PTR,
   pub IssuingThreadId: ULONG,
   pub Size: ULONG,
   pub Flags: ULONG,
   pub ExtraFlags: ULONG,
}
pub type PERFINFO_FILE_READ_WRITE = _PERFINFO_FILE_READ_WRITE;
pub type PPERFINFO_FILE_READ_WRITE = *mut _PERFINFO_FILE_READ_WRITE;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_FILE_SIMPLE_OPERATION {
   pub Irp: ULONG_PTR,
   pub FileObject: ULONG_PTR,
   pub FileKey: ULONG_PTR,
   pub IssuingThreadId: ULONG,
}
pub type PERFINFO_FILE_SIMPLE_OPERATION = _PERFINFO_FILE_SIMPLE_OPERATION;
pub type PPERFINFO_FILE_SIMPLE_OPERATION = *mut _PERFINFO_FILE_SIMPLE_OPERATION;
#[repr(C, packed)]
pub struct _PERFINFO_FILE_OPERATION_END {
   pub Irp: ULONG_PTR,
   pub ExtraInformation: ULONG_PTR,
   pub Status: NTSTATUS,
}
impl Default for _PERFINFO_FILE_OPERATION_END {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_FILE_OPERATION_END = _PERFINFO_FILE_OPERATION_END;
pub type PPERFINFO_FILE_OPERATION_END = *mut _PERFINFO_FILE_OPERATION_END;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_FLT_OPERATION {
   pub RoutineAddr: PVOID,
   pub FileObject: PVOID,
   pub FsContext: PVOID,
   pub IrpPtr: PVOID,
   pub CbdPtr: PVOID,
   pub MajorFunction: LONG,
}
impl Default for _PERFINFO_FLT_OPERATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_FLT_OPERATION = _PERFINFO_FLT_OPERATION;
pub type PPERFINFO_FLT_OPERATION = *mut _PERFINFO_FLT_OPERATION;
#[repr(C, packed)]
pub struct _PERFINFO_FLT_OPERATION_STATUS {
   pub RoutineAddr: PVOID,
   pub FileObject: PVOID,
   pub FsContext: PVOID,
   pub IrpPtr: PVOID,
   pub CbdPtr: PVOID,
   pub MajorFunction: LONG,
   pub Status: NTSTATUS,
}
impl Default for _PERFINFO_FLT_OPERATION_STATUS {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_FLT_OPERATION_STATUS = _PERFINFO_FLT_OPERATION_STATUS;
pub type PPERFINFO_FLT_OPERATION_STATUS = *mut _PERFINFO_FLT_OPERATION_STATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_MEMORY_INFORMATION {
   pub ZeroPageCount: SIZE_T,
   pub FreePageCount: SIZE_T,
   pub ModifiedPageCount: SIZE_T,
   pub ModifiedNoWritePageCount: SIZE_T,
   pub BadPageCount: SIZE_T,
   pub PageCountByPriority: [SIZE_T; 8usize],
   pub RepurposedPagesByPriority: [SIZE_T; 8usize],
   pub ModifiedPageCountPageFile: SIZE_T,
}
pub type PERFINFO_MEMORY_INFORMATION = _PERFINFO_MEMORY_INFORMATION;
pub type PPERFINFO_MEMORY_INFORMATION = *mut _PERFINFO_MEMORY_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_SYSTEM_MEMORY_INFORMATION {
   pub PagedPoolCommitPageCount: SIZE_T,
   pub NonPagedPoolPageCount: SIZE_T,
   pub MdlPageCount: SIZE_T,
   pub CommitPageCount: SIZE_T,
}
pub type PERFINFO_SYSTEM_MEMORY_INFORMATION = _PERFINFO_SYSTEM_MEMORY_INFORMATION;
pub type PPERFINFO_SYSTEM_MEMORY_INFORMATION = *mut _PERFINFO_SYSTEM_MEMORY_INFORMATION;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_WORKINGSET_ENTRY {
   pub __bindgen_anon_1: _PERFINFO_WORKINGSET_ENTRY__bindgen_ty_1,
   pub WorkingSetPageCount: SIZE_T,
   pub CommitPageCount: SIZE_T,
   pub __bindgen_anon_2: _PERFINFO_WORKINGSET_ENTRY__bindgen_ty_2,
   pub PrivateWorkingSetPageCount: SIZE_T,
   pub StoreSizeInPages: SIZE_T,
   pub StoredPageCount: SIZE_T,
   pub CommitDebtInPages: SIZE_T,
   pub SharedCommitInPages: SIZE_T,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _PERFINFO_WORKINGSET_ENTRY__bindgen_ty_1 {
   pub UniqueProcessId: ULONG,
   pub SessionId: ULONG,
}
impl Default for _PERFINFO_WORKINGSET_ENTRY__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _PERFINFO_WORKINGSET_ENTRY__bindgen_ty_2 {
   pub PagedPoolPageCount: SIZE_T,
   pub VirtualSizeInPages: SIZE_T,
}
impl Default for _PERFINFO_WORKINGSET_ENTRY__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _PERFINFO_WORKINGSET_ENTRY {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_WORKINGSET_ENTRY = _PERFINFO_WORKINGSET_ENTRY;
pub type PPERFINFO_WORKINGSET_ENTRY = *mut _PERFINFO_WORKINGSET_ENTRY;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _PERFINFO_WORKINGSET_INFORMATION {
   pub Count: ULONG,
   pub WsEntry: [PERFINFO_WORKINGSET_ENTRY; 1usize],
}
impl Default for _PERFINFO_WORKINGSET_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_WORKINGSET_INFORMATION = _PERFINFO_WORKINGSET_INFORMATION;
pub type PPERFINFO_WORKINGSET_INFORMATION = *mut _PERFINFO_WORKINGSET_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CONTIGUOUS_PAGE_GENERATE {
   pub ThreadId: ULONGLONG,
   pub NumberOfBytes: ULONGLONG,
}
pub type PERFINFO_CONTIGUOUS_PAGE_GENERATE = _PERFINFO_CONTIGUOUS_PAGE_GENERATE;
pub type PPERFINFO_CONTIGUOUS_PAGE_GENERATE = *mut _PERFINFO_CONTIGUOUS_PAGE_GENERATE;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_DEBUG_EVENT_REASON {
   PerfInfoDebugEventReceived = 1,
   PerfInfoDebugEventContinued = 2,
   PerfInfoDebugEventMax = 3,
}
pub use self::_PERFINFO_DEBUG_EVENT_REASON as PERFINFO_DEBUG_EVENT_REASON;
pub type PPERFINFO_DEBUG_EVENT_REASON = *mut _PERFINFO_DEBUG_EVENT_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_DEBUG_EVENT {
   pub ProcessId: ULONG,
   pub ThreadId: ULONG,
   pub Reason: PERFINFO_DEBUG_EVENT_REASON,
}
impl Default for _PERFINFO_DEBUG_EVENT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_DEBUG_EVENT = _PERFINFO_DEBUG_EVENT;
pub type PPERFINFO_DEBUG_EVENT = *mut _PERFINFO_DEBUG_EVENT;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PERFINFO_CCSWAP_TYPE {
   PerfCSwapIdleShort = 0,
   PerfCSwapIdle = 1,
   PerfCSwapLite = 2,
   PerfCSwapFull = 3,
}
pub use self::_PERFINFO_CCSWAP_TYPE as PERFINFO_CCSWAP_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CCSWAP_BUFFER {
   pub FirstTimeStamp: LONGLONG,
   pub TidTable: [ULONG; 16usize],
   pub ThreadBasePriority: [SCHAR; 16usize],
}
pub type PERFINFO_CCSWAP_BUFFER = _PERFINFO_CCSWAP_BUFFER;
pub type PPERFINFO_CCSWAP_BUFFER = *mut _PERFINFO_CCSWAP_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CCSWAP_IDLE_SHORT {
   pub _bitfield_align_1: [u16; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _PERFINFO_CCSWAP_IDLE_SHORT {
   #[inline]
   pub fn DataType(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
   }
   #[inline]
   pub fn set_DataType(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DataType_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_DataType_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TimeDelta(&self) -> USHORT {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
   }
   #[inline]
   pub fn set_TimeDelta(&mut self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 14u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TimeDelta_raw(this: *const Self) -> USHORT {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            14u8,
         ) as u16)
      }
   }
   #[inline]
   pub unsafe fn set_TimeDelta_raw(this: *mut Self, val: USHORT) {
      unsafe {
         let val: u16 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            14u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DataType: USHORT,
      TimeDelta: USHORT,
   ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let DataType: u16 = unsafe { ::core::mem::transmute(DataType) };
         DataType as u64
      });
      __bindgen_bitfield_unit.set(2usize, 14u8, {
         let TimeDelta: u16 = unsafe { ::core::mem::transmute(TimeDelta) };
         TimeDelta as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PERFINFO_CCSWAP_IDLE_SHORT = _PERFINFO_CCSWAP_IDLE_SHORT;
pub type PPERFINFO_CCSWAP_IDLE_SHORT = *mut _PERFINFO_CCSWAP_IDLE_SHORT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CCSWAP_IDLE {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PERFINFO_CCSWAP_IDLE {
   #[inline]
   pub fn DataType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_DataType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DataType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DataType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TimeDelta(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_TimeDelta(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TimeDelta_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TimeDelta_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(DataType: ULONG, TimeDelta: ULONG) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let DataType: u32 = unsafe { ::core::mem::transmute(DataType) };
         DataType as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let TimeDelta: u32 = unsafe { ::core::mem::transmute(TimeDelta) };
         TimeDelta as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PERFINFO_CCSWAP_IDLE = _PERFINFO_CCSWAP_IDLE;
pub type PPERFINFO_CCSWAP_IDLE = *mut _PERFINFO_CCSWAP_IDLE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CCSWAP_LITE {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PERFINFO_CCSWAP_LITE {
   #[inline]
   pub fn DataType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_DataType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DataType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DataType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn OldThreadIdIndex(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_OldThreadIdIndex(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn OldThreadIdIndex_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_OldThreadIdIndex_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn OldThreadPriInc(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
   }
   #[inline]
   pub fn set_OldThreadPriInc(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(6usize, 3u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn OldThreadPriInc_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            6usize,
            3u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_OldThreadPriInc_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            6usize,
            3u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn OldThreadStateWr(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_OldThreadStateWr(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(9usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn OldThreadStateWr_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            9usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_OldThreadStateWr_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            9usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TimeDelta(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
   }
   #[inline]
   pub fn set_TimeDelta(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(15usize, 17u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TimeDelta_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            15usize,
            17u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TimeDelta_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            15usize,
            17u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DataType: ULONG,
      OldThreadIdIndex: ULONG,
      OldThreadPriInc: ULONG,
      OldThreadStateWr: ULONG,
      TimeDelta: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let DataType: u32 = unsafe { ::core::mem::transmute(DataType) };
         DataType as u64
      });
      __bindgen_bitfield_unit.set(2usize, 4u8, {
         let OldThreadIdIndex: u32 = unsafe { ::core::mem::transmute(OldThreadIdIndex) };
         OldThreadIdIndex as u64
      });
      __bindgen_bitfield_unit.set(6usize, 3u8, {
         let OldThreadPriInc: u32 = unsafe { ::core::mem::transmute(OldThreadPriInc) };
         OldThreadPriInc as u64
      });
      __bindgen_bitfield_unit.set(9usize, 6u8, {
         let OldThreadStateWr: u32 = unsafe { ::core::mem::transmute(OldThreadStateWr) };
         OldThreadStateWr as u64
      });
      __bindgen_bitfield_unit.set(15usize, 17u8, {
         let TimeDelta: u32 = unsafe { ::core::mem::transmute(TimeDelta) };
         TimeDelta as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PERFINFO_CCSWAP_LITE = _PERFINFO_CCSWAP_LITE;
pub type PPERFINFO_CCSWAP_LITE = *mut _PERFINFO_CCSWAP_LITE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_CCSWAP {
   pub _bitfield_align_1: [u32; 0],
   pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl _PERFINFO_CCSWAP {
   #[inline]
   pub fn DataType(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
   }
   #[inline]
   pub fn set_DataType(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(0usize, 2u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn DataType_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            0usize,
            2u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_DataType_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            0usize,
            2u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn TimeDelta(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
   }
   #[inline]
   pub fn set_TimeDelta(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(2usize, 30u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn TimeDelta_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            2usize,
            30u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_TimeDelta_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            2usize,
            30u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn OldThreadIdIndex(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u32) }
   }
   #[inline]
   pub fn set_OldThreadIdIndex(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(32usize, 4u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn OldThreadIdIndex_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            32usize,
            4u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_OldThreadIdIndex_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            32usize,
            4u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn OldThreadStateWr(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 6u8) as u32) }
   }
   #[inline]
   pub fn set_OldThreadStateWr(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(36usize, 6u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn OldThreadStateWr_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            36usize,
            6u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_OldThreadStateWr_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            36usize,
            6u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn OldThreadPriority(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 5u8) as u32) }
   }
   #[inline]
   pub fn set_OldThreadPriority(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(42usize, 5u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn OldThreadPriority_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            42usize,
            5u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_OldThreadPriority_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            42usize,
            5u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn NewThreadWaitTime(&self) -> ULONG {
      unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 17u8) as u32) }
   }
   #[inline]
   pub fn set_NewThreadWaitTime(&mut self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         self._bitfield_1.set(47usize, 17u8, val as u64)
      }
   }
   #[inline]
   pub unsafe fn NewThreadWaitTime_raw(this: *const Self) -> ULONG {
      unsafe {
         ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
            ::core::ptr::addr_of!((*this)._bitfield_1),
            47usize,
            17u8,
         ) as u32)
      }
   }
   #[inline]
   pub unsafe fn set_NewThreadWaitTime_raw(this: *mut Self, val: ULONG) {
      unsafe {
         let val: u32 = ::core::mem::transmute(val);
         <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
            ::core::ptr::addr_of_mut!((*this)._bitfield_1),
            47usize,
            17u8,
            val as u64,
         )
      }
   }
   #[inline]
   pub fn new_bitfield_1(
      DataType: ULONG,
      TimeDelta: ULONG,
      OldThreadIdIndex: ULONG,
      OldThreadStateWr: ULONG,
      OldThreadPriority: ULONG,
      NewThreadWaitTime: ULONG,
   ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
      let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
      __bindgen_bitfield_unit.set(0usize, 2u8, {
         let DataType: u32 = unsafe { ::core::mem::transmute(DataType) };
         DataType as u64
      });
      __bindgen_bitfield_unit.set(2usize, 30u8, {
         let TimeDelta: u32 = unsafe { ::core::mem::transmute(TimeDelta) };
         TimeDelta as u64
      });
      __bindgen_bitfield_unit.set(32usize, 4u8, {
         let OldThreadIdIndex: u32 = unsafe { ::core::mem::transmute(OldThreadIdIndex) };
         OldThreadIdIndex as u64
      });
      __bindgen_bitfield_unit.set(36usize, 6u8, {
         let OldThreadStateWr: u32 = unsafe { ::core::mem::transmute(OldThreadStateWr) };
         OldThreadStateWr as u64
      });
      __bindgen_bitfield_unit.set(42usize, 5u8, {
         let OldThreadPriority: u32 = unsafe { ::core::mem::transmute(OldThreadPriority) };
         OldThreadPriority as u64
      });
      __bindgen_bitfield_unit.set(47usize, 17u8, {
         let NewThreadWaitTime: u32 = unsafe { ::core::mem::transmute(NewThreadWaitTime) };
         NewThreadWaitTime as u64
      });
      __bindgen_bitfield_unit
   }
}
pub type PERFINFO_CCSWAP = _PERFINFO_CCSWAP;
pub type PPERFINFO_CCSWAP = *mut _PERFINFO_CCSWAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PROCESS_PERFCTR {
   pub ProcessId: ULONG,
   pub PageFaultCount: ULONG,
   pub HandleCount: ULONG,
   pub Reserved: ULONG,
   pub PeakVirtualSize: SIZE_T,
   pub PeakWorkingSetSize: SIZE_T,
   pub PeakPagefileUsage: SIZE_T,
   pub QuotaPeakPagedPoolUsage: SIZE_T,
   pub QuotaPeakNonPagedPoolUsage: SIZE_T,
   pub VirtualSize: SIZE_T,
   pub WorkingSetSize: SIZE_T,
   pub PagefileUsage: SIZE_T,
   pub QuotaPagedPoolUsage: SIZE_T,
   pub QuotaNonPagedPoolUsage: SIZE_T,
   pub PrivatePageCount: SIZE_T,
}
pub type PERFINFO_PROCESS_PERFCTR = _PERFINFO_PROCESS_PERFCTR;
pub type PPERFINFO_PROCESS_PERFCTR = *mut _PERFINFO_PROCESS_PERFCTR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PROCESS_PERFCTR32 {
   pub ProcessId: ULONG,
   pub PageFaultCount: ULONG,
   pub HandleCount: ULONG,
   pub Reserved: ULONG,
   pub PeakVirtualSize: ULONG32,
   pub PeakWorkingSetSize: ULONG32,
   pub PeakPagefileUsage: ULONG32,
   pub QuotaPeakPagedPoolUsage: ULONG32,
   pub QuotaPeakNonPagedPoolUsage: ULONG32,
   pub VirtualSize: ULONG32,
   pub WorkingSetSize: ULONG32,
   pub PagefileUsage: ULONG32,
   pub QuotaPagedPoolUsage: ULONG32,
   pub QuotaNonPagedPoolUsage: ULONG32,
   pub PrivatePageCount: ULONG32,
}
pub type PERFINFO_PROCESS_PERFCTR32 = _PERFINFO_PROCESS_PERFCTR32;
pub type PPERFINFO_PROCESS_PERFCTR32 = *mut _PERFINFO_PROCESS_PERFCTR32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PROCESS_PERFCTR64 {
   pub ProcessId: ULONG,
   pub PageFaultCount: ULONG,
   pub HandleCount: ULONG,
   pub Reserved: ULONG,
   pub PeakVirtualSize: ULONG64,
   pub PeakWorkingSetSize: ULONG64,
   pub PeakPagefileUsage: ULONG64,
   pub QuotaPeakPagedPoolUsage: ULONG64,
   pub QuotaPeakNonPagedPoolUsage: ULONG64,
   pub VirtualSize: ULONG64,
   pub WorkingSetSize: ULONG64,
   pub PagefileUsage: ULONG64,
   pub QuotaPagedPoolUsage: ULONG64,
   pub QuotaNonPagedPoolUsage: ULONG64,
   pub PrivatePageCount: ULONG64,
}
pub type PERFINFO_PROCESS_PERFCTR64 = _PERFINFO_PROCESS_PERFCTR64;
pub type PPERFINFO_PROCESS_PERFCTR64 = *mut _PERFINFO_PROCESS_PERFCTR64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PERFINFO_PROCESS_INSWAP {
   pub DirectoryTableBase: ULONG_PTR,
   pub ProcessId: ULONG,
}
pub type PERFINFO_PROCESS_INSWAP = _PERFINFO_PROCESS_INSWAP;
pub type PPERFINFO_PROCESS_INSWAP = *mut _PERFINFO_PROCESS_INSWAP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFINFO_IO_TIMER {
   pub DeviceObject: PVOID,
   pub RoutineAddress: PVOID,
}
impl Default for _PERFINFO_IO_TIMER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type PERFINFO_IO_TIMER = _PERFINFO_IO_TIMER;
pub type PPERFINFO_IO_TIMER = *mut _PERFINFO_IO_TIMER;
#[repr(C)]
pub struct _WMI_LOGGER_INFORMATION {
   pub Wnode: WNODE_HEADER,
   pub BufferSize: ULONG,
   pub MinimumBuffers: ULONG,
   pub MaximumBuffers: ULONG,
   pub MaximumFileSize: ULONG,
   pub LogFileMode: ULONG,
   pub FlushTimer: ULONG,
   pub EnableFlags: ULONG,
   pub __bindgen_anon_1: _WMI_LOGGER_INFORMATION__bindgen_ty_1,
   pub Wow: ULONG,
   pub __bindgen_anon_2: _WMI_LOGGER_INFORMATION__bindgen_ty_2,
   pub __bindgen_anon_3: _WMI_LOGGER_INFORMATION__bindgen_ty_3,
   pub __bindgen_anon_4: _WMI_LOGGER_INFORMATION__bindgen_ty_4,
   pub __bindgen_anon_5: _WMI_LOGGER_INFORMATION__bindgen_ty_5,
   pub BuffersWritten: ULONG,
   pub __bindgen_anon_6: _WMI_LOGGER_INFORMATION__bindgen_ty_6,
   pub RealTimeBuffersLost: ULONG,
   pub __bindgen_anon_7: _WMI_LOGGER_INFORMATION__bindgen_ty_7,
   pub __bindgen_anon_8: _WMI_LOGGER_INFORMATION__bindgen_ty_8,
   pub __bindgen_anon_9: _WMI_LOGGER_INFORMATION__bindgen_ty_9,
   pub RealTimeConsumerCount: ULONG,
   pub SpareUlong: ULONG,
   pub DUMMYUNIONNAME10: _WMI_LOGGER_INFORMATION__bindgen_ty_10,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_1 {
   pub AgeLimit: LONG,
   pub FlushThreshold: LONG,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_2 {
   pub LogFileHandle: HANDLE,
   pub LogFileHandle64: ULONG64,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_2 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_3 {
   pub NumberOfBuffers: ULONG,
   pub InstanceCount: ULONG,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_3 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_4 {
   pub FreeBuffers: ULONG,
   pub InstanceId: ULONG,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_4 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_5 {
   pub EventsLost: ULONG,
   pub NumberOfProcessors: ULONG,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_5 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_6 {
   pub LogBuffersLost: ULONG,
   pub Flags: ULONG,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_6 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_7 {
   pub LoggerThreadId: HANDLE,
   pub LoggerThreadId64: ULONG64,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_7 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_8 {
   pub LogFileName: ::core::mem::ManuallyDrop<UNICODE_STRING>,
   pub LogFileName64: ::core::mem::ManuallyDrop<UNICODE_STRING64>,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_8 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_9 {
   pub LoggerName: ::core::mem::ManuallyDrop<UNICODE_STRING>,
   pub LoggerName64: ::core::mem::ManuallyDrop<UNICODE_STRING64>,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_9 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WMI_LOGGER_INFORMATION__bindgen_ty_10 {
   pub LoggerExtension: PVOID,
   pub LoggerExtension64: ULONG64,
}
impl Default for _WMI_LOGGER_INFORMATION__bindgen_ty_10 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _WMI_LOGGER_INFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMI_LOGGER_INFORMATION = _WMI_LOGGER_INFORMATION;
pub type PWMI_LOGGER_INFORMATION = *mut _WMI_LOGGER_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_UMGL_KEY {
   pub LoggerId: UCHAR,
   pub Flags: UCHAR,
}
pub type ETW_UMGL_KEY = _ETW_UMGL_KEY;
pub type PETW_UMGL_KEY = *mut _ETW_UMGL_KEY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_KERNEL_HEADER_EXTENSION {
   pub GroupMasks: PERFINFO_GROUPMASK,
   pub Version: ULONG,
}
pub type ETW_KERNEL_HEADER_EXTENSION = _ETW_KERNEL_HEADER_EXTENSION;
pub type PETW_KERNEL_HEADER_EXTENSION = *mut _ETW_KERNEL_HEADER_EXTENSION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_SET_MARK_INFORMATION {
   pub Flag: ULONG,
   pub Mark: [WCHAR; 1usize],
}
pub type ETW_SET_MARK_INFORMATION = _ETW_SET_MARK_INFORMATION;
pub type PETW_SET_MARK_INFORMATION = *mut _ETW_SET_MARK_INFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_NOTIFICATION_TYPE {
   EtwNotificationTypeNoReply = 1,
   EtwNotificationTypeLegacyEnable = 2,
   EtwNotificationTypeEnable = 3,
   EtwNotificationTypePrivateLogger = 4,
   EtwNotificationTypePerflib = 5,
   EtwNotificationTypeAudio = 6,
   EtwNotificationTypeSession = 7,
   EtwNotificationTypeReserved = 8,
   EtwNotificationTypeCredentialUI = 9,
   EtwNotificationTypeInProcSession = 10,
   EtwNotificationTypeMax = 11,
}
pub use self::_ETW_NOTIFICATION_TYPE as ETW_NOTIFICATION_TYPE;
#[repr(C)]
pub struct _ETW_NOTIFICATION_HEADER {
   pub NotificationType: ETW_NOTIFICATION_TYPE,
   pub NotificationSize: ULONG,
   pub Offset: ULONG,
   pub ReplyRequested: BOOLEAN,
   pub Timeout: ULONG,
   pub __bindgen_anon_1: _ETW_NOTIFICATION_HEADER__bindgen_ty_1,
   pub Reserved2: ULONGLONG,
   pub TargetPID: ULONG,
   pub SourcePID: ULONG,
   pub DestinationGuid: GUID,
   pub SourceGuid: GUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETW_NOTIFICATION_HEADER__bindgen_ty_1 {
   pub ReplyCount: ULONG,
   pub NotifyeeCount: ULONG,
}
impl Default for _ETW_NOTIFICATION_HEADER__bindgen_ty_1 {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
impl Default for _ETW_NOTIFICATION_HEADER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_NOTIFICATION_HEADER = _ETW_NOTIFICATION_HEADER;
pub type PETW_NOTIFICATION_HEADER = *mut _ETW_NOTIFICATION_HEADER;
pub type PETW_NOTIFICATION_CALLBACK = ::core::option::Option<
   unsafe extern "C" fn(NotificationHeader: PETW_NOTIFICATION_HEADER, Context: PVOID) -> ULONG,
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETW_SESSION_NOTIFICATION_TYPE {
   EtwSessionNotificationMediaChanged = 1,
   EtwSessionNotificationSessionTerminated = 2,
   EtwSessionNotificationLogfileError = 3,
   EtwSessionNotificationRealtimeError = 4,
   EtwSessionNotificationSessionStarted = 5,
   EtwSessionNotificationMax = 6,
}
pub use self::_ETW_SESSION_NOTIFICATION_TYPE as ETW_SESSION_NOTIFICATION_TYPE;
#[repr(C)]
pub struct _ETW_SESSION_NOTIFICATION_PACKET {
   pub NotificationHeader: ETW_NOTIFICATION_HEADER,
   pub Type: ETW_SESSION_NOTIFICATION_TYPE,
   pub Status: NTSTATUS,
   pub TraceHandle: TRACEHANDLE,
   pub Reserved: [ULONG; 2usize],
}
impl Default for _ETW_SESSION_NOTIFICATION_PACKET {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type ETW_SESSION_NOTIFICATION_PACKET = _ETW_SESSION_NOTIFICATION_PACKET;
pub type PETW_SESSION_NOTIFICATION_PACKET = *mut _ETW_SESSION_NOTIFICATION_PACKET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EVENT_DESCRIPTOR {
   pub Id: USHORT,
   pub Version: UCHAR,
   pub Channel: UCHAR,
   pub Level: UCHAR,
   pub Opcode: UCHAR,
   pub Task: USHORT,
   pub Keyword: ULONGLONG,
}
pub type EVENT_DESCRIPTOR = _EVENT_DESCRIPTOR;
pub type PEVENT_DESCRIPTOR = *mut _EVENT_DESCRIPTOR;
pub type PCEVENT_DESCRIPTOR = *const EVENT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_DATA_DESCRIPTOR {
   _unused: [u8; 0],
}
pub type EVENT_DATA_DESCRIPTOR = _EVENT_DATA_DESCRIPTOR;
pub type PEVENT_DATA_DESCRIPTOR = *mut _EVENT_DATA_DESCRIPTOR;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EVENT_INFO_CLASS {
   __bindgen_cannot_repr_c_on_empty_enum = 0,
}
pub use self::_EVENT_INFO_CLASS as EVENT_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_TRACE_PROVIDER_INSTANCE_INFO {
   pub NextOffset: ULONG,
   pub EnableCount: ULONG,
   pub Pid: ULONG,
   pub Flags: ULONG,
}
pub type ETW_TRACE_PROVIDER_INSTANCE_INFO = _ETW_TRACE_PROVIDER_INSTANCE_INFO;
pub type PETW_TRACE_PROVIDER_INSTANCE_INFO = *mut _ETW_TRACE_PROVIDER_INSTANCE_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ETW_TRACE_GUID_INFO {
   pub InstanceCount: ULONG,
   pub Reserved: ULONG,
}
pub type ETW_TRACE_GUID_INFO = _ETW_TRACE_GUID_INFO;
pub type PETW_TRACE_GUID_INFO = *mut _ETW_TRACE_GUID_INFO;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ETWTRACECONTROLCODE {
   EtwStartLoggerCode = 1,
   EtwStopLoggerCode = 2,
   EtwQueryLoggerCode = 3,
   EtwUpdateLoggerCode = 4,
   EtwFlushLoggerCode = 5,
   EtwIncrementLoggerFile = 6,
   EtwRealtimeTransition = 7,
   EtwRealtimeConnectCode = 11,
   EtwActivityIdCreate = 12,
   EtwWdiScenarioCode = 13,
   EtwRealtimeDisconnectCode = 14,
   EtwRegisterGuidsCode = 15,
   EtwReceiveNotification = 16,
   EtwSendDataBlock = 17,
   EtwSendReplyDataBlock = 18,
   EtwReceiveReplyDataBlock = 19,
   EtwWdiSemUpdate = 20,
   EtwEnumTraceGuidList = 21,
   EtwGetTraceGuidInfo = 22,
   EtwEnumerateTraceGuids = 23,
   EtwRegisterSecurityProv = 24,
   EtwReferenceTimeCode = 25,
   EtwTrackBinaryCode = 26,
   EtwAddNotificationEvent = 27,
   EtwUpdateDisallowList = 28,
   EtwSetEnableAllKeywordsCode = 29,
   EtwSetProviderTraitsCode = 30,
   EtwUseDescriptorTypeCode = 31,
   EtwEnumTraceGroupList = 32,
   EtwGetTraceGroupInfo = 33,
   EtwGetDisallowList = 34,
   EtwSetCompressionSettings = 35,
   EtwGetCompressionSettings = 36,
   EtwUpdatePeriodicCaptureState = 37,
   EtwGetPrivateSessionTraceHandle = 38,
   EtwRegisterPrivateSession = 39,
   EtwQuerySessionDemuxObject = 40,
   EtwSetProviderBinaryTracking = 41,
   EtwMaxLoggers = 42,
   EtwMaxPmcCounter = 43,
   EtwQueryUsedProcessorCount = 44,
   EtwGetPmcOwnership = 45,
   EtwGetPmcSessions = 46,
}
pub use self::_ETWTRACECONTROLCODE as ETWTRACECONTROLCODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TELEMETRY_COVERAGE_POINT {
   pub Name: PWSTR,
   pub Hash: ULONG,
   pub LastCoveredRound: ULONG,
   pub Flags: ULONG,
}
impl Default for _TELEMETRY_COVERAGE_POINT {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type TELEMETRY_COVERAGE_POINT = _TELEMETRY_COVERAGE_POINT;
pub type PTELEMETRY_COVERAGE_POINT = *mut _TELEMETRY_COVERAGE_POINT;
pub type PNOTIFICATIONCALLBACK =
   ::core::option::Option<unsafe extern "C" fn(arg1: PWNODE_HEADER, arg2: ULONG_PTR)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOFRESOURCEINFOA {
   pub ImagePath: PSTR,
   pub ResourceName: PSTR,
   pub ResourceSize: ULONG,
   pub ResourceBuffer: PUCHAR,
}
impl Default for _MOFRESOURCEINFOA {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOFRESOURCEINFOA = _MOFRESOURCEINFOA;
pub type PMOFRESOURCEINFOA = *mut _MOFRESOURCEINFOA;
pub type MOFRESOURCEINFO = _MOFRESOURCEINFOW;
pub type PMOFRESOURCEINFO = *mut _MOFRESOURCEINFOW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOFRESOURCEINFOW {
   pub ImagePath: LPWSTR,
   pub ResourceName: LPWSTR,
   pub ResourceSize: ULONG,
   pub ResourceBuffer: PUCHAR,
}
impl Default for _MOFRESOURCEINFOW {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type MOFRESOURCEINFOW = _MOFRESOURCEINFOW;
pub type PMOFRESOURCEINFOW = *mut _MOFRESOURCEINFOW;
#[repr(C)]
pub struct _WMIGUIDINFORMATION {
   pub Size: ULONG,
   pub IsExpensive: BOOLEAN,
   pub IsEventOnly: BOOLEAN,
}
impl Default for _WMIGUIDINFORMATION {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type WMIGUIDINFORMATION = _WMIGUIDINFORMATION;
pub type PWMIGUIDINFORMATION = *mut _WMIGUIDINFORMATION;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WINDOWINFOCLASS {
   WindowProcess = 0,
   WindowRealProcess = 1,
   WindowThread = 2,
   WindowActiveWindow = 3,
   WindowFocusWindow = 4,
   WindowIsHung = 5,
   WindowClientBase = 6,
   WindowIsForegroundThread = 7,
   WindowDefaultImeWindow = 8,
   WindowDefaultInputContext = 9,
}
pub use self::_WINDOWINFOCLASS as WINDOWINFOCLASS;
pub type PWINDOWINFOCLASS = *mut _WINDOWINFOCLASS;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CONSOLECONTROL {
   ConsoleSetVDMCursorBounds = 0,
   ConsoleNotifyConsoleApplication = 1,
   ConsoleFullscreenSwitch = 2,
   ConsoleSetCaretInfo = 3,
   ConsoleSetReserveKeys = 4,
   ConsoleSetForeground = 5,
   ConsoleSetWindowOwner = 6,
   ConsoleEndTask = 7,
}
pub use self::_CONSOLECONTROL as CONSOLECONTROL;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CONSOLE_PROCESS_INFO {
   pub ProcessID: ULONG,
   pub Flags: ULONG,
}
pub type CONSOLE_PROCESS_INFO = _CONSOLE_PROCESS_INFO;
pub type PCONSOLE_PROCESS_INFO = *mut _CONSOLE_PROCESS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_CARET_INFO {
   pub WindowHandle: HWND,
   pub Rect: RECT,
}
impl Default for _CONSOLE_CARET_INFO {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CONSOLE_CARET_INFO = _CONSOLE_CARET_INFO;
pub type PCONSOLE_CARET_INFO = *mut _CONSOLE_CARET_INFO;
#[repr(C)]
pub struct _CONSOLESETFOREGROUND {
   pub ProcessHandle: HANDLE,
   pub Foreground: BOOL,
}
impl Default for _CONSOLESETFOREGROUND {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CONSOLESETFOREGROUND = _CONSOLESETFOREGROUND;
pub type PCONSOLESETFOREGROUND = *mut _CONSOLESETFOREGROUND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLEWINDOWOWNER {
   pub WindowHandle: HWND,
   pub ProcessId: ULONG,
   pub ThreadId: ULONG,
}
impl Default for _CONSOLEWINDOWOWNER {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CONSOLEWINDOWOWNER = _CONSOLEWINDOWOWNER;
pub type PCONSOLEWINDOWOWNER = *mut _CONSOLEWINDOWOWNER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLEENDTASK {
   pub ProcessId: HANDLE,
   pub WindowHandle: HWND,
   pub ConsoleEventCode: ULONG,
   pub ConsoleFlags: ULONG,
}
impl Default for _CONSOLEENDTASK {
   fn default() -> Self {
      let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
      unsafe {
         ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
         s.assume_init()
      }
   }
}
pub type CONSOLEENDTASK = _CONSOLEENDTASK;
pub type PCONSOLEENDTASK = *mut _CONSOLEENDTASK;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _USERTHREADINFOCLASS {
   __bindgen_cannot_repr_c_on_empty_enum = 0,
}
pub use self::_USERTHREADINFOCLASS as USERTHREADINFOCLASS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KERNEL_CALLBACK_TABLE {
   pub __fnCOPYDATA: ULONG_PTR,
   pub __fnCOPYGLOBALDATA: ULONG_PTR,
   pub __fnEMPTY1: ULONG_PTR,
   pub __fnNCDESTROY: ULONG_PTR,
   pub __fnDWORDOPTINLPMSG: ULONG_PTR,
   pub __fnINOUTDRAG: ULONG_PTR,
   pub __fnGETTEXTLENGTHS1: ULONG_PTR,
   pub __fnINCNTOUTSTRING: ULONG_PTR,
   pub __fnINCNTOUTSTRINGNULL: ULONG_PTR,
   pub __fnINLPCOMPAREITEMSTRUCT: ULONG_PTR,
   pub __fnINLPCREATESTRUCT: ULONG_PTR,
   pub __fnINLPDELETEITEMSTRUCT: ULONG_PTR,
   pub __fnINLPDRAWITEMSTRUCT: ULONG_PTR,
   pub __fnPOPTINLPUINT1: ULONG_PTR,
   pub __fnPOPTINLPUINT2: ULONG_PTR,
   pub __fnINLPMDICREATESTRUCT: ULONG_PTR,
   pub __fnINOUTLPMEASUREITEMSTRUCT: ULONG_PTR,
   pub __fnINLPWINDOWPOS: ULONG_PTR,
   pub __fnINOUTLPPOINT51: ULONG_PTR,
   pub __fnINOUTLPSCROLLINFO: ULONG_PTR,
   pub __fnINOUTLPRECT: ULONG_PTR,
   pub __fnINOUTNCCALCSIZE: ULONG_PTR,
   pub __fnINOUTLPPOINT52: ULONG_PTR,
   pub __fnINPAINTCLIPBRD: ULONG_PTR,
   pub __fnINSIZECLIPBRD: ULONG_PTR,
   pub __fnINDESTROYCLIPBRD: ULONG_PTR,
   pub __fnINSTRINGNULL1: ULONG_PTR,
   pub __fnINSTRINGNULL2: ULONG_PTR,
   pub __fnINDEVICECHANGE: ULONG_PTR,
   pub __fnPOWERBROADCAST: ULONG_PTR,
   pub __fnINLPUAHDRAWMENU1: ULONG_PTR,
   pub __fnOPTOUTLPDWORDOPTOUTLPDWORD1: ULONG_PTR,
   pub __fnOPTOUTLPDWORDOPTOUTLPDWORD2: ULONG_PTR,
   pub __fnOUTDWORDINDWORD: ULONG_PTR,
   pub __fnOUTLPRECT: ULONG_PTR,
   pub __fnOUTSTRING: ULONG_PTR,
   pub __fnPOPTINLPUINT3: ULONG_PTR,
   pub __fnPOUTLPINT: ULONG_PTR,
   pub __fnSENTDDEMSG: ULONG_PTR,
   pub __fnINOUTSTYLECHANGE1: ULONG_PTR,
   pub __fnHkINDWORD: ULONG_PTR,
   pub __fnHkINLPCBTACTIVATESTRUCT: ULONG_PTR,
   pub __fnHkINLPCBTCREATESTRUCT: ULONG_PTR,
   pub __fnHkINLPDEBUGHOOKSTRUCT: ULONG_PTR,
   pub __fnHkINLPMOUSEHOOKSTRUCTEX1: ULONG_PTR,
   pub __fnHkINLPKBDLLHOOKSTRUCT: ULONG_PTR,
   pub __fnHkINLPMSLLHOOKSTRUCT: ULONG_PTR,
   pub __fnHkINLPMSG: ULONG_PTR,
   pub __fnHkINLPRECT: ULONG_PTR,
   pub __fnHkOPTINLPEVENTMSG: ULONG_PTR,
   pub __xxxClientCallDelegateThread: ULONG_PTR,
   pub __ClientCallDummyCallback1: ULONG_PTR,
   pub __ClientCallDummyCallback2: ULONG_PTR,
   pub __fnSHELLWINDOWMANAGEMENTCALLOUT: ULONG_PTR,
   pub __fnSHELLWINDOWMANAGEMENTNOTIFY: ULONG_PTR,
   pub __ClientCallDummyCallback3: ULONG_PTR,
   pub __xxxClientCallDitThread: ULONG_PTR,
   pub __xxxClientEnableMMCSS: ULONG_PTR,
   pub __xxxClientUpdateDpi: ULONG_PTR,
   pub __xxxClientExpandStringW: ULONG_PTR,
   pub __ClientCopyDDEIn1: ULONG_PTR,
   pub __ClientCopyDDEIn2: ULONG_PTR,
   pub __ClientCopyDDEOut1: ULONG_PTR,
   pub __ClientCopyDDEOut2: ULONG_PTR,
   pub __ClientCopyImage: ULONG_PTR,
   pub __ClientEventCallback: ULONG_PTR,
   pub __ClientFindMnemChar: ULONG_PTR,
   pub __ClientFreeDDEHandle: ULONG_PTR,
   pub __ClientFreeLibrary: ULONG_PTR,
   pub __ClientGetCharsetInfo: ULONG_PTR,
   pub __ClientGetDDEFlags: ULONG_PTR,
   pub __ClientGetDDEHookData: ULONG_PTR,
   pub __ClientGetListboxString: ULONG_PTR,
   pub __ClientGetMessageMPH: ULONG_PTR,
   pub __ClientLoadImage: ULONG_PTR,
   pub __ClientLoadLibrary: ULONG_PTR,
   pub __ClientLoadMenu: ULONG_PTR,
   pub __ClientLoadLocalT1Fonts: ULONG_PTR,
   pub __ClientPSMTextOut: ULONG_PTR,
   pub __ClientLpkDrawTextEx: ULONG_PTR,
   pub __ClientExtTextOutW: ULONG_PTR,
   pub __ClientGetTextExtentPointW: ULONG_PTR,
   pub __ClientCharToWchar: ULONG_PTR,
   pub __ClientAddFontResourceW: ULONG_PTR,
   pub __ClientThreadSetup: ULONG_PTR,
   pub __ClientDeliverUserApc: ULONG_PTR,
   pub __ClientNoMemoryPopup: ULONG_PTR,
   pub __ClientMonitorEnumProc: ULONG_PTR,
   pub __ClientCallWinEventProc: ULONG_PTR,
   pub __ClientWaitMessageExMPH: ULONG_PTR,
   pub __ClientCallDummyCallback4: ULONG_PTR,
   pub __ClientCallDummyCallback5: ULONG_PTR,
   pub __ClientImmLoadLayout: ULONG_PTR,
   pub __ClientImmProcessKey: ULONG_PTR,
   pub __fnIMECONTROL: ULONG_PTR,
   pub __fnINWPARAMDBCSCHAR: ULONG_PTR,
   pub __fnGETTEXTLENGTHS2: ULONG_PTR,
   pub __ClientCallDummyCallback6: ULONG_PTR,
   pub __ClientLoadStringW: ULONG_PTR,
   pub __ClientLoadOLE: ULONG_PTR,
   pub __ClientRegisterDragDrop: ULONG_PTR,
   pub __ClientRevokeDragDrop: ULONG_PTR,
   pub __fnINOUTMENUGETOBJECT: ULONG_PTR,
   pub __ClientPrinterThunk: ULONG_PTR,
   pub __fnOUTLPCOMBOBOXINFO: ULONG_PTR,
   pub __fnOUTLPSCROLLBARINFO: ULONG_PTR,
   pub __fnINLPUAHDRAWMENU2: ULONG_PTR,
   pub __fnINLPUAHDRAWMENUITEM: ULONG_PTR,
   pub __fnINLPUAHDRAWMENU3: ULONG_PTR,
   pub __fnINOUTLPUAHMEASUREMENUITEM: ULONG_PTR,
   pub __fnINLPUAHDRAWMENU4: ULONG_PTR,
   pub __fnOUTLPTITLEBARINFOEX: ULONG_PTR,
   pub __fnTOUCH: ULONG_PTR,
   pub __fnGESTURE: ULONG_PTR,
   pub __fnPOPTINLPUINT4: ULONG_PTR,
   pub __fnPOPTINLPUINT5: ULONG_PTR,
   pub __xxxClientCallDefaultInputHandler: ULONG_PTR,
   pub __fnEMPTY2: ULONG_PTR,
   pub __ClientRimDevCallback: ULONG_PTR,
   pub __xxxClientCallMinTouchHitTestingCallback: ULONG_PTR,
   pub __ClientCallLocalMouseHooks: ULONG_PTR,
   pub __xxxClientBroadcastThemeChange: ULONG_PTR,
   pub __xxxClientCallDevCallbackSimple: ULONG_PTR,
   pub __xxxClientAllocWindowClassExtraBytes: ULONG_PTR,
   pub __xxxClientFreeWindowClassExtraBytes: ULONG_PTR,
   pub __fnGETWINDOWDATA: ULONG_PTR,
   pub __fnINOUTSTYLECHANGE2: ULONG_PTR,
   pub __fnHkINLPMOUSEHOOKSTRUCTEX2: ULONG_PTR,
   pub __xxxClientCallDefWindowProc: ULONG_PTR,
   pub __fnSHELLSYNCDISPLAYCHANGED: ULONG_PTR,
   pub __fnHkINLPCHARHOOKSTRUCT: ULONG_PTR,
   pub __fnINTERCEPTEDWINDOWACTION: ULONG_PTR,
   pub __xxxTooltipCallback: ULONG_PTR,
   pub __xxxClientInitPSBInfo: ULONG_PTR,
   pub __xxxClientDoScrollMenu: ULONG_PTR,
   pub __xxxClientEndScroll: ULONG_PTR,
   pub __xxxClientDrawSize: ULONG_PTR,
   pub __xxxClientDrawScrollBar: ULONG_PTR,
   pub __xxxClientHitTestScrollBar: ULONG_PTR,
   pub __xxxClientTrackInit: ULONG_PTR,
}
pub type KERNEL_CALLBACK_TABLE = _KERNEL_CALLBACK_TABLE;
pub type PKERNEL_CALLBACK_TABLE = *mut _KERNEL_CALLBACK_TABLE;
unsafe extern "C" {
   pub static GUID_NULL: GUID;
   pub static mut NlsAnsiCodePage: USHORT;
   pub static mut NlsMbCodePageTag: BOOLEAN;
   pub static mut NlsMbOemCodePageTag: BOOLEAN;
   pub fn NtCallbackReturn(OutputBuffer: PVOID, OutputLength: ULONG, Status: NTSTATUS) -> NTSTATUS;
   pub fn NtFlushProcessWriteBuffers() -> NTSTATUS;
   pub fn NtQueryDebugFilterState(ComponentId: ULONG, Level: ULONG) -> NTSTATUS;
   pub fn NtSetDebugFilterState(ComponentId: ULONG, Level: ULONG, State: BOOLEAN) -> NTSTATUS;
   pub fn NtYieldExecution() -> NTSTATUS;
   pub fn LdrLoadDll(
      DllPath: PCWSTR,
      DllCharacteristics: PULONG,
      DllName: PUNICODE_STRING,
      DllHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrUnloadDll(DllHandle: PVOID) -> NTSTATUS;
   pub fn LdrGetDllHandle(
      DllPath: PCWSTR,
      DllCharacteristics: PULONG,
      DllName: PUNICODE_STRING,
      DllHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrGetDllHandleEx(
      Flags: ULONG,
      DllPath: PCWSTR,
      DllCharacteristics: PULONG,
      DllName: PUNICODE_STRING,
      DllHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrGetDllHandleByMapping(BaseAddress: PVOID, DllHandle: *mut PVOID) -> NTSTATUS;
   pub fn LdrGetDllHandleByName(
      BaseDllName: PUNICODE_STRING,
      FullDllName: PUNICODE_STRING,
      DllHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrGetDllFullName(DllHandle: PVOID, FullDllName: PUNICODE_STRING) -> NTSTATUS;
   pub fn LdrGetDllPath(
      DllName: PCWSTR,
      Flags: ULONG,
      DllPath: *mut PWSTR,
      SearchPaths: *mut PWSTR,
   ) -> NTSTATUS;
   pub fn LdrGetDllDirectory(DllDirectory: PUNICODE_STRING) -> NTSTATUS;
   pub fn LdrSetDllDirectory(DllDirectory: PUNICODE_STRING) -> NTSTATUS;
   pub fn LdrAddRefDll(Flags: ULONG, DllHandle: PVOID) -> NTSTATUS;
   pub fn LdrGetProcedureAddress(
      DllHandle: PVOID,
      ProcedureName: PANSI_STRING,
      ProcedureNumber: ULONG,
      ProcedureAddress: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrGetProcedureAddressEx(
      DllHandle: PVOID,
      ProcedureName: PANSI_STRING,
      ProcedureNumber: ULONG,
      ProcedureAddress: *mut PVOID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrGetKnownDllSectionHandle(
      DllName: PCWSTR,
      KnownDlls32: BOOLEAN,
      Section: PHANDLE,
   ) -> NTSTATUS;
   pub fn LdrGetProcedureAddressForCaller(
      DllHandle: PVOID,
      ProcedureName: PANSI_STRING,
      ProcedureNumber: ULONG,
      ProcedureAddress: *mut PVOID,
      Flags: ULONG,
      Callback: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrLockLoaderLock(Flags: ULONG, Disposition: *mut ULONG, Cookie: *mut PVOID) -> NTSTATUS;
   pub fn LdrUnlockLoaderLock(Flags: ULONG, Cookie: PVOID) -> NTSTATUS;
   pub fn LdrRelocateImage(
      NewBase: PVOID,
      LoaderName: PSTR,
      Success: NTSTATUS,
      Conflict: NTSTATUS,
      Invalid: NTSTATUS,
   ) -> NTSTATUS;
   pub fn LdrRelocateImageWithBias(
      NewBase: PVOID,
      Bias: LONGLONG,
      LoaderName: PSTR,
      Success: NTSTATUS,
      Conflict: NTSTATUS,
      Invalid: NTSTATUS,
   ) -> NTSTATUS;
   pub fn LdrProcessRelocationBlock(
      VA: ULONG_PTR,
      SizeOfBlock: ULONG,
      NextOffset: PUSHORT,
      Diff: LONG_PTR,
   ) -> PIMAGE_BASE_RELOCATION;
   pub fn LdrProcessRelocationBlockEx(
      Machine: ULONG,
      VA: ULONG_PTR,
      SizeOfBlock: ULONG,
      NextOffset: PUSHORT,
      Diff: LONG_PTR,
   ) -> PIMAGE_BASE_RELOCATION;
   pub fn LdrVerifyMappedImageMatchesChecksum(
      BaseAddress: PVOID,
      NumberOfBytes: SIZE_T,
      FileLength: ULONG,
   ) -> BOOLEAN;
   pub fn LdrVerifyImageMatchesChecksum(
      ImageFileHandle: HANDLE,
      ImportCallbackRoutine: PLDR_IMPORT_MODULE_CALLBACK,
      ImportCallbackParameter: PVOID,
      ImageCharacteristics: PUSHORT,
   ) -> NTSTATUS;
   pub fn LdrVerifyImageMatchesChecksumEx(
      ImageFileHandle: HANDLE,
      VerifyInfo: PLDR_VERIFY_IMAGE_INFO,
   ) -> NTSTATUS;
   pub fn LdrQueryModuleServiceTags(
      DllHandle: PVOID,
      ServiceTagBuffer: PULONG,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn LdrRegisterDllNotification(
      Flags: ULONG,
      NotificationFunction: PLDR_DLL_NOTIFICATION_FUNCTION,
      Context: PVOID,
      Cookie: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrUnregisterDllNotification(Cookie: PVOID) -> NTSTATUS;
   pub fn LdrStandardizeSystemPath(SystemPath: PUNICODE_STRING) -> PUNICODE_STRING;
   pub fn LdrGetFailureData() -> PLDR_FAILURE_DATA;
   pub static mut LdrSystemDllInitBlock: PS_SYSTEM_DLL_INIT_BLOCK;
   pub static mut RtlpScpCfgNtdllExports: RTL_SCPCFG_NTDLL_EXPORTS;
   pub fn LdrAddLoadAsDataTable(
      Module: PVOID,
      FilePath: PCWSTR,
      Size: SIZE_T,
      Handle: HANDLE,
      ActCtx: PACTIVATION_CONTEXT,
   ) -> NTSTATUS;
   pub fn LdrRemoveLoadAsDataTable(
      InitModule: PVOID,
      BaseModule: *mut PVOID,
      Size: PSIZE_T,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrGetFileNameFromLoadAsDataTable(Module: PVOID, pFileNamePrt: *mut PVOID) -> NTSTATUS;
   pub fn LdrDisableThreadCalloutsForDll(DllImageBase: PVOID) -> NTSTATUS;
   pub fn LdrAccessResource(
      DllHandle: PVOID,
      ResourceDataEntry: PIMAGE_RESOURCE_DATA_ENTRY,
      ResourceBuffer: *mut PVOID,
      ResourceLength: *mut ULONG,
   ) -> NTSTATUS;
   pub fn LdrFindResource_U(
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      ResourceDataEntry: *mut PIMAGE_RESOURCE_DATA_ENTRY,
   ) -> NTSTATUS;
   pub fn LdrFindResourceEx_U(
      Flags: ULONG,
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      ResourceDataEntry: *mut PIMAGE_RESOURCE_DATA_ENTRY,
   ) -> NTSTATUS;
   pub fn LdrFindResourceDirectory_U(
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      ResourceDirectory: *mut PIMAGE_RESOURCE_DIRECTORY,
   ) -> NTSTATUS;
   #[doc = "The LdrResFindResource function finds a resource in a DLL.\n# Arguments\n\n* `DllHandle` - A handle to the DLL.\n* `Type` - The type of the resource.\n* `Name` - The name of the resource.\n* `Language` - The language of the resource.\n* `ResourceBuffer` - An optional pointer to receive the resource buffer.\n* `ResourceLength` - An optional pointer to receive the resource length.\n* `CultureName` - An optional buffer to receive the culture name.\n* `CultureNameLength` - An optional pointer to receive the length of the culture name.\n* `Flags` - Flags for the resource search.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn LdrResFindResource(
      DllHandle: PVOID,
      Type: ULONG_PTR,
      Name: ULONG_PTR,
      Language: ULONG_PTR,
      ResourceBuffer: *mut PVOID,
      ResourceLength: PULONG,
      CultureName: PVOID,
      CultureNameLength: PULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   #[doc = "The LdrResFindResourceDirectory function finds a resource directory in a DLL.\n# Arguments\n\n* `DllHandle` - A handle to the DLL.\n* `Type` - The type of the resource.\n* `Name` - The name of the resource.\n* `ResourceDirectory` - An optional pointer to receive the resource directory.\n* `CultureName` - An optional buffer to receive the culture name.\n* `CultureNameLength` - An optional pointer to receive the length of the culture name.\n* `Flags` - Flags for the resource search.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn LdrResFindResourceDirectory(
      DllHandle: PVOID,
      Type: ULONG_PTR,
      Name: ULONG_PTR,
      ResourceDirectory: *mut PIMAGE_RESOURCE_DIRECTORY,
      CultureName: PVOID,
      CultureNameLength: PULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrpResGetResourceDirectory(
      DllHandle: PVOID,
      Size: SIZE_T,
      Flags: ULONG,
      ResourceDirectory: *mut PIMAGE_RESOURCE_DIRECTORY,
      OutHeaders: *mut PIMAGE_NT_HEADERS,
   ) -> NTSTATUS;
   #[doc = "The LdrResSearchResource function searches for a resource in a DLL.\n# Arguments\n\n* `DllHandle` - A handle to the DLL.\n* `ResourceInfo` - A pointer to the resource information.\n* `Level` - The level of the resource.\n* `Flags` - Flags for the resource search.\n* `ResourceBuffer` - An optional pointer to receive the resource buffer.\n* `ResourceLength` - An optional pointer to receive the resource length.\n* `CultureName` - An optional buffer to receive the culture name.\n* `CultureNameLength` - An optional pointer to receive the length of the culture name.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn LdrResSearchResource(
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      Flags: ULONG,
      ResourceBuffer: *mut PVOID,
      ResourceLength: PSIZE_T,
      CultureName: PVOID,
      CultureNameLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "The LdrResGetRCConfig function retrieves the RC configuration for a DLL.\n# Arguments\n\n* `DllHandle` - A handle to the DLL.\n* `Length` - The length of the configuration buffer.\n* `Config` - A buffer to receive the configuration.\n* `Flags` - Flags for the operation.\n* `AlternateResource` - Indicates if an alternate resource should be loaded.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn LdrResGetRCConfig(
      DllHandle: PVOID,
      Length: SIZE_T,
      Config: PVOID,
      Flags: ULONG,
      AlternateResource: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "The LdrResRelease function releases a resource in a DLL.\n# Arguments\n\n* `DllHandle` - A handle to the DLL.\n* `CultureNameOrId` - An optional culture name or ID.\n* `Flags` - Flags for the operation.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn LdrResRelease(DllHandle: PVOID, CultureNameOrId: ULONG_PTR, Flags: ULONG) -> NTSTATUS;
   pub fn LdrEnumResources(
      DllHandle: PVOID,
      ResourceInfo: PLDR_RESOURCE_INFO,
      Level: ULONG,
      ResourceCount: *mut ULONG,
      Resources: PLDR_ENUM_RESOURCE_ENTRY,
   ) -> NTSTATUS;
   pub fn LdrFindEntryForAddress(DllHandle: PVOID, Entry: *mut PLDR_DATA_TABLE_ENTRY) -> NTSTATUS;
   pub fn LdrLoadAlternateResourceModule(
      DllHandle: PVOID,
      ResourceDllBase: *mut PVOID,
      ResourceOffset: *mut ULONG_PTR,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrLoadAlternateResourceModuleEx(
      DllHandle: PVOID,
      LanguageId: LANGID,
      ResourceDllBase: *mut PVOID,
      ResourceOffset: *mut ULONG_PTR,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrUnloadAlternateResourceModule(DllHandle: PVOID) -> BOOLEAN;
   pub fn LdrUnloadAlternateResourceModuleEx(DllHandle: PVOID, Flags: ULONG) -> BOOLEAN;
   pub fn LdrQueryProcessModuleInformation(
      ModuleInformation: PRTL_PROCESS_MODULES,
      Size: ULONG,
      ReturnedSize: PULONG,
   ) -> NTSTATUS;
   pub fn LdrEnumerateLoadedModules(
      ReservedFlag: BOOLEAN,
      EnumProc: PLDR_ENUM_CALLBACK,
      Context: PVOID,
   ) -> NTSTATUS;
   pub fn LdrOpenImageFileOptionsKey(
      SubKey: PUNICODE_STRING,
      Wow64: BOOLEAN,
      NewKeyHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn LdrQueryImageFileKeyOption(
      KeyHandle: HANDLE,
      ValueName: PCWSTR,
      Type: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn LdrQueryImageFileExecutionOptions(
      SubKey: PUNICODE_STRING,
      ValueName: PCWSTR,
      ValueSize: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn LdrQueryImageFileExecutionOptionsEx(
      SubKey: PUNICODE_STRING,
      ValueName: PCWSTR,
      Type: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
      ReturnedLength: PULONG,
      Wow64: BOOLEAN,
   ) -> NTSTATUS;
   pub fn LdrQueryOptionalDelayLoadedAPI(
      ParentModuleBase: PVOID,
      DllName: PCSTR,
      ProcedureName: PCSTR,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrResolveDelayLoadedAPI(
      ParentModuleBase: PVOID,
      DelayloadDescriptor: PCIMAGE_DELAYLOAD_DESCRIPTOR,
      FailureDllHook: PDELAYLOAD_FAILURE_DLL_CALLBACK,
      FailureSystemHook: PDELAYLOAD_FAILURE_SYSTEM_ROUTINE,
      ThunkAddress: PIMAGE_THUNK_DATA,
      Flags: ULONG,
   ) -> PVOID;
   pub fn LdrResolveDelayLoadsFromDll(
      ParentModuleBase: PVOID,
      TargetDllName: PCSTR,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn LdrSetDefaultDllDirectories(DirectoryFlags: ULONG) -> NTSTATUS;
   pub fn LdrAddDllDirectory(
      NewDirectory: PUNICODE_STRING,
      Cookie: PDLL_DIRECTORY_COOKIE,
   ) -> NTSTATUS;
   pub fn LdrRemoveDllDirectory(Cookie: DLL_DIRECTORY_COOKIE) -> NTSTATUS;
   pub fn LdrShutdownProcess() -> !;
   pub fn LdrShutdownThread() -> !;
   pub fn LdrSetImplicitPathOptions(ImplicitPathOptions: ULONG) -> NTSTATUS;
   #[doc = "The LdrControlFlowGuardEnforced function checks if Control Flow Guard is enforced.\n# Returns\n\nBOOLEAN TRUE if Control Flow Guard is enforced, FALSE otherwise."]
   pub fn LdrControlFlowGuardEnforced() -> BOOLEAN;
   #[doc = "The LdrControlFlowGuardEnforcedWithExportSuppression function checks if Control Flow Guard is\nenforced with export suppression.\n# Returns\n\nBOOLEAN TRUE if Control Flow Guard is enforced, FALSE otherwise."]
   pub fn LdrControlFlowGuardEnforcedWithExportSuppression() -> BOOLEAN;
   pub fn LdrIsModuleSxsRedirected(DllHandle: PVOID) -> BOOLEAN;
   pub fn LdrUpdatePackageSearchPath(SearchPathW: PCWSTR) -> NTSTATUS;
   pub fn LdrCreateEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      Reserved: ULONG,
      Size: SIZE_T,
      InitialCommitment: SIZE_T,
      EnclaveType: ULONG,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn LdrInitializeEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn LdrDeleteEnclave(BaseAddress: PVOID) -> NTSTATUS;
   pub fn LdrCallEnclave(
      Routine: PENCLAVE_ROUTINE,
      Flags: ULONG,
      RoutineParamReturn: *mut PVOID,
   ) -> NTSTATUS;
   pub fn LdrLoadEnclaveModule(
      BaseAddress: PVOID,
      DllPath: PCWSTR,
      DllName: PUNICODE_STRING,
   ) -> NTSTATUS;
   #[doc = "This function forcefully terminates the calling program if it is invoked inside a loader callout. Otherwise, it has no effect.\n> This routine does not catch all potential deadlock cases; it is possible for a thread inside a loader callout\nto acquire a lock while some thread outside a loader callout holds the same lock and makes a call into the loader.\nIn other words, there can be a lock order inversion between the loader lock and a client lock."]
   pub fn LdrFastFailInLoaderCallout();
   pub fn LdrFlushAlternateResourceModules() -> BOOLEAN;
   pub fn LdrDllRedirectionCallback(
      Flags: ULONG,
      DllName: PCWSTR,
      DllPath: PCWSTR,
      DllCharacteristics: PULONG,
      CallbackData: PVOID,
      EffectiveDllPath: *mut PCWSTR,
   ) -> NTSTATUS;
   pub fn LdrSetDllManifestProber(Routine: PVOID);
   pub static mut LdrpChildNtdll: BOOLEAN;
   pub fn LdrpResGetMappingSize(
      BaseAddress: PVOID,
      Size: PSIZE_T,
      Flags: ULONG,
      GetFileSizeFromLoadAsDataTable: BOOLEAN,
   );
   #[doc = "The NtDelayExecution routine suspends the current thread until the specified condition is met.\n# Arguments\n\n* `Alertable` - The function returns when either the time-out period has elapsed or when the APC function is called.\n* `DelayInterval` - The time interval for which execution is to be suspended, in milliseconds.\n- A value of zero causes the thread to relinquish the remainder of its time slice to any other thread that is ready to run.\n- If there are no other threads ready to run, the function returns immediately, and the thread continues execution.\n- A value of INFINITE indicates that the suspension should not time out.\n# Returns\n\nNTSTATUS Successful or errant status. The return value is STATUS_USER_APC when Alertable is TRUE, and the function returned due to one or more I/O completion callback functions.\n> Note that a ready thread is not guaranteed to run immediately. Consequently, the thread will not run until some arbitrary time after the sleep interval elapses,\nbased upon the system \"tick\" frequency and the load factor from other processes.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepex](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepex)"]
   pub fn NtDelayExecution(Alertable: BOOLEAN, DelayInterval: PLARGE_INTEGER) -> NTSTATUS;
   #[doc = "Retrieves the value of the specified firmware environment variable.\nThe user account that the app is running under must have the SE_SYSTEM_ENVIRONMENT_NAME privilege.\n# Arguments\n\n* `VariableName` - The name of the firmware environment variable. The pointer must not be NULL.\n* `VariableValue` - A pointer to a buffer that receives the value of the specified firmware environment variable.\n* `ValueLength` - The size of the `VariableValue` buffer, in bytes.\n* `ReturnLength` - If the function succeeds, the return length is the number of bytes stored in the `VariableValue` buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQuerySystemEnvironmentValue(
      VariableName: PUNICODE_STRING,
      VariableValue: PWSTR,
      ValueLength: USHORT,
      ReturnLength: PUSHORT,
   ) -> NTSTATUS;
   #[doc = "Retrieves the value of the specified firmware environment variable and its attributes.\nThe user account that the app is running under must have the SE_SYSTEM_ENVIRONMENT_NAME privilege.\n# Arguments\n\n* `VariableName` - The name of the firmware environment variable. The pointer must not be NULL.\n* `VendorGuid` - The GUID that represents the namespace of the firmware environment variable.\n* `Buffer` - A pointer to a buffer that receives the value of the specified firmware environment variable.\n* `BufferLength` - The size of the `Buffer,` in bytes.\n* `Attributes` - Bitmask identifying UEFI variable attributes associated with the variable.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQuerySystemEnvironmentValueEx(
      VariableName: PUNICODE_STRING,
      VendorGuid: PCGUID,
      Buffer: PVOID,
      BufferLength: PULONG,
      Attributes: PULONG,
   ) -> NTSTATUS;
   #[doc = "Sets the value of the specified firmware environment variable.\nThe user account that the app is running under must have the SE_SYSTEM_ENVIRONMENT_NAME privilege.\n# Arguments\n\n* `VariableName` - The name of the firmware environment variable. The pointer must not be NULL.\n* `VariableValue` - A pointer to the new value for the firmware environment variable.\nIf this parameter is zero, the firmware environment variable is deleted.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetSystemEnvironmentValue(
      VariableName: PUNICODE_STRING,
      VariableValue: PUNICODE_STRING,
   ) -> NTSTATUS;
   #[doc = "Sets the value of the specified firmware environment variable and the attributes that indicate how this variable is stored and maintained.\nThe user account that the app is running under must have the SE_SYSTEM_ENVIRONMENT_NAME privilege.\n# Arguments\n\n* `VariableName` - The name of the firmware environment variable. The pointer must not be NULL.\n* `VendorGuid` - The GUID that represents the namespace of the firmware environment variable.\n* `Buffer` - A pointer to the new value for the firmware environment variable.\n* `BufferLength` - The size of the pValue buffer, in bytes.\nUnless the VARIABLE_ATTRIBUTE_APPEND_WRITE, VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS,\nor VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via dwAttributes,\nsetting this value to zero will result in the deletion of this variable.\n* `Attributes` - Bitmask to set UEFI variable attributes associated with the variable.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetSystemEnvironmentValueEx(
      VariableName: PUNICODE_STRING,
      VendorGuid: PCGUID,
      Buffer: PVOID,
      BufferLength: ULONG,
      Attributes: ULONG,
   ) -> NTSTATUS;
   pub fn NtEnumerateSystemEnvironmentValuesEx(
      InformationClass: ULONG,
      Buffer: PVOID,
      BufferLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "The NtAddBootEntry routine adds a new boot entry to the system boot configuration.\n# Arguments\n\n* `BootEntry` - A pointer to a BOOT_ENTRY structure that specifies the boot entry to be added.\n* `Id` - A pointer to a variable that receives the identifier of the new boot entry.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAddBootEntry(BootEntry: PBOOT_ENTRY, Id: PULONG) -> NTSTATUS;
   #[doc = "The NtDeleteBootEntry routine deletes an existing boot entry from the system boot configuration.\n# Arguments\n\n* `Id` - The identifier of the boot entry to be deleted.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtDeleteBootEntry(Id: ULONG) -> NTSTATUS;
   #[doc = "The NtModifyBootEntry routine modifies an existing boot entry in the system boot configuration.\n# Arguments\n\n* `BootEntry` - A pointer to a BOOT_ENTRY structure that specifies the new boot entry information.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtModifyBootEntry(BootEntry: PBOOT_ENTRY) -> NTSTATUS;
   #[doc = "The NtEnumerateBootEntries routine retrieves information about all boot entries in the system boot configuration.\n# Arguments\n\n* `Buffer` - A pointer to a buffer that receives the boot entries information.\n* `BufferLength` - A pointer to a variable that specifies the size of the buffer. On return, it contains the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtEnumerateBootEntries(Buffer: PVOID, BufferLength: PULONG) -> NTSTATUS;
   #[doc = "The NtQueryBootEntryOrder routine retrieves the current boot entry order.\n# Arguments\n\n* `Ids` - A pointer to a buffer that receives the identifiers of the boot entries in the current boot order.\n* `Count` - A pointer to a variable that specifies the number of entries in the buffer. On return, it contains the number of entries returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryBootEntryOrder(Ids: PULONG, Count: PULONG) -> NTSTATUS;
   #[doc = "The NtSetBootEntryOrder routine sets the boot entry order.\n# Arguments\n\n* `Ids` - A pointer to a buffer that specifies the identifiers of the boot entries in the desired boot order.\n* `Count` - The number of entries in the buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetBootEntryOrder(Ids: PULONG, Count: ULONG) -> NTSTATUS;
   #[doc = "The NtQueryBootOptions routine retrieves the current boot options.\n# Arguments\n\n* `BootOptions` - A pointer to a buffer that receives the boot options.\n* `BootOptionsLength` - A pointer to a variable that specifies the size of the buffer. On return, it contains the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryBootOptions(BootOptions: PBOOT_OPTIONS, BootOptionsLength: PULONG) -> NTSTATUS;
   #[doc = "The NtSetBootOptions routine sets the boot options.\n# Arguments\n\n* `BootOptions` - A pointer to a BOOT_OPTIONS structure that specifies the new boot options.\n* `FieldsToChange` - A bitmask that specifies which fields in the BOOT_OPTIONS structure are to be changed.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetBootOptions(BootOptions: PBOOT_OPTIONS, FieldsToChange: ULONG) -> NTSTATUS;
   #[doc = "The NtTranslateFilePath routine translates a file path from one format to another.\n# Arguments\n\n* `InputFilePath` - A pointer to a FILE_PATH structure that specifies the input file path.\n* `OutputType` - The type of the output file path.\n* `OutputFilePath` - A pointer to a buffer that receives the translated file path.\n* `OutputFilePathLength` - A pointer to a variable that specifies the size of the buffer. On return, it contains the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtTranslateFilePath(
      InputFilePath: PFILE_PATH,
      OutputType: ULONG,
      OutputFilePath: PFILE_PATH,
      OutputFilePathLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "The NtAddDriverEntry routine adds a new driver entry to the system boot configuration.\n# Arguments\n\n* `DriverEntry` - A pointer to an EFI_DRIVER_ENTRY structure that specifies the driver entry to be added.\n* `Id` - A pointer to a variable that receives the identifier of the new driver entry.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAddDriverEntry(DriverEntry: PEFI_DRIVER_ENTRY, Id: PULONG) -> NTSTATUS;
   #[doc = "The NtDeleteDriverEntry routine deletes an existing driver entry from the system boot configuration.\n# Arguments\n\n* `Id` - The identifier of the driver entry to be deleted.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtDeleteDriverEntry(Id: ULONG) -> NTSTATUS;
   #[doc = "The NtModifyDriverEntry routine modifies an existing driver entry in the system boot configuration.\n# Arguments\n\n* `DriverEntry` - A pointer to an EFI_DRIVER_ENTRY structure that specifies the new driver entry information.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtModifyDriverEntry(DriverEntry: PEFI_DRIVER_ENTRY) -> NTSTATUS;
   #[doc = "The NtEnumerateDriverEntries routine retrieves information about all driver entries in the system boot configuration.\n# Arguments\n\n* `Buffer` - A pointer to a buffer that receives the driver entries information.\n* `BufferLength` - A pointer to a variable that specifies the size of the buffer. On return, it contains the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtEnumerateDriverEntries(Buffer: PVOID, BufferLength: PULONG) -> NTSTATUS;
   #[doc = "The NtQueryDriverEntryOrder routine retrieves the current driver entry order.\n# Arguments\n\n* `Ids` - A pointer to a buffer that receives the identifiers of the driver entries in the current driver order.\n* `Count` - A pointer to a variable that specifies the number of entries in the buffer. On return, it contains the number of entries returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryDriverEntryOrder(Ids: PULONG, Count: PULONG) -> NTSTATUS;
   #[doc = "The NtSetDriverEntryOrder routine sets the driver entry order.\n# Arguments\n\n* `Ids` - A pointer to a buffer that specifies the identifiers of the driver entries in the desired driver order.\n* `Count` - The number of entries in the buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetDriverEntryOrder(Ids: PULONG, Count: ULONG) -> NTSTATUS;
   #[doc = "The NtFilterBootOption routine filters boot options based on the specified operation, object type, and element type.\n# Arguments\n\n* `FilterOperation` - The operation to be performed on the boot option. This can be one of the values from the FILTER_BOOT_OPTION_OPERATION enumeration.\n* `ObjectType` - The type of the object to be filtered.\n* `ElementType` - The type of the element within the object to be filtered.\n* `Data` - A pointer to a buffer that contains the data to be used in the filter operation. This parameter is optional and can be NULL.\n* `DataSize` - The size, in bytes, of the data buffer pointed to by the Data parameter.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtFilterBootOption(
      FilterOperation: FILTER_BOOT_OPTION_OPERATION,
      ObjectType: ULONG,
      ElementType: ULONG,
      Data: PVOID,
      DataSize: ULONG,
   ) -> NTSTATUS;
   #[doc = "The NtCreateEvent routine creates an event object, sets the initial state of the event to the specified value,\nand opens a handle to the object with the specified desired access.\n# Arguments\n\n* `EventHandle` - A pointer to a variable that receives the event object handle.\n* `DesiredAccess` - The access mask that specifies the requested access to the event object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n* `EventType` - The type of the event, which can be SynchronizationEvent or a NotificationEvent.\n* `InitialState` - The initial state of the event object.\n# Returns\n\nNTSTATUS Successful or errant status.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwcreateevent](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwcreateevent)"]
   pub fn NtCreateEvent(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      EventType: EVENT_TYPE,
      InitialState: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "The NtOpenEvent routine opens a handle to an existing event object.\n# Arguments\n\n* `EventHandle` - A pointer to a variable that receives the event object handle.\n* `DesiredAccess` - The access mask that specifies the requested access to the event object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenEvent(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "The NtSetEvent routine sets an event object to the signaled state.\n# Arguments\n\n* `EventHandle` - A handle to the event object.\n* `PreviousState` - A pointer to a variable that receives the previous state of the event object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   #[doc = "The NtSetEventEx routine sets an event object to the signaled state and optionally acquires a lock.\n# Arguments\n\n* `ThreadId` - A handle to the thread.\n* `Lock` - A pointer to an RTL_SRWLOCK structure that specifies the lock to acquire.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetEventEx(ThreadId: HANDLE, Lock: PRTL_SRWLOCK) -> NTSTATUS;
   #[doc = "The NtSetEventBoostPriority routine sets an event object to the signaled state and boosts the priority of threads waiting on the event.\n# Arguments\n\n* `EventHandle` - A handle to the event object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetEventBoostPriority(EventHandle: HANDLE) -> NTSTATUS;
   #[doc = "The NtClearEvent routine sets an event object to the not-signaled state.\n# Arguments\n\n* `EventHandle` - A handle to the event object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtClearEvent(EventHandle: HANDLE) -> NTSTATUS;
   #[doc = "The NtResetEvent routine sets an event object to the not-signaled state and optionally returns the previous state.\n# Arguments\n\n* `EventHandle` - A handle to the event object.\n* `PreviousState` - A pointer to a variable that receives the previous state of the event object.\n# Returns\n\nNTSTATUS Successful or errant status.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-resetevent](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-resetevent)"]
   pub fn NtResetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   #[doc = "The NtPulseEvent routine sets an event object to the signaled state and then resets it to the not-signaled state after releasing the appropriate number of waiting threads.\n# Arguments\n\n* `EventHandle` - A handle to the event object.\n* `PreviousState` - A pointer to a variable that receives the previous state of the event object.\n# Returns\n\nNTSTATUS Successful or errant status.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-pulseevent](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-pulseevent)"]
   pub fn NtPulseEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   #[doc = "The NtQueryEvent routine retrieves information about an event object.\n# Arguments\n\n* `EventHandle` - A handle to the event object.\n* `EventInformationClass` - The type of information to be retrieved.\n* `EventInformation` - A pointer to a buffer that receives the requested information.\n* `EventInformationLength` - The size of the buffer pointed to by EventInformation.\n* `ReturnLength` - A pointer to a variable that receives the size of the data returned in the buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryEvent(
      EventHandle: HANDLE,
      EventInformationClass: EVENT_INFORMATION_CLASS,
      EventInformation: PVOID,
      EventInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "The NtCreateEventPair routine creates an event pair object and opens a handle to the object with the specified desired access.\n# Arguments\n\n* `EventPairHandle` - A pointer to a variable that receives the event pair object handle.\n* `DesiredAccess` - The access mask that specifies the requested access to the event pair object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateEventPair(
      EventPairHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "The NtOpenEventPair routine opens a handle to an existing event pair object.\n# Arguments\n\n* `EventPairHandle` - A pointer to a variable that receives the event pair object handle.\n* `DesiredAccess` - The access mask that specifies the requested access to the event pair object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenEventPair(
      EventPairHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "The NtSetLowEventPair routine sets the low event in an event pair to the signaled state.\n# Arguments\n\n* `EventPairHandle` - A handle to the event pair object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   #[doc = "The NtSetHighEventPair routine sets the high event in an event pair to the signaled state.\n# Arguments\n\n* `EventPairHandle` - A handle to the event pair object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   #[doc = "The NtWaitLowEventPair routine waits for the low event in an event pair to be set to the signaled state.\n# Arguments\n\n* `EventPairHandle` - A handle to the event pair object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   #[doc = "The NtWaitHighEventPair routine waits for the high event in an event pair to be set to the signaled state.\n# Arguments\n\n* `EventPairHandle` - A handle to the event pair object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   #[doc = "The NtSetLowWaitHighEventPair routine sets the low event in an event pair to the signaled state and waits for the high event to be set to the signaled state.\n# Arguments\n\n* `EventPairHandle` - A handle to the event pair object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetLowWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   #[doc = "The NtSetHighWaitLowEventPair routine sets the high event in an event pair to the signaled state and waits for the low event to be set to the signaled state.\n# Arguments\n\n* `EventPairHandle` - A handle to the event pair object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetHighWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   #[doc = "The NtCreateMutant routine creates a mutant object, sets the initial state of the mutant to the specified value,\nand opens a handle to the object with the specified desired access.\n# Arguments\n\n* `MutantHandle` - A pointer to a variable that receives the mutant object handle.\n* `DesiredAccess` - The access mask that specifies the requested access to the mutant object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n* `InitialOwner` - If TRUE, the calling thread is the initial owner of the mutant object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateMutant(
      MutantHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      InitialOwner: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "The NtOpenMutant routine opens a handle to an existing mutant object.\n# Arguments\n\n* `MutantHandle` - A pointer to a variable that receives the mutant object handle.\n* `DesiredAccess` - The access mask that specifies the requested access to the mutant object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenMutant(
      MutantHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "The NtReleaseMutant routine releases ownership of a mutant object.\n# Arguments\n\n* `MutantHandle` - A handle to the mutant object.\n* `PreviousCount` - A pointer to a variable that receives the previous count of the mutant object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtReleaseMutant(MutantHandle: HANDLE, PreviousCount: PLONG) -> NTSTATUS;
   #[doc = "The NtQueryMutant routine retrieves information about a mutant object.\n# Arguments\n\n* `MutantHandle` - A handle to the mutant object.\n* `MutantInformationClass` - The type of information to be retrieved.\n* `MutantInformation` - A pointer to a buffer that receives the requested information.\n* `MutantInformationLength` - The size of the buffer pointed to by MutantInformation.\n* `ReturnLength` - A pointer to a variable that receives the size of the data returned in the buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryMutant(
      MutantHandle: HANDLE,
      MutantInformationClass: MUTANT_INFORMATION_CLASS,
      MutantInformation: PVOID,
      MutantInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "The NtCreateSemaphore routine creates a semaphore object, sets the initial count of the semaphore to the specified value,\nand opens a handle to the object with the specified desired access.\n# Arguments\n\n* `SemaphoreHandle` - A pointer to a variable that receives the semaphore object handle.\n* `DesiredAccess` - The access mask that specifies the requested access to the semaphore object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n* `InitialCount` - The initial count of the semaphore object.\n* `MaximumCount` - The maximum count of the semaphore object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateSemaphore(
      SemaphoreHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      InitialCount: LONG,
      MaximumCount: LONG,
   ) -> NTSTATUS;
   #[doc = "The NtOpenSemaphore routine opens a handle to an existing semaphore object.\n# Arguments\n\n* `SemaphoreHandle` - A pointer to a variable that receives the semaphore object handle.\n* `DesiredAccess` - The access mask that specifies the requested access to the semaphore object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenSemaphore(
      SemaphoreHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "The NtReleaseSemaphore routine increases the count of the specified semaphore object by a specified amount.\n# Arguments\n\n* `SemaphoreHandle` - A handle to the semaphore object.\n* `ReleaseCount` - The amount by which the semaphore object's count is to be increased.\n* `PreviousCount` - A pointer to a variable that receives the previous count of the semaphore object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtReleaseSemaphore(
      SemaphoreHandle: HANDLE,
      ReleaseCount: LONG,
      PreviousCount: PLONG,
   ) -> NTSTATUS;
   #[doc = "The NtQuerySemaphore routine retrieves information about a semaphore object.\n# Arguments\n\n* `SemaphoreHandle` - A handle to the semaphore object.\n* `SemaphoreInformationClass` - The type of information to be retrieved.\n* `SemaphoreInformation` - A pointer to a buffer that receives the requested information.\n* `SemaphoreInformationLength` - The size of the buffer pointed to by SemaphoreInformation.\n* `ReturnLength` - A pointer to a variable that receives the size of the data returned in the buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQuerySemaphore(
      SemaphoreHandle: HANDLE,
      SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS,
      SemaphoreInformation: PVOID,
      SemaphoreInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateTimer(
      TimerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      TimerType: TIMER_TYPE,
   ) -> NTSTATUS;
   pub fn NtOpenTimer(
      TimerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtSetTimer(
      TimerHandle: HANDLE,
      DueTime: PLARGE_INTEGER,
      TimerApcRoutine: PTIMER_APC_ROUTINE,
      TimerContext: PVOID,
      ResumeTimer: BOOLEAN,
      Period: LONG,
      PreviousState: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtSetTimerEx(
      TimerHandle: HANDLE,
      TimerSetInformationClass: TIMER_SET_INFORMATION_CLASS,
      TimerSetInformation: PVOID,
      TimerSetInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN) -> NTSTATUS;
   pub fn NtQueryTimer(
      TimerHandle: HANDLE,
      TimerInformationClass: TIMER_INFORMATION_CLASS,
      TimerInformation: PVOID,
      TimerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateIRTimer(
      TimerHandle: PHANDLE,
      Reserved: PVOID,
      DesiredAccess: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn NtSetIRTimer(TimerHandle: HANDLE, DueTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtCreateTimer2(
      TimerHandle: PHANDLE,
      Reserved1: PVOID,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      Attributes: ULONG,
      DesiredAccess: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn NtSetTimer2(
      TimerHandle: HANDLE,
      DueTime: PLARGE_INTEGER,
      Period: PLARGE_INTEGER,
      Parameters: PT2_SET_PARAMETERS,
   ) -> NTSTATUS;
   pub fn NtCancelTimer2(TimerHandle: HANDLE, Parameters: PT2_CANCEL_PARAMETERS) -> NTSTATUS;
   pub fn NtCreateProfile(
      ProfileHandle: PHANDLE,
      Process: HANDLE,
      ProfileBase: PVOID,
      ProfileSize: SIZE_T,
      BucketSize: ULONG,
      Buffer: PULONG,
      BufferSize: ULONG,
      ProfileSource: KPROFILE_SOURCE,
      Affinity: KAFFINITY,
   ) -> NTSTATUS;
   pub fn NtCreateProfileEx(
      ProfileHandle: PHANDLE,
      Process: HANDLE,
      ProfileBase: PVOID,
      ProfileSize: SIZE_T,
      BucketSize: ULONG,
      Buffer: PULONG,
      BufferSize: ULONG,
      ProfileSource: KPROFILE_SOURCE,
      GroupCount: USHORT,
      GroupAffinity: PGROUP_AFFINITY,
   ) -> NTSTATUS;
   pub fn NtStartProfile(ProfileHandle: HANDLE) -> NTSTATUS;
   pub fn NtStopProfile(ProfileHandle: HANDLE) -> NTSTATUS;
   pub fn NtQueryIntervalProfile(ProfileSource: KPROFILE_SOURCE, Interval: PULONG) -> NTSTATUS;
   pub fn NtSetIntervalProfile(Interval: ULONG, Source: KPROFILE_SOURCE) -> NTSTATUS;
   pub fn NtCreateKeyedEvent(
      KeyedEventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenKeyedEvent(
      KeyedEventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtReleaseKeyedEvent(
      KeyedEventHandle: HANDLE,
      KeyValue: PVOID,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtWaitForKeyedEvent(
      KeyedEventHandle: HANDLE,
      KeyValue: PVOID,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtUmsThreadYield(SchedulerParam: PVOID) -> NTSTATUS;
   pub fn NtCreateWnfStateName(
      StateName: PWNF_STATE_NAME,
      NameLifetime: WNF_STATE_NAME_LIFETIME,
      DataScope: WNF_DATA_SCOPE,
      PersistData: BOOLEAN,
      TypeId: PCWNF_TYPE_ID,
      MaximumStateSize: ULONG,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn NtDeleteWnfStateName(StateName: PCWNF_STATE_NAME) -> NTSTATUS;
   pub fn NtUpdateWnfStateData(
      StateName: PCWNF_STATE_NAME,
      Buffer: *const ::core::ffi::c_void,
      Length: ULONG,
      TypeId: PCWNF_TYPE_ID,
      ExplicitScope: *const ::core::ffi::c_void,
      MatchingChangeStamp: WNF_CHANGE_STAMP,
      CheckStamp: LOGICAL,
   ) -> NTSTATUS;
   pub fn NtDeleteWnfStateData(
      StateName: PCWNF_STATE_NAME,
      ExplicitScope: *const ::core::ffi::c_void,
   ) -> NTSTATUS;
   pub fn NtQueryWnfStateData(
      StateName: PCWNF_STATE_NAME,
      TypeId: PCWNF_TYPE_ID,
      ExplicitScope: *const ::core::ffi::c_void,
      ChangeStamp: PWNF_CHANGE_STAMP,
      Buffer: PVOID,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn NtQueryWnfStateNameInformation(
      StateName: PCWNF_STATE_NAME,
      NameInfoClass: WNF_STATE_NAME_INFORMATION,
      ExplicitScope: *const ::core::ffi::c_void,
      InfoBuffer: PVOID,
      InfoBufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn NtSubscribeWnfStateChange(
      StateName: PCWNF_STATE_NAME,
      ChangeStamp: WNF_CHANGE_STAMP,
      EventMask: ULONG,
      SubscriptionId: PULONG64,
   ) -> NTSTATUS;
   pub fn NtUnsubscribeWnfStateChange(StateName: PCWNF_STATE_NAME) -> NTSTATUS;
   pub fn NtGetCompleteWnfStateSubscription(
      OldDescriptorStateName: PWNF_STATE_NAME,
      OldSubscriptionId: *mut ULONG64,
      OldDescriptorEventMask: ULONG,
      OldDescriptorStatus: ULONG,
      NewDeliveryDescriptor: PWNF_DELIVERY_DESCRIPTOR,
      DescriptorSize: ULONG,
   ) -> NTSTATUS;
   pub fn NtSetWnfProcessNotificationEvent(NotificationEvent: HANDLE) -> NTSTATUS;
   pub fn NtCreateWorkerFactory(
      WorkerFactoryHandleReturn: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      CompletionPortHandle: HANDLE,
      WorkerProcessHandle: HANDLE,
      StartRoutine: PVOID,
      StartParameter: PVOID,
      MaxThreadCount: ULONG,
      StackReserve: SIZE_T,
      StackCommit: SIZE_T,
   ) -> NTSTATUS;
   pub fn NtQueryInformationWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
      WorkerFactoryInformation: PVOID,
      WorkerFactoryInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
      WorkerFactoryInformation: PVOID,
      WorkerFactoryInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtShutdownWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      PendingWorkerCount: *mut LONG,
   ) -> NTSTATUS;
   pub fn NtReleaseWorkerFactoryWorker(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
   pub fn NtWorkerFactoryWorkerReady(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
   pub fn NtWaitForWorkViaWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      MiniPackets: PFILE_IO_COMPLETION_INFORMATION,
      Count: ULONG,
      PacketsReturned: PULONG,
      DeferredWork: PWORKER_FACTORY_DEFERRED_WORK,
   ) -> NTSTATUS;
   #[doc = "The NtQuerySystemTime routine obtains the current system time.\n# Arguments\n\n* `SystemTime` - A pointer to a LARGE_INTEGER structure that receives the system time. This is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).\n# Returns\n\nNTSTATUS Successful or errant status.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysystemtime](https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysystemtime)"]
   pub fn NtQuerySystemTime(SystemTime: PLARGE_INTEGER) -> NTSTATUS;
   #[doc = "The NtSetSystemTime routine sets the current system time and date. The system time is expressed in Coordinated Universal Time (UTC).\n# Arguments\n\n* `SystemTime` - A pointer to a LARGE_INTEGER structure that that contains the new system date and time.\n* `PreviousTime` - A pointer to a LARGE_INTEGER structure that that contains the previous system time.\n# Returns\n\nNTSTATUS Successful or errant status.\n> The calling process must have the SE_SYSTEMTIME_NAME privilege.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-setsystemtime](https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-setsystemtime)"]
   pub fn NtSetSystemTime(SystemTime: PLARGE_INTEGER, PreviousTime: PLARGE_INTEGER) -> NTSTATUS;
   #[doc = "The NtQueryTimerResolution routine retrieves the range and current value of the system interrupt timer.\n# Arguments\n\n* `MaximumTime` - The maximum timer resolution, in 100-nanosecond units.\n* `MinimumTime` - The minimum timer resolution, in 100-nanosecond units.\n* `CurrentTime` - The current timer resolution, in 100-nanosecond units.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryTimerResolution(
      MaximumTime: PULONG,
      MinimumTime: PULONG,
      CurrentTime: PULONG,
   ) -> NTSTATUS;
   #[doc = "The NtSetTimerResolution routine sets the system interrupt timer resolution to the specified value.\n# Arguments\n\n* `DesiredTime` - The desired timer resolution, in 100-nanosecond units.\n* `SetResolution` - If TRUE, the timer resolution is set to the value specified by DesiredTime. If FALSE, the timer resolution is reset to the default value.\n* `ActualTime` - The actual timer resolution, in 100-nanosecond units.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetTimerResolution(
      DesiredTime: ULONG,
      SetResolution: BOOLEAN,
      ActualTime: PULONG,
   ) -> NTSTATUS;
   pub fn NtQueryPerformanceCounter(
      PerformanceCounter: PLARGE_INTEGER,
      PerformanceFrequency: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtQueryAuxiliaryCounterFrequency(AuxiliaryCounterFrequency: PULONG64) -> NTSTATUS;
   pub fn NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(
      ConvertAuxiliaryToPerformanceCounter: BOOLEAN,
      PerformanceOrAuxiliaryCounterValue: PULONG64,
      ConvertedValue: PULONG64,
      ConversionError: PULONG64,
   ) -> NTSTATUS;
   pub fn NtAllocateLocallyUniqueId(Luid: PLUID) -> NTSTATUS;
   pub fn NtSetUuidSeed(Seed: PCHAR) -> NTSTATUS;
   pub fn NtAllocateUuids(
      Time: PULARGE_INTEGER,
      Range: PULONG,
      Sequence: PULONG,
      Seed: PCHAR,
   ) -> NTSTATUS;
   pub fn NtQuerySystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtQuerySystemInformationEx(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetSystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtSystemDebugControl(
      Command: SYSDBG_COMMAND,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtRaiseHardError(
      ErrorStatus: NTSTATUS,
      NumberOfParameters: ULONG,
      UnicodeStringParameterMask: ULONG,
      Parameters: PULONG_PTR,
      ValidResponseOptions: ULONG,
      Response: PULONG,
   ) -> NTSTATUS;
   pub fn NtGetTickCount64() -> ULONGLONG;
   pub fn NtGetTickCount() -> ULONG;
   pub fn NtQueryDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: PLCID) -> NTSTATUS;
   pub fn NtSetDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: LCID) -> NTSTATUS;
   pub fn NtQueryInstallUILanguage(InstallUILanguageId: *mut LANGID) -> NTSTATUS;
   pub fn NtFlushInstallUILanguage(InstallUILanguage: LANGID, SetComittedFlag: ULONG) -> NTSTATUS;
   pub fn NtQueryDefaultUILanguage(DefaultUILanguageId: *mut LANGID) -> NTSTATUS;
   pub fn NtSetDefaultUILanguage(DefaultUILanguageId: LANGID) -> NTSTATUS;
   pub fn NtIsUILanguageComitted() -> NTSTATUS;
   pub fn NtInitializeNlsFiles(
      BaseAddress: *mut PVOID,
      DefaultLocaleId: PLCID,
      DefaultCasingTableSize: PLARGE_INTEGER,
      CurrentNLSVersion: PULONG,
   ) -> NTSTATUS;
   pub fn NtGetNlsSectionPtr(
      SectionType: ULONG,
      SectionData: ULONG,
      ContextData: PVOID,
      SectionPointer: *mut PVOID,
      SectionSize: PULONG,
   ) -> NTSTATUS;
   pub fn NtMapCMFModule(
      What: ULONG,
      Index: ULONG,
      CacheIndexOut: PULONG,
      CacheFlagsOut: PULONG,
      ViewSizeOut: PULONG,
      BaseAddress: *mut PVOID,
   ) -> NTSTATUS;
   pub fn NtGetMUIRegistryInfo(Flags: ULONG, DataSize: PULONG, Data: PVOID) -> NTSTATUS;
   pub fn NtAddAtom(AtomName: PCWSTR, Length: ULONG, Atom: PRTL_ATOM) -> NTSTATUS;
   pub fn NtAddAtomEx(AtomName: PCWSTR, Length: ULONG, Atom: PRTL_ATOM, Flags: ULONG) -> NTSTATUS;
   pub fn NtFindAtom(AtomName: PCWSTR, Length: ULONG, Atom: PRTL_ATOM) -> NTSTATUS;
   pub fn NtDeleteAtom(Atom: RTL_ATOM) -> NTSTATUS;
   pub fn NtQueryInformationAtom(
      Atom: RTL_ATOM,
      AtomInformationClass: ATOM_INFORMATION_CLASS,
      AtomInformation: PVOID,
      AtomInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtQueryLicenseValue(
      ValueName: PUNICODE_STRING,
      Type: PULONG,
      Data: PVOID,
      DataSize: ULONG,
      ResultDataSize: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetDefaultHardErrorPort(DefaultHardErrorPort: HANDLE) -> NTSTATUS;
   pub fn NtShutdownSystem(Action: SHUTDOWN_ACTION) -> NTSTATUS;
   pub fn NtDisplayString(String: PUNICODE_STRING) -> NTSTATUS;
   pub fn NtDrawText(Text: PUNICODE_STRING) -> NTSTATUS;
   pub static GUID_BAD_MEMORY_GROUP: GUID;
   pub static GUID_BOOT_LOADER_SETTINGS_GROUP: GUID;
   pub static GUID_CURRENT_BOOT_ENTRY: GUID;
   pub static GUID_DEBUGGER_SETTINGS_GROUP: GUID;
   pub static GUID_DEFAULT_BOOT_ENTRY: GUID;
   pub static GUID_EMS_SETTINGS_GROUP: GUID;
   pub static GUID_FIRMWARE_BOOTMGR: GUID;
   pub static GUID_GLOBAL_SETTINGS_GROUP: GUID;
   pub static GUID_HYPERVISOR_SETTINGS_GROUP: GUID;
   pub static GUID_KERNEL_DEBUGGER_SETTINGS_GROUP: GUID;
   pub static GUID_RESUME_LOADER_SETTINGS_GROUP: GUID;
   pub static GUID_WINDOWS_BOOTMGR: GUID;
   pub static GUID_WINDOWS_LEGACY_NTLDR: GUID;
   pub static GUID_WINDOWS_MEMORY_TESTER: GUID;
   pub static GUID_WINDOWS_OS_TARGET_TEMPLATE_EFI: GUID;
   pub static GUID_WINDOWS_OS_TARGET_TEMPLATE_PCAT: GUID;
   pub static GUID_WINDOWS_RESUME_TARGET_TEMPLATE_EFI: GUID;
   pub static GUID_WINDOWS_RESUME_TARGET_TEMPLATE_PCAT: GUID;
   pub static GUID_WINDOWS_SETUP_EFI: GUID;
   pub static GUID_WINDOWS_SETUP_PCAT: GUID;
   pub static GUID_WINDOWS_SETUP_RAMDISK_OPTIONS: GUID;
   pub static GUID_WINDOWS_SETUP_BOOT_ENTRY: GUID;
   pub static GUID_VHD_BOOT_OPTIONS: GUID;
   pub static PARTITION_BASIC_DATA_GUID: GUID;
   pub static PARTITION_CLUSTER_GUID: GUID;
   pub static PARTITION_ENTRY_UNUSED_GUID: GUID;
   pub static PARTITION_LDM_DATA_GUID: GUID;
   pub static PARTITION_LDM_METADATA_GUID: GUID;
   pub static PARTITION_MSFT_RECOVERY_GUID: GUID;
   pub static PARTITION_MSFT_RESERVED_GUID: GUID;
   pub static PARTITION_MSFT_SNAPSHOT_GUID: GUID;
   pub static PARTITION_SPACES_GUID: GUID;
   pub static PARTITION_SYSTEM_GUID: GUID;
   #[doc = "Sets the logging level and callback routine for BCD messages.\n# Arguments\n\n* `BcdLoggingLevel` - The logging level to set.\n* `BcdMessageCallbackRoutine` - The callback routine for BCD messages.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdSetLogging(
      BcdLoggingLevel: BCD_MESSAGE_TYPE,
      BcdMessageCallbackRoutine: BCD_MESSAGE_CALLBACK,
   ) -> NTSTATUS;
   #[doc = "Initializes the BCD synchronization mutant."]
   pub fn BcdInitializeBcdSyncMutant();
   #[doc = "Retrieves the file name for the BCD.\n# Arguments\n\n* `BcdSystemStorePath` - The pointer to receive the system store path.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdGetSystemStorePath(BcdSystemStorePath: *mut PWSTR) -> NTSTATUS;
   #[doc = "Sets the device for the system BCD store.\n# Arguments\n\n* `SystemPartition` - The system partition to set.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdSetSystemStoreDevice(SystemPartition: PCUNICODE_STRING) -> NTSTATUS;
   #[doc = "Opens the BCD system store.\n# Arguments\n\n* `BcdStoreHandle` - The handle to receive the system store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdOpenSystemStore(BcdStoreHandle: PHANDLE) -> NTSTATUS;
   #[doc = "Opens a BCD store from a file.\n# Arguments\n\n* `BcdFilePath` - The file path of the BCD store.\n* `BcdStoreHandle` - The handle to receive the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdOpenStoreFromFile(BcdFilePath: PCUNICODE_STRING, BcdStoreHandle: PHANDLE) -> NTSTATUS;
   #[doc = "Creates a BCD store.\n# Arguments\n\n* `BcdFilePath` - The file path to create the BCD store.\n* `BcdStoreHandle` - The handle to receive the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdCreateStore(BcdFilePath: PCUNICODE_STRING, BcdStoreHandle: PHANDLE) -> NTSTATUS;
   #[doc = "Exports the BCD store to a file.\n# Arguments\n\n* `BcdFilePath` - The file path to export the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdExportStore(BcdFilePath: PCUNICODE_STRING) -> NTSTATUS;
   #[doc = "Exports the BCD store to a file with additional flags.\n# Arguments\n\n* `BcdStoreHandle` - The handle to the BCD store.\n* `Flags` - The flags for exporting the store.\n* `BcdFilePath` - The file path to export the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdExportStoreEx(
      BcdStoreHandle: HANDLE,
      Flags: ULONG,
      BcdFilePath: PCUNICODE_STRING,
   ) -> NTSTATUS;
   #[doc = "Imports a BCD store from a file.\n# Arguments\n\n* `BcdFilePath` - The file path to import the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdImportStore(BcdFilePath: PCUNICODE_STRING) -> NTSTATUS;
   #[doc = "Imports a BCD store from a file with additional flags.\n# Arguments\n\n* `BcdFilePath` - The file path to import the BCD store.\n* `BcdImportFlags` - The flags for importing the store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdImportStoreWithFlags(
      BcdFilePath: PCUNICODE_STRING,
      BcdImportFlags: BCD_IMPORT_FLAGS,
   ) -> NTSTATUS;
   #[doc = "Deletes object references in the BCD store.\n# Arguments\n\n* `BcdStoreHandle` - The handle to the BCD store.\n* `Identifier` - The identifier of the object to delete references for.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdDeleteObjectReferences(BcdStoreHandle: HANDLE, Identifier: PGUID) -> NTSTATUS;
   #[doc = "Deletes the system store for BCD.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdDeleteSystemStore() -> NTSTATUS;
   #[doc = "Opens a BCD store with additional flags.\n# Arguments\n\n* `BcdFilePath` - The file path of the BCD store.\n* `BcdOpenFlags` - The flags for opening the store.\n* `BcdStoreHandle` - The handle to receive the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdOpenStore(
      BcdFilePath: PCUNICODE_STRING,
      BcdOpenFlags: BCD_OPEN_FLAGS,
      BcdStoreHandle: PHANDLE,
   ) -> NTSTATUS;
   #[doc = "Closes a BCD store.\n# Arguments\n\n* `BcdStoreHandle` - The handle to the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdCloseStore(BcdStoreHandle: HANDLE) -> NTSTATUS;
   #[doc = "Flushes a BCD store.\n# Arguments\n\n* `BcdStoreHandle` - The handle to the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdFlushStore(BcdStoreHandle: HANDLE) -> NTSTATUS;
   #[doc = "Forcibly unloads a BCD store.\n# Arguments\n\n* `BcdStoreHandle` - The handle to the BCD store.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn BcdForciblyUnloadStore(BcdStoreHandle: HANDLE) -> NTSTATUS;
   pub fn BcdMarkAsSystemStore(BcdStoreHandle: HANDLE) -> NTSTATUS;
   pub fn BcdEnumerateObjects(
      BcdStoreHandle: HANDLE,
      BcdEnumDescriptor: PBCD_OBJECT_DESCRIPTION,
      Buffer: PVOID,
      BufferSize: PULONG,
      ObjectCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdOpenObject(
      BcdStoreHandle: HANDLE,
      Identifier: *const GUID,
      BcdObjectHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdCreateObject(
      BcdStoreHandle: HANDLE,
      Identifier: PGUID,
      Description: PBCD_OBJECT_DESCRIPTION,
      BcdObjectHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdDeleteObject(BcdObjectHandle: HANDLE) -> NTSTATUS;
   pub fn BcdCloseObject(BcdObjectHandle: HANDLE) -> NTSTATUS;
   pub fn BcdCopyObject(
      BcdStoreHandle: HANDLE,
      BcdObjectHandle: HANDLE,
      BcdCopyFlags: BCD_COPY_FLAGS,
      TargetStoreHandle: HANDLE,
      TargetObjectHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdCopyObjectEx(
      BcdStoreHandle: HANDLE,
      BcdObjectHandle: HANDLE,
      BcdCopyFlags: BCD_COPY_FLAGS,
      TargetStoreHandle: HANDLE,
      TargetObjectId: PGUID,
      TargetObjectHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn BcdCopyObjects(
      BcdStoreHandle: HANDLE,
      Characteristics: PBCD_OBJECT_DESCRIPTION,
      BcdCopyFlags: BCD_COPY_FLAGS,
      TargetStoreHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn BcdMigrateObjectElementValues(
      TemplateObjectHandle: HANDLE,
      SourceObjectHandle: HANDLE,
      TargetObjectHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn BcdQueryObject(
      BcdObjectHandle: HANDLE,
      BcdVersion: ULONG,
      Description: BCD_OBJECT_DESCRIPTION,
      Identifier: PGUID,
   ) -> NTSTATUS;
   pub fn BcdEnumerateElementTypes(
      BcdObjectHandle: HANDLE,
      Buffer: PVOID,
      BufferSize: PULONG,
      ElementCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdEnumerateElements(
      BcdObjectHandle: HANDLE,
      Buffer: PVOID,
      BufferSize: PULONG,
      ElementCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdEnumerateElementsWithFlags(
      BcdObjectHandle: HANDLE,
      BcdFlags: BCD_FLAGS,
      Buffer: PVOID,
      BufferSize: PULONG,
      ElementCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdEnumerateAndUnpackElements(
      BcdStoreHandle: HANDLE,
      BcdObjectHandle: HANDLE,
      BcdFlags: BCD_FLAGS,
      Buffer: PVOID,
      BufferSize: PULONG,
      ElementCount: PULONG,
   ) -> NTSTATUS;
   pub fn BcdGetElementData(
      BcdObjectHandle: HANDLE,
      BcdElement: ULONG,
      Buffer: PVOID,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn BcdGetElementDataWithFlags(
      BcdObjectHandle: HANDLE,
      BcdElement: ULONG,
      BcdFlags: BCD_FLAGS,
      Buffer: PVOID,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn BcdSetElementData(
      BcdObjectHandle: HANDLE,
      BcdElement: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn BcdSetElementDataWithFlags(
      BcdObjectHandle: HANDLE,
      BcdElement: ULONG,
      BcdFlags: BCD_FLAGS,
      Buffer: PVOID,
      BufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn BcdDeleteElement(BcdObjectHandle: HANDLE, BcdElement: ULONG) -> NTSTATUS;
   pub fn NtAllocateVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
   ) -> NTSTATUS;
   pub fn NtAllocateVirtualMemoryEx(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   #[doc = "Frees virtual memory allocated for a process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose virtual memory is to be freed.\n* `BaseAddress` - A pointer to the base address of the region of pages to be freed.\n* `RegionSize` - A pointer to a variable that specifies the size of the region of memory to be freed.\n* `FreeType` - The type of free operation. This parameter can be MEM_DECOMMIT or MEM_RELEASE.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtFreeVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      FreeType: ULONG,
   ) -> NTSTATUS;
   #[doc = "Reads virtual memory from a process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose memory is to be read.\n* `BaseAddress` - A pointer to the base address in the specified process from which to read.\n* `Buffer` - A pointer to a buffer that receives the contents from the address space of the specified process.\n* `NumberOfBytesToRead` - The number of bytes to be read from the specified process.\n* `NumberOfBytesRead` - A pointer to a variable that receives the number of bytes transferred into the specified buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtReadVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      NumberOfBytesToRead: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtWow64ReadVirtualMemory64(
      ProcessHandle: HANDLE,
      BaseAddress: ULONGLONG,
      Buffer: PVOID,
      NumberOfBytesToRead: ULONGLONG,
      NumberOfBytesRead: PULONGLONG,
   ) -> NTSTATUS;
   #[doc = "Reads virtual memory from a process with extended options.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose memory is to be read.\n* `BaseAddress` - A pointer to the base address in the specified process from which to read.\n* `Buffer` - A pointer to a buffer that receives the contents from the address space of the specified process.\n* `NumberOfBytesToRead` - The number of bytes to be read from the specified process.\n* `NumberOfBytesRead` - A pointer to a variable that receives the number of bytes transferred into the specified buffer.\n* `Flags` - Additional flags for the read operation.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtReadVirtualMemoryEx(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      NumberOfBytesToRead: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
      Flags: ULONG,
   ) -> NTSTATUS;
   #[doc = "Writes virtual memory to a process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose memory is to be written.\n* `BaseAddress` - A pointer to the base address in the specified process to which to write.\n* `Buffer` - A pointer to the buffer that contains the data to be written to the address space of the specified process.\n* `NumberOfBytesToWrite` - The number of bytes to be written to the specified process.\n* `NumberOfBytesWritten` - A pointer to a variable that receives the number of bytes transferred into the specified buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtWriteVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      NumberOfBytesToWrite: SIZE_T,
      NumberOfBytesWritten: PSIZE_T,
   ) -> NTSTATUS;
   #[doc = "Writes virtual memory to a 64-bit process from a 32-bit process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose memory is to be written.\n* `BaseAddress` - A pointer to the base address in the specified process to which to write.\n* `Buffer` - A pointer to the buffer that contains the data to be written to the address space of the specified process.\n* `NumberOfBytesToWrite` - The number of bytes to be written to the specified process.\n* `NumberOfBytesWritten` - A pointer to a variable that receives the number of bytes transferred into the specified buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtWow64WriteVirtualMemory64(
      ProcessHandle: HANDLE,
      BaseAddress: ULONGLONG,
      Buffer: PVOID,
      NumberOfBytesToWrite: ULONGLONG,
      NumberOfBytesWritten: PULONGLONG,
   ) -> NTSTATUS;
   #[doc = "Changes the protection on a region of virtual memory.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose memory protection is to be changed.\n* `BaseAddress` - A pointer to the base address of the region of pages whose access protection attributes are to be changed.\n* `RegionSize` - A pointer to a variable that specifies the size of the region whose access protection attributes are to be changed.\n* `NewProtection` - The memory protection option. This parameter can be one of the memory protection constants.\n* `OldProtection` - A pointer to a variable that receives the previous access protection of the first page in the specified region of pages.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtProtectVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      NewProtection: ULONG,
      OldProtection: PULONG,
   ) -> NTSTATUS;
   #[doc = "Queries information about a region of virtual memory in a process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose memory information is to be queried.\n* `BaseAddress` - A pointer to the base address of the region of pages to be queried.\n* `MemoryInformationClass` - The type of information to be queried.\n* `MemoryInformation` - A pointer to a buffer that receives the memory information.\n* `MemoryInformationLength` - The size of the buffer pointed to by the MemoryInformation parameter.\n* `ReturnLength` - A pointer to a variable that receives the number of bytes returned in the MemoryInformation buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      MemoryInformationClass: MEMORY_INFORMATION_CLASS,
      MemoryInformation: PVOID,
      MemoryInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   #[doc = "Queries information about a region of virtual memory in a 64-bit process from a 32-bit process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose memory information is to be queried.\n* `BaseAddress` - A pointer to the base address of the region of pages to be queried.\n* `MemoryInformationClass` - The type of information to be queried.\n* `MemoryInformation` - A pointer to a buffer that receives the memory information.\n* `MemoryInformationLength` - The size of the buffer pointed to by the MemoryInformation parameter.\n* `ReturnLength` - A pointer to a variable that receives the number of bytes returned in the MemoryInformation buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtWow64QueryVirtualMemory64(
      ProcessHandle: HANDLE,
      BaseAddress: ULONGLONG,
      MemoryInformationClass: MEMORY_INFORMATION_CLASS,
      MemoryInformation: PVOID,
      MemoryInformationLength: ULONGLONG,
      ReturnLength: PULONGLONG,
   ) -> NTSTATUS;
   #[doc = "Flushes the instruction cache for a specified process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process whose instruction cache is to be flushed.\n* `BaseAddress` - A pointer to the base address of the region of memory to be flushed.\n* `RegionSize` - A pointer to a variable that specifies the size of the region to be flushed.\n* `IoStatus` - A pointer to an IO_STATUS_BLOCK structure that receives the status of the flush operation.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtFlushVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      IoStatus: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn NtSetInformationVirtualMemory(
      ProcessHandle: HANDLE,
      VmInformationClass: VIRTUAL_MEMORY_INFORMATION_CLASS,
      NumberOfEntries: SIZE_T,
      VirtualAddresses: PMEMORY_RANGE_ENTRY,
      VmInformation: PVOID,
      VmInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtLockVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      MapType: ULONG,
   ) -> NTSTATUS;
   pub fn NtUnlockVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      MapType: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateSection(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      MaximumSize: PLARGE_INTEGER,
      SectionPageProtection: ULONG,
      AllocationAttributes: ULONG,
      FileHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn NtCreateSectionEx(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      MaximumSize: PLARGE_INTEGER,
      SectionPageProtection: ULONG,
      AllocationAttributes: ULONG,
      FileHandle: HANDLE,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenSection(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtMapViewOfSection(
      SectionHandle: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      CommitSize: SIZE_T,
      SectionOffset: PLARGE_INTEGER,
      ViewSize: PSIZE_T,
      InheritDisposition: SECTION_INHERIT,
      AllocationType: ULONG,
      PageProtection: ULONG,
   ) -> NTSTATUS;
   pub fn NtMapViewOfSectionEx(
      SectionHandle: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      SectionOffset: PLARGE_INTEGER,
      ViewSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn NtUnmapViewOfSection(ProcessHandle: HANDLE, BaseAddress: PVOID) -> NTSTATUS;
   pub fn NtUnmapViewOfSectionEx(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtExtendSection(SectionHandle: HANDLE, NewSectionSize: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtQuerySection(
      SectionHandle: HANDLE,
      SectionInformationClass: SECTION_INFORMATION_CLASS,
      SectionInformation: PVOID,
      SectionInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtAreMappedFilesTheSame(
      File1MappedAsAnImage: PVOID,
      File2MappedAsFile: PVOID,
   ) -> NTSTATUS;
   pub fn NtCreatePartition(
      ParentPartitionHandle: HANDLE,
      PartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      PreferredNode: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenPartition(
      PartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtManagePartition(
      TargetHandle: HANDLE,
      SourceHandle: HANDLE,
      PartitionInformationClass: PARTITION_INFORMATION_CLASS,
      PartitionInformation: PVOID,
      PartitionInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtMapUserPhysicalPages(
      VirtualAddress: PVOID,
      NumberOfPages: SIZE_T,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtMapUserPhysicalPagesScatter(
      VirtualAddresses: *mut PVOID,
      NumberOfPages: SIZE_T,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtAllocateUserPhysicalPages(
      ProcessHandle: HANDLE,
      NumberOfPages: PSIZE_T,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtAllocateUserPhysicalPagesEx(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn NtFreeUserPhysicalPages(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtGetWriteWatch(
      ProcessHandle: HANDLE,
      Flags: ULONG,
      BaseAddress: PVOID,
      RegionSize: SIZE_T,
      UserAddressArray: *mut PVOID,
      EntriesInUserAddressArray: PULONG_PTR,
      Granularity: PULONG,
   ) -> NTSTATUS;
   pub fn NtResetWriteWatch(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      RegionSize: SIZE_T,
   ) -> NTSTATUS;
   pub fn NtCreatePagingFile(
      PageFileName: PUNICODE_STRING,
      MinimumSize: PLARGE_INTEGER,
      MaximumSize: PLARGE_INTEGER,
      Priority: ULONG,
   ) -> NTSTATUS;
   pub fn NtFlushInstructionCache(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Length: SIZE_T,
   ) -> NTSTATUS;
   pub fn NtFlushWriteBuffer() -> NTSTATUS;
   pub fn NtCreateEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      Size: SIZE_T,
      InitialCommitment: SIZE_T,
      EnclaveType: ULONG,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn NtLoadEnclaveData(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      Protect: ULONG,
      PageInformation: PVOID,
      PageInformationLength: ULONG,
      NumberOfBytesWritten: PSIZE_T,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn NtInitializeEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn NtTerminateEnclave(BaseAddress: PVOID, Flags: ULONG) -> NTSTATUS;
   pub fn NtCallEnclave(
      Routine: PENCLAVE_ROUTINE,
      Reserved: PVOID,
      Flags: ULONG,
      RoutineParamReturn: *mut PVOID,
   ) -> NTSTATUS;
   pub fn NtQueryObject(
      Handle: HANDLE,
      ObjectInformationClass: OBJECT_INFORMATION_CLASS,
      ObjectInformation: PVOID,
      ObjectInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationObject(
      Handle: HANDLE,
      ObjectInformationClass: OBJECT_INFORMATION_CLASS,
      ObjectInformation: PVOID,
      ObjectInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtDuplicateObject(
      SourceProcessHandle: HANDLE,
      SourceHandle: HANDLE,
      TargetProcessHandle: HANDLE,
      TargetHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Options: ULONG,
   ) -> NTSTATUS;
   pub fn NtMakeTemporaryObject(Handle: HANDLE) -> NTSTATUS;
   pub fn NtMakePermanentObject(Handle: HANDLE) -> NTSTATUS;
   pub fn NtSignalAndWaitForSingleObject(
      SignalHandle: HANDLE,
      WaitHandle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtWaitForSingleObject(
      Handle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtWaitForMultipleObjects(
      Count: ULONG,
      Handles: *mut HANDLE,
      WaitType: WAIT_TYPE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtWaitForMultipleObjects32(
      Count: ULONG,
      Handles: *mut LONG,
      WaitType: WAIT_TYPE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtSetSecurityObject(
      Handle: HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn NtQuerySecurityObject(
      Handle: HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Length: ULONG,
      LengthNeeded: PULONG,
   ) -> NTSTATUS;
   pub fn NtClose(Handle: HANDLE) -> NTSTATUS;
   pub fn NtCompareObjects(FirstObjectHandle: HANDLE, SecondObjectHandle: HANDLE) -> NTSTATUS;
   pub fn NtCreateDirectoryObject(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtCreateDirectoryObjectEx(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ShadowDirectoryHandle: HANDLE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenDirectoryObject(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtQueryDirectoryObject(
      DirectoryHandle: HANDLE,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      RestartScan: BOOLEAN,
      Context: PULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreatePrivateNamespace(
      NamespaceHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn NtOpenPrivateNamespace(
      NamespaceHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn NtDeletePrivateNamespace(NamespaceHandle: HANDLE) -> NTSTATUS;
   pub fn NtCreateSymbolicLinkObject(
      LinkHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LinkTarget: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtOpenSymbolicLinkObject(
      LinkHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtQuerySymbolicLinkObject(
      LinkHandle: HANDLE,
      LinkTarget: PUNICODE_STRING,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationSymbolicLink(
      LinkHandle: HANDLE,
      SymbolicLinkInformationClass: SYMBOLIC_LINK_INFO_CLASS,
      SymbolicLinkInformation: PVOID,
      SymbolicLinkInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryPortInformationProcess() -> NTSTATUS;
   #[doc = "Creates a new process.\n# Arguments\n\n* `ProcessHandle` - A pointer to a handle that receives the process object handle.\n* `DesiredAccess` - The access rights desired for the process object.\n* `ObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new process.\n* `ParentProcess` - A handle to the parent process.\n* `InheritObjectTable` - If TRUE, the new process inherits the object table of the parent process.\n* `SectionHandle` - Optional. A handle to a section object to be used for the new process.\n* `DebugPort` - Optional. A handle to a debug port to be used for the new process.\n* `TokenHandle` - Optional. A handle to an access token to be used for the new process.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateProcess(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ParentProcess: HANDLE,
      InheritObjectTable: BOOLEAN,
      SectionHandle: HANDLE,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
   ) -> NTSTATUS;
   #[doc = "Creates a new process with extended options.\n# Arguments\n\n* `ProcessHandle` - A pointer to a handle that receives the process object handle.\n* `DesiredAccess` - The access rights desired for the process object.\n* `ObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new process.\n* `ParentProcess` - A handle to the parent process.\n* `Flags` - Flags that control the creation of the process. These flags are defined as PROCESS_CREATE_FLAGS_*.\n* `SectionHandle` - Optional. A handle to a section object to be used for the new process.\n* `DebugPort` - Optional. A handle to a debug port to be used for the new process.\n* `TokenHandle` - Optional. A handle to an access token to be used for the new process.\n* `Reserved` - Reserved for future use. Must be zero.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateProcessEx(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ParentProcess: HANDLE,
      Flags: ULONG,
      SectionHandle: HANDLE,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
      Reserved: ULONG,
   ) -> NTSTATUS;
   #[doc = "Opens an existing process object.\n# Arguments\n\n* `ProcessHandle` - A pointer to a handle that receives the process object handle.\n* `DesiredAccess` - The access rights desired for the process object.\n* `ObjectAttributes` - A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new process.\n* `ClientId` - Optional. A pointer to a CLIENT_ID structure that specifies the client ID of the process to be opened.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenProcess(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   #[doc = "Terminates the specified process.\n# Arguments\n\n* `ProcessHandle` - Optional. A handle to the process to be terminated. If this parameter is NULL, the calling process is terminated.\n* `ExitStatus` - The exit status to be used by the process and the process's termination status.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtTerminateProcess(ProcessHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   #[doc = "Suspends the specified process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process to be suspended.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSuspendProcess(ProcessHandle: HANDLE) -> NTSTATUS;
   #[doc = "Resumes the specified process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process to be resumed.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtResumeProcess(ProcessHandle: HANDLE) -> NTSTATUS;
   pub static mut __ImageBase: IMAGE_DOS_HEADER;
   #[doc = "Retrieves information about the specified process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process.\n* `ProcessInformationClass` - The type of process information to be retrieved.\n* `ProcessInformation` - A pointer to a buffer that receives the process information.\n* `ProcessInformationLength` - The size of the buffer pointed to by the ProcessInformation parameter.\n* `ReturnLength` - An optional pointer to a variable that receives the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryInformationProcess(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtWow64QueryInformationProcess64(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "Sets information for the specified process.\n# Arguments\n\n* `ProcessHandle` - A handle to the process.\n* `ProcessInformationClass` - The type of process information to be set.\n* `ProcessInformation` - A pointer to a buffer that contains the process information.\n* `ProcessInformationLength` - The size of the buffer pointed to by the ProcessInformation parameter.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetInformationProcess(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
   ) -> NTSTATUS;
   #[doc = "Retrieves a handle to the next process in the system.\n# Arguments\n\n* `ProcessHandle` - An optional handle to a process. If this parameter is NULL, the function retrieves the first process in the system.\n* `DesiredAccess` - The access rights desired for the new process handle.\n* `HandleAttributes` - The attributes for the new process handle.\n* `Flags` - Flags that modify the behavior of the function. This can be a combination of the following flags:\n- [`PROCESS_GET_NEXT_FLAGS_PREVIOUS_PROCESS`] (0x00000001): Retrieve the previous process in the system.\n* `NewProcessHandle` - A pointer to a variable that receives the handle to the next process.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtGetNextProcess(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Flags: ULONG,
      NewProcessHandle: PHANDLE,
   ) -> NTSTATUS;
   #[doc = "Retrieves a handle to the next thread in the system.\n# Arguments\n\n* `ProcessHandle` - A handle to the process for enumerateration of threads.\n* `ThreadHandle` - An optional handle to a thread. If this parameter is NULL, the function retrieves the first thread in the process.\n* `DesiredAccess` - The access rights desired for the new thread handle.\n* `HandleAttributes` - The attributes for the new thread handle.\n* `Flags` - Flags that modify the behavior of the function. This can be a combination of the following flags:\n- [`THREAD_GET_NEXT_FLAGS_PREVIOUS_THREAD`] (0x00000001): Retrieve the previous thread in the process.\n* `NewThreadHandle` - A pointer to a variable that receives the handle to the next thread.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtGetNextThread(
      ProcessHandle: HANDLE,
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Flags: ULONG,
      NewThreadHandle: PHANDLE,
   ) -> NTSTATUS;
   #[doc = "Creates a state change handle for changing the suspension state of a process.\n# Arguments\n\n* `ProcessStateChangeHandle` - A pointer to a variable that receives the handle.\n* `DesiredAccess` - The access rights desired for the handle.\n* `ObjectAttributes` - Optional attributes for the handle.\n* `ProcessHandle` - A handle to the process.\n* `Reserved` - Reserved for future use.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateProcessStateChange(
      ProcessStateChangeHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   #[doc = "Changes the suspension state of a process.\n# Arguments\n\n* `ProcessStateChangeHandle` - A handle to the process state change object.\n* `ProcessHandle` - A handle to the process.\n* `StateChangeType` - The type of state change.\n* `ExtendedInformation` - Optional extended information.\n* `ExtendedInformationLength` - The length of the extended information.\n* `Reserved` - Reserved for future use.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtChangeProcessState(
      ProcessStateChangeHandle: HANDLE,
      ProcessHandle: HANDLE,
      StateChangeType: PROCESS_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   #[doc = "Creates a state change handle for changing the suspension state of a thread.\n# Arguments\n\n* `ThreadStateChangeHandle` - A pointer to a variable that receives the handle.\n* `DesiredAccess` - The access rights desired for the handle.\n* `ObjectAttributes` - Optional attributes for the handle.\n* `ThreadHandle` - A handle to the thread.\n* `Reserved` - Reserved for future use.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateThreadStateChange(
      ThreadStateChangeHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ThreadHandle: HANDLE,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   #[doc = "Changes the suspension state of a thread.\n# Arguments\n\n* `ThreadStateChangeHandle` - A handle to the thread state change object.\n* `ThreadHandle` - A handle to the thread.\n* `StateChangeType` - The type of state change.\n* `ExtendedInformation` - Optional extended information.\n* `ExtendedInformationLength` - The length of the extended information.\n* `Reserved` - Reserved for future use.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtChangeThreadState(
      ThreadStateChangeHandle: HANDLE,
      ThreadHandle: HANDLE,
      StateChangeType: THREAD_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   #[doc = "Creates a new thread in the specified process.\n# Arguments\n\n* `ThreadHandle` - A pointer to a handle that receives the thread object handle.\n* `DesiredAccess` - The access rights desired for the thread object.\n* `ObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new thread.\n* `ProcessHandle` - A handle to the process in which the thread is to be created.\n* `ClientId` - A pointer to a CLIENT_ID structure that receives the client ID of the new thread.\n* `ThreadContext` - A pointer to a CONTEXT structure that specifies the initial context of the new thread.\n* `InitialTeb` - A pointer to an INITIAL_TEB structure that specifies the initial stack limits of the new thread.\n* `CreateSuspended` - If TRUE, the thread is created in a suspended state.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateThread(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      ClientId: PCLIENT_ID,
      ThreadContext: PCONTEXT,
      InitialTeb: PINITIAL_TEB,
      CreateSuspended: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "Opens an existing thread object.\n# Arguments\n\n* `ThreadHandle` - A pointer to a handle that receives the thread object handle.\n* `DesiredAccess` - The access rights desired for the thread object.\n* `ObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new thread.\n* `ClientId` - Optional. A pointer to a CLIENT_ID structure that specifies the client ID of the thread to be opened.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenThread(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   #[doc = "Terminates the specified thread.\n# Arguments\n\n* `ThreadHandle` - Optional. A handle to the thread to be terminated. If this parameter is NULL, the calling thread is terminated.\n* `ExitStatus` - The exit status to be used by the thread and the thread's termination status.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtTerminateThread(ThreadHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   #[doc = "Suspends the specified thread.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread to be suspended.\n* `PreviousSuspendCount` - Optional. A pointer to a variable that receives the thread's previous suspend count.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSuspendThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   #[doc = "Resumes the specified thread.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread to be resumed.\n* `PreviousSuspendCount` - Optional. A pointer to a variable that receives the thread's previous suspend count.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   #[doc = "Retrieves the number of the current processor.\n# Returns\n\nULONG The number of the current processor."]
   pub fn NtGetCurrentProcessorNumber() -> ULONG;
   #[doc = "Retrieves the number of the current processor.\n# Arguments\n\n* `ProcessorNumber` - An optional pointer to a PROCESSOR_NUMBER structure that receives the processor number.\n# Returns\n\nULONG The number of the current processor."]
   pub fn NtGetCurrentProcessorNumberEx(ProcessorNumber: PPROCESSOR_NUMBER) -> ULONG;
   #[doc = "Retrieves the context of the specified thread.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread.\n* `ThreadContext` - A pointer to a CONTEXT structure that receives the thread context.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtGetContextThread(ThreadHandle: HANDLE, ThreadContext: PCONTEXT) -> NTSTATUS;
   #[doc = "Sets the context of the specified thread.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread.\n* `ThreadContext` - A pointer to a CONTEXT structure that specifies the thread context.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetContextThread(ThreadHandle: HANDLE, ThreadContext: PCONTEXT) -> NTSTATUS;
   #[doc = "Retrieves information about the specified thread.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread.\n* `ThreadInformationClass` - The type of thread information to be retrieved.\n* `ThreadInformation` - A pointer to a buffer that receives the thread information.\n* `ThreadInformationLength` - The size of the buffer pointed to by the ThreadInformation parameter.\n* `ReturnLength` - An optional pointer to a variable that receives the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: THREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "Sets information for the specified thread.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread.\n* `ThreadInformationClass` - The type of thread information to be set.\n* `ThreadInformation` - A pointer to a buffer that contains the thread information.\n* `ThreadInformationLength` - The size of the buffer pointed to by the ThreadInformation parameter.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: THREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
   ) -> NTSTATUS;
   #[doc = "Sends an alert to the specified thread.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread to be alerted.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAlertThread(ThreadHandle: HANDLE) -> NTSTATUS;
   #[doc = "Resumes a thread that was previously suspended and sends an alert to it.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread to be resumed and alerted.\n* `PreviousSuspendCount` - An optional pointer to a variable that receives the thread's previous suspend count.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAlertResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   #[doc = "Tests whether the current thread has an alert pending.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtTestAlert() -> NTSTATUS;
   #[doc = "Sends an alert to the specified thread.\n# Arguments\n\n* `ThreadId` - The thread ID of the thread to be alerted.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAlertThreadByThreadId(ThreadId: HANDLE) -> NTSTATUS;
   #[doc = "Sends an alert to the specified thread by its thread ID, with an optional lock.\n# Arguments\n\n* `ThreadId` - The thread ID of the thread to be alerted.\n* `Lock` - An optional pointer to an SRW lock to be used during the alert.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAlertThreadByThreadIdEx(ThreadId: HANDLE, Lock: PRTL_SRWLOCK) -> NTSTATUS;
   #[doc = "Sends an alert to multiple threads by their thread IDs.\n# Arguments\n\n* `MultipleThreadId` - A pointer to an array of thread IDs to be alerted.\n* `Count` - The number of thread IDs in the array.\n* `Boost` - A pointer to a boost value to be applied to the threads.\n* `BoostCount` - The number of boost values in the array.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAlertMultipleThreadByThreadId(
      MultipleThreadId: PHANDLE,
      Count: ULONG,
      Boost: PVOID,
      BoostCount: ULONG,
   ) -> NTSTATUS;
   #[doc = "Waits for an alert to be delivered to the specified thread.\n# Arguments\n\n* `Address` - The address to wait for an alert on.\n* `Timeout` - The timeout value for waiting, or NULL for no timeout.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtWaitForAlertByThreadId(Address: PVOID, Timeout: PLARGE_INTEGER) -> NTSTATUS;
   #[doc = "Impersonates a client thread.\n# Arguments\n\n* `ServerThreadHandle` - A handle to the server thread.\n* `ClientThreadHandle` - A handle to the client thread.\n* `SecurityQos` - A pointer to a SECURITY_QUALITY_OF_SERVICE structure that specifies the impersonation level and context tracking mode.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtImpersonateThread(
      ServerThreadHandle: HANDLE,
      ClientThreadHandle: HANDLE,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
   ) -> NTSTATUS;
   #[doc = "Registers a thread termination port.\n# Arguments\n\n* `PortHandle` - A handle to the port to be registered.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtRegisterThreadTerminatePort(PortHandle: HANDLE) -> NTSTATUS;
   #[doc = "Sets LDT (Local Descriptor Table) entries.\n# Arguments\n\n* `Selector0` - The first selector.\n* `Entry0Low` - The low part of the first entry.\n* `Entry0Hi` - The high part of the first entry.\n* `Selector1` - The second selector.\n* `Entry1Low` - The low part of the second entry.\n* `Entry1Hi` - The high part of the second entry.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetLdtEntries(
      Selector0: ULONG,
      Entry0Low: ULONG,
      Entry0Hi: ULONG,
      Selector1: ULONG,
      Entry1Low: ULONG,
      Entry1Hi: ULONG,
   ) -> NTSTATUS;
   #[doc = "Dispatches the Asynchronous Procedure Call (APC) from the NtQueueApc* functions to the specified routine.\n# Arguments\n\n* `ApcRoutine` - A pointer to the APC routine to be executed.\n* `Parameter` - Optional. A pointer to a parameter to be passed to the APC routine.\n* `ActxContext` - Optional. A handle to an activation context."]
   pub fn RtlDispatchAPC(ApcRoutine: PAPCFUNC, Parameter: PVOID, ActxContext: HANDLE);
   #[doc = "Queues an APC (Asynchronous Procedure Call) to a thread.\n# Arguments\n\n* `ThreadHandle` - Handle to the thread to which the APC is to be queued.\n* `ApcRoutine` - A pointer to the RtlDispatchAPC function or custom APC routine to be executed.\n* `ApcArgument1` - Optional first argument to be passed to the APC routine.\n* `ApcArgument2` - Optional second argument to be passed to the APC routine.\n* `ApcArgument3` - Optional third argument to be passed to the APC routine.\n# Returns\n\nNTSTATUS Successful or errant status.\n> The APC will be executed in the context of the specified thread when the thread enters an alertable wait state or when any\nprocess calls the NtTestAlert, NtAlertThread, NtAlertResumeThread or NtAlertThreadByThreadId functions."]
   pub fn NtQueueApcThread(
      ThreadHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   #[doc = "Queues an APC (Asynchronous Procedure Call) to a thread.\n# Arguments\n\n* `ThreadHandle` - Handle to the thread to which the APC is to be queued.\n* `ReserveHandle` - Optional handle to a reserve object. This can be QUEUE_USER_APC_SPECIAL_USER_APC or a handle returned by NtAllocateReserveObject.\n* `ApcRoutine` - A pointer to the RtlDispatchAPC function or custom APC routine to be executed.\n* `ApcArgument1` - Optional first argument to be passed to the APC routine.\n* `ApcArgument2` - Optional second argument to be passed to the APC routine.\n* `ApcArgument3` - Optional third argument to be passed to the APC routine.\n# Returns\n\nNTSTATUS Successful or errant status.\n> The APC will be executed in the context of the specified thread after the thread enters an alertable wait state or immediately\nwhen QUEUE_USER_APC_SPECIAL_USER_APC is used or NtTestAlert, NtAlertThread, NtAlertResumeThread or NtAlertThreadByThreadId are called."]
   pub fn NtQueueApcThreadEx(
      ThreadHandle: HANDLE,
      ReserveHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   #[doc = "Queues an Asynchronous Procedure Call (APC) to a specified thread.\n# Arguments\n\n* `ThreadHandle` - A handle to the thread to which the APC is to be queued.\n* `ReserveHandle` - An optional handle to a reserve object. This can be obtained using NtAllocateReserveObject.\n* `ApcFlags` - Flags that control the behavior of the APC. These flags are defined in QUEUE_USER_APC_FLAGS.\n* `ApcRoutine` - A pointer to the RtlDispatchAPC function or custom APC routine to be executed.\n* `ApcArgument1` - An optional argument to be passed to the APC routine.\n* `ApcArgument2` - An optional argument to be passed to the APC routine.\n* `ApcArgument3` - An optional argument to be passed to the APC routine.\n# Returns\n\nNTSTATUS Successful or errant status.\n> The APC will be executed in the context of the specified thread when the thread enters an alertable wait state or immediately\nwhen QUEUE_USER_APC_SPECIAL_USER_APC is used or any process calls the NtTestAlert, NtAlertThread,\nNtAlertResumeThread or NtAlertThreadByThreadId functions."]
   pub fn NtQueueApcThreadEx2(
      ThreadHandle: HANDLE,
      ReserveHandle: HANDLE,
      ApcFlags: ULONG,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   #[doc = "Creates a new process and primary thread.\n# Arguments\n\n* `ProcessHandle` - A pointer to a handle that receives the process object handle.\n* `ThreadHandle` - A pointer to a handle that receives the thread object handle.\n* `ProcessDesiredAccess` - The access rights desired for the process object.\n* `ThreadDesiredAccess` - The access rights desired for the thread object.\n* `ProcessObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new process.\n* `ThreadObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new thread.\n* `ProcessFlags` - Flags that control the creation of the process. These flags are defined as PROCESS_CREATE_FLAGS_*.\n* `ThreadFlags` - Flags that control the creation of the thread. These flags are defined as THREAD_CREATE_FLAGS_*.\n* `ProcessParameters` - Optional. A pointer to a RTL_USER_PROCESS_PARAMETERS structure that specifies the parameters for the new process.\n* `CreateInfo` - A pointer to a PS_CREATE_INFO structure that specifies additional information for the process creation.\n* `AttributeList` - Optional. A pointer to a list of attributes for the process and thread.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateUserProcess(
      ProcessHandle: PHANDLE,
      ThreadHandle: PHANDLE,
      ProcessDesiredAccess: ACCESS_MASK,
      ThreadDesiredAccess: ACCESS_MASK,
      ProcessObjectAttributes: PCOBJECT_ATTRIBUTES,
      ThreadObjectAttributes: PCOBJECT_ATTRIBUTES,
      ProcessFlags: ULONG,
      ThreadFlags: ULONG,
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
      CreateInfo: PPS_CREATE_INFO,
      AttributeList: PPS_ATTRIBUTE_LIST,
   ) -> NTSTATUS;
   #[doc = "Creates a new thread in the specified process.\n# Arguments\n\n* `ThreadHandle` - A pointer to a handle that receives the thread object handle.\n* `DesiredAccess` - The access rights desired for the thread object.\n* `ObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new thread.\n* `ProcessHandle` - A handle to the process in which the thread is to be created.\n* `StartRoutine` - A pointer to the application-defined function to be executed by the thread.\n* `Argument` - Optional. A pointer to a variable to be passed to the thread.\n* `CreateFlags` - Flags that control the creation of the thread. These flags are defined as THREAD_CREATE_FLAGS_*.\n* `ZeroBits` - The number of zero bits in the starting address of the thread's stack.\n* `StackSize` - The initial size of the thread's stack, in bytes.\n* `MaximumStackSize` - The maximum size of the thread's stack, in bytes.\n* `AttributeList` - Optional. A pointer to a list of attributes for the thread.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateThreadEx(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      StartRoutine: PUSER_THREAD_START_ROUTINE,
      Argument: PVOID,
      CreateFlags: ULONG,
      ZeroBits: SIZE_T,
      StackSize: SIZE_T,
      MaximumStackSize: SIZE_T,
      AttributeList: PPS_ATTRIBUTE_LIST,
   ) -> NTSTATUS;
   #[doc = "Creates or opens a job object.\n# Arguments\n\n* `JobHandle` - A handle to the job object.\n* `DesiredAccess` - The access rights desired for the thread object.\n* `ObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new thread.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateJobObject(
      JobHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "Opens an existing job object.\n# Arguments\n\n* `JobHandle` - A handle to the job object.\n* `DesiredAccess` - The access rights desired for the thread object.\n* `ObjectAttributes` - Optional. A pointer to an OBJECT_ATTRIBUTES structure that specifies the attributes of the new thread.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenJobObject(
      JobHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "Assigns a process to an existing job object.\n# Arguments\n\n* `JobHandle` - A handle to the job object to which the process will be associated. The handle must have the JOB_OBJECT_ASSIGN_PROCESS access right.\n* `ProcessHandle` - A handle to the process to associate with the job object. The handle must have the PROCESS_SET_QUOTA and PROCESS_TERMINATE access rights.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAssignProcessToJobObject(JobHandle: HANDLE, ProcessHandle: HANDLE) -> NTSTATUS;
   #[doc = "Terminates all processes associated with the job object. If the job is nested, all processes currently associated with the job and all child jobs in the hierarchy are terminated.\n# Arguments\n\n* `JobHandle` - A handle to the job whose processes will be terminated. The handle must have the JOB_OBJECT_TERMINATE access right.\n* `ExitStatus` - The exit status to be used by all processes and threads in the job object.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtTerminateJobObject(JobHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   #[doc = "Checks if a process is associated with a job object.\n# Arguments\n\n* `ProcessHandle` - A handle to the process to be checked.\n* `JobHandle` - An optional handle to the job object. If this parameter is NULL, the function checks if the process is associated with any job object.\n# Returns\n\nNTSTATUS Successful or errant status.\n> This function can be used to determine if a process is running within a job object, which can be useful for managing process resources and constraints."]
   pub fn NtIsProcessInJob(ProcessHandle: HANDLE, JobHandle: HANDLE) -> NTSTATUS;
   #[doc = "Retrieves information about a job object.\n# Arguments\n\n* `JobHandle` - An optional handle to the job object. If this parameter is NULL, the function retrieves information about the job object associated with the calling process.\n* `JobObjectInformationClass` - The type of job object information to be retrieved.\n* `JobObjectInformation` - A pointer to a buffer that receives the job object information.\n* `JobObjectInformationLength` - The size of the buffer pointed to by the JobObjectInformation parameter.\n* `ReturnLength` - An optional pointer to a variable that receives the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status.\n> This function can be used to query various types of information about a job object, such as accounting information, limit information, and process ID list."]
   pub fn NtQueryInformationJobObject(
      JobHandle: HANDLE,
      JobObjectInformationClass: JOBOBJECTINFOCLASS,
      JobObjectInformation: PVOID,
      JobObjectInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "Sets information for a job object.\n# Arguments\n\n* `JobHandle` - A handle to the job object.\n* `JobObjectInformationClass` - The type of job object information to be set.\n* `JobObjectInformation` - A pointer to a buffer that contains the job object information.\n* `JobObjectInformationLength` - The size of the buffer pointed to by the JobObjectInformation parameter.\n# Returns\n\nNTSTATUS Successful or errant status.\n> This function can be used to set various types of information for a job object, such as limit information, UI restrictions, and security limit information."]
   pub fn NtSetInformationJobObject(
      JobHandle: HANDLE,
      JobObjectInformationClass: JOBOBJECTINFOCLASS,
      JobObjectInformation: PVOID,
      JobObjectInformationLength: ULONG,
   ) -> NTSTATUS;
   #[doc = "Creates a set of job objects.\n# Arguments\n\n* `NumJob` - The number of job objects in the set.\n* `UserJobSet` - A pointer to an array of JOB_SET_ARRAY structures that specify the job objects in the set.\n* `Flags` - Reserved for future use. Must be zero.\n# Returns\n\nNTSTATUS Successful or errant status.\n> This function can be used to create a set of job objects, which can be useful for managing groups of related processes."]
   pub fn NtCreateJobSet(NumJob: ULONG, UserJobSet: PJOB_SET_ARRAY, Flags: ULONG) -> NTSTATUS;
   pub fn NtRevertContainerImpersonation() -> NTSTATUS;
   #[doc = "Allocates a memory reserve object.\n# Arguments\n\n* `MemoryReserveHandle` - Pointer to a variable that receives the memory reserve object handle.\n* `ObjectAttributes` - Pointer to an object attributes structure.\n* `Type` - The type of memory reserve.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtAllocateReserveObject(
      MemoryReserveHandle: PHANDLE,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      Type: MEMORY_RESERVE_TYPE,
   ) -> NTSTATUS;
   #[doc = "Captures a snapshot of the specified process.\n# Arguments\n\n* `SnapshotHandle` - Pointer to a variable that receives the snapshot handle.\n* `ProcessHandle` - Handle to the process.\n* `CaptureFlags` - Flags indicating what to capture.\n* `ThreadContextFlags` - Optional flags for capturing thread context.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn PssNtCaptureSnapshot(
      SnapshotHandle: PHANDLE,
      ProcessHandle: HANDLE,
      CaptureFlags: PSSNT_CAPTURE_FLAGS,
      ThreadContextFlags: ULONG,
   ) -> NTSTATUS;
   #[doc = "Duplicates a process snapshot from one process to another.\n# Arguments\n\n* `SourceProcessHandle` - Handle to the source process.\n* `SnapshotHandle` - Handle to the snapshot to duplicate.\n* `TargetProcessHandle` - Handle to the target process.\n* `TargetSnapshotHandle` - Pointer to a variable that receives the duplicated snapshot handle.\n* `Flags` - Optional flags for duplication.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn PssNtDuplicateSnapshot(
      SourceProcessHandle: HANDLE,
      SnapshotHandle: HANDLE,
      TargetProcessHandle: HANDLE,
      TargetSnapshotHandle: PHANDLE,
      Flags: PSSNT_DUPLICATE_FLAGS,
   ) -> NTSTATUS;
   #[doc = "Frees a remote process snapshot.\n# Arguments\n\n* `ProcessHandle` - A handle to the process that contains the snapshot. The handle must have PROCESS_VM_READ, PROCESS_VM_OPERATION, and PROCESS_DUP_HANDLE rights.\n* `SnapshotHandle` - Handle to the snapshot to free.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn PssNtFreeSnapshot(SnapshotHandle: HANDLE) -> NTSTATUS;
   #[doc = "Frees a snapshot.\n# Arguments\n\n* `SnapshotHandle` - Handle to the snapshot to free.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn PssNtFreeRemoteSnapshot(ProcessHandle: HANDLE, SnapshotHandle: HANDLE) -> NTSTATUS;
   #[doc = "Queries information from a the specified snapshot.\n# Arguments\n\n* `SnapshotHandle` - Handle to the snapshot.\n* `InformationClass` - The information class to query.\n* `Buffer` - Pointer to a buffer that receives the queried information.\n* `BufferLength` - Length of the buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn PssNtQuerySnapshot(
      SnapshotHandle: HANDLE,
      InformationClass: PSSNT_QUERY_INFORMATION_CLASS,
      Buffer: PVOID,
      BufferLength: ULONG,
   ) -> NTSTATUS;
   #[doc = "Captures virtual address space bulk information for a process.\n# Arguments\n\n* `ProcessHandle` - Handle to the process.\n* `BaseAddress` - Optional base address to start the capture.\n* `BulkInformation` - Pointer to the memory bulk information structure.\n* `BulkInformationLength` - Length of the memory bulk information structure.\n* `ReturnLength` - Optional pointer to a variable that receives the length of the captured information.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtPssCaptureVaSpaceBulk(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      BulkInformation: PNTPSS_MEMORY_BULK_INFORMATION,
      BulkInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn DbgUserBreakPoint();
   pub fn DbgBreakPoint();
   pub fn DbgBreakPointWithStatus(Status: ULONG);
   pub fn DbgPrint(Format: PCCH, ...) -> ULONG;
   pub fn DbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCCH, ...) -> ULONG;
   pub fn vDbgPrintEx(ComponentId: ULONG, Level: ULONG, Format: PCCH, arglist: va_list) -> ULONG;
   pub fn vDbgPrintExWithPrefix(
      Prefix: PCCH,
      ComponentId: ULONG,
      Level: ULONG,
      Format: PCCH,
      arglist: va_list,
   ) -> ULONG;
   pub fn DbgPrintReturnControlC(Format: PCCH, ...) -> ULONG;
   pub fn DbgQueryDebugFilterState(ComponentId: ULONG, Level: ULONG) -> NTSTATUS;
   pub fn DbgSetDebugFilterState(ComponentId: ULONG, Level: ULONG, State: BOOLEAN) -> NTSTATUS;
   pub fn DbgPrompt(Prompt: PCCH, Response: PCH, Length: ULONG) -> ULONG;
   pub fn NtCreateDebugObject(
      DebugObjectHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtDebugActiveProcess(ProcessHandle: HANDLE, DebugObjectHandle: HANDLE) -> NTSTATUS;
   pub fn NtDebugContinue(
      DebugObjectHandle: HANDLE,
      ClientId: PCLIENT_ID,
      ContinueStatus: NTSTATUS,
   ) -> NTSTATUS;
   pub fn NtRemoveProcessDebug(ProcessHandle: HANDLE, DebugObjectHandle: HANDLE) -> NTSTATUS;
   pub fn NtSetInformationDebugObject(
      DebugObjectHandle: HANDLE,
      DebugObjectInformationClass: DEBUGOBJECTINFOCLASS,
      DebugInformation: PVOID,
      DebugInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtWaitForDebugEvent(
      DebugObjectHandle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
      WaitStateChange: PDBGUI_WAIT_STATE_CHANGE,
   ) -> NTSTATUS;
   pub fn DbgUiConnectToDbg() -> NTSTATUS;
   pub fn DbgUiGetThreadDebugObject() -> HANDLE;
   pub fn DbgUiSetThreadDebugObject(DebugObject: HANDLE);
   pub fn DbgUiWaitStateChange(
      StateChange: PDBGUI_WAIT_STATE_CHANGE,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn DbgUiContinue(AppClientId: PCLIENT_ID, ContinueStatus: NTSTATUS) -> NTSTATUS;
   pub fn DbgUiStopDebugging(Process: HANDLE) -> NTSTATUS;
   pub fn DbgUiDebugActiveProcess(Process: HANDLE) -> NTSTATUS;
   pub fn DbgUiRemoteBreakin(Context: PVOID);
   pub fn DbgUiIssueRemoteBreakin(Process: HANDLE) -> NTSTATUS;
   pub fn DbgUiConvertStateChangeStructure(
      StateChange: PDBGUI_WAIT_STATE_CHANGE,
      DebugEvent: LPDEBUG_EVENT,
   ) -> NTSTATUS;
   pub fn DbgUiConvertStateChangeStructureEx(
      StateChange: PDBGUI_WAIT_STATE_CHANGE,
      DebugEvent: LPDEBUG_EVENT,
   ) -> NTSTATUS;
   pub fn EtwEventRegister(
      ProviderId: LPCGUID,
      EnableCallback: PENABLECALLBACK,
      CallbackContext: PVOID,
      RegHandle: PREGHANDLE,
   ) -> NTSTATUS;
   pub fn NtCreateFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      AllocationSize: PLARGE_INTEGER,
      FileAttributes: ULONG,
      ShareAccess: ULONG,
      CreateDisposition: ULONG,
      CreateOptions: ULONG,
      EaBuffer: PVOID,
      EaLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateNamedPipeFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ShareAccess: ULONG,
      CreateDisposition: ULONG,
      CreateOptions: ULONG,
      NamedPipeType: ULONG,
      ReadMode: ULONG,
      CompletionMode: ULONG,
      MaximumInstances: ULONG,
      InboundQuota: ULONG,
      OutboundQuota: ULONG,
      DefaultTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtCreateMailslotFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CreateOptions: ULONG,
      MailslotQuota: ULONG,
      MaximumMessageSize: ULONG,
      ReadTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtOpenFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ShareAccess: ULONG,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn NtDeleteFile(ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn NtFlushBuffersFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
   pub fn NtFlushBuffersFileEx(
      FileHandle: HANDLE,
      Flags: ULONG,
      Parameters: PVOID,
      ParametersSize: ULONG,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn NtQueryInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn NtQueryInformationByName(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn NtSetInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn NtQueryDirectoryFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
      ReturnSingleEntry: BOOLEAN,
      FileName: PUNICODE_STRING,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtQueryDirectoryFileEx(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
      QueryFlags: ULONG,
      FileName: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtQueryEaFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      EaList: PVOID,
      EaListLength: ULONG,
      EaIndex: PULONG,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtSetEaFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryQuotaInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      SidList: PVOID,
      SidListLength: ULONG,
      StartSid: PSID,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtSetQuotaInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryVolumeInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsInformation: PVOID,
      Length: ULONG,
      FsInformationClass: FSINFOCLASS,
   ) -> NTSTATUS;
   pub fn NtSetVolumeInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsInformation: PVOID,
      Length: ULONG,
      FsInformationClass: FSINFOCLASS,
   ) -> NTSTATUS;
   pub fn NtCancelIoFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
   pub fn NtCancelIoFileEx(
      FileHandle: HANDLE,
      IoRequestToCancel: PIO_STATUS_BLOCK,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn NtCancelSynchronousIoFile(
      ThreadHandle: HANDLE,
      IoRequestToCancel: PIO_STATUS_BLOCK,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn NtDeviceIoControlFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      IoControlCode: ULONG,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtFsControlFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsControlCode: ULONG,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtReadFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn NtWriteFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn NtReadFileScatter(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      SegmentArray: PFILE_SEGMENT_ELEMENT,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn NtWriteFileGather(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      SegmentArray: PFILE_SEGMENT_ELEMENT,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn NtLockFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ByteOffset: PLARGE_INTEGER,
      Length: PLARGE_INTEGER,
      Key: ULONG,
      FailImmediately: BOOLEAN,
      ExclusiveLock: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtUnlockFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ByteOffset: PLARGE_INTEGER,
      Length: PLARGE_INTEGER,
      Key: ULONG,
   ) -> NTSTATUS;
   pub fn NtQueryAttributesFile(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      FileInformation: PFILE_BASIC_INFORMATION,
   ) -> NTSTATUS;
   pub fn NtQueryFullAttributesFile(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
   ) -> NTSTATUS;
   pub fn NtNotifyChangeDirectoryFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtNotifyChangeDirectoryFileEx(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
   ) -> NTSTATUS;
   #[doc = "The NtLoadDriver function loads a driver specified by the DriverServiceName parameter.\n# Arguments\n\n* `DriverServiceName` - A pointer to a UNICODE_STRING structure that specifies the name of the driver service to load.\n# Returns\n\nNTSTATUS The status code returned by the function. Possible values include, but are not limited to:\n- STATUS_SUCCESS: The driver was successfully loaded.\n- STATUS_INVALID_PARAMETER: The DriverServiceName parameter is invalid.\n- STATUS_INSUFFICIENT_RESOURCES: There are insufficient resources to load the driver.\n- STATUS_OBJECT_NAME_NOT_FOUND: The specified driver service name was not found.\n- STATUS_OBJECT_PATH_NOT_FOUND: The path to the driver service was not found.\n- STATUS_OBJECT_NAME_COLLISION: A driver with the same name already exists."]
   pub fn NtLoadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
   #[doc = "The NtUnloadDriver function unloads a driver specified by the DriverServiceName parameter.\n# Arguments\n\n* `DriverServiceName` - A pointer to a UNICODE_STRING structure that specifies the name of the driver service to unload.\n# Returns\n\nNTSTATUS The status code returned by the function. Possible values include, but are not limited to:\n- STATUS_SUCCESS: The driver was successfully unloaded.\n- STATUS_INVALID_PARAMETER: The DriverServiceName parameter is invalid.\n- STATUS_OBJECT_NAME_NOT_FOUND: The specified driver service name was not found.\n- STATUS_OBJECT_PATH_NOT_FOUND: The path to the driver service was not found.\n- STATUS_OBJECT_NAME_COLLISION: A driver with the same name already exists."]
   pub fn NtUnloadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
   pub fn NtCreateIoCompletion(
      IoCompletionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      NumberOfConcurrentThreads: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenIoCompletion(
      IoCompletionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtQueryIoCompletion(
      IoCompletionHandle: HANDLE,
      IoCompletionInformationClass: IO_COMPLETION_INFORMATION_CLASS,
      IoCompletionInformation: PVOID,
      IoCompletionInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetIoCompletion(
      IoCompletionHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtSetIoCompletionEx(
      IoCompletionHandle: HANDLE,
      IoCompletionPacketHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtRemoveIoCompletion(
      IoCompletionHandle: HANDLE,
      KeyContext: *mut PVOID,
      ApcContext: *mut PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtRemoveIoCompletionEx(
      IoCompletionHandle: HANDLE,
      IoCompletionInformation: PFILE_IO_COMPLETION_INFORMATION,
      Count: ULONG,
      NumEntriesRemoved: PULONG,
      Timeout: PLARGE_INTEGER,
      Alertable: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtCreateWaitCompletionPacket(
      WaitCompletionPacketHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtAssociateWaitCompletionPacket(
      WaitCompletionPacketHandle: HANDLE,
      IoCompletionHandle: HANDLE,
      TargetObjectHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
      AlreadySignaled: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtCancelWaitCompletionPacket(
      WaitCompletionPacketHandle: HANDLE,
      RemoveSignaledPacket: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtOpenSession(
      SessionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtNotifyChangeSession(
      SessionHandle: HANDLE,
      ChangeSequenceNumber: ULONG,
      ChangeTimeStamp: PLARGE_INTEGER,
      Event: IO_SESSION_EVENT,
      NewState: IO_SESSION_STATE,
      PreviousState: IO_SESSION_STATE,
      Payload: PVOID,
      PayloadSize: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateIoRing(
      IoRingHandle: PHANDLE,
      CreateParametersLength: ULONG,
      CreateParameters: PVOID,
      OutputParametersLength: ULONG,
      OutputParameters: PVOID,
   ) -> NTSTATUS;
   pub fn NtSubmitIoRing(
      IoRingHandle: HANDLE,
      Flags: ULONG,
      WaitOperations: ULONG,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtQueryIoRingCapabilities(
      IoRingCapabilitiesLength: SIZE_T,
      IoRingCapabilities: PVOID,
   ) -> NTSTATUS;
   pub fn NtSetInformationIoRing(
      IoRingHandle: HANDLE,
      IoRingInformationClass: ULONG,
      IoRingInformationLength: ULONG,
      IoRingInformation: PVOID,
   ) -> NTSTATUS;
   pub fn NtCreatePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaxConnectionInfoLength: ULONG,
      MaxMessageLength: ULONG,
      MaxPoolUsage: ULONG,
   ) -> NTSTATUS;
   pub fn NtCreateWaitablePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaxConnectionInfoLength: ULONG,
      MaxMessageLength: ULONG,
      MaxPoolUsage: ULONG,
   ) -> NTSTATUS;
   pub fn NtConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
      ClientView: PPORT_VIEW,
      ServerView: PREMOTE_PORT_VIEW,
      MaxMessageLength: PULONG,
      ConnectionInformation: PVOID,
      ConnectionInformationLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSecureConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
      ClientView: PPORT_VIEW,
      RequiredServerSid: PSID,
      ServerView: PREMOTE_PORT_VIEW,
      MaxMessageLength: PULONG,
      ConnectionInformation: PVOID,
      ConnectionInformationLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtListenPort(PortHandle: HANDLE, ConnectionRequest: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtAcceptConnectPort(
      PortHandle: PHANDLE,
      PortContext: PVOID,
      ConnectionRequest: PPORT_MESSAGE,
      AcceptConnection: BOOLEAN,
      ServerView: PPORT_VIEW,
      ClientView: PREMOTE_PORT_VIEW,
   ) -> NTSTATUS;
   pub fn NtCompleteConnectPort(PortHandle: HANDLE) -> NTSTATUS;
   pub fn NtRequestPort(PortHandle: HANDLE, RequestMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtRequestWaitReplyPort(
      PortHandle: HANDLE,
      RequestMessage: PPORT_MESSAGE,
      ReplyMessage: PPORT_MESSAGE,
   ) -> NTSTATUS;
   pub fn NtReplyPort(PortHandle: HANDLE, ReplyMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtReplyWaitReplyPort(PortHandle: HANDLE, ReplyMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtReplyWaitReceivePort(
      PortHandle: HANDLE,
      PortContext: *mut PVOID,
      ReplyMessage: PPORT_MESSAGE,
      ReceiveMessage: PPORT_MESSAGE,
   ) -> NTSTATUS;
   pub fn NtReplyWaitReceivePortEx(
      PortHandle: HANDLE,
      PortContext: *mut PVOID,
      ReplyMessage: PPORT_MESSAGE,
      ReceiveMessage: PPORT_MESSAGE,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtImpersonateClientOfPort(PortHandle: HANDLE, Message: PPORT_MESSAGE) -> NTSTATUS;
   pub fn NtReadRequestData(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      DataEntryIndex: ULONG,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtWriteRequestData(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      DataEntryIndex: ULONG,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesWritten: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtQueryInformationPort(
      PortHandle: HANDLE,
      PortInformationClass: PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcCreatePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtAlpcDisconnectPort(PortHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   pub fn NtAlpcQueryInformation(
      PortHandle: HANDLE,
      PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcSetInformation(
      PortHandle: HANDLE,
      PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcCreatePortSection(
      PortHandle: HANDLE,
      Flags: ULONG,
      SectionHandle: HANDLE,
      SectionSize: SIZE_T,
      AlpcSectionHandle: PALPC_HANDLE,
      ActualSectionSize: PSIZE_T,
   ) -> NTSTATUS;
   pub fn NtAlpcDeletePortSection(
      PortHandle: HANDLE,
      Flags: ULONG,
      SectionHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcCreateResourceReserve(
      PortHandle: HANDLE,
      Flags: ULONG,
      MessageSize: SIZE_T,
      ResourceId: PALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcDeleteResourceReserve(
      PortHandle: HANDLE,
      Flags: ULONG,
      ResourceId: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcCreateSectionView(
      PortHandle: HANDLE,
      Flags: ULONG,
      ViewAttributes: PALPC_DATA_VIEW_ATTR,
   ) -> NTSTATUS;
   pub fn NtAlpcDeleteSectionView(PortHandle: HANDLE, Flags: ULONG, ViewBase: PVOID) -> NTSTATUS;
   pub fn NtAlpcCreateSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      SecurityAttribute: PALPC_SECURITY_ATTR,
   ) -> NTSTATUS;
   pub fn NtAlpcDeleteSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      ContextHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcRevokeSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      ContextHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn NtAlpcQueryInformationMessage(
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      MessageInformationClass: ALPC_MESSAGE_INFORMATION_CLASS,
      MessageInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      Flags: ULONG,
      RequiredServerSid: PSID,
      ConnectionMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      OutMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      InMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtAlpcConnectPortEx(
      PortHandle: PHANDLE,
      ConnectionPortObjectAttributes: POBJECT_ATTRIBUTES,
      ClientPortObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      Flags: ULONG,
      ServerSecurityRequirements: PSECURITY_DESCRIPTOR,
      ConnectionMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      OutMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      InMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtAlpcAcceptConnectPort(
      PortHandle: PHANDLE,
      ConnectionPortHandle: HANDLE,
      Flags: ULONG,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      PortContext: PVOID,
      ConnectionRequest: PPORT_MESSAGE,
      ConnectionMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      AcceptConnection: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtAlpcSendWaitReceivePort(
      PortHandle: HANDLE,
      Flags: ULONG,
      SendMessageW: PPORT_MESSAGE,
      SendMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      ReceiveMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      ReceiveMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtAlpcCancelMessage(
      PortHandle: HANDLE,
      Flags: ULONG,
      MessageContext: PALPC_CONTEXT_ATTR,
   ) -> NTSTATUS;
   pub fn NtAlpcImpersonateClientOfPort(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      Flags: PVOID,
   ) -> NTSTATUS;
   pub fn NtAlpcImpersonateClientContainerOfPort(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn NtAlpcOpenSenderProcess(
      ProcessHandle: PHANDLE,
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtAlpcOpenSenderThread(
      ThreadHandle: PHANDLE,
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn AlpcMaxAllowedMessageLength() -> ULONG;
   pub fn AlpcGetHeaderSize(Flags: ULONG) -> ULONG;
   pub fn AlpcInitializeMessageAttribute(
      AttributeFlags: ULONG,
      Buffer: PALPC_MESSAGE_ATTRIBUTES,
      BufferSize: SIZE_T,
      RequiredBufferSize: PSIZE_T,
   ) -> NTSTATUS;
   pub fn AlpcGetMessageAttribute(Buffer: PALPC_MESSAGE_ATTRIBUTES, AttributeFlag: ULONG) -> PVOID;
   pub fn AlpcRegisterCompletionList(
      PortHandle: HANDLE,
      Buffer: PALPC_COMPLETION_LIST_HEADER,
      Size: ULONG,
      ConcurrencyCount: ULONG,
      AttributeFlags: ULONG,
   ) -> NTSTATUS;
   pub fn AlpcUnregisterCompletionList(PortHandle: HANDLE) -> NTSTATUS;
   pub fn AlpcRundownCompletionList(PortHandle: HANDLE) -> NTSTATUS;
   pub fn AlpcAdjustCompletionListConcurrencyCount(
      PortHandle: HANDLE,
      ConcurrencyCount: ULONG,
   ) -> NTSTATUS;
   pub fn AlpcRegisterCompletionListWorkerThread(CompletionList: PVOID) -> BOOLEAN;
   pub fn AlpcUnregisterCompletionListWorkerThread(CompletionList: PVOID) -> BOOLEAN;
   pub fn AlpcGetCompletionListLastMessageInformation(
      CompletionList: PVOID,
      LastMessageId: PULONG,
      LastCallbackId: PULONG,
   );
   pub fn AlpcGetOutstandingCompletionListMessageCount(CompletionList: PVOID) -> ULONG;
   pub fn AlpcGetMessageFromCompletionList(
      CompletionList: PVOID,
      MessageAttributes: *mut PALPC_MESSAGE_ATTRIBUTES,
   ) -> PPORT_MESSAGE;
   pub fn AlpcFreeCompletionListMessage(CompletionList: PVOID, Message: PPORT_MESSAGE);
   pub fn AlpcGetCompletionListMessageAttributes(
      CompletionList: PVOID,
      Message: PPORT_MESSAGE,
   ) -> PALPC_MESSAGE_ATTRIBUTES;
   pub fn NtPlugPlayControl(
      PnPControlClass: PLUGPLAY_CONTROL_CLASS,
      PnPControlData: PVOID,
      PnPControlDataLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtSerializeBoot() -> NTSTATUS;
   pub fn NtEnableLastKnownGood() -> NTSTATUS;
   pub fn NtDisableLastKnownGood() -> NTSTATUS;
   pub fn NtReplacePartitionUnit(
      TargetInstancePath: PUNICODE_STRING,
      SpareInstancePath: PUNICODE_STRING,
      Flags: ULONG,
   ) -> NTSTATUS;
   #[doc = "The NtPowerInformation routine sets or retrieves system power information.\n# Arguments\n\n* `InformationLevel` - Specifies the requested information level, which indicates the specific power information to be set or retrieved.\n* `InputBuffer` - Optional pointer to a caller-allocated input buffer.\n* `InputBufferLength` - Size, in bytes, of the buffer at InputBuffer.\n* `OutputBuffer` - Optional pointer to an output buffer. The type depends on the InformationLevel requested.\n* `OutputBufferLength` - Size, in bytes, of the output buffer.\n# Returns\n\nSuccessful or errant status."]
   pub fn NtPowerInformation(
      InformationLevel: POWER_INFORMATION_LEVEL,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   #[doc = "Enables an application to inform the system that it is in use,\nthereby preventing the system from entering sleep or turning off the display while the application is running.\n# Arguments\n\n* `NewFlags` - New execution state flags.\n* `PreviousFlags` - Pointer to receive the previous execution state flags.\n# Returns\n\nSuccessful or errant status."]
   pub fn NtSetThreadExecutionState(
      NewFlags: EXECUTION_STATE,
      PreviousFlags: *mut EXECUTION_STATE,
   ) -> NTSTATUS;
   #[doc = "Initiates a power action of the current system.\n# Arguments\n\n* `SystemAction` - The system power action.\n* `LightestSystemState` - The lightest system power state.\n* `Flags` - Flags for the power action.\n* `Asynchronous` - Whether the action is asynchronous.\n# Returns\n\nSuccessful or errant status."]
   pub fn NtInitiatePowerAction(
      SystemAction: POWER_ACTION,
      LightestSystemState: SYSTEM_POWER_STATE,
      Flags: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "Initiates a power action of the current system. Depending on the Flags parameter, the function either\nsuspends operation immediately or requests permission from all applications and device drivers before doing so.\n# Arguments\n\n* `SystemAction` - The system power action.\n* `LightestSystemState` - The lightest system power state.\n* `Flags` - Flags for the power action.\n# Returns\n\nSuccessful or errant status."]
   pub fn NtSetSystemPowerState(
      SystemAction: POWER_ACTION,
      LightestSystemState: SYSTEM_POWER_STATE,
      Flags: ULONG,
   ) -> NTSTATUS;
   #[doc = "Retrieves the current power state of the specified device. This function cannot be used to query the power state of a display device.\n# Arguments\n\n* `Device` - A handle to an object on the device, such as a file or socket, or a handle to the device itself.\n* `State` - A pointer to the variable that receives the power state.\n# Returns\n\nSuccessful or errant status.\n> An application can use NtGetDevicePowerState to determine whether a device is in the working state or a low-power state.\nIf the device is in a low-power state, accessing the device may cause it to either queue or fail any I/O requests, or transition the device into the working state.\nThe exact behavior depends on the implementation of the device."]
   pub fn NtGetDevicePowerState(Device: HANDLE, State: PDEVICE_POWER_STATE) -> NTSTATUS;
   #[doc = "Checks if the system resume is automatic.\n# Returns\n\nBOOLEAN TRUE if the system resume is automatic, FALSE otherwise."]
   pub fn NtIsSystemResumeAutomatic() -> BOOLEAN;
   #[doc = "Creates a new registry key routine or opens an existing one.\n# Arguments\n\n* `KeyHandle` [out]  - A pointer to a handle that receives the key handle.\n* `DesiredAccess` [in]  - The access mask that specifies the desired access rights.\n* `ObjectAttributes` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n* `TitleIndex` [in]  - Reserved.\n* `Class` [in, optional]  - A pointer to a UNICODE_STRING structure that specifies the class of the key.\n* `CreateOptions` [in]  - The options to use when creating the key.\n* `Disposition` [out, optional]  - A pointer to a variable that receives the disposition value.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateKey(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TitleIndex: ULONG,
      Class: PUNICODE_STRING,
      CreateOptions: ULONG,
      Disposition: PULONG,
   ) -> NTSTATUS;
   #[doc = "Creates a new registry key or opens an existing one, and it associates the key with a transaction.\n# Arguments\n\n* `KeyHandle` [out]  - A pointer to a handle that receives the key handle.\n* `DesiredAccess` [in]  - The access mask that specifies the desired access rights.\n* `ObjectAttributes` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n* `TitleIndex` [in]  - Reserved.\n* `Class` [in, optional]  - A pointer to a UNICODE_STRING structure that specifies the class of the key.\n* `CreateOptions` [in]  - The options to use when creating the key.\n* `TransactionHandle` [in]  - A handle to the transaction.\n* `Disposition` [out, optional]  - A pointer to a variable that receives the disposition value.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateKeyTransacted(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TitleIndex: ULONG,
      Class: PUNICODE_STRING,
      CreateOptions: ULONG,
      TransactionHandle: HANDLE,
      Disposition: PULONG,
   ) -> NTSTATUS;
   #[doc = "Opens an existing registry key.\n# Arguments\n\n* `KeyHandle` [out]  - A pointer to a handle that receives the key handle.\n* `DesiredAccess` [in]  - The access mask that specifies the desired access rights.\n* `ObjectAttributes` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n# Returns\n\nNTSTATUS Successful or errant status.\n> NtOpenKey ignores the security information in the ObjectAttributes structure."]
   pub fn NtOpenKey(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "Opens an existing registry key and associates the key with a transaction.\n# Arguments\n\n* `KeyHandle` [out]  - A pointer to a handle that receives the key handle.\n* `DesiredAccess` [in]  - The access mask that specifies the desired access rights.\n* `ObjectAttributes` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n* `TransactionHandle` [in]  - A handle to the transaction.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenKeyTransacted(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TransactionHandle: HANDLE,
   ) -> NTSTATUS;
   #[doc = "Opens an existing registry key with extended options.\n# Arguments\n\n* `KeyHandle` [out]  - A pointer to a handle that receives the key handle.\n* `DesiredAccess` [in]  - The access mask that specifies the desired access rights.\n* `ObjectAttributes` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n* `OpenOptions` [in]  - The options to use when opening the key.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenKeyEx(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   #[doc = "Opens an existing registry key in a transaction with extended options.\n# Arguments\n\n* `KeyHandle` [out]  - A pointer to a handle that receives the key handle.\n* `DesiredAccess` [in]  - The access mask that specifies the desired access rights.\n* `ObjectAttributes` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the object attributes.\n* `OpenOptions` [in]  - The options to use when opening the key.\n* `TransactionHandle` [in]  - A handle to the transaction.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenKeyTransactedEx(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      OpenOptions: ULONG,
      TransactionHandle: HANDLE,
   ) -> NTSTATUS;
   #[doc = "Deletes a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be deleted.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtDeleteKey(KeyHandle: HANDLE) -> NTSTATUS;
   #[doc = "Renames a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be renamed.\n* `NewName` [in]  - A pointer to a UNICODE_STRING structure that specifies the new name of the key.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtRenameKey(KeyHandle: HANDLE, NewName: PUNICODE_STRING) -> NTSTATUS;
   #[doc = "Deletes a value from a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key that contains the value to be deleted.\n* `ValueName` [in]  - A pointer to a UNICODE_STRING structure that specifies the name of the value to be deleted.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtDeleteValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING) -> NTSTATUS;
   #[doc = "Queries information about a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be queried.\n* `KeyInformationClass` [in]  - The type of information to be queried.\n* `KeyInformation` [out]  - A pointer to a buffer that receives the key information.\n* `Length` [in]  - The size of the buffer.\n* `ResultLength` [out]  - A pointer to a variable that receives the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryKey(
      KeyHandle: HANDLE,
      KeyInformationClass: KEY_INFORMATION_CLASS,
      KeyInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "Sets information for a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be modified.\n* `KeySetInformationClass` [in]  - The type of information to be set.\n* `KeySetInformation` [in]  - A pointer to a buffer that contains the key information.\n* `KeySetInformationLength` [in]  - The size of the buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetInformationKey(
      KeyHandle: HANDLE,
      KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
      KeySetInformation: PVOID,
      KeySetInformationLength: ULONG,
   ) -> NTSTATUS;
   #[doc = "Queries the value of a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be queried.\n* `ValueName` [in]  - A pointer to a UNICODE_STRING structure that specifies the name of the value to be queried.\n* `KeyValueInformationClass` [in]  - The type of information to be queried.\n* `KeyValueInformation` [out]  - A pointer to a buffer that receives the value information.\n* `Length` [in]  - The size of the buffer.\n* `ResultLength` [out]  - A pointer to a variable that receives the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryValueKey(
      KeyHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
      KeyValueInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "Sets the value of a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be modified.\n* `ValueName` [in]  - A pointer to a UNICODE_STRING structure that specifies the name of the value to be set.\n* `TitleIndex` [in, optional]  - Reserved.\n* `Type` [in]  - The type of the value.\n* `Data` [in]  - A pointer to a buffer that contains the value data.\n* `DataSize` [in]  - The size of the buffer.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSetValueKey(
      KeyHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      TitleIndex: ULONG,
      Type: ULONG,
      Data: PVOID,
      DataSize: ULONG,
   ) -> NTSTATUS;
   #[doc = "Queries multiple values of a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be queried.\n* `ValueEntries` [in, out]  - A pointer to an array of KEY_VALUE_ENTRY structures that specify the values to be queried.\n* `EntryCount` [in]  - The number of entries in the array.\n* `ValueBuffer` [out]  - A pointer to a buffer that receives the value data.\n* `BufferLength` [in, out]  - A pointer to a variable that specifies the size of the buffer and receives the size of the data returned.\n* `RequiredBufferLength` [out, optional]  - A pointer to a variable that receives the size of the buffer required to hold the data.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryMultipleValueKey(
      KeyHandle: HANDLE,
      ValueEntries: PKEY_VALUE_ENTRY,
      EntryCount: ULONG,
      ValueBuffer: PVOID,
      BufferLength: PULONG,
      RequiredBufferLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "Enumerates the subkeys of a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be enumerated.\n* `Index` [in]  - The index of the subkey to be enumerated.\n* `KeyInformationClass` [in]  - The type of information to be queried.\n* `KeyInformation` [out]  - A pointer to a buffer that receives the key information.\n* `Length` [in]  - The size of the buffer.\n* `ResultLength` [out]  - A pointer to a variable that receives the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtEnumerateKey(
      KeyHandle: HANDLE,
      Index: ULONG,
      KeyInformationClass: KEY_INFORMATION_CLASS,
      KeyInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "Enumerates the values of a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be enumerated.\n* `Index` [in]  - The index of the value to be enumerated.\n* `KeyValueInformationClass` [in]  - The type of information to be queried.\n* `KeyValueInformation` [out]  - A pointer to a buffer that receives the value information.\n* `Length` [in]  - The size of the buffer.\n* `ResultLength` [out]  - A pointer to a variable that receives the size of the data returned.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtEnumerateValueKey(
      KeyHandle: HANDLE,
      Index: ULONG,
      KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
      KeyValueInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   #[doc = "Flushes the changes to a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be flushed.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtFlushKey(KeyHandle: HANDLE) -> NTSTATUS;
   #[doc = "Compacts the specified registry keys.\n# Arguments\n\n* `Count` [in]  - The number of keys to be compacted.\n* `KeyArray` [in]  - An array of handles to the keys to be compacted.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCompactKeys(Count: ULONG, KeyArray: *mut HANDLE) -> NTSTATUS;
   #[doc = "Compresses a registry key.\n# Arguments\n\n* `KeyHandle` [in]  - A handle to the key to be compressed.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCompressKey(KeyHandle: HANDLE) -> NTSTATUS;
   #[doc = "Loads a registry key from a file.\n# Arguments\n\n* `TargetKey` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the target key.\n* `SourceFile` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the source file.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtLoadKey(TargetKey: POBJECT_ATTRIBUTES, SourceFile: POBJECT_ATTRIBUTES) -> NTSTATUS;
   #[doc = "Loads a registry key from a file with additional options.\n# Arguments\n\n* `TargetKey` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the target key.\n* `SourceFile` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the source file.\n* `Flags` [in]  - The options to use when loading the key.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtLoadKey2(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   #[doc = "Loads a registry key from a file with extended options.\n# Arguments\n\n* `TargetKey` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the target key.\n* `SourceFile` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the source file.\n* `Flags` [in]  - The options to use when loading the key.\n* `TrustClassKey` [in, optional]  - A handle to the trust class key.\n* `Event` [in, optional]  - A handle to an event.\n* `DesiredAccess` [in, optional]  - The access mask that specifies the desired access rights.\n* `RootHandle` [out, optional]  - A pointer to a handle that receives the root handle.\n* `Reserved` [in, reserved]  - Reserved.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtLoadKeyEx(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
      TrustClassKey: HANDLE,
      Event: HANDLE,
      DesiredAccess: ACCESS_MASK,
      RootHandle: PHANDLE,
      Reserved: PVOID,
   ) -> NTSTATUS;
   #[doc = "Loads a registry key from a file with extended parameters.\n# Arguments\n\n* `TargetKey` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the target key.\n* `SourceFile` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the source file.\n* `Flags` [in]  - The options to use when loading the key.\n* `ExtendedParameters` [in]  - A pointer to an array of extended parameters.\n* `ExtendedParameterCount` [in]  - The number of extended parameters.\n* `DesiredAccess` [in, optional]  - The access mask that specifies the desired access rights.\n* `RootHandle` [out, optional]  - A pointer to a handle that receives the root handle.\n* `Reserved` [in, reserved]  - Reserved.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtLoadKey3(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
      ExtendedParameters: PCM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
      DesiredAccess: ACCESS_MASK,
      RootHandle: PHANDLE,
      Reserved: PVOID,
   ) -> NTSTATUS;
   #[doc = "Replaces a registry key.\n# Arguments\n\n* `NewFile` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the new file.\n* `TargetHandle` [in]  - A handle to the target key.\n* `OldFile` [in]  - A pointer to an OBJECT_ATTRIBUTES structure that specifies the old file.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtReplaceKey(
      NewFile: POBJECT_ATTRIBUTES,
      TargetHandle: HANDLE,
      OldFile: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "Saves the specified registry key to a file.\n# Arguments\n\n* `KeyHandle` - Handle to the registry key.\n* `FileHandle` - Handle to the file where the key will be saved.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSaveKey(KeyHandle: HANDLE, FileHandle: HANDLE) -> NTSTATUS;
   #[doc = "Saves the specified registry key to a file with a specified format.\n# Arguments\n\n* `KeyHandle` - Handle to the registry key.\n* `FileHandle` - Handle to the file where the key will be saved.\n* `Format` - Format in which the key will be saved.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSaveKeyEx(KeyHandle: HANDLE, FileHandle: HANDLE, Format: ULONG) -> NTSTATUS;
   #[doc = "Merges two registry keys and saves the result to a file.\n# Arguments\n\n* `HighPrecedenceKeyHandle` - Handle to the high precedence registry key.\n* `LowPrecedenceKeyHandle` - Handle to the low precedence registry key.\n* `FileHandle` - Handle to the file where the merged key will be saved.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtSaveMergedKeys(
      HighPrecedenceKeyHandle: HANDLE,
      LowPrecedenceKeyHandle: HANDLE,
      FileHandle: HANDLE,
   ) -> NTSTATUS;
   #[doc = "Restores a registry key from a file.\n# Arguments\n\n* `KeyHandle` - Handle to the registry key.\n* `FileHandle` - Handle to the file from which the key will be restored.\n* `Flags` - Flags for the restore operation.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtRestoreKey(KeyHandle: HANDLE, FileHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   #[doc = "Unloads a registry key.\n# Arguments\n\n* `TargetKey` - Pointer to the object attributes of the target key.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtUnloadKey(TargetKey: POBJECT_ATTRIBUTES) -> NTSTATUS;
   #[doc = "Unloads a registry key with additional flags.\n# Arguments\n\n* `TargetKey` - Pointer to the object attributes of the target key.\n* `Flags` - Flags for the unload operation.\n# Returns\n\nNTSTATUS Successful or errant status.\n> Valid flags are REG_FORCE_UNLOAD and REG_UNLOAD_LEGAL_FLAGS."]
   pub fn NtUnloadKey2(TargetKey: POBJECT_ATTRIBUTES, Flags: ULONG) -> NTSTATUS;
   #[doc = "Unloads a registry key and optionally signals an event.\n# Arguments\n\n* `TargetKey` - Pointer to the object attributes of the target key.\n* `Event` - Optional handle to an event to be signaled.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtUnloadKeyEx(TargetKey: POBJECT_ATTRIBUTES, Event: HANDLE) -> NTSTATUS;
   #[doc = "Notifies of changes to a registry key.\n# Arguments\n\n* `KeyHandle` - Handle to the registry key.\n* `Event` - Optional handle to an event to be signaled.\n* `ApcRoutine` - Optional APC routine to be called.\n* `ApcContext` - Optional context for the APC routine.\n* `IoStatusBlock` - Pointer to an IO status block.\n* `CompletionFilter` - Filter for the types of changes to notify.\n* `WatchTree` - Whether to watch the entire tree.\n* `Buffer` - Optional buffer for change data.\n* `BufferSize` - Size of the buffer.\n* `Asynchronous` - Whether the operation is asynchronous.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtNotifyChangeKey(
      KeyHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      Buffer: PVOID,
      BufferSize: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "Requests notification when a registry key or any of its subkeys changes.\n# Arguments\n\n* `MasterKeyHandle` - A handle to an open key. The handle must be opened with the KEY_NOTIFY access right.\n* `Count` - The number of subkeys under the key specified by the MasterKeyHandle parameter.\n* `SubordinateObjects` - Pointer to an array of OBJECT_ATTRIBUTES structures, one for each subkey. This array can contain one OBJECT_ATTRIBUTES structure.\n* `Event` - A handle to an event created by the caller. If Event is not NULL, the caller waits until the operation succeeds, at which time the event is signaled.\n* `ApcRoutine` - A pointer to an asynchronous procedure call (APC) function supplied by the caller. If ApcRoutine is not NULL, the specified APC function executes after the operation completes.\n* `ApcContext` - A pointer to a context supplied by the caller for its APC function. This value is passed to the APC function when it is executed. The Asynchronous parameter must be TRUE. If ApcContext is specified, the Event parameter must be NULL.\n* `IoStatusBlock` - A pointer to an IO_STATUS_BLOCK structure that contains the final status and information about the operation. For successful calls that return data, the number of bytes written to the Buffer parameter is supplied in the Information member of the IO_STATUS_BLOCK structure.\n* `CompletionFilter` - A bitmap of operations that trigger notification. This parameter can be one or more of the following flags. REG_NOTIFY_CHANGE_NAME, REG_NOTIFY_CHANGE_ATTRIBUTES, REG_NOTIFY_CHANGE_LAST_SET, REG_NOTIFY_CHANGE_SECURITY.\n* `WatchTree` - If this parameter is TRUE, the caller is notified about changes to all subkeys of the specified key. If this parameter is FALSE, the caller is notified only about changes to the specified key.\n* `Buffer` - Reserved for system use. This parameter must be NULL.\n* `BufferSize` - Reserved for system use. This parameter must be zero.\n* `Asynchronous` - Whether the operation is asynchronous.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtNotifyChangeMultipleKeys(
      MasterKeyHandle: HANDLE,
      Count: ULONG,
      SubordinateObjects: *mut OBJECT_ATTRIBUTES,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      Buffer: PVOID,
      BufferSize: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "Queries the number of open subkeys of a registry key.\n# Arguments\n\n* `TargetKey` - Pointer to the object attributes of the target key.\n* `HandleCount` - Pointer to a variable to receive the handle count.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtQueryOpenSubKeys(TargetKey: POBJECT_ATTRIBUTES, HandleCount: PULONG) -> NTSTATUS;
   #[doc = "Queries the open subkeys of a registry key with additional information.\n# Arguments\n\n* `TargetKey` - Pointer to the object attributes of the target key.\n* `BufferLength` - Length of the buffer.\n* `Buffer` - Optional buffer to receive the subkey information.\n* `RequiredSize` - Pointer to a variable to receive the required size.\n# Returns\n\nNTSTATUS Successful or errant status.\n> Returns an array of KEY_OPEN_SUBKEYS_INFORMATION structures."]
   pub fn NtQueryOpenSubKeysEx(
      TargetKey: POBJECT_ATTRIBUTES,
      BufferLength: ULONG,
      Buffer: PVOID,
      RequiredSize: PULONG,
   ) -> NTSTATUS;
   #[doc = "Initializes the registry.\n# Arguments\n\n* `BootCondition` - Condition for the boot.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtInitializeRegistry(BootCondition: USHORT) -> NTSTATUS;
   #[doc = "Locks the registry key and prevents changes from being written to disk.\n# Arguments\n\n* `KeyHandle` - Handle to the registry key.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtLockRegistryKey(KeyHandle: HANDLE) -> NTSTATUS;
   #[doc = "Locks the product activation keys.\n# Arguments\n\n* `pPrivateVer` - Optional pointer to a private version variable.\n* `pSafeMode` - Optional pointer to a safe mode variable.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtLockProductActivationKeys(pPrivateVer: *mut ULONG, pSafeMode: *mut ULONG) -> NTSTATUS;
   #[doc = "Freezes the registry and prevents changes from being flushed to disk.\n# Arguments\n\n* `TimeOutInSeconds` - Timeout in seconds.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtFreezeRegistry(TimeOutInSeconds: ULONG) -> NTSTATUS;
   #[doc = "Thaws the registry and enables flushing changes to disk.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtThawRegistry() -> NTSTATUS;
   #[doc = "Creates a registry transaction.\n# Arguments\n\n* `RegistryTransactionHandle` - Pointer to a variable to receive the handle.\n* `DesiredAccess` - Desired access mask.\n* `ObjAttributes` - Optional pointer to object attributes.\n* `CreateOptions` - Reserved for future use.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCreateRegistryTransaction(
      RegistryTransactionHandle: *mut HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
   ) -> NTSTATUS;
   #[doc = "Opens a registry transaction.\n# Arguments\n\n* `RegistryTransactionHandle` - Pointer to a variable to receive the handle.\n* `DesiredAccess` - Desired access mask.\n* `ObjAttributes` - Pointer to object attributes.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtOpenRegistryTransaction(
      RegistryTransactionHandle: *mut HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   #[doc = "Commits a registry transaction.\n# Arguments\n\n* `RegistryTransactionHandle` - Handle to the registry transaction.\n* `Flags` - Reserved for future use.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtCommitRegistryTransaction(RegistryTransactionHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   #[doc = "Rolls back a registry transaction.\n# Arguments\n\n* `RegistryTransactionHandle` - Handle to the registry transaction.\n* `Flags` - Reserved for future use.\n# Returns\n\nNTSTATUS Successful or errant status."]
   pub fn NtRollbackRegistryTransaction(
      RegistryTransactionHandle: HANDLE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn InitializeListHead(ListHead: PLIST_ENTRY);
   pub fn InitializeListHead32(ListHead: PLIST_ENTRY32);
   pub fn IsListEmpty(ListHead: PLIST_ENTRY) -> BOOLEAN;
   pub fn RemoveEntryList(Entry: PLIST_ENTRY) -> BOOLEAN;
   pub fn RemoveHeadList(ListHead: PLIST_ENTRY) -> PLIST_ENTRY;
   pub fn RemoveTailList(ListHead: PLIST_ENTRY) -> PLIST_ENTRY;
   pub fn InsertTailList(ListHead: PLIST_ENTRY, Entry: PLIST_ENTRY);
   pub fn InsertHeadList(ListHead: PLIST_ENTRY, Entry: PLIST_ENTRY);
   pub fn AppendTailList(ListHead: PLIST_ENTRY, ListToAppend: PLIST_ENTRY);
   pub fn PopEntryList(ListHead: PSINGLE_LIST_ENTRY) -> PSINGLE_LIST_ENTRY;
   pub fn PushEntryList(ListHead: PSINGLE_LIST_ENTRY, Entry: PSINGLE_LIST_ENTRY);
   pub fn RtlInitializeGenericTableAvl(
      Table: PRTL_AVL_TABLE,
      CompareRoutine: PRTL_AVL_COMPARE_ROUTINE,
      AllocateRoutine: PRTL_AVL_ALLOCATE_ROUTINE,
      FreeRoutine: PRTL_AVL_FREE_ROUTINE,
      TableContext: PVOID,
   );
   pub fn RtlInsertElementGenericTableAvl(
      Table: PRTL_AVL_TABLE,
      Buffer: PVOID,
      BufferSize: CLONG,
      NewElement: PBOOLEAN,
   ) -> PVOID;
   pub fn RtlInsertElementGenericTableFullAvl(
      Table: PRTL_AVL_TABLE,
      Buffer: PVOID,
      BufferSize: CLONG,
      NewElement: PBOOLEAN,
      NodeOrParent: PVOID,
      SearchResult: TABLE_SEARCH_RESULT,
   ) -> PVOID;
   pub fn RtlDeleteElementGenericTableAvl(Table: PRTL_AVL_TABLE, Buffer: PVOID) -> BOOLEAN;
   pub fn RtlLookupElementGenericTableAvl(Table: PRTL_AVL_TABLE, Buffer: PVOID) -> PVOID;
   pub fn RtlLookupElementGenericTableFullAvl(
      Table: PRTL_AVL_TABLE,
      Buffer: PVOID,
      NodeOrParent: *mut PVOID,
      SearchResult: *mut TABLE_SEARCH_RESULT,
   ) -> PVOID;
   pub fn RtlEnumerateGenericTableAvl(Table: PRTL_AVL_TABLE, Restart: BOOLEAN) -> PVOID;
   pub fn RtlEnumerateGenericTableWithoutSplayingAvl(
      Table: PRTL_AVL_TABLE,
      RestartKey: *mut PVOID,
   ) -> PVOID;
   pub fn RtlLookupFirstMatchingElementGenericTableAvl(
      Table: PRTL_AVL_TABLE,
      Buffer: PVOID,
      RestartKey: *mut PVOID,
   ) -> PVOID;
   pub fn RtlEnumerateGenericTableLikeADirectory(
      Table: PRTL_AVL_TABLE,
      MatchFunction: PRTL_AVL_MATCH_FUNCTION,
      MatchData: PVOID,
      NextFlag: ULONG,
      RestartKey: *mut PVOID,
      DeleteCount: PULONG,
      Buffer: PVOID,
   ) -> PVOID;
   pub fn RtlGetElementGenericTableAvl(Table: PRTL_AVL_TABLE, I: ULONG) -> PVOID;
   pub fn RtlNumberGenericTableElementsAvl(Table: PRTL_AVL_TABLE) -> ULONG;
   pub fn RtlIsGenericTableEmptyAvl(Table: PRTL_AVL_TABLE) -> BOOLEAN;
   pub fn RtlSplay(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlDelete(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlDeleteNoSplay(Links: PRTL_SPLAY_LINKS, Root: *mut PRTL_SPLAY_LINKS);
   pub fn RtlSubtreeSuccessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlSubtreePredecessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlRealSuccessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlRealPredecessor(Links: PRTL_SPLAY_LINKS) -> PRTL_SPLAY_LINKS;
   pub fn RtlInitializeGenericTable(
      Table: PRTL_GENERIC_TABLE,
      CompareRoutine: PRTL_GENERIC_COMPARE_ROUTINE,
      AllocateRoutine: PRTL_GENERIC_ALLOCATE_ROUTINE,
      FreeRoutine: PRTL_GENERIC_FREE_ROUTINE,
      TableContext: PVOID,
   );
   pub fn RtlInsertElementGenericTable(
      Table: PRTL_GENERIC_TABLE,
      Buffer: PVOID,
      BufferSize: CLONG,
      NewElement: PBOOLEAN,
   ) -> PVOID;
   pub fn RtlInsertElementGenericTableFull(
      Table: PRTL_GENERIC_TABLE,
      Buffer: PVOID,
      BufferSize: CLONG,
      NewElement: PBOOLEAN,
      NodeOrParent: PVOID,
      SearchResult: TABLE_SEARCH_RESULT,
   ) -> PVOID;
   pub fn RtlDeleteElementGenericTable(Table: PRTL_GENERIC_TABLE, Buffer: PVOID) -> BOOLEAN;
   pub fn RtlLookupElementGenericTable(Table: PRTL_GENERIC_TABLE, Buffer: PVOID) -> PVOID;
   pub fn RtlLookupElementGenericTableFull(
      Table: PRTL_GENERIC_TABLE,
      Buffer: PVOID,
      NodeOrParent: *mut PVOID,
      SearchResult: *mut TABLE_SEARCH_RESULT,
   ) -> PVOID;
   pub fn RtlEnumerateGenericTable(Table: PRTL_GENERIC_TABLE, Restart: BOOLEAN) -> PVOID;
   pub fn RtlEnumerateGenericTableWithoutSplaying(
      Table: PRTL_GENERIC_TABLE,
      RestartKey: *mut PVOID,
   ) -> PVOID;
   pub fn RtlGetElementGenericTable(Table: PRTL_GENERIC_TABLE, I: ULONG) -> PVOID;
   pub fn RtlNumberGenericTableElements(Table: PRTL_GENERIC_TABLE) -> ULONG;
   pub fn RtlIsGenericTableEmpty(Table: PRTL_GENERIC_TABLE) -> BOOLEAN;
   pub fn RtlRbInsertNodeEx(
      Tree: PRTL_RB_TREE,
      Parent: PRTL_BALANCED_NODE,
      Right: BOOLEAN,
      Node: PRTL_BALANCED_NODE,
   ) -> BOOLEAN;
   pub fn RtlRbRemoveNode(Tree: PRTL_RB_TREE, Node: PRTL_BALANCED_NODE) -> BOOLEAN;
   pub fn RtlCompareExchangePointerMapping(
      Node1: PRTL_BALANCED_NODE,
      Node2: PRTL_BALANCED_NODE,
      Node3: *mut PRTL_BALANCED_NODE,
      Node4: *mut PRTL_BALANCED_NODE,
   ) -> NTSTATUS;
   pub fn RtlQueryPointerMapping(Tree: PRTL_RB_TREE, Children: PRTL_BALANCED_NODE) -> NTSTATUS;
   pub fn RtlRemovePointerMapping(Tree: PRTL_RB_TREE, Children: PRTL_BALANCED_NODE) -> NTSTATUS;
   pub fn RtlInitHashTableContext(Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT);
   pub fn RtlInitHashTableContextFromEnumerator(
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   );
   pub fn RtlReleaseHashTableContext(Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT);
   pub fn RtlTotalBucketsHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlNonEmptyBucketsHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlEmptyBucketsHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlTotalEntriesHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlActiveEnumeratorsHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> ULONG;
   pub fn RtlCreateHashTable(
      HashTable: *mut PRTL_DYNAMIC_HASH_TABLE,
      Shift: ULONG,
      Flags: ULONG,
   ) -> BOOLEAN;
   pub fn RtlCreateHashTableEx(
      HashTable: *mut PRTL_DYNAMIC_HASH_TABLE,
      InitialSize: ULONG,
      Shift: ULONG,
      Flags: ULONG,
   ) -> BOOLEAN;
   pub fn RtlDeleteHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> LOGICAL;
   pub fn RtlInsertEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Entry: PRTL_DYNAMIC_HASH_TABLE_ENTRY,
      Signature: ULONG_PTR,
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
   ) -> BOOLEAN;
   pub fn RtlRemoveEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Entry: PRTL_DYNAMIC_HASH_TABLE_ENTRY,
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
   ) -> BOOLEAN;
   pub fn RtlLookupEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Signature: ULONG_PTR,
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlGetNextEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Context: PRTL_DYNAMIC_HASH_TABLE_CONTEXT,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlInitEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> BOOLEAN;
   pub fn RtlEnumerateEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlEndEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   );
   pub fn RtlInitWeakEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> BOOLEAN;
   pub fn RtlWeaklyEnumerateEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlEndWeakEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   );
   pub fn RtlExpandHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> BOOLEAN;
   pub fn RtlContractHashTable(HashTable: PRTL_DYNAMIC_HASH_TABLE) -> BOOLEAN;
   pub fn RtlInitStrongEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> BOOLEAN;
   pub fn RtlStronglyEnumerateEntryHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   ) -> PRTL_DYNAMIC_HASH_TABLE_ENTRY;
   pub fn RtlEndStrongEnumerationHashTable(
      HashTable: PRTL_DYNAMIC_HASH_TABLE,
      Enumerator: PRTL_DYNAMIC_HASH_TABLE_ENUMERATOR,
   );
   pub fn RtlInitializeCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> NTSTATUS;
   pub fn RtlInitializeCriticalSectionAndSpinCount(
      CriticalSection: PRTL_CRITICAL_SECTION,
      SpinCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlInitializeCriticalSectionEx(
      CriticalSection: PRTL_CRITICAL_SECTION,
      SpinCount: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeleteCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> NTSTATUS;
   pub fn RtlEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> NTSTATUS;
   pub fn RtlLeaveCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> NTSTATUS;
   pub fn RtlTryEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> LOGICAL;
   pub fn RtlIsCriticalSectionLocked(CriticalSection: PRTL_CRITICAL_SECTION) -> LOGICAL;
   pub fn RtlIsCriticalSectionLockedByThread(CriticalSection: PRTL_CRITICAL_SECTION) -> LOGICAL;
   pub fn RtlGetCriticalSectionRecursionCount(CriticalSection: PRTL_CRITICAL_SECTION) -> ULONG;
   pub fn RtlSetCriticalSectionSpinCount(
      CriticalSection: PRTL_CRITICAL_SECTION,
      SpinCount: ULONG,
   ) -> ULONG;
   pub fn RtlQueryCriticalSectionOwner(EventHandle: HANDLE) -> HANDLE;
   pub fn RtlCheckForOrphanedCriticalSections(ThreadHandle: HANDLE);
   #[doc = "Enables the creation of early critical section events.\nThis function allows the system to create critical section events early in the process\ninitialization. It is typically used to ensure that critical sections are properly\ninitialized and can be used safely during the early stages of process startup.\n> This function sets the FLG_CRITSEC_EVENT_CREATION flag in the PEB flags field.\n# Returns\n\nA pointer to the Process Environment Block (PEB)."]
   pub fn RtlEnableEarlyCriticalSectionEventCreation() -> PPEB;
   pub fn RtlInitializeResource(Resource: PRTL_RESOURCE);
   pub fn RtlDeleteResource(Resource: PRTL_RESOURCE);
   pub fn RtlAcquireResourceShared(Resource: PRTL_RESOURCE, Wait: BOOLEAN) -> BOOLEAN;
   pub fn RtlAcquireResourceExclusive(Resource: PRTL_RESOURCE, Wait: BOOLEAN) -> BOOLEAN;
   pub fn RtlReleaseResource(Resource: PRTL_RESOURCE);
   pub fn RtlConvertSharedToExclusive(Resource: PRTL_RESOURCE);
   pub fn RtlConvertExclusiveToShared(Resource: PRTL_RESOURCE);
   pub fn RtlDumpResource(Resource: PRTL_RESOURCE) -> ULONG;
   pub fn RtlInitializeSRWLock(SRWLock: PRTL_SRWLOCK);
   pub fn RtlAcquireSRWLockExclusive(SRWLock: PRTL_SRWLOCK);
   pub fn RtlAcquireSRWLockShared(SRWLock: PRTL_SRWLOCK);
   pub fn RtlReleaseSRWLockExclusive(SRWLock: PRTL_SRWLOCK);
   pub fn RtlReleaseSRWLockShared(SRWLock: PRTL_SRWLOCK);
   pub fn RtlTryAcquireSRWLockExclusive(SRWLock: PRTL_SRWLOCK) -> BOOLEAN;
   pub fn RtlTryAcquireSRWLockShared(SRWLock: PRTL_SRWLOCK) -> BOOLEAN;
   pub fn RtlAcquireReleaseSRWLockExclusive(SRWLock: PRTL_SRWLOCK);
   pub fn RtlConvertSRWLockExclusiveToShared(SRWLock: PRTL_SRWLOCK) -> BOOLEAN;
   pub fn RtlRcuAllocate(Size: SIZE_T) -> PVOID;
   pub fn RtlRcuFree(Rcu: PULONG) -> LOGICAL;
   pub fn RtlRcuReadLock(SRWLock: PRTL_SRWLOCK, Rcu: PULONG);
   pub fn RtlRcuReadUnlock(SRWLock: PRTL_SRWLOCK, Rcu: *mut PULONG);
   pub fn RtlRcuSynchronize(SRWLock: PRTL_SRWLOCK) -> LONG;
   pub fn RtlInitializeConditionVariable(ConditionVariable: PRTL_CONDITION_VARIABLE);
   pub fn RtlSleepConditionVariableCS(
      ConditionVariable: PRTL_CONDITION_VARIABLE,
      CriticalSection: PRTL_CRITICAL_SECTION,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlSleepConditionVariableSRW(
      ConditionVariable: PRTL_CONDITION_VARIABLE,
      SRWLock: PRTL_SRWLOCK,
      Timeout: PLARGE_INTEGER,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlWakeConditionVariable(ConditionVariable: PRTL_CONDITION_VARIABLE);
   pub fn RtlWakeAllConditionVariable(ConditionVariable: PRTL_CONDITION_VARIABLE);
   pub fn RtlInitBarrier(Barrier: PRTL_BARRIER, TotalThreads: ULONG, SpinCount: ULONG) -> NTSTATUS;
   pub fn RtlDeleteBarrier(Barrier: PRTL_BARRIER) -> NTSTATUS;
   pub fn RtlBarrier(Barrier: PRTL_BARRIER, Flags: ULONG) -> BOOLEAN;
   pub fn RtlBarrierForDelete(Barrier: PRTL_BARRIER, Flags: ULONG) -> BOOLEAN;
   pub fn RtlWaitOnAddress(
      Address: *mut ::core::ffi::c_void,
      CompareAddress: PVOID,
      AddressSize: SIZE_T,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlWakeAddressAll(Address: PVOID);
   pub fn RtlWakeAddressAllNoFence(Address: PVOID);
   pub fn RtlWakeAddressSingle(Address: PVOID);
   pub fn RtlWakeAddressSingleNoFence(Address: PVOID);
   pub fn RtlInitEmptyAnsiString(AnsiString: PANSI_STRING, Buffer: PCHAR, MaximumLength: USHORT);
   pub fn RtlInitString(DestinationString: PSTRING, SourceString: PCSTR);
   pub fn RtlInitStringEx(DestinationString: PSTRING, SourceString: PCSZ) -> NTSTATUS;
   pub fn RtlInitAnsiString(DestinationString: PANSI_STRING, SourceString: PCSTR);
   pub fn RtlInitAnsiStringEx(DestinationString: PANSI_STRING, SourceString: PCSZ) -> NTSTATUS;
   pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
   pub fn RtlInitUTF8String(DestinationString: PUTF8_STRING, SourceString: PCSZ);
   pub fn RtlInitUTF8StringEx(DestinationString: PUTF8_STRING, SourceString: PCSZ) -> NTSTATUS;
   pub fn RtlFreeUTF8String(Utf8String: PUTF8_STRING);
   pub fn RtlFreeOemString(OemString: POEM_STRING);
   pub fn RtlCopyString(DestinationString: PSTRING, SourceString: PSTRING);
   pub fn RtlUpperChar(Character: CHAR) -> CHAR;
   pub fn RtlCompareString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> LONG;
   pub fn RtlEqualString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> BOOLEAN;
   pub fn RtlPrefixString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> BOOLEAN;
   pub fn RtlAppendStringToString(Destination: PSTRING, Source: PSTRING) -> NTSTATUS;
   pub fn RtlAppendAsciizToString(Destination: PSTRING, Source: PCSTR) -> NTSTATUS;
   pub fn RtlUpperString(DestinationString: PSTRING, SourceString: *const STRING);
   pub fn RtlIsNullOrEmptyUnicodeString(String: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlInitEmptyUnicodeString(
      DestinationString: PUNICODE_STRING,
      Buffer: PWCHAR,
      MaximumLength: USHORT,
   );
   pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCWSTR);
   pub fn RtlInitUnicodeStringEx(
      DestinationString: PUNICODE_STRING,
      SourceString: PCWSTR,
   ) -> NTSTATUS;
   pub fn RtlCreateUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PCWSTR,
   ) -> BOOLEAN;
   pub fn RtlCreateUnicodeStringFromAsciiz(
      DestinationString: PUNICODE_STRING,
      SourceString: PCSTR,
   ) -> BOOLEAN;
   pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
   pub fn RtlDuplicateUnicodeString(
      Flags: ULONG,
      StringIn: PUNICODE_STRING,
      StringOut: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlCopyUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCUNICODE_STRING);
   pub fn RtlUpcaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
   pub fn RtlDowncaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
   pub fn RtlCompareUnicodeString(
      String1: PUNICODE_STRING,
      String2: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
   ) -> LONG;
   pub fn RtlCompareUnicodeStrings(
      String1: PCWCH,
      String1Length: SIZE_T,
      String2: PCWCH,
      String2Length: SIZE_T,
      CaseInSensitive: BOOLEAN,
   ) -> LONG;
   pub fn RtlEqualUnicodeString(
      String1: PUNICODE_STRING,
      String2: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
   ) -> BOOLEAN;
   pub fn RtlHashUnicodeString(
      String: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
      HashAlgorithm: ULONG,
      HashValue: PULONG,
   ) -> NTSTATUS;
   pub fn RtlValidateUnicodeString(Flags: ULONG, String: PUNICODE_STRING) -> NTSTATUS;
   pub fn RtlPrefixUnicodeString(
      String1: PUNICODE_STRING,
      String2: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
   ) -> BOOLEAN;
   pub fn RtlFindUnicodeSubstring(
      FullString: PUNICODE_STRING,
      SearchString: PUNICODE_STRING,
      CaseInSensitive: BOOLEAN,
   ) -> PWCHAR;
   pub fn RtlFindCharInUnicodeString(
      Flags: ULONG,
      StringToSearch: PUNICODE_STRING,
      CharSet: PUNICODE_STRING,
      NonInclusivePrefixLength: PUSHORT,
   ) -> NTSTATUS;
   pub fn RtlAppendUnicodeStringToString(
      Destination: PUNICODE_STRING,
      Source: PCUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlAppendUnicodeToString(Destination: PUNICODE_STRING, Source: PCWSTR) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlDowncaseUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlEraseUnicodeString(String: PUNICODE_STRING);
   pub fn RtlAnsiStringToUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PCANSI_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlxAnsiStringToUnicodeSize(AnsiString: PCANSI_STRING) -> ULONG;
   pub fn RtlUnicodeStringToAnsiString(
      DestinationString: PANSI_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToAnsiSize(SourceString: PUNICODE_STRING) -> ULONG;
   pub fn RtlUnicodeStringToUTF8String(
      DestinationString: PUTF8_STRING,
      SourceString: PCUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUTF8StringToUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PUTF8_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAnsiCharToUnicodeChar(SourceCharacter: *mut PUCHAR) -> WCHAR;
   pub fn RtlUpcaseUnicodeStringToAnsiString(
      DestinationString: PANSI_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlOemStringToUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: POEM_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToOemString(
      DestinationString: POEM_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeStringToOemString(
      DestinationString: POEM_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlOemStringToCountedUnicodeString(
      DestinationString: PUNICODE_STRING,
      SourceString: PCOEM_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToCountedOemString(
      DestinationString: POEM_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeStringToCountedOemString(
      DestinationString: POEM_STRING,
      SourceString: PUNICODE_STRING,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlMultiByteToUnicodeN(
      UnicodeString: PWCH,
      MaxBytesInUnicodeString: ULONG,
      BytesInUnicodeString: PULONG,
      MultiByteString: PCSTR,
      BytesInMultiByteString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlMultiByteToUnicodeSize(
      BytesInUnicodeString: PULONG,
      MultiByteString: PCSTR,
      BytesInMultiByteString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToMultiByteN(
      MultiByteString: PCHAR,
      MaxBytesInMultiByteString: ULONG,
      BytesInMultiByteString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToMultiByteSize(
      BytesInMultiByteString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeToMultiByteN(
      MultiByteString: PCHAR,
      MaxBytesInMultiByteString: ULONG,
      BytesInMultiByteString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlOemToUnicodeN(
      UnicodeString: PWSTR,
      MaxBytesInUnicodeString: ULONG,
      BytesInUnicodeString: PULONG,
      OemString: PCCH,
      BytesInOemString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToOemN(
      OemString: PCHAR,
      MaxBytesInOemString: ULONG,
      BytesInOemString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeToOemN(
      OemString: PCHAR,
      MaxBytesInOemString: ULONG,
      BytesInOemString: PULONG,
      UnicodeString: PCWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlConsoleMultiByteToUnicodeN(
      UnicodeString: PWCH,
      MaxBytesInUnicodeString: ULONG,
      BytesInUnicodeString: PULONG,
      MultiByteString: PCCH,
      BytesInMultiByteString: ULONG,
      pdwSpecialChar: PULONG,
   ) -> NTSTATUS;
   pub fn RtlUTF8ToUnicodeN(
      UnicodeStringDestination: PWSTR,
      UnicodeStringMaxByteCount: ULONG,
      UnicodeStringActualByteCount: PULONG,
      UTF8StringSource: PCCH,
      UTF8StringByteCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToUTF8N(
      UTF8StringDestination: PCHAR,
      UTF8StringMaxByteCount: ULONG,
      UTF8StringActualByteCount: PULONG,
      UnicodeStringSource: PCWCH,
      UnicodeStringByteCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlCustomCPToUnicodeN(
      CustomCP: PCPTABLEINFO,
      UnicodeString: PWCH,
      MaxBytesInUnicodeString: ULONG,
      BytesInUnicodeString: PULONG,
      CustomCPString: PCH,
      BytesInCustomCPString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnicodeToCustomCPN(
      CustomCP: PCPTABLEINFO,
      CustomCPString: PCH,
      MaxBytesInCustomCPString: ULONG,
      BytesInCustomCPString: PULONG,
      UnicodeString: PWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUpcaseUnicodeToCustomCPN(
      CustomCP: PCPTABLEINFO,
      CustomCPString: PCH,
      MaxBytesInCustomCPString: ULONG,
      BytesInCustomCPString: PULONG,
      UnicodeString: PWCH,
      BytesInUnicodeString: ULONG,
   ) -> NTSTATUS;
   pub fn RtlInitCodePageTable(TableBase: PUSHORT, CodePageTable: PCPTABLEINFO);
   pub fn RtlInitNlsTables(
      AnsiNlsBase: PUSHORT,
      OemNlsBase: PUSHORT,
      LanguageNlsBase: PUSHORT,
      TableInfo: PNLSTABLEINFO,
   );
   pub fn RtlResetRtlTranslations(TableInfo: PNLSTABLEINFO);
   pub fn RtlIsTextUnicode(Buffer: PVOID, Size: ULONG, Result: PULONG) -> BOOLEAN;
   pub fn RtlNormalizeString(
      NormForm: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      DestinationString: PWSTR,
      DestinationStringLength: PLONG,
   ) -> NTSTATUS;
   pub fn RtlIsNormalizedString(
      NormForm: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      Normalized: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlIsNameInExpression(
      Expression: PUNICODE_STRING,
      Name: PUNICODE_STRING,
      IgnoreCase: BOOLEAN,
      UpcaseTable: PWCH,
   ) -> BOOLEAN;
   pub fn RtlIsNameInUnUpcasedExpression(
      Expression: PUNICODE_STRING,
      Name: PUNICODE_STRING,
      IgnoreCase: BOOLEAN,
      UpcaseTable: PWCH,
   ) -> BOOLEAN;
   pub fn RtlDoesNameContainWildCards(Expression: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlEqualDomainName(String1: PUNICODE_STRING, String2: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlEqualComputerName(String1: PUNICODE_STRING, String2: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlDnsHostNameToComputerName(
      ComputerNameString: PUNICODE_STRING,
      DnsHostNameString: PUNICODE_STRING,
      AllocateComputerNameString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlStringFromGUID(Guid: PGUID, GuidString: PUNICODE_STRING) -> NTSTATUS;
   pub fn RtlStringFromGUIDEx(
      Guid: PGUID,
      GuidString: PUNICODE_STRING,
      AllocateGuidString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGUIDFromString(GuidString: PUNICODE_STRING, Guid: PGUID) -> NTSTATUS;
   pub fn RtlCompareAltitudes(Altitude1: PUNICODE_STRING, Altitude2: PUNICODE_STRING) -> LONG;
   pub fn RtlIdnToAscii(
      Flags: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      DestinationString: PWSTR,
      DestinationStringLength: PLONG,
   ) -> NTSTATUS;
   pub fn RtlIdnToUnicode(
      Flags: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      DestinationString: PWSTR,
      DestinationStringLength: PLONG,
   ) -> NTSTATUS;
   pub fn RtlIdnToNameprepUnicode(
      Flags: ULONG,
      SourceString: PCWSTR,
      SourceStringLength: LONG,
      DestinationString: PWSTR,
      DestinationStringLength: PLONG,
   ) -> NTSTATUS;
   pub fn PfxInitialize(PrefixTable: PPREFIX_TABLE);
   pub fn PfxInsertPrefix(
      PrefixTable: PPREFIX_TABLE,
      Prefix: PSTRING,
      PrefixTableEntry: PPREFIX_TABLE_ENTRY,
   ) -> BOOLEAN;
   pub fn PfxRemovePrefix(PrefixTable: PPREFIX_TABLE, PrefixTableEntry: PPREFIX_TABLE_ENTRY);
   pub fn PfxFindPrefix(PrefixTable: PPREFIX_TABLE, FullName: PSTRING) -> PPREFIX_TABLE_ENTRY;
   pub fn RtlInitializeUnicodePrefix(PrefixTable: PUNICODE_PREFIX_TABLE);
   pub fn RtlInsertUnicodePrefix(
      PrefixTable: PUNICODE_PREFIX_TABLE,
      Prefix: PUNICODE_STRING,
      PrefixTableEntry: PUNICODE_PREFIX_TABLE_ENTRY,
   ) -> BOOLEAN;
   pub fn RtlRemoveUnicodePrefix(
      PrefixTable: PUNICODE_PREFIX_TABLE,
      PrefixTableEntry: PUNICODE_PREFIX_TABLE_ENTRY,
   );
   pub fn RtlFindUnicodePrefix(
      PrefixTable: PUNICODE_PREFIX_TABLE,
      FullName: PUNICODE_STRING,
      CaseInsensitiveIndex: ULONG,
   ) -> PUNICODE_PREFIX_TABLE_ENTRY;
   pub fn RtlNextUnicodePrefix(
      PrefixTable: PUNICODE_PREFIX_TABLE,
      Restart: BOOLEAN,
   ) -> PUNICODE_PREFIX_TABLE_ENTRY;
   pub fn RtlGetCompressionWorkSpaceSize(
      CompressionFormatAndEngine: USHORT,
      CompressBufferWorkSpaceSize: PULONG,
      CompressFragmentWorkSpaceSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlCompressBuffer(
      CompressionFormatAndEngine: USHORT,
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      UncompressedChunkSize: ULONG,
      FinalCompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecompressBuffer(
      CompressionFormat: USHORT,
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      FinalUncompressedSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlDecompressBufferEx(
      CompressionFormat: USHORT,
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      FinalUncompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecompressBufferEx2(
      CompressionFormat: USHORT,
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      UncompressedChunkSize: ULONG,
      FinalUncompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecompressFragment(
      CompressionFormat: USHORT,
      UncompressedFragment: PUCHAR,
      UncompressedFragmentSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      FragmentOffset: ULONG,
      FinalUncompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecompressFragmentEx(
      CompressionFormat: USHORT,
      UncompressedFragment: PUCHAR,
      UncompressedFragmentSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      FragmentOffset: ULONG,
      UncompressedChunkSize: ULONG,
      FinalUncompressedSize: PULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlDescribeChunk(
      CompressionFormat: USHORT,
      CompressedBuffer: *mut PUCHAR,
      EndOfCompressedBufferPlus1: PUCHAR,
      ChunkBuffer: *mut PUCHAR,
      ChunkSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlReserveChunk(
      CompressionFormat: USHORT,
      CompressedBuffer: *mut PUCHAR,
      EndOfCompressedBufferPlus1: PUCHAR,
      ChunkBuffer: *mut PUCHAR,
      ChunkSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDecompressChunks(
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      CompressedTail: PUCHAR,
      CompressedTailSize: ULONG,
      CompressedDataInfo: PCOMPRESSED_DATA_INFO,
   ) -> NTSTATUS;
   pub fn RtlCompressChunks(
      UncompressedBuffer: PUCHAR,
      UncompressedBufferSize: ULONG,
      CompressedBuffer: PUCHAR,
      CompressedBufferSize: ULONG,
      CompressedDataInfo: PCOMPRESSED_DATA_INFO,
      CompressedDataInfoLength: ULONG,
      WorkSpace: PVOID,
   ) -> NTSTATUS;
   pub fn RtlConvertLCIDToString(
      LcidValue: LCID,
      Base: ULONG,
      Padding: ULONG,
      pResultBuf: PWSTR,
      Size: ULONG,
   ) -> NTSTATUS;
   pub fn RtlIsValidLocaleName(LocaleName: PCWSTR, Flags: ULONG) -> BOOLEAN;
   pub fn RtlGetParentLocaleName(
      LocaleName: PCWSTR,
      ParentLocaleName: PUNICODE_STRING,
      Flags: ULONG,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlLcidToLocaleName(
      lcid: LCID,
      LocaleName: PUNICODE_STRING,
      Flags: ULONG,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlLocaleNameToLcid(LocaleName: PCWSTR, lcid: PLCID, Flags: ULONG) -> NTSTATUS;
   pub fn RtlLCIDToCultureName(Lcid: LCID, String: PUNICODE_STRING) -> BOOLEAN;
   pub fn RtlCultureNameToLCID(String: PUNICODE_STRING, Lcid: PLCID) -> BOOLEAN;
   pub fn RtlCleanUpTEBLangLists();
   pub fn RtlGetThreadPreferredUILanguages(
      Flags: ULONG,
      NumberOfLanguages: PULONG,
      Languages: PZZWSTR,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetProcessPreferredUILanguages(
      Flags: ULONG,
      NumberOfLanguages: PULONG,
      Languages: PZZWSTR,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetSystemPreferredUILanguages(
      Flags: ULONG,
      LocaleName: PCWSTR,
      NumberOfLanguages: PULONG,
      Languages: PZZWSTR,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlpGetSystemDefaultUILanguage(DefaultUILanguageId: LANGID, Lcid: PLCID) -> NTSTATUS;
   pub fn RtlGetUserPreferredUILanguages(
      Flags: ULONG,
      LocaleName: PCWSTR,
      NumberOfLanguages: PULONG,
      Languages: PZZWSTR,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetUILanguageInfo(
      Flags: ULONG,
      Languages: PCZZWSTR,
      FallbackLanguages: PZZWSTR,
      NumberOfFallbackLanguages: PULONG,
      Attributes: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetLocaleFileMappingAddress(
      BaseAddress: *mut PVOID,
      DefaultLocaleId: PLCID,
      DefaultCasingTableSize: PLARGE_INTEGER,
      CurrentNLSVersion: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetCurrentPeb() -> PPEB;
   pub fn RtlAcquirePebLock() -> NTSTATUS;
   pub fn RtlReleasePebLock() -> NTSTATUS;
   pub fn RtlTryAcquirePebLock() -> LOGICAL;
   pub fn RtlCreateProcessParameters(
      pProcessParameters: *mut PRTL_USER_PROCESS_PARAMETERS,
      ImagePathName: PUNICODE_STRING,
      DllPath: PUNICODE_STRING,
      CurrentDirectory: PUNICODE_STRING,
      CommandLine: PUNICODE_STRING,
      Environment: PVOID,
      WindowTitle: PUNICODE_STRING,
      DesktopInfo: PUNICODE_STRING,
      ShellInfo: PUNICODE_STRING,
      RuntimeData: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlCreateProcessParametersEx(
      pProcessParameters: *mut PRTL_USER_PROCESS_PARAMETERS,
      ImagePathName: PUNICODE_STRING,
      DllPath: PUNICODE_STRING,
      CurrentDirectory: PUNICODE_STRING,
      CommandLine: PUNICODE_STRING,
      Environment: PVOID,
      WindowTitle: PUNICODE_STRING,
      DesktopInfo: PUNICODE_STRING,
      ShellInfo: PUNICODE_STRING,
      RuntimeData: PUNICODE_STRING,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlCreateProcessParametersWithTemplate(
      pProcessParameters: *mut PRTL_USER_PROCESS_PARAMETERS,
      ImagePathName: PUNICODE_STRING,
      DllPath: PUNICODE_STRING,
      CurrentDirectory: PUNICODE_STRING,
      CommandLine: PUNICODE_STRING,
      Environment: PVOID,
      WindowTitle: PUNICODE_STRING,
      DesktopInfo: PUNICODE_STRING,
      ShellInfo: PUNICODE_STRING,
      RuntimeData: PUNICODE_STRING,
      RedirectionDllName: PUNICODE_STRING,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDestroyProcessParameters(ProcessParameters: PRTL_USER_PROCESS_PARAMETERS) -> NTSTATUS;
   pub fn RtlNormalizeProcessParams(
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
   ) -> PRTL_USER_PROCESS_PARAMETERS;
   pub fn RtlDeNormalizeProcessParams(
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
   ) -> PRTL_USER_PROCESS_PARAMETERS;
   pub fn RtlCreateUserProcess(
      NtImagePathName: PUNICODE_STRING,
      ExtendedParameters: ULONG,
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
      ProcessSecurityDescriptor: PSECURITY_DESCRIPTOR,
      ThreadSecurityDescriptor: PSECURITY_DESCRIPTOR,
      ParentProcess: HANDLE,
      InheritHandles: BOOLEAN,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
      ProcessInformation: PRTL_USER_PROCESS_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlCreateUserProcessEx(
      NtImagePathName: PUNICODE_STRING,
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
      InheritHandles: BOOLEAN,
      ProcessExtendedParameters: PRTL_USER_PROCESS_EXTENDED_PARAMETERS,
      ProcessInformation: PRTL_USER_PROCESS_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlExitUserProcess(ExitStatus: NTSTATUS) -> !;
   pub fn RtlCloneUserProcess(
      ProcessFlags: ULONG,
      ProcessSecurityDescriptor: PSECURITY_DESCRIPTOR,
      ThreadSecurityDescriptor: PSECURITY_DESCRIPTOR,
      DebugPort: HANDLE,
      ProcessInformation: PRTL_USER_PROCESS_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlPrepareForProcessCloning() -> NTSTATUS;
   pub fn RtlCompleteProcessCloning(Completed: LOGICAL) -> NTSTATUS;
   pub fn RtlUpdateClonedCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
   pub fn RtlUpdateClonedSRWLock(SRWLock: PRTL_SRWLOCK, Shared: LOGICAL);
   pub fn RtlCreateProcessReflection(
      ProcessHandle: HANDLE,
      Flags: ULONG,
      StartRoutine: PVOID,
      StartContext: PVOID,
      EventHandle: HANDLE,
      ReflectionInformation: PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlSetProcessIsCritical(
      NewValue: BOOLEAN,
      OldValue: PBOOLEAN,
      CheckFlag: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSetThreadIsCritical(
      NewValue: BOOLEAN,
      OldValue: PBOOLEAN,
      CheckFlag: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSetThreadSubProcessTag(SubProcessTag: PVOID) -> PVOID;
   pub fn RtlValidProcessProtection(ProcessProtection: PS_PROTECTION) -> BOOLEAN;
   pub fn RtlTestProtectedAccess(Source: PS_PROTECTION, Target: PS_PROTECTION) -> BOOLEAN;
   pub fn RtlIsCurrentProcess(ProcessHandle: HANDLE) -> BOOLEAN;
   pub fn RtlIsCurrentThread(ThreadHandle: HANDLE) -> BOOLEAN;
   pub fn RtlCreateUserThread(
      ProcessHandle: HANDLE,
      ThreadSecurityDescriptor: PSECURITY_DESCRIPTOR,
      CreateSuspended: BOOLEAN,
      ZeroBits: ULONG,
      MaximumStackSize: SIZE_T,
      CommittedStackSize: SIZE_T,
      StartAddress: PUSER_THREAD_START_ROUTINE,
      Parameter: PVOID,
      ThreadHandle: PHANDLE,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   pub fn RtlExitUserThread(ExitStatus: NTSTATUS) -> !;
   pub fn RtlIsCurrentThreadAttachExempt() -> BOOLEAN;
   pub fn RtlCreateUserStack(
      CommittedStackSize: SIZE_T,
      MaximumStackSize: SIZE_T,
      ZeroBits: ULONG_PTR,
      PageSize: SIZE_T,
      ReserveAlignment: ULONG_PTR,
      InitialTeb: PINITIAL_TEB,
   ) -> NTSTATUS;
   pub fn RtlFreeUserStack(AllocationBase: PVOID) -> NTSTATUS;
   pub fn RtlInitializeContext(
      ProcessHandle: HANDLE,
      Context: PCONTEXT,
      Parameter: PVOID,
      InitialPc: PVOID,
      InitialSp: PVOID,
   ) -> NTSTATUS;
   pub fn RtlInitializeExtendedContext(
      Context: PCONTEXT,
      ContextFlags: ULONG,
      ContextEx: *mut PCONTEXT_EX,
   ) -> NTSTATUS;
   pub fn RtlInitializeExtendedContext2(
      Context: PCONTEXT,
      ContextFlags: ULONG,
      ContextEx: *mut PCONTEXT_EX,
      EnabledExtendedFeatures: ULONG64,
   ) -> NTSTATUS;
   pub fn RtlCopyContext(Context: PCONTEXT, ContextFlags: ULONG, Source: PCONTEXT) -> NTSTATUS;
   pub fn RtlCopyExtendedContext(
      Destination: PCONTEXT_EX,
      ContextFlags: ULONG,
      Source: PCONTEXT_EX,
   ) -> NTSTATUS;
   pub fn RtlGetExtendedContextLength(ContextFlags: ULONG, ContextLength: PULONG) -> NTSTATUS;
   pub fn RtlGetExtendedContextLength2(
      ContextFlags: ULONG,
      ContextLength: PULONG,
      EnabledExtendedFeatures: ULONG64,
   ) -> NTSTATUS;
   pub fn RtlGetExtendedFeaturesMask(ContextEx: PCONTEXT_EX) -> ULONG64;
   pub fn RtlLocateExtendedFeature(
      ContextEx: PCONTEXT_EX,
      FeatureId: ULONG,
      Length: PULONG,
   ) -> PVOID;
   pub fn RtlLocateLegacyContext(ContextEx: PCONTEXT_EX, Length: PULONG) -> PCONTEXT;
   pub fn RtlSetExtendedFeaturesMask(ContextEx: PCONTEXT_EX, FeatureMask: ULONG64);
   pub fn RtlWow64GetThreadContext(ThreadHandle: HANDLE, ThreadContext: PWOW64_CONTEXT)
      -> NTSTATUS;
   pub fn RtlWow64SetThreadContext(ThreadHandle: HANDLE, ThreadContext: PWOW64_CONTEXT)
      -> NTSTATUS;
   pub fn RtlRemoteCall(
      ProcessHandle: HANDLE,
      ThreadHandle: HANDLE,
      CallSite: PVOID,
      ArgumentCount: ULONG,
      Arguments: PULONG_PTR,
      PassContext: BOOLEAN,
      AlreadySuspended: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "Registers a vectored exception handler.\n# Arguments\n\n* `First` - If this parameter is TRUE, the handler is the first handler in the list.\n* `Handler` - A pointer to the vectored exception handler to be called.\n# Returns\n\nA handle to the vectored exception handler.\n# See also\n\n> [https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler)"]
   pub fn RtlAddVectoredExceptionHandler(
      First: ULONG,
      Handler: PVECTORED_EXCEPTION_HANDLER,
   ) -> PVOID;
   #[doc = "Removes a vectored exception handler.\n# Arguments\n\n* `Handle` - A handle to the vectored exception handler to remove.\n# Returns\n\nThe function returns 0 if the handler is removed, or -1 if the handler is not found.\n# See also\n\n> [https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-removevectoredexceptionhandler](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-removevectoredexceptionhandler)"]
   pub fn RtlRemoveVectoredExceptionHandler(Handle: PVOID) -> ULONG;
   #[doc = "Registers a vectored continue handler.\n# Arguments\n\n* `First` - If this parameter is TRUE, the handler is the first handler in the list.\n* `Handler` - A pointer to the vectored exception handler to be called.\n# Returns\n\nA handle to the vectored continue handler.\n# See also\n\n> [https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredcontinuehandler](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredcontinuehandler)"]
   pub fn RtlAddVectoredContinueHandler(
      First: ULONG,
      Handler: PVECTORED_EXCEPTION_HANDLER,
   ) -> PVOID;
   #[doc = "Removes a vectored continue handler.\n# Arguments\n\n* `Handle` - A handle to the vectored continue handler to remove.\n# Returns\n\nThe function returns 0 if the handler is removed, or -1 if the handler is not found.\n# See also\n\n> [https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-removevectoredcontinuehandler](https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-removevectoredcontinuehandler)"]
   pub fn RtlRemoveVectoredContinueHandler(Handle: PVOID) -> ULONG;
   pub fn RtlSetUnhandledExceptionFilter(
      UnhandledExceptionFilter: PRTLP_UNHANDLED_EXCEPTION_FILTER,
   );
   pub fn RtlUnhandledExceptionFilter(ExceptionPointers: PEXCEPTION_POINTERS) -> LONG;
   pub fn RtlUnhandledExceptionFilter2(
      ExceptionPointers: PEXCEPTION_POINTERS,
      Flags: ULONG,
   ) -> LONG;
   pub fn RtlKnownExceptionFilter(ExceptionPointers: PEXCEPTION_POINTERS) -> LONG;
   pub fn RtlGetFunctionTableListHead() -> PLIST_ENTRY;
   pub fn RtlInitializeSListHead(ListHead: PSLIST_HEADER);
   pub fn RtlFirstEntrySList(ListHead: *const SLIST_HEADER) -> PSLIST_ENTRY;
   pub fn RtlInterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
   pub fn RtlInterlockedPushEntrySList(
      ListHead: PSLIST_HEADER,
      ListEntry: PSLIST_ENTRY,
   ) -> PSLIST_ENTRY;
   pub fn RtlInterlockedPushListSListEx(
      ListHead: PSLIST_HEADER,
      List: PSLIST_ENTRY,
      ListEnd: PSLIST_ENTRY,
      Count: DWORD,
   ) -> PSLIST_ENTRY;
   pub fn RtlInterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
   pub fn RtlQueryDepthSList(ListHead: PSLIST_HEADER) -> WORD;
   pub fn RtlGetActiveActivationContext(ActivationContext: PACTIVATION_CONTEXT) -> NTSTATUS;
   pub fn RtlAddRefActivationContext(ActivationContext: PACTIVATION_CONTEXT);
   pub fn RtlReleaseActivationContext(ActivationContext: PACTIVATION_CONTEXT);
   pub fn RtlZombifyActivationContext(ActivationContext: PACTIVATION_CONTEXT) -> NTSTATUS;
   pub fn RtlIsActivationContextActive(ActivationContext: PACTIVATION_CONTEXT) -> BOOLEAN;
   pub fn RtlActivateActivationContext(
      Flags: ULONG,
      ActivationContext: PACTIVATION_CONTEXT,
      Cookie: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn RtlActivateActivationContextEx(
      Flags: ULONG,
      Teb: PTEB,
      ActivationContext: PACTIVATION_CONTEXT,
      Cookie: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn RtlDeactivateActivationContext(Flags: ULONG, Cookie: ULONG_PTR);
   pub fn RtlCreateActivationContext(
      Flags: ULONG,
      ActivationContextData: PACTIVATION_CONTEXT_DATA,
      ExtraBytes: ULONG,
      NotificationRoutine: PACTIVATION_CONTEXT_NOTIFY_ROUTINE,
      NotificationContext: PVOID,
      ActivationContext: *mut PACTIVATION_CONTEXT,
   ) -> NTSTATUS;
   pub fn RtlFindActivationContextSectionString(
      Flags: ULONG,
      ExtensionGuid: PGUID,
      SectionId: ULONG,
      StringToFind: PUNICODE_STRING,
      ReturnedData: PACTCTX_SECTION_KEYED_DATA,
   ) -> NTSTATUS;
   pub fn RtlFindActivationContextSectionGuid(
      Flags: ULONG,
      ExtensionGuid: PGUID,
      SectionId: ULONG,
      GuidToFind: PGUID,
      ReturnedData: PACTCTX_SECTION_KEYED_DATA,
   ) -> NTSTATUS;
   pub fn RtlQueryActivationContextApplicationSettings(
      Flags: ULONG,
      ActivationContext: PACTIVATION_CONTEXT,
      SettingsNameSpace: PCWSTR,
      SettingName: PCWSTR,
      Buffer: PWSTR,
      BufferLength: SIZE_T,
      RequiredLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlQueryInformationActivationContext(
      Flags: ULONG,
      ActivationContext: PACTIVATION_CONTEXT,
      SubInstanceIndex: PACTIVATION_CONTEXT_QUERY_INDEX,
      ActivationContextInformationClass: ACTIVATION_CONTEXT_INFO_CLASS,
      ActivationContextInformation: PVOID,
      ActivationContextInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlQueryInformationActiveActivationContext(
      ActivationContextInformationClass: ACTIVATION_CONTEXT_INFO_CLASS,
      ActivationContextInformation: PVOID,
      ActivationContextInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlImageNtHeader(BaseOfImage: PVOID) -> PIMAGE_NT_HEADERS;
   pub fn RtlImageNtHeaderEx(
      Flags: ULONG,
      BaseOfImage: PVOID,
      Size: ULONG64,
      OutHeaders: *mut PIMAGE_NT_HEADERS,
   ) -> NTSTATUS;
   pub fn RtlAddressInSectionTable(
      NtHeaders: PIMAGE_NT_HEADERS,
      BaseOfImage: PVOID,
      VirtualAddress: ULONG,
   ) -> PVOID;
   pub fn RtlSectionTableFromVirtualAddress(
      NtHeaders: PIMAGE_NT_HEADERS,
      BaseOfImage: PVOID,
      VirtualAddress: ULONG,
   ) -> PIMAGE_SECTION_HEADER;
   pub fn RtlImageDirectoryEntryToData(
      BaseOfImage: PVOID,
      MappedAsImage: BOOLEAN,
      DirectoryEntry: USHORT,
      Size: PULONG,
   ) -> PVOID;
   pub fn RtlImageRvaToSection(
      NtHeaders: PIMAGE_NT_HEADERS,
      BaseOfImage: PVOID,
      Rva: ULONG,
   ) -> PIMAGE_SECTION_HEADER;
   pub fn RtlImageRvaToVa(
      NtHeaders: PIMAGE_NT_HEADERS,
      BaseOfImage: PVOID,
      Rva: ULONG,
      LastRvaSection: *mut PIMAGE_SECTION_HEADER,
   ) -> PVOID;
   pub fn RtlFindExportedRoutineByName(BaseOfImage: PVOID, RoutineName: PCSTR) -> PVOID;
   pub fn RtlGuardCheckLongJumpTarget(
      PcValue: PVOID,
      IsFastFail: BOOL,
      IsLongJumpTarget: PBOOL,
   ) -> NTSTATUS;
   pub fn RtlValidateUserCallTarget(Address: PVOID, Flags: PULONG);
   pub fn RtlCompareMemory(
      Source1: *const ::core::ffi::c_void,
      Source2: *const ::core::ffi::c_void,
      Length: SIZE_T,
   ) -> SIZE_T;
   pub fn RtlCompareMemoryUlong(Source: PVOID, Length: SIZE_T, Pattern: ULONG) -> SIZE_T;
   pub fn RtlFillMemoryUlong(Destination: PVOID, Length: SIZE_T, Pattern: ULONG);
   pub fn RtlFillMemoryUlonglong(Destination: PVOID, Length: SIZE_T, Pattern: ULONGLONG);
   pub fn RtlIsZeroMemory(Buffer: PVOID, Length: SIZE_T) -> BOOLEAN;
   pub fn RtlCrc32(Buffer: *const ::core::ffi::c_void, Size: usize, InitialCrc: DWORD) -> DWORD;
   pub fn RtlCrc64(
      Buffer: *const ::core::ffi::c_void,
      Size: usize,
      InitialCrc: ULONGLONG,
   ) -> ULONGLONG;
   pub fn RtlGetSystemGlobalData(
      DataId: RTL_SYSTEM_GLOBAL_DATA_ID,
      Buffer: PVOID,
      Size: DWORD,
   ) -> DWORD;
   pub fn RtlSetSystemGlobalData(
      DataId: RTL_SYSTEM_GLOBAL_DATA_ID,
      Buffer: PVOID,
      Size: DWORD,
   ) -> DWORD;
   pub fn RtlCreateEnvironment(
      CloneCurrentEnvironment: BOOLEAN,
      Environment: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlCreateEnvironmentEx(
      SourceEnvironment: PVOID,
      Environment: *mut PVOID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDestroyEnvironment(Environment: PVOID) -> NTSTATUS;
   pub fn RtlSetCurrentEnvironment(Environment: PVOID, PreviousEnvironment: *mut PVOID)
      -> NTSTATUS;
   pub fn RtlSetEnvironmentVar(
      Environment: *mut PVOID,
      Name: PCWSTR,
      NameLength: SIZE_T,
      Value: PCWSTR,
      ValueLength: SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlSetEnvironmentVariable(
      Environment: *mut PVOID,
      Name: PUNICODE_STRING,
      Value: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlQueryEnvironmentVariable(
      Environment: PVOID,
      Name: PCWSTR,
      NameLength: SIZE_T,
      Value: PWSTR,
      ValueLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlQueryEnvironmentVariable_U(
      Environment: PVOID,
      Name: PUNICODE_STRING,
      Value: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlExpandEnvironmentStrings(
      Environment: PVOID,
      Source: PCWSTR,
      SourceLength: SIZE_T,
      Destination: PWSTR,
      DestinationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlExpandEnvironmentStrings_U(
      Environment: PVOID,
      Source: PUNICODE_STRING,
      Destination: PUNICODE_STRING,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSetEnvironmentStrings(NewEnvironment: PCWSTR, NewEnvironmentSize: SIZE_T) -> NTSTATUS;
   pub static mut RtlDosPathSeperatorsString: UNICODE_STRING;
   pub static mut RtlAlternateDosPathSeperatorString: UNICODE_STRING;
   pub static mut RtlNtPathSeperatorString: UNICODE_STRING;
   pub fn RtlDetermineDosPathNameType_U(DosFileName: PCWSTR) -> RTL_PATH_TYPE;
   pub fn RtlIsDosDeviceName_U(DosFileName: PCWSTR) -> ULONG;
   pub fn RtlGetFullPathName_U(
      FileName: PCWSTR,
      BufferLength: ULONG,
      Buffer: PWSTR,
      FilePart: *mut PWSTR,
   ) -> ULONG;
   pub fn RtlGetFullPathName_UEx(
      FileName: PCWSTR,
      BufferLength: ULONG,
      Buffer: PWSTR,
      FilePart: *mut PWSTR,
      BytesRequired: *mut ULONG,
   ) -> NTSTATUS;
   pub fn RtlGetFullPathName_UstrEx(
      FileName: PUNICODE_STRING,
      StaticString: PUNICODE_STRING,
      DynamicString: PUNICODE_STRING,
      StringUsed: *mut PUNICODE_STRING,
      FilePartPrefixCch: *mut SIZE_T,
      NameInvalid: PBOOLEAN,
      InputPathType: *mut RTL_PATH_TYPE,
      BytesRequired: *mut SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlGetCurrentDirectory_U(BufferLength: ULONG, Buffer: PWSTR) -> ULONG;
   pub fn RtlSetCurrentDirectory_U(PathName: PUNICODE_STRING) -> NTSTATUS;
   pub fn RtlGetLongestNtPathLength() -> ULONG;
   pub fn RtlNtPathNameToDosPathName(
      Flags: ULONG,
      Path: PRTL_UNICODE_STRING_BUFFER,
      Disposition: PULONG,
      FilePart: *mut PWSTR,
   ) -> NTSTATUS;
   pub fn RtlDosPathNameToNtPathName_U(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> BOOLEAN;
   pub fn RtlDosPathNameToNtPathName_U_WithStatus(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> NTSTATUS;
   pub fn RtlDosLongPathNameToNtPathName_U_WithStatus(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> NTSTATUS;
   pub fn RtlDosPathNameToRelativeNtPathName_U(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> BOOLEAN;
   pub fn RtlDosPathNameToRelativeNtPathName_U_WithStatus(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> NTSTATUS;
   pub fn RtlDosLongPathNameToRelativeNtPathName_U_WithStatus(
      DosFileName: PCWSTR,
      NtFileName: PUNICODE_STRING,
      FilePart: *mut PWSTR,
      RelativeName: PRTL_RELATIVE_NAME_U,
   ) -> NTSTATUS;
   pub fn RtlReleaseRelativeName(RelativeName: PRTL_RELATIVE_NAME_U);
   pub fn RtlDosSearchPath_U(
      Path: PCWSTR,
      FileName: PCWSTR,
      Extension: PCWSTR,
      BufferLength: ULONG,
      Buffer: PWSTR,
      FilePart: *mut PWSTR,
   ) -> ULONG;
   pub fn RtlDosSearchPath_Ustr(
      Flags: ULONG,
      Path: PUNICODE_STRING,
      FileName: PUNICODE_STRING,
      DefaultExtension: PUNICODE_STRING,
      StaticString: PUNICODE_STRING,
      DynamicString: PUNICODE_STRING,
      FullFileNameOut: *mut PCUNICODE_STRING,
      FilePartPrefixCch: *mut SIZE_T,
      BytesRequired: *mut SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlDoesFileExists_U(FileName: PCWSTR) -> BOOLEAN;
   pub fn RtlDosApplyFileIsolationRedirection_Ustr(
      Flags: ULONG,
      OriginalName: PUNICODE_STRING,
      Extension: PUNICODE_STRING,
      StaticString: PUNICODE_STRING,
      DynamicString: PUNICODE_STRING,
      NewName: *mut PUNICODE_STRING,
      NewFlags: PULONG,
      FileNameSize: PSIZE_T,
      RequiredLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlGetLengthWithoutLastFullDosOrNtPathElement(
      Flags: ULONG,
      PathString: PUNICODE_STRING,
      Length: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetLengthWithoutTrailingPathSeperators(
      Flags: ULONG,
      PathString: PUNICODE_STRING,
      Length: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGenerate8dot3Name(
      Name: PUNICODE_STRING,
      AllowExtendedCharacters: BOOLEAN,
      Context: PGENERATE_NAME_CONTEXT,
      Name8dot3: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlComputePrivatizedDllName_U(
      DllName: PUNICODE_STRING,
      RealName: PUNICODE_STRING,
      LocalName: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlGetSearchPath(SearchPathW: *mut PWSTR) -> NTSTATUS;
   pub fn RtlSetSearchPathMode(Flags: ULONG) -> NTSTATUS;
   pub fn RtlGetExePath(DosPathName: PCWSTR, SearchPathW: *mut PWSTR) -> NTSTATUS;
   pub fn RtlReleasePath(Path: PCWSTR);
   pub fn RtlReplaceSystemDirectoryInPath(
      Destination: PUNICODE_STRING,
      Machine: USHORT,
      TargetMachine: USHORT,
      IncludePathSeperator: BOOLEAN,
   ) -> ULONG;
   pub fn RtlWow64GetCurrentMachine() -> USHORT;
   pub fn RtlWow64IsWowGuestMachineSupported(
      NativeMachine: USHORT,
      IsWowGuestMachineSupported: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlWow64GetProcessMachines(
      ProcessHandle: HANDLE,
      ProcessMachine: PUSHORT,
      NativeMachine: PUSHORT,
   ) -> NTSTATUS;
   pub fn RtlGetImageFileMachines(FileName: PCWSTR, FileMachines: PUSHORT) -> NTSTATUS;
   pub fn RtlGetNtSystemRoot() -> PWSTR;
   pub fn RtlAreLongPathsEnabled() -> BOOLEAN;
   pub fn RtlIsThreadWithinLoaderCallout() -> BOOLEAN;
   #[doc = "Gets a value indicating whether the process is currently in the shutdown phase.\n# Returns\n\nTRUE if a shutdown of the current dll process is in progress; otherwise, FALSE."]
   pub fn RtlDllShutdownInProgress() -> BOOLEAN;
   pub fn RtlCreateHeap(
      Flags: ULONG,
      HeapBase: PVOID,
      ReserveSize: SIZE_T,
      CommitSize: SIZE_T,
      Lock: PVOID,
      Parameters: PVOID,
   ) -> PVOID;
   pub fn RtlDestroyHeap(HeapHandle: PVOID) -> PVOID;
   pub fn RtlAllocateHeap(HeapHandle: PVOID, Flags: ULONG, Size: SIZE_T) -> PVOID;
   pub fn RtlFreeHeap(HeapHandle: PVOID, Flags: ULONG, BaseAddress: PVOID) -> LOGICAL;
   pub fn RtlSizeHeap(HeapHandle: PVOID, Flags: ULONG, BaseAddress: PVOID) -> SIZE_T;
   pub fn RtlZeroHeap(HeapHandle: PVOID, Flags: ULONG) -> NTSTATUS;
   pub fn RtlProtectHeap(HeapHandle: PVOID, MakeReadOnly: BOOLEAN);
   pub fn RtlLockHeap(HeapHandle: PVOID) -> BOOLEAN;
   pub fn RtlUnlockHeap(HeapHandle: PVOID) -> BOOLEAN;
   pub fn RtlReAllocateHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      BaseAddress: PVOID,
      Size: SIZE_T,
   ) -> PVOID;
   pub fn RtlGetUserInfoHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      BaseAddress: PVOID,
      UserValue: *mut PVOID,
      UserFlags: PULONG,
   ) -> BOOLEAN;
   pub fn RtlSetUserValueHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      BaseAddress: PVOID,
      UserValue: PVOID,
   ) -> BOOLEAN;
   pub fn RtlSetUserFlagsHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      BaseAddress: PVOID,
      UserFlagsReset: ULONG,
      UserFlagsSet: ULONG,
   ) -> BOOLEAN;
   pub fn RtlCreateTagHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      TagPrefix: PCWSTR,
      TagNames: PCWSTR,
   ) -> ULONG;
   pub fn RtlQueryTagHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      TagIndex: USHORT,
      ResetCounters: BOOLEAN,
      TagInfo: PRTL_HEAP_TAG_INFO,
   ) -> PWSTR;
   pub fn RtlExtendHeap(HeapHandle: PVOID, Flags: ULONG, Base: PVOID, Size: SIZE_T) -> NTSTATUS;
   pub fn RtlCompactHeap(HeapHandle: PVOID, Flags: ULONG) -> SIZE_T;
   pub fn RtlValidateHeap(HeapHandle: PVOID, Flags: ULONG, BaseAddress: PVOID) -> BOOLEAN;
   pub fn RtlValidateProcessHeaps() -> BOOLEAN;
   pub fn RtlGetProcessHeaps(NumberOfHeaps: ULONG, ProcessHeaps: *mut PVOID) -> ULONG;
   pub fn RtlEnumProcessHeaps(EnumRoutine: PRTL_ENUM_HEAPS_ROUTINE, Parameter: PVOID) -> NTSTATUS;
   pub fn RtlUsageHeap(HeapHandle: PVOID, Flags: ULONG, Usage: PRTL_HEAP_USAGE) -> NTSTATUS;
   pub fn RtlWalkHeap(HeapHandle: PVOID, Entry: PRTL_HEAP_WALK_ENTRY) -> NTSTATUS;
   pub fn RtlQueryHeapInformation(
      HeapHandle: PVOID,
      HeapInformationClass: HEAP_INFORMATION_CLASS,
      HeapInformation: PVOID,
      HeapInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlSetHeapInformation(
      HeapHandle: PVOID,
      HeapInformationClass: HEAP_INFORMATION_CLASS,
      HeapInformation: PVOID,
      HeapInformationLength: SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlMultipleAllocateHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      Size: SIZE_T,
      Count: ULONG,
      Array: *mut PVOID,
   ) -> ULONG;
   pub fn RtlMultipleFreeHeap(
      HeapHandle: PVOID,
      Flags: ULONG,
      Count: ULONG,
      Array: *mut PVOID,
   ) -> ULONG;
   pub fn RtlDetectHeapLeaks();
   pub fn RtlFlushHeaps();
   pub fn RtlCreateMemoryZone(
      MemoryZone: *mut PVOID,
      InitialSize: SIZE_T,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDestroyMemoryZone(MemoryZone: PVOID) -> NTSTATUS;
   pub fn RtlAllocateMemoryZone(
      MemoryZone: PVOID,
      BlockSize: SIZE_T,
      Block: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlResetMemoryZone(MemoryZone: PVOID) -> NTSTATUS;
   pub fn RtlLockMemoryZone(MemoryZone: PVOID) -> NTSTATUS;
   pub fn RtlUnlockMemoryZone(MemoryZone: PVOID) -> NTSTATUS;
   pub fn RtlCreateMemoryBlockLookaside(
      MemoryBlockLookaside: *mut PVOID,
      Flags: ULONG,
      InitialSize: ULONG,
      MinimumBlockSize: ULONG,
      MaximumBlockSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDestroyMemoryBlockLookaside(MemoryBlockLookaside: PVOID) -> NTSTATUS;
   pub fn RtlAllocateMemoryBlockLookaside(
      MemoryBlockLookaside: PVOID,
      BlockSize: ULONG,
      Block: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlFreeMemoryBlockLookaside(MemoryBlockLookaside: PVOID, Block: PVOID) -> NTSTATUS;
   pub fn RtlExtendMemoryBlockLookaside(MemoryBlockLookaside: PVOID, Increment: ULONG) -> NTSTATUS;
   pub fn RtlResetMemoryBlockLookaside(MemoryBlockLookaside: PVOID) -> NTSTATUS;
   pub fn RtlLockMemoryBlockLookaside(MemoryBlockLookaside: PVOID) -> NTSTATUS;
   pub fn RtlUnlockMemoryBlockLookaside(MemoryBlockLookaside: PVOID) -> NTSTATUS;
   pub fn RtlGetCurrentTransaction(ExistingFileName: PCWSTR, NewFileName: PCWSTR) -> HANDLE;
   pub fn RtlSetCurrentTransaction(TransactionHandle: HANDLE) -> LOGICAL;
   pub fn RtlIsEqualLuid(L1: PLUID, L2: PLUID) -> BOOLEAN;
   pub fn RtlIsZeroLuid(L1: PLUID) -> BOOLEAN;
   pub fn RtlConvertLongToLuid(Long: LONG) -> LUID;
   pub fn RtlConvertUlongToLuid(Ulong: ULONG) -> LUID;
   pub fn RtlConvertLuidToLonglong(Luid: LUID) -> LONGLONG;
   pub fn RtlConvertLuidToUlonglong(Luid: LUID) -> ULONGLONG;
   pub fn RtlCopyLuid(DestinationLuid: PLUID, SourceLuid: PLUID);
   pub fn RtlCopyLuidAndAttributesArray(
      Count: ULONG,
      Src: PLUID_AND_ATTRIBUTES,
      Dest: PLUID_AND_ATTRIBUTES,
   );
   pub fn RtlConvertUlongToLargeInteger(UnsignedInteger: ULONG) -> LARGE_INTEGER;
   pub fn RtlConvertLongToLargeInteger(SignedInteger: LONG) -> LARGE_INTEGER;
   pub fn RtlEnlargedIntegerMultiply(Multiplicand: LONG, Multiplier: LONG) -> LARGE_INTEGER;
   pub fn RtlEnlargedUnsignedMultiply(Multiplicand: ULONG, Multiplier: ULONG) -> LARGE_INTEGER;
   pub fn RtlCreateQueryDebugBuffer(
      MaximumCommit: ULONG,
      UseEventPair: BOOLEAN,
   ) -> PRTL_DEBUG_INFORMATION;
   pub fn RtlDestroyQueryDebugBuffer(Buffer: PRTL_DEBUG_INFORMATION) -> NTSTATUS;
   pub fn RtlCommitDebugInfo(Buffer: PRTL_DEBUG_INFORMATION, Size: SIZE_T) -> PVOID;
   pub fn RtlDeCommitDebugInfo(Buffer: PRTL_DEBUG_INFORMATION, p: PVOID, Size: SIZE_T);
   pub fn RtlQueryProcessDebugInformation(
      UniqueProcessId: HANDLE,
      Flags: ULONG,
      Buffer: PRTL_DEBUG_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlSetProcessDebugInformation(
      UniqueProcessId: HANDLE,
      Flags: ULONG,
      Buffer: PRTL_DEBUG_INFORMATION,
   ) -> NTSTATUS;
   pub fn RtlIsAnyDebuggerPresent() -> BOOLEAN;
   pub fn RtlDebugPrintTimes() -> NTSTATUS;
   pub fn RtlFindMessage(
      DllHandle: PVOID,
      MessageTableId: ULONG,
      MessageLanguageId: ULONG,
      MessageId: ULONG,
      MessageEntry: *mut PMESSAGE_RESOURCE_ENTRY,
   ) -> NTSTATUS;
   pub fn RtlFormatMessage(
      MessageFormat: PCWSTR,
      MaximumWidth: ULONG,
      IgnoreInserts: BOOLEAN,
      ArgumentsAreAnsi: BOOLEAN,
      ArgumentsAreAnArray: BOOLEAN,
      Arguments: *mut va_list,
      Buffer: PWSTR,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlFormatMessageEx(
      MessageFormat: PCWSTR,
      MaximumWidth: ULONG,
      IgnoreInserts: BOOLEAN,
      ArgumentsAreAnsi: BOOLEAN,
      ArgumentsAreAnArray: BOOLEAN,
      Arguments: *mut va_list,
      Buffer: PWSTR,
      Length: ULONG,
      ReturnLength: PULONG,
      ParseContext: PPARSE_MESSAGE_CONTEXT,
   ) -> NTSTATUS;
   pub fn RtlGetFileMUIPath(
      Flags: ULONG,
      FilePath: PCWSTR,
      Language: PCWSTR,
      LanguageLength: PULONG,
      FileMUIPath: PWSTR,
      FileMUIPathLength: PULONG,
      Enumerator: PULONGLONG,
   ) -> NTSTATUS;
   pub fn RtlLoadString(
      DllHandle: PVOID,
      StringId: ULONG,
      StringLanguage: PCWSTR,
      Flags: ULONG,
      ReturnString: *mut PCWSTR,
      ReturnStringLen: PUSHORT,
      ReturnLanguageName: PWSTR,
      ReturnLanguageLen: PULONG,
   ) -> NTSTATUS;
   pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
   pub fn RtlNtStatusToDosErrorNoTeb(Status: NTSTATUS) -> ULONG;
   pub fn RtlGetLastNtStatus() -> NTSTATUS;
   pub fn RtlGetLastWin32Error() -> LONG;
   pub fn RtlSetLastWin32ErrorAndNtStatusFromNtStatus(Status: NTSTATUS);
   pub fn RtlSetLastWin32Error(Win32Error: LONG);
   pub fn RtlRestoreLastWin32Error(Win32Error: LONG);
   pub fn RtlGetThreadErrorMode() -> ULONG;
   pub fn RtlSetThreadErrorMode(NewMode: ULONG, OldMode: PULONG) -> NTSTATUS;
   pub fn RtlReportException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlReportExceptionEx(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
      Flags: ULONG,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlWerpReportException(
      ProcessId: ULONG,
      CrashReportSharedMem: HANDLE,
      Flags: ULONG,
      CrashVerticalProcessHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn RtlReportSilentProcessExit(ProcessHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn RtlUniform(Seed: PULONG) -> ULONG;
   pub fn RtlRandom(Seed: PULONG) -> ULONG;
   pub fn RtlRandomEx(Seed: PULONG) -> ULONG;
   pub fn RtlComputeImportTableHash(
      FileHandle: HANDLE,
      Hash: PCHAR,
      ImportTableHashRevision: ULONG,
   ) -> NTSTATUS;
   pub fn RtlIntegerToChar(Value: ULONG, Base: ULONG, OutputLength: LONG, String: PSTR)
      -> NTSTATUS;
   pub fn RtlCharToInteger(String: PCSTR, Base: ULONG, Value: PULONG) -> NTSTATUS;
   pub fn RtlLargeIntegerToChar(
      Value: PLARGE_INTEGER,
      Base: ULONG,
      OutputLength: LONG,
      String: PSTR,
   ) -> NTSTATUS;
   pub fn RtlIntegerToUnicodeString(Value: ULONG, Base: ULONG, String: PUNICODE_STRING)
      -> NTSTATUS;
   pub fn RtlInt64ToUnicodeString(
      Value: ULONGLONG,
      Base: ULONG,
      String: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlUnicodeStringToInteger(
      String: PUNICODE_STRING,
      Base: ULONG,
      Value: PULONG,
   ) -> NTSTATUS;
   pub fn RtlIpv4AddressToStringW(Address: PCIN_ADDR, AddressString: PWSTR) -> PWSTR;
   pub fn RtlIpv4AddressToStringExW(
      Address: PCIN_ADDR,
      Port: USHORT,
      AddressString: PWSTR,
      AddressStringLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlIpv6AddressToStringW(Address: PCIN6_ADDR, AddressString: PWSTR) -> PWSTR;
   pub fn RtlIpv6AddressToStringExW(
      Address: PCIN6_ADDR,
      ScopeId: ULONG,
      Port: USHORT,
      AddressString: PWSTR,
      AddressStringLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlIpv4StringToAddressW(
      AddressString: PCWSTR,
      Strict: BOOLEAN,
      Terminator: *mut LPCWSTR,
      Address: PIN_ADDR,
   ) -> NTSTATUS;
   pub fn RtlIpv4StringToAddressExW(
      AddressString: PCWSTR,
      Strict: BOOLEAN,
      Address: PIN_ADDR,
      Port: PUSHORT,
   ) -> NTSTATUS;
   pub fn RtlIpv6StringToAddressW(
      AddressString: PCWSTR,
      Terminator: *mut PCWSTR,
      Address: PIN6_ADDR,
   ) -> NTSTATUS;
   pub fn RtlIpv6StringToAddressExW(
      AddressString: PCWSTR,
      Address: PIN6_ADDR,
      ScopeId: PULONG,
      Port: PUSHORT,
   ) -> NTSTATUS;
   pub fn RtlCutoverTimeToSystemTime(
      CutoverTime: PTIME_FIELDS,
      SystemTime: PLARGE_INTEGER,
      CurrentSystemTime: PLARGE_INTEGER,
      ThisYear: BOOLEAN,
   ) -> BOOLEAN;
   pub fn RtlSystemTimeToLocalTime(
      SystemTime: PLARGE_INTEGER,
      LocalTime: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlLocalTimeToSystemTime(
      LocalTime: PLARGE_INTEGER,
      SystemTime: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn RtlTimeToElapsedTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
   pub fn RtlTimeToTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
   pub fn RtlTimeFieldsToTime(TimeFields: PTIME_FIELDS, Time: PLARGE_INTEGER) -> BOOLEAN;
   pub fn RtlTimeToSecondsSince1980(Time: PLARGE_INTEGER, ElapsedSeconds: PULONG) -> BOOLEAN;
   pub fn RtlSecondsSince1980ToTime(ElapsedSeconds: ULONG, Time: PLARGE_INTEGER);
   pub fn RtlTimeToSecondsSince1970(Time: PLARGE_INTEGER, ElapsedSeconds: PULONG) -> BOOLEAN;
   pub fn RtlSecondsSince1970ToTime(ElapsedSeconds: ULONG, Time: PLARGE_INTEGER);
   pub fn RtlGetSystemTimePrecise() -> ULONGLONG;
   pub fn RtlGetSystemTimeAndBias(
      TimeZoneBias: KSYSTEM_TIME,
      TimeZoneBiasEffectiveStart: PLARGE_INTEGER,
      TimeZoneBiasEffectiveEnd: PLARGE_INTEGER,
   ) -> KSYSTEM_TIME;
   pub fn RtlGetInterruptTimePrecise(PerformanceCounter: PLARGE_INTEGER) -> ULONGLONG;
   pub fn RtlQueryUnbiasedInterruptTime(InterruptTime: PLARGE_INTEGER) -> BOOLEAN;
   pub fn RtlBeginReadTickLock(TimeUpdateLock: PULONGLONG) -> ULONGLONG;
   pub fn RtlQueryTimeZoneInformation(TimeZoneInformation: PRTL_TIME_ZONE_INFORMATION) -> NTSTATUS;
   pub fn RtlSetTimeZoneInformation(TimeZoneInformation: PRTL_TIME_ZONE_INFORMATION) -> NTSTATUS;
   pub fn RtlInitializeBitMap(BitMapHeader: PRTL_BITMAP, BitMapBuffer: PULONG, SizeOfBitMap: ULONG);
   pub fn RtlClearBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
   pub fn RtlSetBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG);
   pub fn RtlTestBit(BitMapHeader: PRTL_BITMAP, BitNumber: ULONG) -> BOOLEAN;
   pub fn RtlClearAllBits(BitMapHeader: PRTL_BITMAP);
   pub fn RtlSetAllBits(BitMapHeader: PRTL_BITMAP);
   pub fn RtlFindClearBits(
      BitMapHeader: PRTL_BITMAP,
      NumberToFind: ULONG,
      HintIndex: ULONG,
   ) -> ULONG;
   pub fn RtlFindSetBits(BitMapHeader: PRTL_BITMAP, NumberToFind: ULONG, HintIndex: ULONG)
      -> ULONG;
   pub fn RtlFindClearBitsAndSet(
      BitMapHeader: PRTL_BITMAP,
      NumberToFind: ULONG,
      HintIndex: ULONG,
   ) -> ULONG;
   pub fn RtlFindSetBitsAndClear(
      BitMapHeader: PRTL_BITMAP,
      NumberToFind: ULONG,
      HintIndex: ULONG,
   ) -> ULONG;
   pub fn RtlClearBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, NumberToClear: ULONG);
   pub fn RtlSetBits(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, NumberToSet: ULONG);
   pub fn RtlFindMostSignificantBit(Set: ULONGLONG) -> CCHAR;
   pub fn RtlFindLeastSignificantBit(Set: ULONGLONG) -> CCHAR;
   pub fn RtlFindClearRuns(
      BitMapHeader: PRTL_BITMAP,
      RunArray: PRTL_BITMAP_RUN,
      SizeOfRunArray: ULONG,
      LocateLongestRuns: BOOLEAN,
   ) -> ULONG;
   pub fn RtlFindLongestRunClear(BitMapHeader: PRTL_BITMAP, StartingIndex: PULONG) -> ULONG;
   pub fn RtlFindFirstRunClear(BitMapHeader: PRTL_BITMAP, StartingIndex: PULONG) -> ULONG;
   pub fn RtlCheckBit(BitMapHeader: PRTL_BITMAP, BitPosition: ULONG) -> BOOLEAN;
   pub fn RtlNumberOfClearBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
   pub fn RtlNumberOfSetBits(BitMapHeader: PRTL_BITMAP) -> ULONG;
   pub fn RtlAreBitsClear(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      Length: ULONG,
   ) -> BOOLEAN;
   pub fn RtlAreBitsSet(BitMapHeader: PRTL_BITMAP, StartingIndex: ULONG, Length: ULONG) -> BOOLEAN;
   pub fn RtlFindNextForwardRunClear(
      BitMapHeader: PRTL_BITMAP,
      FromIndex: ULONG,
      StartingRunIndex: PULONG,
   ) -> ULONG;
   pub fn RtlFindLastBackwardRunClear(
      BitMapHeader: PRTL_BITMAP,
      FromIndex: ULONG,
      StartingRunIndex: PULONG,
   ) -> ULONG;
   pub fn RtlNumberOfSetBitsUlongPtr(Target: ULONG_PTR) -> ULONG;
   pub fn RtlInterlockedClearBitRun(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      NumberToClear: ULONG,
   );
   pub fn RtlInterlockedSetBitRun(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      NumberToSet: ULONG,
   );
   pub fn RtlCopyBitMap(Source: PRTL_BITMAP, Destination: PRTL_BITMAP, TargetBit: ULONG);
   pub fn RtlExtractBitMap(
      Source: PRTL_BITMAP,
      Destination: PRTL_BITMAP,
      TargetBit: ULONG,
      NumberOfBits: ULONG,
   );
   pub fn RtlNumberOfClearBitsInRange(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      Length: ULONG,
   ) -> ULONG;
   pub fn RtlNumberOfSetBitsInRange(
      BitMapHeader: PRTL_BITMAP,
      StartingIndex: ULONG,
      Length: ULONG,
   ) -> ULONG;
   pub fn RtlInitializeBitMapEx(
      BitMapHeader: PRTL_BITMAP_EX,
      BitMapBuffer: PULONG64,
      SizeOfBitMap: ULONG64,
   );
   pub fn RtlTestBitEx(BitMapHeader: PRTL_BITMAP_EX, BitNumber: ULONG64) -> BOOLEAN;
   pub fn RtlClearAllBitsEx(BitMapHeader: PRTL_BITMAP_EX);
   pub fn RtlClearBitEx(BitMapHeader: PRTL_BITMAP_EX, BitNumber: ULONG64);
   pub fn RtlSetBitEx(BitMapHeader: PRTL_BITMAP_EX, BitNumber: ULONG64);
   pub fn RtlFindSetBitsEx(
      BitMapHeader: PRTL_BITMAP_EX,
      NumberToFind: ULONG64,
      HintIndex: ULONG64,
   ) -> ULONG64;
   pub fn RtlFindSetBitsAndClearEx(
      BitMapHeader: PRTL_BITMAP_EX,
      NumberToFind: ULONG64,
      HintIndex: ULONG64,
   ) -> ULONG64;
   pub fn RtlInitializeHandleTable(
      MaximumNumberOfHandles: ULONG,
      SizeOfHandleTableEntry: ULONG,
      HandleTable: PRTL_HANDLE_TABLE,
   );
   pub fn RtlDestroyHandleTable(HandleTable: PRTL_HANDLE_TABLE) -> NTSTATUS;
   pub fn RtlAllocateHandle(
      HandleTable: PRTL_HANDLE_TABLE,
      HandleIndex: PULONG,
   ) -> PRTL_HANDLE_TABLE_ENTRY;
   pub fn RtlFreeHandle(HandleTable: PRTL_HANDLE_TABLE, Handle: PRTL_HANDLE_TABLE_ENTRY)
      -> BOOLEAN;
   pub fn RtlIsValidHandle(
      HandleTable: PRTL_HANDLE_TABLE,
      Handle: PRTL_HANDLE_TABLE_ENTRY,
   ) -> BOOLEAN;
   pub fn RtlIsValidIndexHandle(
      HandleTable: PRTL_HANDLE_TABLE,
      HandleIndex: ULONG,
      Handle: *mut PRTL_HANDLE_TABLE_ENTRY,
   ) -> BOOLEAN;
   pub fn RtlCreateAtomTable(NumberOfBuckets: ULONG, AtomTableHandle: *mut PVOID) -> NTSTATUS;
   pub fn RtlDestroyAtomTable(AtomTableHandle: PVOID) -> NTSTATUS;
   pub fn RtlEmptyAtomTable(AtomTableHandle: PVOID, IncludePinnedAtoms: BOOLEAN) -> NTSTATUS;
   pub fn RtlAddAtomToAtomTable(
      AtomTableHandle: PVOID,
      AtomName: PCWSTR,
      Atom: PRTL_ATOM,
   ) -> NTSTATUS;
   pub fn RtlLookupAtomInAtomTable(
      AtomTableHandle: PVOID,
      AtomName: PCWSTR,
      Atom: PRTL_ATOM,
   ) -> NTSTATUS;
   pub fn RtlDeleteAtomFromAtomTable(AtomTableHandle: PVOID, Atom: RTL_ATOM) -> NTSTATUS;
   pub fn RtlPinAtomInAtomTable(AtomTableHandle: PVOID, Atom: RTL_ATOM) -> NTSTATUS;
   pub fn RtlQueryAtomInAtomTable(
      AtomTableHandle: PVOID,
      Atom: RTL_ATOM,
      AtomUsage: PULONG,
      AtomFlags: PULONG,
      AtomName: PWSTR,
      AtomNameLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetIntegerAtom(AtomName: PCWSTR, IntegerAtom: PUSHORT) -> BOOLEAN;
   pub fn RtlValidSid(Sid: PSID) -> BOOLEAN;
   pub fn RtlEqualSid(Sid1: PSID, Sid2: PSID) -> BOOLEAN;
   pub fn RtlEqualPrefixSid(Sid1: PSID, Sid2: PSID) -> BOOLEAN;
   pub fn RtlLengthRequiredSid(SubAuthorityCount: ULONG) -> ULONG;
   pub fn RtlFreeSid(Sid: PSID) -> PVOID;
   pub fn RtlAllocateAndInitializeSid(
      IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
      SubAuthorityCount: UCHAR,
      SubAuthority0: ULONG,
      SubAuthority1: ULONG,
      SubAuthority2: ULONG,
      SubAuthority3: ULONG,
      SubAuthority4: ULONG,
      SubAuthority5: ULONG,
      SubAuthority6: ULONG,
      SubAuthority7: ULONG,
      Sid: *mut PSID,
   ) -> NTSTATUS;
   pub fn RtlAllocateAndInitializeSidEx(
      IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
      SubAuthorityCount: UCHAR,
      SubAuthorities: PULONG,
      Sid: *mut PSID,
   ) -> NTSTATUS;
   pub fn RtlInitializeSid(
      Sid: PSID,
      IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
      SubAuthorityCount: UCHAR,
   ) -> NTSTATUS;
   pub fn RtlInitializeSidEx(
      Sid: PSID,
      IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
      SubAuthorityCount: UCHAR,
      ...
   ) -> NTSTATUS;
   pub fn RtlIdentifierAuthoritySid(Sid: PSID) -> PSID_IDENTIFIER_AUTHORITY;
   pub fn RtlSubAuthoritySid(Sid: PSID, SubAuthority: ULONG) -> PULONG;
   pub fn RtlSubAuthorityCountSid(Sid: PSID) -> PUCHAR;
   pub fn RtlLengthSid(Sid: PSID) -> ULONG;
   pub fn RtlCopySid(
      DestinationSidLength: ULONG,
      DestinationSid: PSID,
      SourceSid: PSID,
   ) -> NTSTATUS;
   pub fn RtlCopySidAndAttributesArray(
      Count: ULONG,
      Src: PSID_AND_ATTRIBUTES,
      SidAreaSize: ULONG,
      Dest: PSID_AND_ATTRIBUTES,
      SidArea: PSID,
      RemainingSidArea: *mut PSID,
      RemainingSidAreaSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlCreateServiceSid(
      ServiceName: PUNICODE_STRING,
      ServiceSid: PSID,
      ServiceSidLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSidDominates(Sid1: PSID, Sid2: PSID, Dominates: PBOOLEAN) -> NTSTATUS;
   pub fn RtlSidDominatesForTrust(Sid1: PSID, Sid2: PSID, DominatesTrust: PBOOLEAN) -> NTSTATUS;
   pub fn RtlSidEqualLevel(Sid1: PSID, Sid2: PSID, EqualLevel: PBOOLEAN) -> NTSTATUS;
   pub fn RtlSidIsHigherLevel(Sid1: PSID, Sid2: PSID, HigherLevel: PBOOLEAN) -> NTSTATUS;
   pub fn RtlCreateVirtualAccountSid(
      Name: PUNICODE_STRING,
      BaseSubAuthority: ULONG,
      Sid: PSID,
      SidLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlReplaceSidInSd(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      OldSid: PSID,
      NewSid: PSID,
      NumChanges: *mut ULONG,
   ) -> NTSTATUS;
   pub fn RtlLengthSidAsUnicodeString(Sid: PSID, StringLength: PULONG) -> NTSTATUS;
   pub fn RtlConvertSidToUnicodeString(
      UnicodeString: PUNICODE_STRING,
      Sid: PSID,
      AllocateDestinationString: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSidHashInitialize(
      SidAttr: PSID_AND_ATTRIBUTES,
      SidCount: ULONG,
      SidAttrHash: PSID_AND_ATTRIBUTES_HASH,
   ) -> NTSTATUS;
   pub fn RtlSidHashLookup(SidAttrHash: PSID_AND_ATTRIBUTES_HASH, Sid: PSID)
      -> PSID_AND_ATTRIBUTES;
   pub fn RtlIsElevatedRid(SidAttr: PSID_AND_ATTRIBUTES) -> BOOLEAN;
   pub fn RtlDeriveCapabilitySidsFromName(
      UnicodeString: PUNICODE_STRING,
      CapabilityGroupSid: PSID,
      CapabilitySid: PSID,
   ) -> NTSTATUS;
   #[doc = "The RtlCreateSecurityDescriptor routine initializes a new absolute-format security descriptor.\nOn return, the security descriptor is initialized with no system ACL, no discretionary ACL, no owner, no primary group, and all control flags set to zero.\n# Arguments\n\n* `SecurityDescriptor` - Pointer to the buffer for the [`SECURITY_DESCRIPTOR`] to be initialized.\n* `Revision` - Specifies the revision level to assign to the security descriptor. Set this parameter to SECURITY_DESCRIPTOR_REVISION.\n# Returns\n\nNTSTATUS Successful or errant status.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlcreatesecuritydescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlcreatesecuritydescriptor)"]
   pub fn RtlCreateSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Revision: ULONG,
   ) -> NTSTATUS;
   #[doc = "The RtlValidSecurityDescriptor routine checks a given security descriptor's validity.\n# Arguments\n\n* `SecurityDescriptor` - Pointer to the [`SECURITY_DESCRIPTOR`] to be checked.\n# Returns\n\nReturns TRUE if the security descriptor is valid, or FALSE otherwise.\n> The routine checks the validity of an absolute-format security descriptor. To check the validity of a self-relative security descriptor, use the [`RtlValidRelativeSecurityDescriptor`] routine instead.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlvalidsecuritydescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlvalidsecuritydescriptor)"]
   pub fn RtlValidSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> BOOLEAN;
   #[doc = "The RtlLengthSecurityDescriptor routine returns the size of a given security descriptor.\n# Arguments\n\n* `SecurityDescriptor` - A pointer to a [`SECURITY_DESCRIPTOR`] structure whose length the function retrieves.\n# Returns\n\nReturns the length, in bytes, of the SECURITY_DESCRIPTOR structure.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtllengthsecuritydescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtllengthsecuritydescriptor)"]
   pub fn RtlLengthSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR) -> ULONG;
   #[doc = "The RtlValidRelativeSecurityDescriptor routine checks the validity of a self-relative security descriptor.\n# Arguments\n\n* `SecurityDescriptorInput` - A pointer to the buffer that contains the security descriptor in self-relative format.\nThe buffer must begin with a SECURITY_DESCRIPTOR structure, which is followed by the rest of the security descriptor data.\n* `SecurityDescriptorLength` - The size of the SecurityDescriptorInput structure.\n* `RequiredInformation` - A SECURITY_INFORMATION value that specifies the information that is required to be contained in the security descriptor.\n# Returns\n\nRtlValidRelativeSecurityDescriptor returns TRUE if the security descriptor is valid and includes the information that the RequiredInformation parameter specifies. Otherwise, this routine returns FALSE.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlvalidrelativesecuritydescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlvalidrelativesecuritydescriptor)"]
   pub fn RtlValidRelativeSecurityDescriptor(
      SecurityDescriptorInput: PSECURITY_DESCRIPTOR,
      SecurityDescriptorLength: ULONG,
      RequiredInformation: SECURITY_INFORMATION,
   ) -> BOOLEAN;
   pub fn RtlGetControlSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Control: PSECURITY_DESCRIPTOR_CONTROL,
      Revision: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSetControlSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ControlBitsOfInterest: SECURITY_DESCRIPTOR_CONTROL,
      ControlBitsToSet: SECURITY_DESCRIPTOR_CONTROL,
   ) -> NTSTATUS;
   pub fn RtlSetAttributesSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Control: SECURITY_DESCRIPTOR_CONTROL,
      Revision: PULONG,
   ) -> NTSTATUS;
   pub fn RtlGetSecurityDescriptorRMControl(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      RMControl: PUCHAR,
   ) -> BOOLEAN;
   pub fn RtlSetSecurityDescriptorRMControl(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      RMControl: PUCHAR,
   );
   pub fn RtlSetDaclSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      DaclPresent: BOOLEAN,
      Dacl: PACL,
      DaclDefaulted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGetDaclSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      DaclPresent: PBOOLEAN,
      Dacl: *mut PACL,
      DaclDefaulted: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlSetSaclSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      SaclPresent: BOOLEAN,
      Sacl: PACL,
      SaclDefaulted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGetSaclSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      SaclPresent: PBOOLEAN,
      Sacl: *mut PACL,
      SaclDefaulted: PBOOLEAN,
   ) -> NTSTATUS;
   #[doc = "The RtlSetOwnerSecurityDescriptor routine sets the owner information of an absolute-format security descriptor. It replaces any owner information that is already present in the security descriptor.\n# Arguments\n\n* `SecurityDescriptor` - Pointer to the SECURITY_DESCRIPTOR structure whose owner is to be set. RtlSetOwnerSecurityDescriptor replaces any existing owner with the new owner.\n* `Owner` - Pointer to a security identifier (SID) structure for the security descriptor's new primary owner.\n- `This` pointer, not the SID structure itself, is copied into the security descriptor.\n- `If` this parameter is NULL, RtlSetOwnerSecurityDescriptor clears the security descriptor's owner information. This marks the security descriptor as having no owner.\n* `OwnerDefaulted` - Set to TRUE if the owner information is derived from a default mechanism.\n- `If` this value is TRUE, it is default information. RtlSetOwnerSecurityDescriptor sets the SE_OWNER_DEFAULTED flag in the security descriptor's SECURITY_DESCRIPTOR_CONTROL field.\n- `If` this parameter is FALSE, the SE_OWNER_DEFAULTED flag is cleared.\n# Returns\n\nNTSTATUS Successful or errant status.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlsetownersecuritydescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlsetownersecuritydescriptor)"]
   pub fn RtlSetOwnerSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Owner: PSID,
      OwnerDefaulted: BOOLEAN,
   ) -> NTSTATUS;
   #[doc = "The RtlGetOwnerSecurityDescriptor routine returns the owner information for a given security descriptor.\n# Arguments\n\n* `SecurityDescriptor` - Pointer to the SECURITY_DESCRIPTOR structure.\n* `Owner` - Pointer to an address to receive a pointer to the owner security identifier (SID). If the security descriptor does not currently contain an owner SID, Owner receives NULL.\n* `OwnerDefaulted` - Pointer to a Boolean variable that receives TRUE if the owner information is derived from a default mechanism, FALSE otherwise. Valid only if Owner receives a non-NULL value.\n# Returns\n\nNTSTATUS Successful or errant status.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlgetownersecuritydescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlgetownersecuritydescriptor)"]
   pub fn RtlGetOwnerSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Owner: *mut PSID,
      OwnerDefaulted: PBOOLEAN,
   ) -> NTSTATUS;
   #[doc = "The RtlSetGroupSecurityDescriptor routine sets the primary group information of an absolute-format security descriptor. It replaces any primary group information that is already present in the security descriptor.\n# Arguments\n\n* `SecurityDescriptor` - Pointer to the SECURITY_DESCRIPTOR structure whose primary group is to be set. RtlSetGroupSecurityDescriptor replaces any existing primary group with the new primary group.\n* `Group` - Pointer to a security identifier (SID) structure for the security descriptor's new primary owner.\n- `This` pointer, not the SID structure itself, is copied into the security descriptor.\n- `If` Group is NULL, RtlSetGroupSecurityDescriptor clears the security descriptor's primary group information. This marks the security descriptor as having no primary group.\n* `GroupDefaulted` - Set this Boolean variable to TRUE if the primary group information is derived from a default mechanism.\n- `If` this parameter is TRUE, RtlSetGroupSecurityDescriptor sets the SE_GROUP_DEFAULTED flag in the security descriptor's SECURITY_DESCRIPTOR_CONTROL field.\n- `If` this parameter is FALSE, RtlSetGroupSecurityDescriptor clears the SE_GROUP_DEFAULTED flag.\n# Returns\n\nNTSTATUS Successful or errant status.\n# See also\n\n> [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlsetgroupsecuritydescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlsetgroupsecuritydescriptor)"]
   pub fn RtlSetGroupSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Group: PSID,
      GroupDefaulted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlGetGroupSecurityDescriptor(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Group: *mut PSID,
      GroupDefaulted: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlMakeSelfRelativeSD(
      AbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
      SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
      BufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlAbsoluteToSelfRelativeSD(
      AbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
      SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
      BufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSelfRelativeToAbsoluteSD(
      SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
      AbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
      AbsoluteSecurityDescriptorSize: PULONG,
      Dacl: PACL,
      DaclSize: PULONG,
      Sacl: PACL,
      SaclSize: PULONG,
      Owner: PSID,
      OwnerSize: PULONG,
      PrimaryGroup: PSID,
      PrimaryGroupSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSelfRelativeToAbsoluteSD2(
      SelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn RtlNormalizeSecurityDescriptor(
      SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      SecurityDescriptorLength: DWORD,
      NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      NewSecurityDescriptorLength: PDWORD,
      CheckOnly: BOOLEAN,
   ) -> BOOLEAN;
   #[doc = "Checks if all desired accesses are granted.\nThis function determines whether all the accesses specified in the DesiredAccess\nmask are granted by the GrantedAccess mask.\n# Arguments\n\n* `GrantedAccess` - The access mask that specifies the granted accesses.\n* `DesiredAccess` - The access mask that specifies the desired accesses.\n# Returns\n\nReturns TRUE if all desired accesses are granted, otherwise FALSE."]
   pub fn RtlAreAllAccessesGranted(
      GrantedAccess: ACCESS_MASK,
      DesiredAccess: ACCESS_MASK,
   ) -> BOOLEAN;
   #[doc = "Checks if any of the desired accesses are granted.\nThis function determines if any of the access rights specified in the DesiredAccess\nmask are present in the GrantedAccess mask.\n# Arguments\n\n* `GrantedAccess` - The access mask that specifies the granted access rights.\n* `DesiredAccess` - The access mask that specifies the desired access rights.\n# Returns\n\nReturns TRUE if any of the desired access rights are granted, otherwise FALSE."]
   pub fn RtlAreAnyAccessesGranted(
      GrantedAccess: ACCESS_MASK,
      DesiredAccess: ACCESS_MASK,
   ) -> BOOLEAN;
   pub fn RtlMapGenericMask(AccessMask: PACCESS_MASK, GenericMapping: PGENERIC_MAPPING);
   pub fn RtlCreateAcl(Acl: PACL, AclLength: ULONG, AclRevision: ULONG) -> NTSTATUS;
   pub fn RtlValidAcl(Acl: PACL) -> BOOLEAN;
   pub fn RtlQueryInformationAcl(
      Acl: PACL,
      AclInformation: PVOID,
      AclInformationLength: ULONG,
      AclInformationClass: ACL_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn RtlSetInformationAcl(
      Acl: PACL,
      AclInformation: PVOID,
      AclInformationLength: ULONG,
      AclInformationClass: ACL_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn RtlAddAce(
      Acl: PACL,
      AceRevision: ULONG,
      StartingAceIndex: ULONG,
      AceList: PVOID,
      AceListLength: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeleteAce(Acl: PACL, AceIndex: ULONG) -> NTSTATUS;
   pub fn RtlGetAce(Acl: PACL, AceIndex: ULONG, Ace: *mut PVOID) -> NTSTATUS;
   pub fn RtlGetAcesBufferSize(Acl: PACL, AcesBufferSize: PULONG) -> NTSTATUS;
   pub fn RtlFirstFreeAce(Acl: PACL, FirstFree: *mut PVOID) -> BOOLEAN;
   pub fn RtlFindAceByType(Acl: PACL, AceType: UCHAR, Index: PULONG) -> PVOID;
   pub fn RtlOwnerAcesPresent(pAcl: PACL) -> BOOLEAN;
   pub fn RtlAddAccessAllowedAce(
      Acl: PACL,
      AceRevision: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAccessAllowedAceEx(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAccessDeniedAce(
      Acl: PACL,
      AceRevision: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAccessDeniedAceEx(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAuditAccessAce(
      Acl: PACL,
      AceRevision: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
      AuditSuccess: BOOLEAN,
      AuditFailure: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAddAuditAccessAceEx(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      Sid: PSID,
      AuditSuccess: BOOLEAN,
      AuditFailure: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAddAccessAllowedObjectAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      ObjectTypeGuid: PGUID,
      InheritedObjectTypeGuid: PGUID,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAccessDeniedObjectAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      ObjectTypeGuid: PGUID,
      InheritedObjectTypeGuid: PGUID,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddAuditAccessObjectAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ACCESS_MASK,
      ObjectTypeGuid: PGUID,
      InheritedObjectTypeGuid: PGUID,
      Sid: PSID,
      AuditSuccess: BOOLEAN,
      AuditFailure: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAddCompoundAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceType: UCHAR,
      AccessMask: ACCESS_MASK,
      ServerSid: PSID,
      ClientSid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddMandatoryAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      Sid: PSID,
      AceType: UCHAR,
      AccessMask: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn RtlAddResourceAttributeAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ULONG,
      Sid: PSID,
      AttributeInfo: PCLAIM_SECURITY_ATTRIBUTES_INFORMATION,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlAddScopedPolicyIDAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      AccessMask: ULONG,
      Sid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddProcessTrustLabelAce(
      Acl: PACL,
      AceRevision: ULONG,
      AceFlags: ULONG,
      ProcessTrustLabelSid: PSID,
      AceType: UCHAR,
      AccessMask: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn RtlDefaultNpAcl(Acl: *mut PACL) -> NTSTATUS;
   pub fn RtlNewSecurityObject(
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CreatorDescriptor: PSECURITY_DESCRIPTOR,
      NewDescriptor: *mut PSECURITY_DESCRIPTOR,
      IsDirectoryObject: BOOLEAN,
      Token: HANDLE,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlNewSecurityObjectEx(
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CreatorDescriptor: PSECURITY_DESCRIPTOR,
      NewDescriptor: *mut PSECURITY_DESCRIPTOR,
      ObjectType: *mut GUID,
      IsDirectoryObject: BOOLEAN,
      AutoInheritFlags: ULONG,
      Token: HANDLE,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlNewSecurityObjectWithMultipleInheritance(
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CreatorDescriptor: PSECURITY_DESCRIPTOR,
      NewDescriptor: *mut PSECURITY_DESCRIPTOR,
      ObjectType: *mut *mut GUID,
      GuidCount: ULONG,
      IsDirectoryObject: BOOLEAN,
      AutoInheritFlags: ULONG,
      Token: HANDLE,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlDeleteSecurityObject(ObjectDescriptor: *mut PSECURITY_DESCRIPTOR) -> NTSTATUS;
   pub fn RtlQuerySecurityObject(
      ObjectDescriptor: PSECURITY_DESCRIPTOR,
      SecurityInformation: SECURITY_INFORMATION,
      ResultantDescriptor: PSECURITY_DESCRIPTOR,
      DescriptorLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSetSecurityObject(
      SecurityInformation: SECURITY_INFORMATION,
      ModificationDescriptor: PSECURITY_DESCRIPTOR,
      ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      GenericMapping: PGENERIC_MAPPING,
      TokenHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn RtlSetSecurityObjectEx(
      SecurityInformation: SECURITY_INFORMATION,
      ModificationDescriptor: PSECURITY_DESCRIPTOR,
      ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      AutoInheritFlags: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      TokenHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn RtlConvertToAutoInheritSecurityObject(
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CurrentSecurityDescriptor: PSECURITY_DESCRIPTOR,
      NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
      ObjectType: *mut GUID,
      IsDirectoryObject: BOOLEAN,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlNewInstanceSecurityObject(
      ParentDescriptorChanged: BOOLEAN,
      CreatorDescriptorChanged: BOOLEAN,
      OldClientTokenModifiedId: PLUID,
      NewClientTokenModifiedId: PLUID,
      ParentDescriptor: PSECURITY_DESCRIPTOR,
      CreatorDescriptor: PSECURITY_DESCRIPTOR,
      NewDescriptor: *mut PSECURITY_DESCRIPTOR,
      IsDirectoryObject: BOOLEAN,
      TokenHandle: HANDLE,
      GenericMapping: PGENERIC_MAPPING,
   ) -> NTSTATUS;
   pub fn RtlCopySecurityDescriptor(
      InputSecurityDescriptor: PSECURITY_DESCRIPTOR,
      OutputSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn RtlCreateUserSecurityObject(
      AceData: PRTL_ACE_DATA,
      AceCount: ULONG,
      OwnerSid: PSID,
      GroupSid: PSID,
      IsDirectoryObject: BOOLEAN,
      GenericMapping: PGENERIC_MAPPING,
      NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn RtlCreateAndSetSD(
      AceData: PRTL_ACE_DATA,
      AceCount: ULONG,
      OwnerSid: PSID,
      GroupSid: PSID,
      NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn RtlRunEncodeUnicodeString(Seed: PUCHAR, String: PUNICODE_STRING);
   pub fn RtlRunDecodeUnicodeString(Seed: UCHAR, String: PUNICODE_STRING);
   pub fn RtlImpersonateSelf(ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL) -> NTSTATUS;
   pub fn RtlImpersonateSelfEx(
      ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
      AdditionalAccess: ACCESS_MASK,
      ThreadToken: PHANDLE,
   ) -> NTSTATUS;
   pub fn RtlAdjustPrivilege(
      Privilege: ULONG,
      Enable: BOOLEAN,
      Client: BOOLEAN,
      WasEnabled: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAcquirePrivilege(
      Privilege: PULONG,
      NumPriv: ULONG,
      Flags: ULONG,
      ReturnedState: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlReleasePrivilege(StatePointer: PVOID);
   pub fn RtlRemovePrivileges(
      TokenHandle: HANDLE,
      PrivilegesToKeep: PULONG,
      PrivilegeCount: ULONG,
   ) -> NTSTATUS;
   pub fn RtlIsUntrustedObject(
      Handle: HANDLE,
      Object: PVOID,
      IsUntrustedObject: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryValidationRunlevel(ComponentName: PUNICODE_STRING) -> ULONG;
   pub fn RtlCreateBoundaryDescriptor(
      Name: PUNICODE_STRING,
      Flags: ULONG,
   ) -> POBJECT_BOUNDARY_DESCRIPTOR;
   pub fn RtlDeleteBoundaryDescriptor(BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR);
   pub fn RtlAddSIDToBoundaryDescriptor(
      BoundaryDescriptor: *mut POBJECT_BOUNDARY_DESCRIPTOR,
      RequiredSid: PSID,
   ) -> NTSTATUS;
   pub fn RtlAddIntegrityLabelToBoundaryDescriptor(
      BoundaryDescriptor: *mut POBJECT_BOUNDARY_DESCRIPTOR,
      IntegrityLabel: PSID,
   ) -> NTSTATUS;
   pub fn RtlGetVersion(VersionInformation: PRTL_OSVERSIONINFOEXW) -> NTSTATUS;
   pub fn RtlVerifyVersionInfo(
      VersionInformation: PRTL_OSVERSIONINFOEXW,
      TypeMask: ULONG,
      ConditionMask: ULONGLONG,
   ) -> NTSTATUS;
   pub fn RtlGetNtVersionNumbers(
      NtMajorVersion: PULONG,
      NtMinorVersion: PULONG,
      NtBuildNumber: PULONG,
   );
   pub fn RtlGetNtGlobalFlags() -> ULONG;
   pub fn RtlGetNtProductType(NtProductType: PNT_PRODUCT_TYPE) -> BOOLEAN;
   pub fn RtlGetSuiteMask() -> ULONG;
   pub fn RtlRegisterWait(
      WaitHandle: PHANDLE,
      Handle: HANDLE,
      Function: WAITORTIMERCALLBACKFUNC,
      Context: PVOID,
      Milliseconds: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeregisterWait(WaitHandle: HANDLE) -> NTSTATUS;
   pub fn RtlDeregisterWaitEx(WaitHandle: HANDLE, CompletionEvent: HANDLE) -> NTSTATUS;
   pub fn RtlQueueWorkItem(Function: WORKERCALLBACKFUNC, Context: PVOID, Flags: ULONG) -> NTSTATUS;
   pub fn RtlSetIoCompletionCallback(
      FileHandle: HANDLE,
      CompletionProc: APC_CALLBACK_FUNCTION,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlSetThreadPoolStartFunc(
      StartPoolThread: PRTL_START_POOL_THREAD,
      ExitPoolThread: PRTL_EXIT_POOL_THREAD,
   ) -> NTSTATUS;
   pub fn RtlUserThreadStart(Function: PTHREAD_START_ROUTINE, Parameter: PVOID);
   pub fn LdrInitializeThunk(ContextRecord: PCONTEXT, Parameter: PVOID);
   pub fn RtlDelayExecution(Alertable: BOOLEAN, DelayInterval: PLARGE_INTEGER) -> NTSTATUS;
   pub fn RtlCreateTimerQueue(TimerQueueHandle: PHANDLE) -> NTSTATUS;
   pub fn RtlCreateTimer(
      TimerQueueHandle: HANDLE,
      Handle: PHANDLE,
      Function: WAITORTIMERCALLBACKFUNC,
      Context: PVOID,
      DueTime: ULONG,
      Period: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlSetTimer(
      TimerQueueHandle: HANDLE,
      Handle: PHANDLE,
      Function: WAITORTIMERCALLBACKFUNC,
      Context: PVOID,
      DueTime: ULONG,
      Period: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUpdateTimer(
      TimerQueueHandle: HANDLE,
      TimerHandle: HANDLE,
      DueTime: ULONG,
      Period: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeleteTimer(
      TimerQueueHandle: HANDLE,
      TimerToCancel: HANDLE,
      Event: HANDLE,
   ) -> NTSTATUS;
   pub fn RtlDeleteTimerQueue(TimerQueueHandle: HANDLE) -> NTSTATUS;
   pub fn RtlDeleteTimerQueueEx(TimerQueueHandle: HANDLE, Event: HANDLE) -> NTSTATUS;
   pub fn RtlFormatCurrentUserKeyPath(CurrentUserKeyPath: PUNICODE_STRING) -> NTSTATUS;
   pub fn RtlOpenCurrentUser(DesiredAccess: ACCESS_MASK, CurrentUserKey: PHANDLE) -> NTSTATUS;
   pub fn RtlCreateRegistryKey(RelativeTo: ULONG, Path: PCWSTR) -> NTSTATUS;
   pub fn RtlCheckRegistryKey(RelativeTo: ULONG, Path: PCWSTR) -> NTSTATUS;
   pub fn RtlQueryRegistryValues(
      RelativeTo: ULONG,
      Path: PCWSTR,
      QueryTable: PRTL_QUERY_REGISTRY_TABLE,
      Context: PVOID,
      Environment: PVOID,
   ) -> NTSTATUS;
   pub fn RtlQueryRegistryValuesEx(
      RelativeTo: ULONG,
      Path: PCWSTR,
      QueryTable: PRTL_QUERY_REGISTRY_TABLE,
      Context: PVOID,
      Environment: PVOID,
   ) -> NTSTATUS;
   pub fn RtlQueryRegistryValueWithFallback(
      PrimaryHandle: HANDLE,
      FallbackHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      ValueLength: ULONG,
      ValueType: PULONG,
      ValueData: PVOID,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlWriteRegistryValue(
      RelativeTo: ULONG,
      Path: PCWSTR,
      ValueName: PCWSTR,
      ValueType: ULONG,
      ValueData: PVOID,
      ValueLength: ULONG,
   ) -> NTSTATUS;
   pub fn RtlDeleteRegistryValue(RelativeTo: ULONG, Path: PCWSTR, ValueName: PCWSTR) -> NTSTATUS;
   pub fn RtlEnableThreadProfiling(
      ThreadHandle: HANDLE,
      Flags: ULONG,
      HardwareCounters: ULONG64,
      PerformanceDataHandle: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlDisableThreadProfiling(PerformanceDataHandle: PVOID) -> NTSTATUS;
   pub fn RtlQueryThreadProfiling(ThreadHandle: HANDLE, Enabled: PBOOLEAN) -> NTSTATUS;
   pub fn RtlReadThreadProfilingData(
      PerformanceDataHandle: HANDLE,
      Flags: ULONG,
      PerformanceData: PPERFORMANCE_DATA,
   ) -> NTSTATUS;
   pub fn RtlGetNativeSystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      NativeSystemInformation: PVOID,
      InformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtWow64GetNativeSystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      NativeSystemInformation: PVOID,
      InformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlQueueApcWow64Thread(
      ThreadHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn RtlWow64EnableFsRedirection(Wow64FsEnableRedirection: BOOLEAN) -> NTSTATUS;
   pub fn RtlWow64EnableFsRedirectionEx(
      Wow64FsEnableRedirection: PVOID,
      OldFsRedirectionLevel: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlComputeCrc32(PartialCrc: ULONG32, Buffer: PVOID, Length: ULONG) -> ULONG32;
   pub fn RtlEncodePointer(Ptr: PVOID) -> PVOID;
   pub fn RtlDecodePointer(Ptr: PVOID) -> PVOID;
   pub fn RtlEncodeSystemPointer(Ptr: PVOID) -> PVOID;
   pub fn RtlDecodeSystemPointer(Ptr: PVOID) -> PVOID;
   pub fn RtlEncodeRemotePointer(
      ProcessHandle: HANDLE,
      Pointer: PVOID,
      EncodedPointer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlDecodeRemotePointer(
      ProcessHandle: HANDLE,
      Pointer: PVOID,
      DecodedPointer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlIsProcessorFeaturePresent(ProcessorFeature: ULONG) -> BOOLEAN;
   pub fn RtlGetCurrentProcessorNumber() -> ULONG;
   pub fn RtlGetCurrentProcessorNumberEx(ProcessorNumber: PPROCESSOR_NUMBER);
   pub fn RtlPushFrame(Frame: PTEB_ACTIVE_FRAME);
   pub fn RtlPopFrame(Frame: PTEB_ACTIVE_FRAME);
   pub fn RtlGetFrame() -> PTEB_ACTIVE_FRAME;
   pub fn RtlWalkFrameChain(Callers: *mut PVOID, Count: ULONG, Flags: ULONG) -> ULONG;
   pub fn RtlGetCallersAddress(CallersAddress: *mut PVOID, CallersCaller: *mut PVOID);
   pub fn RtlGetEnabledExtendedFeatures(FeatureMask: ULONG64) -> ULONG64;
   pub fn RtlGetEnabledExtendedAndSupervisorFeatures(FeatureMask: ULONG64) -> ULONG64;
   pub fn RtlLocateSupervisorFeature(
      XStateHeader: PXSAVE_AREA_HEADER,
      FeatureId: ULONG,
      Length: PULONG,
   ) -> PVOID;
   pub fn RtlQueryElevationFlags(Flags: PRTL_ELEVATION_FLAGS) -> NTSTATUS;
   pub fn RtlRegisterThreadWithCsrss() -> NTSTATUS;
   pub fn RtlLockCurrentThread() -> NTSTATUS;
   pub fn RtlUnlockCurrentThread() -> NTSTATUS;
   pub fn RtlLockModuleSection(Address: PVOID) -> NTSTATUS;
   pub fn RtlUnlockModuleSection(Address: PVOID) -> NTSTATUS;
   pub fn RtlGetUnloadEventTrace() -> PRTL_UNLOAD_EVENT_TRACE;
   pub fn RtlGetUnloadEventTraceEx(
      ElementSize: *mut PULONG,
      ElementCount: *mut PULONG,
      EventTrace: *mut PVOID,
   ) -> PRTL_UNLOAD_EVENT_TRACE;
   pub fn RtlCaptureStackBackTrace(
      FramesToSkip: DWORD,
      FramesToCapture: DWORD,
      BackTrace: *mut PVOID,
      BackTraceHash: PDWORD,
   ) -> WORD;
   pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
   pub fn RtlCaptureContext2(ContextRecord: PCONTEXT);
   pub fn RtlRestoreContext(ContextRecord: PCONTEXT, ExceptionRecord: *mut _EXCEPTION_RECORD);
   pub fn RtlUnwind(
      TargetFrame: PVOID,
      TargetIp: PVOID,
      ExceptionRecord: PEXCEPTION_RECORD,
      ReturnValue: PVOID,
   );
   pub fn RtlPcToFileHeader(PcValue: PVOID, BaseOfImage: *mut PVOID) -> PVOID;
   pub fn RtlQueryPerformanceCounter(PerformanceCounter: PLARGE_INTEGER) -> LOGICAL;
   pub fn RtlQueryPerformanceFrequency(PerformanceFrequency: PLARGE_INTEGER) -> LOGICAL;
   pub fn RtlQueryImageMitigationPolicy(
      ImagePath: PCWSTR,
      Policy: IMAGE_MITIGATION_POLICY,
      Flags: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlSetImageMitigationPolicy(
      ImagePath: PCWSTR,
      Policy: IMAGE_MITIGATION_POLICY,
      Flags: ULONG,
      Buffer: PVOID,
      BufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlGetCurrentServiceSessionId() -> ULONG;
   pub fn RtlGetActiveConsoleId() -> ULONG;
   pub fn RtlGetConsoleSessionForegroundProcessId() -> LONGLONG;
   pub fn RtlGetTokenNamedObjectPath(
      TokenHandle: HANDLE,
      Sid: PSID,
      ObjectPath: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlGetAppContainerNamedObjectPath(
      TokenHandle: HANDLE,
      AppContainerSid: PSID,
      RelativePath: BOOLEAN,
      ObjectPath: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn RtlGetAppContainerParent(
      AppContainerSid: PSID,
      AppContainerSidParent: *mut PSID,
   ) -> NTSTATUS;
   pub fn RtlCheckSandboxedToken(TokenHandle: HANDLE, IsSandboxed: PBOOLEAN) -> NTSTATUS;
   pub fn RtlCheckTokenCapability(
      TokenHandle: HANDLE,
      CapabilitySidToCheck: PSID,
      HasCapability: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlCapabilityCheck(
      TokenHandle: HANDLE,
      CapabilityName: PUNICODE_STRING,
      HasCapability: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlCheckTokenMembership(
      TokenHandle: HANDLE,
      SidToCheck: PSID,
      IsMember: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlCheckTokenMembershipEx(
      TokenHandle: HANDLE,
      SidToCheck: PSID,
      Flags: ULONG,
      IsMember: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryTokenHostIdAsUlong64(TokenHandle: HANDLE, HostId: PULONG64) -> NTSTATUS;
   pub fn RtlIsParentOfChildAppContainer(
      ParentAppContainerSid: PSID,
      ChildAppContainerSid: PSID,
   ) -> BOOLEAN;
   pub fn RtlIsApiSetImplemented(ApiSetName: PCSTR) -> NTSTATUS;
   pub fn RtlIsCapabilitySid(Sid: PSID) -> BOOLEAN;
   pub fn RtlIsPackageSid(Sid: PSID) -> BOOLEAN;
   pub fn RtlIsValidProcessTrustLabelSid(Sid: PSID) -> BOOLEAN;
   pub fn RtlGetAppContainerSidType(
      AppContainerSid: PSID,
      AppContainerSidType: PAPPCONTAINER_SID_TYPE,
   ) -> NTSTATUS;
   pub fn RtlFlsAlloc(Callback: PFLS_CALLBACK_FUNCTION, FlsIndex: PULONG) -> NTSTATUS;
   pub fn RtlFlsAllocEx(
      Callback: PFLS_CALLBACK_FUNCTION,
      arg1: PULONG,
      FlsIndex: PULONG,
   ) -> NTSTATUS;
   pub fn RtlFlsFree(FlsIndex: ULONG) -> NTSTATUS;
   pub fn RtlFlsGetValue(FlsIndex: ULONG, FlsData: *mut PVOID) -> NTSTATUS;
   pub fn RtlFlsGetValue2(FlsIndex: ULONG) -> PVOID;
   pub fn RtlFlsSetValue(FlsIndex: ULONG, FlsData: PVOID) -> NTSTATUS;
   pub fn RtlProcessFlsData(ProcessHandle: HANDLE, FlsData: *mut PVOID) -> NTSTATUS;
   pub fn RtlTlsAlloc(TlsIndex: PULONG) -> NTSTATUS;
   pub fn RtlTlsFree(TlsIndex: ULONG) -> NTSTATUS;
   pub fn RtlTlsSetValue(TlsIndex: ULONG, TlsData: PVOID) -> NTSTATUS;
   pub fn RtlIsStateSeparationEnabled() -> BOOLEAN;
   pub fn RtlGetPersistedStateLocation(
      SourceID: PCWSTR,
      CustomValue: PCWSTR,
      DefaultPath: PCWSTR,
      StateLocationType: STATE_LOCATION_TYPE,
      TargetPath: PWCHAR,
      BufferLengthIn: ULONG,
      BufferLengthOut: PULONG,
   ) -> NTSTATUS;
   pub fn RtlIsCloudFilesPlaceholder(FileAttributes: ULONG, ReparseTag: ULONG) -> BOOLEAN;
   pub fn RtlIsPartialPlaceholder(FileAttributes: ULONG, ReparseTag: ULONG) -> BOOLEAN;
   pub fn RtlIsPartialPlaceholderFileHandle(
      FileHandle: HANDLE,
      IsPartialPlaceholder: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlIsPartialPlaceholderFileInfo(
      InfoBuffer: PVOID,
      InfoClass: FILE_INFORMATION_CLASS,
      IsPartialPlaceholder: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryThreadPlaceholderCompatibilityMode() -> CHAR;
   pub fn RtlSetThreadPlaceholderCompatibilityMode(Mode: CHAR) -> CHAR;
   pub fn RtlQueryProcessPlaceholderCompatibilityMode() -> CHAR;
   pub fn RtlSetProcessPlaceholderCompatibilityMode(Mode: CHAR) -> CHAR;
   pub fn RtlIsNonEmptyDirectoryReparsePointAllowed(ReparseTag: ULONG) -> BOOLEAN;
   pub fn RtlAppxIsFileOwnedByTrustedInstaller(
      FileHandle: HANDLE,
      IsFileOwnedByTrustedInstaller: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryPackageClaims(
      TokenHandle: HANDLE,
      PackageFullName: PWSTR,
      PackageSize: PSIZE_T,
      AppId: PWSTR,
      AppIdSize: PSIZE_T,
      DynamicId: PGUID,
      PkgClaim: PPS_PKG_CLAIM,
      AttributesPresent: PULONG64,
   ) -> NTSTATUS;
   pub fn RtlQueryPackageIdentity(
      TokenHandle: HANDLE,
      PackageFullName: PWSTR,
      PackageSize: PSIZE_T,
      AppId: PWSTR,
      AppIdSize: PSIZE_T,
      Packaged: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlQueryPackageIdentityEx(
      TokenHandle: HANDLE,
      PackageFullName: PWSTR,
      PackageSize: PSIZE_T,
      AppId: PWSTR,
      AppIdSize: PSIZE_T,
      DynamicId: PGUID,
      Flags: PULONG64,
   ) -> NTSTATUS;
   pub fn RtlQueryProtectedPolicy(PolicyGuid: PGUID, PolicyValue: PULONG_PTR) -> NTSTATUS;
   pub fn RtlSetProtectedPolicy(
      PolicyGuid: PGUID,
      PolicyValue: ULONG_PTR,
      OldPolicyValue: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn RtlIsEnclaveFeaturePresent(FeatureMask: ULONG) -> BOOLEAN;
   pub fn RtlIsMultiSessionSku() -> BOOLEAN;
   pub fn RtlIsMultiUsersInSessionSku() -> BOOLEAN;
   pub fn RtlGetSessionProperties(SessionId: ULONG, SharedUserSessionId: PULONG) -> NTSTATUS;
   pub fn RtlCreateBootStatusDataFile() -> NTSTATUS;
   pub fn RtlLockBootStatusData(FileHandle: PHANDLE) -> NTSTATUS;
   pub fn RtlUnlockBootStatusData(FileHandle: HANDLE) -> NTSTATUS;
   pub fn RtlGetSetBootStatusData(
      FileHandle: HANDLE,
      Read: BOOLEAN,
      DataClass: RTL_BSD_ITEM_TYPE,
      Buffer: PVOID,
      BufferSize: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlCheckBootStatusIntegrity(FileHandle: HANDLE, Verified: PBOOLEAN) -> NTSTATUS;
   pub fn RtlRestoreBootStatusDefaults(FileHandle: HANDLE) -> NTSTATUS;
   pub fn RtlRestoreSystemBootStatusDefaults() -> NTSTATUS;
   pub fn RtlGetSystemBootStatus(
      BootStatusInformationClass: RTL_BSD_ITEM_TYPE,
      DataBuffer: PVOID,
      DataLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlSetSystemBootStatus(
      BootStatusInformationClass: RTL_BSD_ITEM_TYPE,
      DataBuffer: PVOID,
      DataLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn RtlCheckPortableOperatingSystem(IsPortable: PBOOLEAN) -> NTSTATUS;
   pub fn RtlSetPortableOperatingSystem(IsPortable: BOOLEAN) -> NTSTATUS;
   pub fn RtlSetProxiedProcessId(ProxiedProcessId: ULONG) -> ULONG;
   pub fn RtlFindClosestEncodableLength(
      SourceLength: ULONGLONG,
      TargetLength: PULONGLONG,
   ) -> NTSTATUS;
   pub fn RtlRegisterSecureMemoryCacheCallback(
      Callback: PRTL_SECURE_MEMORY_CACHE_CALLBACK,
   ) -> NTSTATUS;
   pub fn RtlDeregisterSecureMemoryCacheCallback(
      Callback: PRTL_SECURE_MEMORY_CACHE_CALLBACK,
   ) -> NTSTATUS;
   pub fn RtlFlushSecureMemoryCache(MemoryCache: PVOID, MemoryLength: SIZE_T) -> BOOLEAN;
   pub fn RtlNotifyFeatureUsage(FeatureUsageReport: PRTL_FEATURE_USAGE_REPORT) -> NTSTATUS;
   pub fn RtlQueryFeatureConfiguration(
      FeatureId: RTL_FEATURE_ID,
      ConfigurationType: RTL_FEATURE_CONFIGURATION_TYPE,
      ChangeStamp: PRTL_FEATURE_CHANGE_STAMP,
      FeatureConfiguration: PRTL_FEATURE_CONFIGURATION,
   ) -> NTSTATUS;
   pub fn RtlSetFeatureConfigurations(
      PreviousChangeStamp: PRTL_FEATURE_CHANGE_STAMP,
      ConfigurationType: RTL_FEATURE_CONFIGURATION_TYPE,
      ConfigurationUpdates: PRTL_FEATURE_CONFIGURATION_UPDATE,
      ConfigurationUpdateCount: SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlQueryAllFeatureConfigurations(
      ConfigurationType: RTL_FEATURE_CONFIGURATION_TYPE,
      ChangeStamp: PRTL_FEATURE_CHANGE_STAMP,
      Configurations: PRTL_FEATURE_CONFIGURATION,
      ConfigurationCount: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlQueryFeatureConfigurationChangeStamp() -> RTL_FEATURE_CHANGE_STAMP;
   pub fn RtlQueryFeatureUsageNotificationSubscriptions(
      Subscriptions: PRTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS,
      SubscriptionCount: PSIZE_T,
   ) -> NTSTATUS;
   pub fn RtlRegisterFeatureConfigurationChangeNotification(
      Callback: PRTL_FEATURE_CONFIGURATION_CHANGE_CALLBACK,
      Context: PVOID,
      ObservedChangeStamp: PRTL_FEATURE_CHANGE_STAMP,
      RegistrationHandle: PRTL_FEATURE_CONFIGURATION_CHANGE_REGISTRATION,
   ) -> NTSTATUS;
   pub fn RtlUnregisterFeatureConfigurationChangeNotification(
      RegistrationHandle: RTL_FEATURE_CONFIGURATION_CHANGE_REGISTRATION,
   ) -> NTSTATUS;
   pub fn RtlSubscribeForFeatureUsageNotification(
      SubscriptionDetails: PRTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS,
      SubscriptionCount: SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlUnsubscribeFromFeatureUsageNotifications(
      SubscriptionDetails: PRTL_FEATURE_USAGE_SUBSCRIPTION_DETAILS,
      SubscriptionCount: SIZE_T,
   ) -> NTSTATUS;
   pub fn RtlOverwriteFeatureConfigurationBuffer(
      PreviousChangeStamp: PRTL_FEATURE_CHANGE_STAMP,
      ConfigurationType: RTL_FEATURE_CONFIGURATION_TYPE,
      ConfigurationBuffer: PVOID,
      ConfigurationBufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn RtlNotifyFeatureToggleUsage(
      FeatureUsageReport: PRTL_FEATURE_USAGE_REPORT,
      FeatureId: RTL_FEATURE_ID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlRunOnceInitialize(RunOnce: PRTL_RUN_ONCE);
   pub fn RtlRunOnceExecuteOnce(
      RunOnce: PRTL_RUN_ONCE,
      InitFn: PRTL_RUN_ONCE_INIT_FN,
      Parameter: PVOID,
      Context: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlRunOnceBeginInitialize(
      RunOnce: PRTL_RUN_ONCE,
      Flags: ULONG,
      Context: *mut PVOID,
   ) -> NTSTATUS;
   pub fn RtlRunOnceComplete(RunOnce: PRTL_RUN_ONCE, Flags: ULONG, Context: PVOID) -> NTSTATUS;
   pub fn RtlEqualWnfChangeStamps(
      ChangeStamp1: WNF_CHANGE_STAMP,
      ChangeStamp2: WNF_CHANGE_STAMP,
   ) -> BOOLEAN;
   pub fn RtlQueryWnfStateData(
      ChangeStamp: PWNF_CHANGE_STAMP,
      StateName: WNF_STATE_NAME,
      Callback: PWNF_USER_CALLBACK,
      CallbackContext: PVOID,
      TypeId: PWNF_TYPE_ID,
   ) -> NTSTATUS;
   pub fn RtlPublishWnfStateData(
      StateName: WNF_STATE_NAME,
      TypeId: PCWNF_TYPE_ID,
      Buffer: *const ::core::ffi::c_void,
      Length: ULONG,
      ExplicitScope: *const ::core::ffi::c_void,
   ) -> NTSTATUS;
   pub fn RtlSubscribeWnfStateChangeNotification(
      SubscriptionHandle: *mut PVOID,
      StateName: WNF_STATE_NAME,
      ChangeStamp: WNF_CHANGE_STAMP,
      Callback: PWNF_USER_CALLBACK,
      CallbackContext: PVOID,
      TypeId: PCWNF_TYPE_ID,
      SerializationGroup: ULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlUnsubscribeWnfStateChangeNotification(Callback: PWNF_USER_CALLBACK) -> NTSTATUS;
   pub fn RtlWnfDllUnloadCallback(DllBase: PVOID) -> NTSTATUS;
   pub fn NtCopyFileChunk(
      SourceHandle: HANDLE,
      DestinationHandle: HANDLE,
      EventHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Length: ULONG,
      SourceOffset: PLARGE_INTEGER,
      DestOffset: PLARGE_INTEGER,
      SourceKey: PULONG,
      DestKey: PULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn RtlQueryPropertyStore(Key: ULONG_PTR, Context: PULONG_PTR) -> NTSTATUS;
   pub fn RtlRemovePropertyStore(Key: ULONG_PTR, Context: PULONG_PTR) -> NTSTATUS;
   pub fn RtlCompareExchangePropertyStore(
      Key: ULONG_PTR,
      Comperand: PULONG_PTR,
      Exchange: PULONG_PTR,
      Context: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn RtlWow64ChangeThreadState(
      ThreadStateChangeHandle: HANDLE,
      ThreadHandle: HANDLE,
      StateChangeType: THREAD_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn RtlGetCurrentThreadPrimaryGroup() -> USHORT;
   pub fn NtCreateToken(
      TokenHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: TOKEN_TYPE,
      AuthenticationId: PLUID,
      ExpirationTime: PLARGE_INTEGER,
      User: PTOKEN_USER,
      Groups: PTOKEN_GROUPS,
      Privileges: PTOKEN_PRIVILEGES,
      Owner: PTOKEN_OWNER,
      PrimaryGroup: PTOKEN_PRIMARY_GROUP,
      DefaultDacl: PTOKEN_DEFAULT_DACL,
      Source: PTOKEN_SOURCE,
   ) -> NTSTATUS;
   pub fn NtCreateLowBoxToken(
      TokenHandle: PHANDLE,
      ExistingTokenHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PackageSid: PSID,
      CapabilityCount: ULONG,
      Capabilities: PSID_AND_ATTRIBUTES,
      HandleCount: ULONG,
      Handles: *mut HANDLE,
   ) -> NTSTATUS;
   pub fn NtCreateTokenEx(
      TokenHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: TOKEN_TYPE,
      AuthenticationId: PLUID,
      ExpirationTime: PLARGE_INTEGER,
      User: PTOKEN_USER,
      Groups: PTOKEN_GROUPS,
      Privileges: PTOKEN_PRIVILEGES,
      UserAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceGroups: PTOKEN_GROUPS,
      MandatoryPolicy: PTOKEN_MANDATORY_POLICY,
      Owner: PTOKEN_OWNER,
      PrimaryGroup: PTOKEN_PRIMARY_GROUP,
      DefaultDacl: PTOKEN_DEFAULT_DACL,
      Source: PTOKEN_SOURCE,
   ) -> NTSTATUS;
   pub fn NtOpenProcessToken(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtOpenProcessTokenEx(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtOpenThreadToken(
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      OpenAsSelf: BOOLEAN,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtOpenThreadTokenEx(
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      OpenAsSelf: BOOLEAN,
      HandleAttributes: ULONG,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtDuplicateToken(
      ExistingTokenHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      EffectiveOnly: BOOLEAN,
      Type: TOKEN_TYPE,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtQueryInformationToken(
      TokenHandle: HANDLE,
      TokenInformationClass: ULONG,
      TokenInformation: PVOID,
      TokenInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationToken(
      TokenHandle: HANDLE,
      TokenInformationClass: ULONG,
      TokenInformation: PVOID,
      TokenInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtAdjustPrivilegesToken(
      TokenHandle: HANDLE,
      DisableAllPrivileges: BOOLEAN,
      NewState: PTOKEN_PRIVILEGES,
      BufferLength: ULONG,
      PreviousState: PTOKEN_PRIVILEGES,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAdjustGroupsToken(
      TokenHandle: HANDLE,
      ResetToDefault: BOOLEAN,
      NewState: PTOKEN_GROUPS,
      BufferLength: ULONG,
      PreviousState: PTOKEN_GROUPS,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAdjustTokenClaimsAndDeviceGroups(
      TokenHandle: HANDLE,
      UserResetToDefault: BOOLEAN,
      DeviceResetToDefault: BOOLEAN,
      DeviceGroupsResetToDefault: BOOLEAN,
      NewUserState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      NewDeviceState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      NewDeviceGroupsState: PTOKEN_GROUPS,
      UserBufferLength: ULONG,
      PreviousUserState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceBufferLength: ULONG,
      PreviousDeviceState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceGroupsBufferLength: ULONG,
      PreviousDeviceGroups: PTOKEN_GROUPS,
      UserReturnLength: PULONG,
      DeviceReturnLength: PULONG,
      DeviceGroupsReturnBufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtFilterToken(
      ExistingTokenHandle: HANDLE,
      Flags: ULONG,
      SidsToDisable: PTOKEN_GROUPS,
      PrivilegesToDelete: PTOKEN_PRIVILEGES,
      RestrictedSids: PTOKEN_GROUPS,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtFilterTokenEx(
      ExistingTokenHandle: HANDLE,
      Flags: ULONG,
      SidsToDisable: PTOKEN_GROUPS,
      PrivilegesToDelete: PTOKEN_PRIVILEGES,
      RestrictedSids: PTOKEN_GROUPS,
      DisableUserClaimsCount: ULONG,
      UserClaimsToDisable: PUNICODE_STRING,
      DisableDeviceClaimsCount: ULONG,
      DeviceClaimsToDisable: PUNICODE_STRING,
      DeviceGroupsToDisable: PTOKEN_GROUPS,
      RestrictedUserAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      RestrictedDeviceAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      RestrictedDeviceGroups: PTOKEN_GROUPS,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn NtCompareTokens(
      FirstTokenHandle: HANDLE,
      SecondTokenHandle: HANDLE,
      Equal: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtPrivilegeCheck(
      ClientToken: HANDLE,
      RequiredPrivileges: PPRIVILEGE_SET,
      Result: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtImpersonateAnonymousToken(ThreadHandle: HANDLE) -> NTSTATUS;
   pub fn NtQuerySecurityAttributesToken(
      TokenHandle: HANDLE,
      Attributes: PUNICODE_STRING,
      NumberOfAttributes: ULONG,
      Buffer: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtAccessCheck(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByType(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByTypeResultList(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn NtSetCachedSigningLevel(
      Flags: ULONG,
      InputSigningLevel: SE_SIGNING_LEVEL,
      SourceFiles: PHANDLE,
      SourceFileCount: ULONG,
      TargetFile: HANDLE,
   ) -> NTSTATUS;
   pub fn NtGetCachedSigningLevel(
      File: HANDLE,
      Flags: PULONG,
      SigningLevel: PSE_SIGNING_LEVEL,
      Thumbprint: PUCHAR,
      ThumbprintSize: PULONG,
      ThumbprintAlgorithm: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetCachedSigningLevel2(
      Flags: ULONG,
      InputSigningLevel: SE_SIGNING_LEVEL,
      SourceFiles: PHANDLE,
      SourceFileCount: ULONG,
      TargetFile: HANDLE,
      CacheInformation: *mut SE_SET_FILE_CACHE_INFORMATION,
   ) -> NTSTATUS;
   pub fn NtCompareSigningLevels(
      FirstSigningLevel: SE_SIGNING_LEVEL,
      SecondSigningLevel: SE_SIGNING_LEVEL,
   ) -> NTSTATUS;
   pub fn NtAccessCheckAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      DesiredAccess: ACCESS_MASK,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByTypeAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByTypeResultListAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtAccessCheckByTypeResultListAndAuditAlarmByHandle(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ClientToken: HANDLE,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtOpenObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      GrantedAccess: ACCESS_MASK,
      Privileges: PPRIVILEGE_SET,
      ObjectCreation: BOOLEAN,
      AccessGranted: BOOLEAN,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtPrivilegeObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      Privileges: PPRIVILEGE_SET,
      AccessGranted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtCloseObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      GenerateOnClose: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtDeleteObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      GenerateOnClose: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtPrivilegedServiceAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      ServiceName: PUNICODE_STRING,
      ClientToken: HANDLE,
      Privileges: PPRIVILEGE_SET,
      AccessGranted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn NtCreateTransactionManager(
      TmHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LogFileName: PUNICODE_STRING,
      CreateOptions: ULONG,
      CommitStrength: ULONG,
   ) -> NTSTATUS;
   pub fn NtOpenTransactionManager(
      TmHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LogFileName: PUNICODE_STRING,
      TmIdentity: LPGUID,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn NtRenameTransactionManager(
      LogFileName: PUNICODE_STRING,
      ExistingTransactionManagerGuid: LPGUID,
   ) -> NTSTATUS;
   pub fn NtRollforwardTransactionManager(
      TransactionManagerHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtRecoverTransactionManager(TransactionManagerHandle: HANDLE) -> NTSTATUS;
   pub fn NtQueryInformationTransactionManager(
      TransactionManagerHandle: HANDLE,
      TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
      TransactionManagerInformation: PVOID,
      TransactionManagerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationTransactionManager(
      TmHandle: HANDLE,
      TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
      TransactionManagerInformation: PVOID,
      TransactionManagerInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtEnumerateTransactionObject(
      RootObjectHandle: HANDLE,
      QueryType: KTMOBJECT_TYPE,
      ObjectCursor: PKTMOBJECT_CURSOR,
      ObjectCursorLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateTransaction(
      TransactionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Uow: LPGUID,
      TmHandle: HANDLE,
      CreateOptions: ULONG,
      IsolationLevel: ULONG,
      IsolationFlags: ULONG,
      Timeout: PLARGE_INTEGER,
      Description: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtOpenTransaction(
      TransactionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Uow: LPGUID,
      TmHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn NtQueryInformationTransaction(
      TransactionHandle: HANDLE,
      TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
      TransactionInformation: PVOID,
      TransactionInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationTransaction(
      TransactionHandle: HANDLE,
      TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
      TransactionInformation: PVOID,
      TransactionInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
   pub fn NtRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
   pub fn NtCreateEnlistment(
      EnlistmentHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ResourceManagerHandle: HANDLE,
      TransactionHandle: HANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
      NotificationMask: NOTIFICATION_MASK,
      EnlistmentKey: PVOID,
   ) -> NTSTATUS;
   pub fn NtOpenEnlistment(
      EnlistmentHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ResourceManagerHandle: HANDLE,
      EnlistmentGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtQueryInformationEnlistment(
      EnlistmentHandle: HANDLE,
      EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
      EnlistmentInformation: PVOID,
      EnlistmentInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationEnlistment(
      EnlistmentHandle: HANDLE,
      EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
      EnlistmentInformation: PVOID,
      EnlistmentInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID) -> NTSTATUS;
   pub fn NtPrePrepareEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtPrepareEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
      -> NTSTATUS;
   pub fn NtCommitEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtRollbackEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtPrePrepareComplete(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtPrepareComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtCommitComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtReadOnlyEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtRollbackComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtSinglePhaseReject(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
      -> NTSTATUS;
   pub fn NtCreateResourceManager(
      ResourceManagerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      TmHandle: HANDLE,
      RmGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
      Description: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn NtOpenResourceManager(
      ResourceManagerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      TmHandle: HANDLE,
      ResourceManagerGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtRecoverResourceManager(ResourceManagerHandle: HANDLE) -> NTSTATUS;
   pub fn NtGetNotificationResourceManager(
      ResourceManagerHandle: HANDLE,
      TransactionNotification: PTRANSACTION_NOTIFICATION,
      NotificationLength: ULONG,
      Timeout: PLARGE_INTEGER,
      ReturnLength: PULONG,
      Asynchronous: ULONG,
      AsynchronousContext: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn NtQueryInformationResourceManager(
      ResourceManagerHandle: HANDLE,
      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
      ResourceManagerInformation: PVOID,
      ResourceManagerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtSetInformationResourceManager(
      ResourceManagerHandle: HANDLE,
      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
      ResourceManagerInformation: PVOID,
      ResourceManagerInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn NtRegisterProtocolAddressInformation(
      ResourceManager: HANDLE,
      ProtocolId: PCRM_PROTOCOL_ID,
      ProtocolInformationSize: ULONG,
      ProtocolInformation: PVOID,
      CreateOptions: ULONG,
   ) -> NTSTATUS;
   pub fn NtPropagationComplete(
      ResourceManagerHandle: HANDLE,
      RequestCookie: ULONG,
      BufferLength: ULONG,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn NtPropagationFailed(
      ResourceManagerHandle: HANDLE,
      RequestCookie: ULONG,
      PropStatus: NTSTATUS,
   ) -> NTSTATUS;
   pub fn NtFreezeTransactions(
      FreezeTimeout: PLARGE_INTEGER,
      ThawTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn NtThawTransactions() -> NTSTATUS;
   pub fn TpAllocPool(PoolReturn: *mut PTP_POOL, Reserved: PVOID) -> NTSTATUS;
   pub fn TpReleasePool(Pool: PTP_POOL);
   pub fn TpSetPoolMaxThreads(Pool: PTP_POOL, MaxThreads: ULONG);
   pub fn TpSetPoolMinThreads(Pool: PTP_POOL, MinThreads: ULONG) -> NTSTATUS;
   pub fn TpQueryPoolStackInformation(
      Pool: PTP_POOL,
      PoolStackInformation: PTP_POOL_STACK_INFORMATION,
   ) -> NTSTATUS;
   pub fn TpSetPoolStackInformation(
      Pool: PTP_POOL,
      PoolStackInformation: PTP_POOL_STACK_INFORMATION,
   ) -> NTSTATUS;
   pub fn TpSetPoolThreadBasePriority(Pool: PTP_POOL, BasePriority: ULONG) -> NTSTATUS;
   pub fn TpAllocCleanupGroup(CleanupGroupReturn: *mut PTP_CLEANUP_GROUP) -> NTSTATUS;
   pub fn TpReleaseCleanupGroup(CleanupGroup: PTP_CLEANUP_GROUP);
   pub fn TpReleaseCleanupGroupMembers(
      CleanupGroup: PTP_CLEANUP_GROUP,
      CancelPendingCallbacks: LOGICAL,
      CleanupParameter: PVOID,
   );
   pub fn TpCallbackSetEventOnCompletion(Instance: PTP_CALLBACK_INSTANCE, Event: HANDLE);
   pub fn TpCallbackReleaseSemaphoreOnCompletion(
      Instance: PTP_CALLBACK_INSTANCE,
      Semaphore: HANDLE,
      ReleaseCount: ULONG,
   );
   pub fn TpCallbackReleaseMutexOnCompletion(Instance: PTP_CALLBACK_INSTANCE, Mutex: HANDLE);
   pub fn TpCallbackLeaveCriticalSectionOnCompletion(
      Instance: PTP_CALLBACK_INSTANCE,
      CriticalSection: PRTL_CRITICAL_SECTION,
   );
   pub fn TpCallbackUnloadDllOnCompletion(Instance: PTP_CALLBACK_INSTANCE, DllHandle: PVOID);
   pub fn TpCallbackMayRunLong(Instance: PTP_CALLBACK_INSTANCE) -> NTSTATUS;
   pub fn TpDisassociateCallback(Instance: PTP_CALLBACK_INSTANCE);
   pub fn TpSimpleTryPost(
      Callback: PTP_SIMPLE_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpAllocWork(
      WorkReturn: *mut PTP_WORK,
      Callback: PTP_WORK_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseWork(Work: PTP_WORK);
   pub fn TpPostWork(Work: PTP_WORK);
   pub fn TpWaitForWork(Work: PTP_WORK, CancelPendingCallbacks: LOGICAL);
   pub fn TpAllocTimer(
      Timer: *mut PTP_TIMER,
      Callback: PTP_TIMER_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseTimer(Timer: PTP_TIMER);
   pub fn TpSetTimer(Timer: PTP_TIMER, DueTime: PLARGE_INTEGER, Period: ULONG, WindowLength: ULONG);
   pub fn TpSetTimerEx(
      Timer: PTP_TIMER,
      DueTime: PLARGE_INTEGER,
      Period: ULONG,
      WindowLength: ULONG,
   ) -> NTSTATUS;
   pub fn TpIsTimerSet(Timer: PTP_TIMER) -> LOGICAL;
   pub fn TpWaitForTimer(Timer: PTP_TIMER, CancelPendingCallbacks: LOGICAL);
   pub fn TpAllocWait(
      WaitReturn: *mut PTP_WAIT,
      Callback: PTP_WAIT_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseWait(Wait: PTP_WAIT);
   pub fn TpSetWait(Wait: PTP_WAIT, Handle: HANDLE, Timeout: PLARGE_INTEGER);
   pub fn TpSetWaitEx(
      Wait: PTP_WAIT,
      Handle: HANDLE,
      Timeout: PLARGE_INTEGER,
      Reserved: PVOID,
   ) -> NTSTATUS;
   pub fn TpWaitForWait(Wait: PTP_WAIT, CancelPendingCallbacks: LOGICAL);
   pub fn TpAllocIoCompletion(
      IoReturn: *mut PTP_IO,
      File: HANDLE,
      Callback: PTP_IO_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseIoCompletion(Io: PTP_IO);
   pub fn TpStartAsyncIoOperation(Io: PTP_IO);
   pub fn TpCancelAsyncIoOperation(Io: PTP_IO);
   pub fn TpWaitForIoCompletion(Io: PTP_IO, CancelPendingCallbacks: LOGICAL);
   pub fn TpAllocAlpcCompletion(
      AlpcReturn: *mut PTP_ALPC,
      AlpcPort: HANDLE,
      Callback: PTP_ALPC_CALLBACK,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpAllocAlpcCompletionEx(
      AlpcReturn: *mut PTP_ALPC,
      AlpcPort: HANDLE,
      Callback: PTP_ALPC_CALLBACK_EX,
      Context: PVOID,
      CallbackEnviron: PTP_CALLBACK_ENVIRON,
   ) -> NTSTATUS;
   pub fn TpReleaseAlpcCompletion(Alpc: PTP_ALPC);
   pub fn TpWaitForAlpcCompletion(Alpc: PTP_ALPC);
   pub fn TpAlpcRegisterCompletionList(Alpc: PTP_ALPC);
   pub fn TpAlpcUnregisterCompletionList(Alpc: PTP_ALPC);
   pub fn TpCaptureCaller(Type: TP_TRACE_TYPE);
   pub fn TpCheckTerminateWorker(Thread: HANDLE);
   pub fn RtlDispatchException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
   ) -> BOOLEAN;
   pub fn RtlRaiseStatus(Status: NTSTATUS) -> !;
   pub fn RtlRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
   pub fn RtlRaiseExceptionForReturnAddressHijack();
   pub fn RtlRaiseNoncontinuableException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
   ) -> !;
   pub fn NtContinue(ContextRecord: PCONTEXT, TestAlert: BOOLEAN) -> NTSTATUS;
   pub fn NtContinueEx(ContextRecord: PCONTEXT, ContinueArgument: PVOID) -> NTSTATUS;
   pub fn NtRaiseException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
      FirstChance: BOOLEAN,
   ) -> NTSTATUS;
   pub fn RtlAssert(
      VoidFailedAssertion: PVOID,
      VoidFileName: PVOID,
      LineNumber: ULONG,
      MutableMessage: PSTR,
   ) -> !;
   pub fn UStr32ToUStr(Destination: PUNICODE_STRING, Source: PUNICODE_STRING32);
   pub fn UStrToUStr32(Destination: PUNICODE_STRING32, Source: PUNICODE_STRING);
   pub fn SamFreeMemory(Buffer: PVOID) -> NTSTATUS;
   pub fn SamCloseHandle(SamHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamSetSecurityObject(
      ObjectHandle: SAM_HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn SamQuerySecurityObject(
      ObjectHandle: SAM_HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn SamRidToSid(ObjectHandle: SAM_HANDLE, Rid: ULONG, Sid: *mut PSID) -> NTSTATUS;
   pub fn SamConnect(
      ServerName: PUNICODE_STRING,
      ServerHandle: PSAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn SamConnectWithCreds(
      ServerName: PUNICODE_STRING,
      ServerHandle: PSAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Creds: PRPC_AUTH_IDENTITY_HANDLE,
      Spn: PWCHAR,
      pfDstIsW2K: *mut BOOL,
   ) -> NTSTATUS;
   pub fn SamShutdownSamServer(ServerHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamLookupDomainInSamServer(
      ServerHandle: SAM_HANDLE,
      Name: PUNICODE_STRING,
      DomainId: *mut PSID,
   ) -> NTSTATUS;
   pub fn SamEnumerateDomainsInSamServer(
      ServerHandle: SAM_HANDLE,
      EnumerationContext: PSAM_ENUMERATE_HANDLE,
      Buffer: *mut PVOID,
      PreferedMaximumLength: ULONG,
      CountReturned: PULONG,
   ) -> NTSTATUS;
   pub fn SamOpenDomain(
      ServerHandle: SAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      DomainId: PSID,
      DomainHandle: PSAM_HANDLE,
   ) -> NTSTATUS;
   pub fn SamQueryInformationDomain(
      DomainHandle: SAM_HANDLE,
      DomainInformationClass: DOMAIN_INFORMATION_CLASS,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamSetInformationDomain(
      DomainHandle: SAM_HANDLE,
      DomainInformationClass: DOMAIN_INFORMATION_CLASS,
      DomainInformation: PVOID,
   ) -> NTSTATUS;
   pub fn SamLookupNamesInDomain(
      DomainHandle: SAM_HANDLE,
      Count: ULONG,
      Names: PUNICODE_STRING,
      RelativeIds: *mut PULONG,
      Use: *mut PSID_NAME_USE,
   ) -> NTSTATUS;
   pub fn SamLookupNamesInDomain2(
      DomainHandle: SAM_HANDLE,
      Count: ULONG,
      Names: PUNICODE_STRING,
      Sids: *mut PSID,
      Use: *mut PSID_NAME_USE,
   ) -> NTSTATUS;
   pub fn SamLookupIdsInDomain(
      DomainHandle: SAM_HANDLE,
      Count: ULONG,
      RelativeIds: PULONG,
      Names: *mut PUNICODE_STRING,
      Use: *mut PSID_NAME_USE,
   ) -> NTSTATUS;
   pub fn SamRemoveMemberFromForeignDomain(DomainHandle: SAM_HANDLE, MemberId: PSID) -> NTSTATUS;
   pub fn SamQueryLocalizableAccountsInDomain(
      Domain: SAM_HANDLE,
      Flags: ULONG,
      LanguageId: ULONG,
      Class: DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamEnumerateGroupsInDomain(
      DomainHandle: SAM_HANDLE,
      EnumerationContext: PSAM_ENUMERATE_HANDLE,
      Buffer: *mut PVOID,
      PreferedMaximumLength: ULONG,
      CountReturned: PULONG,
   ) -> NTSTATUS;
   pub fn SamCreateGroupInDomain(
      DomainHandle: SAM_HANDLE,
      AccountName: PUNICODE_STRING,
      DesiredAccess: ACCESS_MASK,
      GroupHandle: PSAM_HANDLE,
      RelativeId: PULONG,
   ) -> NTSTATUS;
   pub fn SamOpenGroup(
      DomainHandle: SAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      GroupId: ULONG,
      GroupHandle: PSAM_HANDLE,
   ) -> NTSTATUS;
   pub fn SamDeleteGroup(GroupHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamQueryInformationGroup(
      GroupHandle: SAM_HANDLE,
      GroupInformationClass: GROUP_INFORMATION_CLASS,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamSetInformationGroup(
      GroupHandle: SAM_HANDLE,
      GroupInformationClass: GROUP_INFORMATION_CLASS,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn SamAddMemberToGroup(
      GroupHandle: SAM_HANDLE,
      MemberId: ULONG,
      Attributes: ULONG,
   ) -> NTSTATUS;
   pub fn SamRemoveMemberFromGroup(GroupHandle: SAM_HANDLE, MemberId: ULONG) -> NTSTATUS;
   pub fn SamGetMembersInGroup(
      GroupHandle: SAM_HANDLE,
      MemberIds: *mut PULONG,
      Attributes: *mut PULONG,
      MemberCount: PULONG,
   ) -> NTSTATUS;
   pub fn SamSetMemberAttributesOfGroup(
      GroupHandle: SAM_HANDLE,
      MemberId: ULONG,
      Attributes: ULONG,
   ) -> NTSTATUS;
   pub fn SamEnumerateAliasesInDomain(
      DomainHandle: SAM_HANDLE,
      EnumerationContext: PSAM_ENUMERATE_HANDLE,
      Buffer: *mut PVOID,
      PreferedMaximumLength: ULONG,
      CountReturned: PULONG,
   ) -> NTSTATUS;
   pub fn SamCreateAliasInDomain(
      DomainHandle: SAM_HANDLE,
      AccountName: PUNICODE_STRING,
      DesiredAccess: ACCESS_MASK,
      AliasHandle: PSAM_HANDLE,
      RelativeId: PULONG,
   ) -> NTSTATUS;
   pub fn SamOpenAlias(
      DomainHandle: SAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      AliasId: ULONG,
      AliasHandle: PSAM_HANDLE,
   ) -> NTSTATUS;
   pub fn SamDeleteAlias(AliasHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamQueryInformationAlias(
      AliasHandle: SAM_HANDLE,
      AliasInformationClass: ALIAS_INFORMATION_CLASS,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamSetInformationAlias(
      AliasHandle: SAM_HANDLE,
      AliasInformationClass: ALIAS_INFORMATION_CLASS,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn SamAddMemberToAlias(AliasHandle: SAM_HANDLE, MemberId: PSID) -> NTSTATUS;
   pub fn SamAddMultipleMembersToAlias(
      AliasHandle: SAM_HANDLE,
      MemberIds: *mut PSID,
      MemberCount: ULONG,
   ) -> NTSTATUS;
   pub fn SamRemoveMemberFromAlias(AliasHandle: SAM_HANDLE, MemberId: PSID) -> NTSTATUS;
   pub fn SamRemoveMultipleMembersFromAlias(
      AliasHandle: SAM_HANDLE,
      MemberIds: *mut PSID,
      MemberCount: ULONG,
   ) -> NTSTATUS;
   pub fn SamGetMembersInAlias(
      AliasHandle: SAM_HANDLE,
      MemberIds: *mut *mut PSID,
      MemberCount: PULONG,
   ) -> NTSTATUS;
   pub fn SamGetAliasMembership(
      DomainHandle: SAM_HANDLE,
      PassedCount: ULONG,
      Sids: *mut PSID,
      MembershipCount: PULONG,
      Aliases: *mut PULONG,
   ) -> NTSTATUS;
   pub fn SamEnumerateUsersInDomain(
      DomainHandle: SAM_HANDLE,
      EnumerationContext: PSAM_ENUMERATE_HANDLE,
      UserAccountControl: ULONG,
      Buffer: *mut PVOID,
      PreferedMaximumLength: ULONG,
      CountReturned: PULONG,
   ) -> NTSTATUS;
   pub fn SamCreateUserInDomain(
      DomainHandle: SAM_HANDLE,
      AccountName: PUNICODE_STRING,
      DesiredAccess: ACCESS_MASK,
      UserHandle: PSAM_HANDLE,
      RelativeId: PULONG,
   ) -> NTSTATUS;
   pub fn SamCreateUser2InDomain(
      DomainHandle: SAM_HANDLE,
      AccountName: PUNICODE_STRING,
      AccountType: ULONG,
      DesiredAccess: ACCESS_MASK,
      UserHandle: PSAM_HANDLE,
      GrantedAccess: PULONG,
      RelativeId: PULONG,
   ) -> NTSTATUS;
   pub fn SamOpenUser(
      DomainHandle: SAM_HANDLE,
      DesiredAccess: ACCESS_MASK,
      UserId: ULONG,
      UserHandle: PSAM_HANDLE,
   ) -> NTSTATUS;
   pub fn SamDeleteUser(UserHandle: SAM_HANDLE) -> NTSTATUS;
   pub fn SamQueryInformationUser(
      UserHandle: SAM_HANDLE,
      UserInformationClass: USER_INFORMATION_CLASS,
      Buffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamSetInformationUser(
      UserHandle: SAM_HANDLE,
      UserInformationClass: USER_INFORMATION_CLASS,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn SamGetGroupsForUser(
      UserHandle: SAM_HANDLE,
      Groups: *mut PGROUP_MEMBERSHIP,
      MembershipCount: PULONG,
   ) -> NTSTATUS;
   pub fn SamChangePasswordUser(
      UserHandle: SAM_HANDLE,
      OldPassword: PUNICODE_STRING,
      NewPassword: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn SamChangePasswordUser2(
      ServerName: PUNICODE_STRING,
      UserName: PUNICODE_STRING,
      OldPassword: PUNICODE_STRING,
      NewPassword: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn SamChangePasswordUser3(
      ServerName: PUNICODE_STRING,
      UserName: PUNICODE_STRING,
      OldPassword: PUNICODE_STRING,
      NewPassword: PUNICODE_STRING,
      EffectivePasswordPolicy: *mut PDOMAIN_PASSWORD_INFORMATION,
      PasswordChangeFailureInfo: *mut PUSER_PWD_CHANGE_FAILURE_INFORMATION,
   ) -> NTSTATUS;
   pub fn SamQueryDisplayInformation(
      DomainHandle: SAM_HANDLE,
      DisplayInformation: DOMAIN_DISPLAY_INFORMATION,
      Index: ULONG,
      EntryCount: ULONG,
      PreferredMaximumLength: ULONG,
      TotalAvailable: PULONG,
      TotalReturned: PULONG,
      ReturnedEntryCount: PULONG,
      SortedBuffer: *mut PVOID,
   ) -> NTSTATUS;
   pub fn SamGetDisplayEnumerationIndex(
      DomainHandle: SAM_HANDLE,
      DisplayInformation: DOMAIN_DISPLAY_INFORMATION,
      Prefix: PUNICODE_STRING,
      Index: PULONG,
   ) -> NTSTATUS;
   pub fn SamRegisterObjectChangeNotification(
      ObjectType: SECURITY_DB_OBJECT_TYPE,
      NotificationEventHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn SamUnregisterObjectChangeNotification(
      ObjectType: SECURITY_DB_OBJECT_TYPE,
      NotificationEventHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn SamGetCompatibilityMode(ObjectHandle: SAM_HANDLE, Mode: *mut ULONG) -> NTSTATUS;
   pub fn SamValidatePassword(
      ServerName: PUNICODE_STRING,
      ValidationType: PASSWORD_POLICY_VALIDATION_TYPE,
      InputArg: PSAM_VALIDATE_INPUT_ARG,
      OutputArg: *mut PSAM_VALIDATE_OUTPUT_ARG,
   ) -> NTSTATUS;
   pub fn SamPerformGenericOperation(
      ServerName: PWSTR,
      OperationType: SAM_GENERIC_OPERATION_TYPE,
      OperationIn: PSAM_GENERIC_OPERATION_INPUT,
      OperationOut: *mut PSAM_GENERIC_OPERATION_OUTPUT,
   ) -> NTSTATUS;
   pub fn NtVdmControl(Service: VDMSERVICECLASS, ServiceData: PVOID) -> NTSTATUS;
   pub fn ApiSetQueryApiSetPresence(Namespace: PCUNICODE_STRING, Present: PBOOLEAN) -> BOOL;
   pub fn ApiSetQueryApiSetPresenceEx(
      Namespace: PCUNICODE_STRING,
      IsInSchema: PBOOLEAN,
      Present: PBOOLEAN,
   ) -> BOOL;
   pub fn NtQuerySecurityPolicy(
      Policy: PCUNICODE_STRING,
      KeyName: PCUNICODE_STRING,
      ValueName: PCUNICODE_STRING,
      ValueType: SECURE_SETTING_VALUE_TYPE,
      Value: PVOID,
      ValueSize: PULONG,
   ) -> NTSTATUS;
   pub fn NtCreateCrossVmEvent(
      CrossVmEvent: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CrossVmEventFlags: ULONG,
      VMID: LPCGUID,
      ServiceID: LPCGUID,
   ) -> NTSTATUS;
   pub fn NtCreateCrossVmMutant(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CrossVmEventFlags: ULONG,
      VMID: LPCGUID,
      ServiceID: LPCGUID,
   ) -> NTSTATUS;
   pub fn NtAcquireCrossVmMutant(CrossVmMutant: HANDLE, Timeout: PLARGE_INTEGER) -> NTSTATUS;
   pub fn NtDirectGraphicsCall(
      InputBufferLength: ULONG,
      InputBuffer: PVOID,
      OutputBufferLength: ULONG,
      OutputBuffer: PVOID,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtOpenCpuPartition(
      CpuPartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtCreateCpuPartition(
      CpuPartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn NtSetInformationCpuPartition(
      CpuPartitionHandle: HANDLE,
      CpuPartitionInformationClass: ULONG,
      CpuPartitionInformation: PVOID,
      CpuPartitionInformationLength: ULONG,
      arg1: PVOID,
      arg2: ULONG,
      arg3: ULONG,
   ) -> NTSTATUS;
   pub fn NtAcquireProcessActivityReference(
      ActivityReferenceHandle: PHANDLE,
      ParentProcessHandle: HANDLE,
      Reserved: PROCESS_ACTIVITY_TYPE,
   ) -> NTSTATUS;
   pub fn PerfIsGroupOnInGroupMask(Group: ULONG, GroupMask: PPERFINFO_GROUPMASK) -> BOOLEAN;
   pub static EtwSecondaryDumpDataGuid: GUID;
   pub static CKCLGuid: GUID;
   pub static AuditLoggerGuid: GUID;
   pub static SecurityProviderGuid: GUID;
   pub static PrivateLoggerSecurityGuid: GUID;
   pub static GlobalLoggerGuid: GUID;
   pub static GenericMessageGuid: GUID;
   pub static TraceErrorGuid: GUID;
   pub static HardFaultGuid: GUID;
   pub static WmiEventLoggerGuid: GUID;
   pub static DbgPrintGuid: GUID;
   pub static DriverVerifierGuid: GUID;
   pub static ApplicationVerifierGuid: GUID;
   pub static JobGuid: GUID;
   pub static EventTraceSpare1: GUID;
   pub static WnfGuid: GUID;
   pub static UmglThreadGuid: GUID;
   pub static DiskIoGuid: GUID;
   pub static ImageIdGuid: GUID;
   pub static PoolGuid: GUID;
   pub static PerfinfoGuid: GUID;
   pub static HeapGuid: GUID;
   pub static HeapRangeGuid: GUID;
   pub static HeapSummaryGuid: GUID;
   pub static CritSecGuid: GUID;
   pub static StackWalkGuid: GUID;
   pub static ALPCGuid: GUID;
   pub static RTLostEventsGuid: GUID;
   pub static NtdllTraceGuid: GUID;
   pub static UserLoaderGuid: GUID;
   pub static LoadMUIDllGuid: GUID;
   pub static ObjectGuid: GUID;
   pub static ModBoundGuid: GUID;
   pub static ProcessGuid: GUID;
   pub static PowerGuid: GUID;
   pub static MmcssGuid: GUID;
   pub static DpcGuid: GUID;
   pub static SplitIoGuid: GUID;
   pub static ThreadPoolGuid: GUID;
   pub static UmsTraceGuid: GUID;
   pub static UmsEventGuid: GUID;
   pub static HypervisorTraceGuid: GUID;
   pub static HypervisorXTraceGuid: GUID;
   pub static LegacyEventLogGuid: GUID;
   pub static KernelRundownGuid: GUID;
   pub static SessionNotificationGuid: GUID;
   pub static CcGuid: GUID;
   pub static NullGuid: GUID;
   pub static UserDiagnosticGuid: GUID;
   pub static WerSvcTriggerGuid: GUID;
   pub static FileIoGuid: GUID;
   pub static ImageLoadGuid: GUID;
   pub static PageFaultGuid: GUID;
   pub static RegistryGuid: GUID;
   pub static TcpIpGuid: GUID;
   pub static ThreadGuid: GUID;
   pub static UdpIpGuid: GUID;
   pub fn EtwSetMark(
      TraceHandle: TRACEHANDLE,
      MarkInfo: PETW_SET_MARK_INFORMATION,
      Size: ULONG,
   ) -> ULONG;
   pub fn EtwEventWriteFull(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      EventProperty: USHORT,
      ActivityId: LPCGUID,
      RelatedActivityId: LPCGUID,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventUnregister(RegHandle: REGHANDLE) -> ULONG;
   pub fn EtwEventSetInformation(
      RegHandle: REGHANDLE,
      InformationClass: EVENT_INFO_CLASS,
      EventInformation: PVOID,
      InformationLength: ULONG,
   ) -> ULONG;
   pub fn EtwRegisterSecurityProvider() -> ULONG;
   pub fn EtwEventProviderEnabled(
      RegHandle: REGHANDLE,
      Level: UCHAR,
      Keyword: ULONGLONG,
   ) -> BOOLEAN;
   pub fn EtwEventEnabled(RegHandle: REGHANDLE, EventDescriptor: PCEVENT_DESCRIPTOR) -> BOOLEAN;
   pub fn EtwEventWrite(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteTransfer(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      ActivityId: LPCGUID,
      RelatedActivityId: LPCGUID,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteString(
      RegHandle: REGHANDLE,
      Level: UCHAR,
      Keyword: ULONGLONG,
      String: PCWSTR,
   ) -> ULONG;
   pub fn EtwEventWriteEx(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      Filter: ULONG64,
      Flags: ULONG,
      ActivityId: LPCGUID,
      RelatedActivityId: LPCGUID,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteStartScenario(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteEndScenario(
      RegHandle: REGHANDLE,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwWriteUMSecurityEvent(
      EventDescriptor: PCEVENT_DESCRIPTOR,
      EventProperty: USHORT,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventWriteNoRegistration(
      ProviderId: LPCGUID,
      EventDescriptor: PCEVENT_DESCRIPTOR,
      UserDataCount: ULONG,
      UserData: PEVENT_DATA_DESCRIPTOR,
   ) -> ULONG;
   pub fn EtwEventActivityIdControl(ControlCode: ULONG, ActivityId: LPGUID) -> ULONG;
   pub fn EtwNotificationRegister(
      Guid: LPCGUID,
      Type: ULONG,
      Callback: PETW_NOTIFICATION_CALLBACK,
      Context: PVOID,
      RegHandle: PREGHANDLE,
   ) -> ULONG;
   pub fn EtwNotificationUnregister(RegHandle: REGHANDLE, Context: *mut PVOID) -> ULONG;
   pub fn EtwSendNotification(
      DataBlock: PETW_NOTIFICATION_HEADER,
      ReceiveDataBlockSize: ULONG,
      ReceiveDataBlock: PVOID,
      ReplyReceived: PULONG,
      ReplySizeNeeded: PULONG,
   ) -> ULONG;
   pub fn EtwReplyNotification(Notification: PETW_NOTIFICATION_HEADER) -> ULONG;
   pub fn EtwEnumerateProcessRegGuids(
      OutBuffer: PVOID,
      OutBufferSize: ULONG,
      ReturnLength: PULONG,
   ) -> ULONG;
   pub fn EtwQueryRealtimeConsumer(
      TraceHandle: TRACEHANDLE,
      EventsLostCount: PULONG,
      BuffersLostCount: PULONG,
   ) -> ULONG;
   pub fn NtTraceControl(
      FunctionCode: ETWTRACECONTROLCODE,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtTraceEvent(
      TraceHandle: HANDLE,
      Flags: ULONG,
      FieldSize: ULONG,
      Fields: PVOID,
   ) -> NTSTATUS;
   pub fn EtwCheckCoverage(CoveragePoint: PTELEMETRY_COVERAGE_POINT) -> BOOLEAN;
   pub fn WmiOpenBlock(
      Guid: LPCGUID,
      DesiredAccess: ACCESS_MASK,
      DataBlockHandle: PHANDLE,
   ) -> ULONG;
   pub fn WmiCloseBlock(DataBlockHandle: HANDLE) -> ULONG;
   pub fn WmiQueryAllDataA(DataBlockHandle: HANDLE, BufferLength: PULONG, Buffer: PVOID) -> ULONG;
   pub fn WmiQueryAllDataW(DataBlockHandle: HANDLE, BufferLength: PULONG, Buffer: PVOID) -> ULONG;
   pub fn WmiQueryAllDataMultipleA(
      HandleList: PHANDLE,
      HandleCount: ULONG,
      InOutBufferSize: PULONG,
      OutBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiQueryAllDataMultipleW(
      HandleList: PHANDLE,
      HandleCount: ULONG,
      InOutBufferSize: PULONG,
      OutBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiQuerySingleInstanceA(
      DataBlockHandle: HANDLE,
      InstanceName: PCSTR,
      BufferSize: PULONG,
      Buffer: PVOID,
   ) -> ULONG;
   pub fn WmiQuerySingleInstanceW(
      DataBlockHandle: HANDLE,
      InstanceName: PCWSTR,
      BufferSize: PULONG,
      Buffer: PVOID,
   ) -> ULONG;
   pub fn WmiQuerySingleInstanceMultipleW(
      HandleList: PHANDLE,
      InstanceNames: *mut PCWSTR,
      HandleCount: ULONG,
      InOutBufferSize: PULONG,
      OutBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiQuerySingleInstanceMultipleA(
      HandleList: PHANDLE,
      InstanceNames: *mut PCSTR,
      HandleCount: ULONG,
      InOutBufferSize: PULONG,
      OutBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiSetSingleInstanceA(
      DataBlockHandle: HANDLE,
      InstanceName: PCSTR,
      Reserved: ULONG,
      ValueBufferSize: ULONG,
      ValueBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiSetSingleInstanceW(
      DataBlockHandle: HANDLE,
      InstanceName: PCWSTR,
      Reserved: ULONG,
      ValueBufferSize: ULONG,
      ValueBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiSetSingleItemA(
      DataBlockHandle: HANDLE,
      InstanceName: PCSTR,
      DataItemId: ULONG,
      Reserved: ULONG,
      ValueBufferSize: ULONG,
      ValueBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiSetSingleItemW(
      DataBlockHandle: HANDLE,
      InstanceName: PCWSTR,
      DataItemId: ULONG,
      Reserved: ULONG,
      ValueBufferSize: ULONG,
      ValueBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiExecuteMethodA(
      MethodDataBlockHandle: HANDLE,
      MethodInstanceName: PCSTR,
      MethodId: ULONG,
      InputBufferSize: ULONG,
      InputBuffer: PVOID,
      OutputBufferSize: PULONG,
      OutputBuffer: PVOID,
   ) -> ULONG;
   pub fn WmiExecuteMethodW(
      MethodDataBlockHandle: HANDLE,
      MethodInstanceName: PCWSTR,
      MethodId: ULONG,
      InputBufferSize: ULONG,
      InputBuffer: PVOID,
      OutputBufferSize: PULONG,
      OutputBuffer: PVOID,
   ) -> ULONG;
   pub static GUID_REGISTRATION_CHANGE_NOTIFICATION: GUID;
   pub static GUID_MOF_RESOURCE_ADDED_NOTIFICATION: GUID;
   pub static GUID_MOF_RESOURCE_REMOVED_NOTIFICATION: GUID;
   pub fn WmiNotificationRegistrationA(
      Guid: PCGUID,
      Enable: BOOLEAN,
      DeliveryInfo: PVOID,
      DeliveryContext: ULONG_PTR,
      Flags: ULONG,
   ) -> ULONG;
   pub fn WmiNotificationRegistrationW(
      Guid: PCGUID,
      Enable: BOOLEAN,
      DeliveryInfo: PVOID,
      DeliveryContext: ULONG_PTR,
      Flags: ULONG,
   ) -> ULONG;
   pub fn WmiEnumerateGuids(GuidList: PGUID, GuidCount: PULONG) -> ULONG;
   pub fn WmiMofEnumerateResourcesW(
      MofResourceHandle: HANDLE,
      MofResourceCount: PULONG,
      MofResourceInfo: *mut PMOFRESOURCEINFOW,
   ) -> ULONG;
   pub fn WmiMofEnumerateResourcesA(
      MofResourceHandle: HANDLE,
      MofResourceCount: PULONG,
      MofResourceInfo: *mut PMOFRESOURCEINFOA,
   ) -> ULONG;
   pub fn WmiFileHandleToInstanceNameA(
      DataBlockHandle: HANDLE,
      FileHandle: HANDLE,
      NumberCharacters: PULONG,
      InstanceNames: *mut CHAR,
   ) -> ULONG;
   pub fn WmiFileHandleToInstanceNameW(
      DataBlockHandle: HANDLE,
      FileHandle: HANDLE,
      NumberCharacters: PULONG,
      InstanceNames: *mut WCHAR,
   ) -> ULONG;
   pub fn WmiDevInstToInstanceNameA(
      InstanceName: PSTR,
      InstanceNameLength: ULONG,
      DevInst: PCSTR,
      InstanceIndex: ULONG,
   ) -> ULONG;
   pub fn WmiDevInstToInstanceNameW(
      InstanceName: PWSTR,
      InstanceNameLength: ULONG,
      DevInst: PCWSTR,
      InstanceIndex: ULONG,
   ) -> ULONG;
   pub fn WmiQueryGuidInformation(GuidHandle: HANDLE, GuidInfo: PWMIGUIDINFORMATION) -> ULONG;
   pub fn WmiReceiveNotificationsW(
      HandleCount: ULONG,
      HandleList: PHANDLE,
      Callback: ::core::option::Option<unsafe extern "C" fn(arg1: PWNODE_HEADER, arg2: ULONG_PTR)>,
      DeliveryContext: ULONG_PTR,
   ) -> ULONG;
   pub fn WmiReceiveNotificationsA(
      HandleCount: ULONG,
      HandleList: PHANDLE,
      Callback: ::core::option::Option<unsafe extern "C" fn(arg1: PWNODE_HEADER, arg2: ULONG_PTR)>,
      DeliveryContext: ULONG_PTR,
   ) -> ULONG;
   pub fn WmiFreeBuffer(Buffer: PVOID);
   pub fn ZwAcceptConnectPort(
      PortHandle: PHANDLE,
      PortContext: PVOID,
      ConnectionRequest: PPORT_MESSAGE,
      AcceptConnection: BOOLEAN,
      ServerView: PPORT_VIEW,
      ClientView: PREMOTE_PORT_VIEW,
   ) -> NTSTATUS;
   pub fn ZwAccessCheck(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      DesiredAccess: ACCESS_MASK,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByType(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByTypeAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByTypeResultList(
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      PrivilegeSet: PPRIVILEGE_SET,
      PrivilegeSetLength: PULONG,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByTypeResultListAndAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ClientToken: HANDLE,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      PrincipalSelfSid: PSID,
      DesiredAccess: ACCESS_MASK,
      AuditType: AUDIT_EVENT_TYPE,
      Flags: ULONG,
      ObjectTypeList: POBJECT_TYPE_LIST,
      ObjectTypeListLength: ULONG,
      GenericMapping: PGENERIC_MAPPING,
      ObjectCreation: BOOLEAN,
      GrantedAccess: PACCESS_MASK,
      AccessStatus: PNTSTATUS,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAcquireCMFViewOwnership(
      TimeStamp: PULONGLONG,
      tokenTaken: PBOOLEAN,
      replaceExisting: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAcquireCrossVmMutant(CrossVmMutant: HANDLE, Timeout: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwAcquireProcessActivityReference(
      ActivityReferenceHandle: PHANDLE,
      ParentProcessHandle: HANDLE,
      Reserved: PROCESS_ACTIVITY_TYPE,
   ) -> NTSTATUS;
   pub fn ZwAddAtom(AtomName: PCWSTR, Length: ULONG, Atom: PRTL_ATOM) -> NTSTATUS;
   pub fn ZwAddAtomEx(AtomName: PCWSTR, Length: ULONG, Atom: PRTL_ATOM, Flags: ULONG) -> NTSTATUS;
   pub fn ZwAddBootEntry(BootEntry: PBOOT_ENTRY, Id: PULONG) -> NTSTATUS;
   pub fn ZwAddDriverEntry(DriverEntry: PEFI_DRIVER_ENTRY, Id: PULONG) -> NTSTATUS;
   pub fn ZwAdjustGroupsToken(
      TokenHandle: HANDLE,
      ResetToDefault: BOOLEAN,
      NewState: PTOKEN_GROUPS,
      BufferLength: ULONG,
      PreviousState: PTOKEN_GROUPS,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAdjustPrivilegesToken(
      TokenHandle: HANDLE,
      DisableAllPrivileges: BOOLEAN,
      NewState: PTOKEN_PRIVILEGES,
      BufferLength: ULONG,
      PreviousState: PTOKEN_PRIVILEGES,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAdjustTokenClaimsAndDeviceGroups(
      TokenHandle: HANDLE,
      UserResetToDefault: BOOLEAN,
      DeviceResetToDefault: BOOLEAN,
      DeviceGroupsResetToDefault: BOOLEAN,
      NewUserState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      NewDeviceState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      NewDeviceGroupsState: PTOKEN_GROUPS,
      UserBufferLength: ULONG,
      PreviousUserState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceBufferLength: ULONG,
      PreviousDeviceState: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceGroupsBufferLength: ULONG,
      PreviousDeviceGroups: PTOKEN_GROUPS,
      UserReturnLength: PULONG,
      DeviceReturnLength: PULONG,
      DeviceGroupsReturnBufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAlertMultipleThreadByThreadId(
      MultipleThreadId: PHANDLE,
      Count: ULONG,
      Boost: PVOID,
      BoostCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAlertResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn ZwAlertThread(ThreadHandle: HANDLE) -> NTSTATUS;
   pub fn ZwAlertThreadByThreadId(ThreadId: HANDLE) -> NTSTATUS;
   pub fn ZwAlertThreadByThreadIdEx(ThreadId: HANDLE, Lock: PRTL_SRWLOCK) -> NTSTATUS;
   pub fn ZwAllocateLocallyUniqueId(Luid: PLUID) -> NTSTATUS;
   pub fn ZwAllocateReserveObject(
      MemoryReserveHandle: PHANDLE,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      Type: MEMORY_RESERVE_TYPE,
   ) -> NTSTATUS;
   pub fn ZwAllocateUserPhysicalPages(
      ProcessHandle: HANDLE,
      NumberOfPages: PSIZE_T,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwAllocateUserPhysicalPagesEx(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAllocateUuids(
      Time: PULARGE_INTEGER,
      Range: PULONG,
      Sequence: PULONG,
      Seed: PCHAR,
   ) -> NTSTATUS;
   pub fn ZwAllocateVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      Protect: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAllocateVirtualMemoryEx(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAlpcAcceptConnectPort(
      PortHandle: PHANDLE,
      ConnectionPortHandle: HANDLE,
      Flags: ULONG,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      PortContext: PVOID,
      ConnectionRequest: PPORT_MESSAGE,
      ConnectionMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      AcceptConnection: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwAlpcCancelMessage(
      PortHandle: HANDLE,
      Flags: ULONG,
      MessageContext: PALPC_CONTEXT_ATTR,
   ) -> NTSTATUS;
   pub fn ZwAlpcConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      Flags: ULONG,
      RequiredServerSid: PSID,
      ConnectionMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      OutMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      InMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwAlpcConnectPortEx(
      PortHandle: PHANDLE,
      ConnectionPortObjectAttributes: POBJECT_ATTRIBUTES,
      ClientPortObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
      Flags: ULONG,
      ServerSecurityRequirements: PSECURITY_DESCRIPTOR,
      ConnectionMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      OutMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      InMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreatePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PortAttributes: PALPC_PORT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreatePortSection(
      PortHandle: HANDLE,
      Flags: ULONG,
      SectionHandle: HANDLE,
      SectionSize: SIZE_T,
      AlpcSectionHandle: PALPC_HANDLE,
      ActualSectionSize: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreateResourceReserve(
      PortHandle: HANDLE,
      Flags: ULONG,
      MessageSize: SIZE_T,
      ResourceId: PALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreateSectionView(
      PortHandle: HANDLE,
      Flags: ULONG,
      ViewAttributes: PALPC_DATA_VIEW_ATTR,
   ) -> NTSTATUS;
   pub fn ZwAlpcCreateSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      SecurityAttribute: PALPC_SECURITY_ATTR,
   ) -> NTSTATUS;
   pub fn ZwAlpcDeletePortSection(
      PortHandle: HANDLE,
      Flags: ULONG,
      SectionHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcDeleteResourceReserve(
      PortHandle: HANDLE,
      Flags: ULONG,
      ResourceId: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcDeleteSectionView(PortHandle: HANDLE, Flags: ULONG, ViewBase: PVOID) -> NTSTATUS;
   pub fn ZwAlpcDeleteSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      ContextHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcDisconnectPort(PortHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   pub fn ZwAlpcImpersonateClientContainerOfPort(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAlpcImpersonateClientOfPort(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      Flags: PVOID,
   ) -> NTSTATUS;
   pub fn ZwAlpcOpenSenderProcess(
      ProcessHandle: PHANDLE,
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwAlpcOpenSenderThread(
      ThreadHandle: PHANDLE,
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwAlpcQueryInformation(
      PortHandle: HANDLE,
      PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAlpcQueryInformationMessage(
      PortHandle: HANDLE,
      PortMessage: PPORT_MESSAGE,
      MessageInformationClass: ALPC_MESSAGE_INFORMATION_CLASS,
      MessageInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwAlpcRevokeSecurityContext(
      PortHandle: HANDLE,
      Flags: ULONG,
      ContextHandle: ALPC_HANDLE,
   ) -> NTSTATUS;
   pub fn ZwAlpcSendWaitReceivePort(
      PortHandle: HANDLE,
      Flags: ULONG,
      SendMessageW: PPORT_MESSAGE,
      SendMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      ReceiveMessage: PPORT_MESSAGE,
      BufferLength: PSIZE_T,
      ReceiveMessageAttributes: PALPC_MESSAGE_ATTRIBUTES,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwAlpcSetInformation(
      PortHandle: HANDLE,
      PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn ZwAreMappedFilesTheSame(
      File1MappedAsAnImage: PVOID,
      File2MappedAsFile: PVOID,
   ) -> NTSTATUS;
   pub fn ZwAssignProcessToJobObject(JobHandle: HANDLE, ProcessHandle: HANDLE) -> NTSTATUS;
   pub fn ZwAssociateWaitCompletionPacket(
      WaitCompletionPacketHandle: HANDLE,
      IoCompletionHandle: HANDLE,
      TargetObjectHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
      AlreadySignaled: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCallbackReturn(OutputBuffer: PVOID, OutputLength: ULONG, Status: NTSTATUS) -> NTSTATUS;
   pub fn ZwCallEnclave(
      Routine: PENCLAVE_ROUTINE,
      Reserved: PVOID,
      Flags: ULONG,
      RoutineParamReturn: *mut PVOID,
   ) -> NTSTATUS;
   pub fn ZwCancelIoFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
   pub fn ZwCancelIoFileEx(
      FileHandle: HANDLE,
      IoRequestToCancel: PIO_STATUS_BLOCK,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn ZwCancelSynchronousIoFile(
      ThreadHandle: HANDLE,
      IoRequestToCancel: PIO_STATUS_BLOCK,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn ZwCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN) -> NTSTATUS;
   pub fn ZwCancelTimer2(TimerHandle: HANDLE, Parameters: PT2_CANCEL_PARAMETERS) -> NTSTATUS;
   pub fn ZwCancelWaitCompletionPacket(
      WaitCompletionPacketHandle: HANDLE,
      RemoveSignaledPacket: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwChangeProcessState(
      ProcessStateChangeHandle: HANDLE,
      ProcessHandle: HANDLE,
      StateChangeType: PROCESS_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn ZwChangeThreadState(
      ThreadStateChangeHandle: HANDLE,
      ThreadHandle: HANDLE,
      StateChangeType: THREAD_STATE_CHANGE_TYPE,
      ExtendedInformation: PVOID,
      ExtendedInformationLength: SIZE_T,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn ZwClearEvent(EventHandle: HANDLE) -> NTSTATUS;
   pub fn ZwClose(Handle: HANDLE) -> NTSTATUS;
   pub fn ZwCloseObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      GenerateOnClose: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCommitComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwCommitEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwCommitTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
   pub fn ZwCompactKeys(Count: ULONG, KeyArray: *mut HANDLE) -> NTSTATUS;
   pub fn ZwCompareObjects(FirstObjectHandle: HANDLE, SecondObjectHandle: HANDLE) -> NTSTATUS;
   pub fn ZwCompareSigningLevels(
      FirstSigningLevel: SE_SIGNING_LEVEL,
      SecondSigningLevel: SE_SIGNING_LEVEL,
   ) -> NTSTATUS;
   pub fn ZwCompareTokens(
      FirstTokenHandle: HANDLE,
      SecondTokenHandle: HANDLE,
      Equal: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCompleteConnectPort(PortHandle: HANDLE) -> NTSTATUS;
   pub fn ZwCompressKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn ZwConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
      ClientView: PPORT_VIEW,
      ServerView: PREMOTE_PORT_VIEW,
      MaxMessageLength: PULONG,
      ConnectionInformation: PVOID,
      ConnectionInformationLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwContinue(ContextRecord: PCONTEXT, TestAlert: BOOLEAN) -> NTSTATUS;
   pub fn ZwContinueEx(ContextRecord: PCONTEXT, ContinueArgument: PVOID) -> NTSTATUS;
   pub fn ZwConvertBetweenAuxiliaryCounterAndPerformanceCounter(
      ConvertAuxiliaryToPerformanceCounter: BOOLEAN,
      PerformanceOrAuxiliaryCounterValue: PULONG64,
      ConvertedValue: PULONG64,
      ConversionError: PULONG64,
   ) -> NTSTATUS;
   pub fn ZwCopyFileChunk(
      SourceHandle: HANDLE,
      DestinationHandle: HANDLE,
      EventHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Length: ULONG,
      SourceOffset: PLARGE_INTEGER,
      DestOffset: PLARGE_INTEGER,
      SourceKey: PULONG,
      DestKey: PULONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateCpuPartition(
      CpuPartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateCrossVmEvent(
      CrossVmEvent: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CrossVmEventFlags: ULONG,
      VMID: LPCGUID,
      ServiceID: LPCGUID,
   ) -> NTSTATUS;
   pub fn ZwCreateCrossVmMutant(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CrossVmEventFlags: ULONG,
      VMID: LPCGUID,
      ServiceID: LPCGUID,
   ) -> NTSTATUS;
   pub fn ZwCreateDebugObject(
      DebugObjectHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateDirectoryObject(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateDirectoryObjectEx(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      ShadowDirectoryHandle: HANDLE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      Size: SIZE_T,
      InitialCommitment: SIZE_T,
      EnclaveType: ULONG,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateEnlistment(
      EnlistmentHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ResourceManagerHandle: HANDLE,
      TransactionHandle: HANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
      NotificationMask: NOTIFICATION_MASK,
      EnlistmentKey: PVOID,
   ) -> NTSTATUS;
   pub fn ZwCreateEvent(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      EventType: EVENT_TYPE,
      InitialState: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCreateEventPair(
      EventPairHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      AllocationSize: PLARGE_INTEGER,
      FileAttributes: ULONG,
      ShareAccess: ULONG,
      CreateDisposition: ULONG,
      CreateOptions: ULONG,
      EaBuffer: PVOID,
      EaLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateIoCompletion(
      IoCompletionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Count: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateIoRing(
      IoRingHandle: PHANDLE,
      CreateParametersLength: ULONG,
      CreateParameters: PVOID,
      OutputParametersLength: ULONG,
      OutputParameters: PVOID,
   ) -> NTSTATUS;
   pub fn ZwCreateIRTimer(
      TimerHandle: PHANDLE,
      Reserved: PVOID,
      DesiredAccess: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn ZwCreateJobObject(
      JobHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateJobSet(NumJob: ULONG, UserJobSet: PJOB_SET_ARRAY, Flags: ULONG) -> NTSTATUS;
   pub fn ZwCreateKey(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TitleIndex: ULONG,
      Class: PUNICODE_STRING,
      CreateOptions: ULONG,
      Disposition: PULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateKeyedEvent(
      KeyedEventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateKeyTransacted(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TitleIndex: ULONG,
      Class: PUNICODE_STRING,
      CreateOptions: ULONG,
      TransactionHandle: HANDLE,
      Disposition: PULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateLowBoxToken(
      TokenHandle: PHANDLE,
      ExistingTokenHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      PackageSid: PSID,
      CapabilityCount: ULONG,
      Capabilities: PSID_AND_ATTRIBUTES,
      HandleCount: ULONG,
      Handles: *mut HANDLE,
   ) -> NTSTATUS;
   pub fn ZwCreateMailslotFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CreateOptions: ULONG,
      MailslotQuota: ULONG,
      MaximumMessageSize: ULONG,
      ReadTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwCreateMutant(
      MutantHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      InitialOwner: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCreateNamedPipeFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ShareAccess: ULONG,
      CreateDisposition: ULONG,
      CreateOptions: ULONG,
      NamedPipeType: ULONG,
      ReadMode: ULONG,
      CompletionMode: ULONG,
      MaximumInstances: ULONG,
      InboundQuota: ULONG,
      OutboundQuota: ULONG,
      DefaultTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwCreatePagingFile(
      PageFileName: PUNICODE_STRING,
      MinimumSize: PLARGE_INTEGER,
      MaximumSize: PLARGE_INTEGER,
      Priority: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreatePartition(
      ParentPartitionHandle: HANDLE,
      PartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      PreferredNode: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreatePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaxConnectionInfoLength: ULONG,
      MaxMessageLength: ULONG,
      MaxPoolUsage: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreatePrivateNamespace(
      NamespaceHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn ZwCreateProcess(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ParentProcess: HANDLE,
      InheritObjectTable: BOOLEAN,
      SectionHandle: HANDLE,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwCreateProcessEx(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ParentProcess: HANDLE,
      Flags: ULONG,
      SectionHandle: HANDLE,
      DebugPort: HANDLE,
      TokenHandle: HANDLE,
      Reserved: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateProcessStateChange(
      ProcessStateChangeHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn ZwCreateProfile(
      ProfileHandle: PHANDLE,
      Process: HANDLE,
      ProfileBase: PVOID,
      ProfileSize: SIZE_T,
      BucketSize: ULONG,
      Buffer: PULONG,
      BufferSize: ULONG,
      ProfileSource: KPROFILE_SOURCE,
      Affinity: KAFFINITY,
   ) -> NTSTATUS;
   pub fn ZwCreateProfileEx(
      ProfileHandle: PHANDLE,
      Process: HANDLE,
      ProfileBase: PVOID,
      ProfileSize: SIZE_T,
      BucketSize: ULONG,
      Buffer: PULONG,
      BufferSize: ULONG,
      ProfileSource: KPROFILE_SOURCE,
      GroupCount: USHORT,
      GroupAffinity: PGROUP_AFFINITY,
   ) -> NTSTATUS;
   pub fn ZwCreateResourceManager(
      ResourceManagerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      TmHandle: HANDLE,
      RmGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      CreateOptions: ULONG,
      Description: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwCreateSection(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      MaximumSize: PLARGE_INTEGER,
      SectionPageProtection: ULONG,
      AllocationAttributes: ULONG,
      FileHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwCreateSectionEx(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      MaximumSize: PLARGE_INTEGER,
      SectionPageProtection: ULONG,
      AllocationAttributes: ULONG,
      FileHandle: HANDLE,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateSemaphore(
      SemaphoreHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      InitialCount: LONG,
      MaximumCount: LONG,
   ) -> NTSTATUS;
   pub fn ZwCreateSymbolicLinkObject(
      LinkHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LinkTarget: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwCreateThread(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      ClientId: PCLIENT_ID,
      ThreadContext: PCONTEXT,
      InitialTeb: PINITIAL_TEB,
      CreateSuspended: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwCreateThreadEx(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ProcessHandle: HANDLE,
      StartRoutine: PUSER_THREAD_START_ROUTINE,
      Argument: PVOID,
      CreateFlags: ULONG,
      ZeroBits: SIZE_T,
      StackSize: SIZE_T,
      MaximumStackSize: SIZE_T,
      AttributeList: PPS_ATTRIBUTE_LIST,
   ) -> NTSTATUS;
   pub fn ZwCreateThreadStateChange(
      ThreadStateChangeHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ThreadHandle: HANDLE,
      Reserved: ULONG64,
   ) -> NTSTATUS;
   pub fn ZwCreateTimer(
      TimerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      TimerType: TIMER_TYPE,
   ) -> NTSTATUS;
   pub fn ZwCreateTimer2(
      TimerHandle: PHANDLE,
      Reserved1: PVOID,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      Attributes: ULONG,
      DesiredAccess: ACCESS_MASK,
   ) -> NTSTATUS;
   pub fn ZwCreateToken(
      TokenHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: TOKEN_TYPE,
      AuthenticationId: PLUID,
      ExpirationTime: PLARGE_INTEGER,
      User: PTOKEN_USER,
      Groups: PTOKEN_GROUPS,
      Privileges: PTOKEN_PRIVILEGES,
      Owner: PTOKEN_OWNER,
      PrimaryGroup: PTOKEN_PRIMARY_GROUP,
      DefaultDacl: PTOKEN_DEFAULT_DACL,
      Source: PTOKEN_SOURCE,
   ) -> NTSTATUS;
   pub fn ZwCreateTokenEx(
      TokenHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Type: TOKEN_TYPE,
      AuthenticationId: PLUID,
      ExpirationTime: PLARGE_INTEGER,
      User: PTOKEN_USER,
      Groups: PTOKEN_GROUPS,
      Privileges: PTOKEN_PRIVILEGES,
      UserAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      DeviceGroups: PTOKEN_GROUPS,
      MandatoryPolicy: PTOKEN_MANDATORY_POLICY,
      Owner: PTOKEN_OWNER,
      PrimaryGroup: PTOKEN_PRIMARY_GROUP,
      DefaultDacl: PTOKEN_DEFAULT_DACL,
      Source: PTOKEN_SOURCE,
   ) -> NTSTATUS;
   pub fn ZwCreateTransaction(
      TransactionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Uow: LPGUID,
      TmHandle: HANDLE,
      CreateOptions: ULONG,
      IsolationLevel: ULONG,
      IsolationFlags: ULONG,
      Timeout: PLARGE_INTEGER,
      Description: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwCreateTransactionManager(
      TmHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LogFileName: PUNICODE_STRING,
      CreateOptions: ULONG,
      CommitStrength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateUserProcess(
      ProcessHandle: PHANDLE,
      ThreadHandle: PHANDLE,
      ProcessDesiredAccess: ACCESS_MASK,
      ThreadDesiredAccess: ACCESS_MASK,
      ProcessObjectAttributes: PCOBJECT_ATTRIBUTES,
      ThreadObjectAttributes: PCOBJECT_ATTRIBUTES,
      ProcessFlags: ULONG,
      ThreadFlags: ULONG,
      ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
      CreateInfo: PPS_CREATE_INFO,
      AttributeList: PPS_ATTRIBUTE_LIST,
   ) -> NTSTATUS;
   pub fn ZwCreateWaitablePort(
      PortHandle: PHANDLE,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      MaxConnectionInfoLength: ULONG,
      MaxMessageLength: ULONG,
      MaxPoolUsage: ULONG,
   ) -> NTSTATUS;
   pub fn ZwCreateWaitCompletionPacket(
      WaitCompletionPacketHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwCreateWnfStateName(
      StateName: PWNF_STATE_NAME,
      NameLifetime: WNF_STATE_NAME_LIFETIME,
      DataScope: WNF_DATA_SCOPE,
      PersistData: BOOLEAN,
      TypeId: PCWNF_TYPE_ID,
      MaximumStateSize: ULONG,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn ZwCreateWorkerFactory(
      WorkerFactoryHandleReturn: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      CompletionPortHandle: HANDLE,
      WorkerProcessHandle: HANDLE,
      StartRoutine: PVOID,
      StartParameter: PVOID,
      MaxThreadCount: ULONG,
      StackReserve: SIZE_T,
      StackCommit: SIZE_T,
   ) -> NTSTATUS;
   pub fn ZwDebugActiveProcess(ProcessHandle: HANDLE, DebugObjectHandle: HANDLE) -> NTSTATUS;
   pub fn ZwDebugContinue(
      DebugObjectHandle: HANDLE,
      ClientId: PCLIENT_ID,
      ContinueStatus: NTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwDelayExecution(Alertable: BOOLEAN, DelayInterval: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwDeleteAtom(Atom: RTL_ATOM) -> NTSTATUS;
   pub fn ZwDeleteBootEntry(Id: ULONG) -> NTSTATUS;
   pub fn ZwDeleteDriverEntry(Id: ULONG) -> NTSTATUS;
   pub fn ZwDeleteFile(ObjectAttributes: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn ZwDeleteKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn ZwDeleteObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      GenerateOnClose: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwDeletePrivateNamespace(NamespaceHandle: HANDLE) -> NTSTATUS;
   pub fn ZwDeleteValueKey(KeyHandle: HANDLE, ValueName: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwDeleteWnfStateData(
      StateName: PCWNF_STATE_NAME,
      ExplicitScope: *const ::core::ffi::c_void,
   ) -> NTSTATUS;
   pub fn ZwDeleteWnfStateName(StateName: PCWNF_STATE_NAME) -> NTSTATUS;
   pub fn ZwDeviceIoControlFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      IoControlCode: ULONG,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwDirectGraphicsCall(
      InputBufferLength: ULONG,
      InputBuffer: PVOID,
      OutputBufferLength: ULONG,
      OutputBuffer: PVOID,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwDisableLastKnownGood() -> NTSTATUS;
   pub fn ZwDisplayString(String: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwDrawText(Text: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwDuplicateObject(
      SourceProcessHandle: HANDLE,
      SourceHandle: HANDLE,
      TargetProcessHandle: HANDLE,
      TargetHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Options: ULONG,
   ) -> NTSTATUS;
   pub fn ZwDuplicateToken(
      ExistingTokenHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      EffectiveOnly: BOOLEAN,
      Type: TOKEN_TYPE,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwEnableLastKnownGood() -> NTSTATUS;
   pub fn ZwEnumerateBootEntries(Buffer: PVOID, BufferLength: PULONG) -> NTSTATUS;
   pub fn ZwEnumerateDriverEntries(Buffer: PVOID, BufferLength: PULONG) -> NTSTATUS;
   pub fn ZwEnumerateKey(
      KeyHandle: HANDLE,
      Index: ULONG,
      KeyInformationClass: KEY_INFORMATION_CLASS,
      KeyInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwEnumerateSystemEnvironmentValuesEx(
      InformationClass: ULONG,
      Buffer: PVOID,
      BufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwEnumerateTransactionObject(
      RootObjectHandle: HANDLE,
      QueryType: KTMOBJECT_TYPE,
      ObjectCursor: PKTMOBJECT_CURSOR,
      ObjectCursorLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwEnumerateValueKey(
      KeyHandle: HANDLE,
      Index: ULONG,
      KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
      KeyValueInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwExtendSection(SectionHandle: HANDLE, NewSectionSize: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwFilterBootOption(
      FilterOperation: FILTER_BOOT_OPTION_OPERATION,
      ObjectType: ULONG,
      ElementType: ULONG,
      Data: PVOID,
      DataSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwFilterToken(
      ExistingTokenHandle: HANDLE,
      Flags: ULONG,
      SidsToDisable: PTOKEN_GROUPS,
      PrivilegesToDelete: PTOKEN_PRIVILEGES,
      RestrictedSids: PTOKEN_GROUPS,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwFilterTokenEx(
      ExistingTokenHandle: HANDLE,
      Flags: ULONG,
      SidsToDisable: PTOKEN_GROUPS,
      PrivilegesToDelete: PTOKEN_PRIVILEGES,
      RestrictedSids: PTOKEN_GROUPS,
      DisableUserClaimsCount: ULONG,
      UserClaimsToDisable: PUNICODE_STRING,
      DisableDeviceClaimsCount: ULONG,
      DeviceClaimsToDisable: PUNICODE_STRING,
      DeviceGroupsToDisable: PTOKEN_GROUPS,
      RestrictedUserAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      RestrictedDeviceAttributes: PTOKEN_SECURITY_ATTRIBUTES_INFORMATION,
      RestrictedDeviceGroups: PTOKEN_GROUPS,
      NewTokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwFindAtom(AtomName: PCWSTR, Length: ULONG, Atom: PRTL_ATOM) -> NTSTATUS;
   pub fn ZwFlushBuffersFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
   pub fn ZwFlushBuffersFileEx(
      FileHandle: HANDLE,
      Flags: ULONG,
      Parameters: PVOID,
      ParametersSize: ULONG,
      IoStatusBlock: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn ZwFlushInstallUILanguage(InstallUILanguage: LANGID, SetComittedFlag: ULONG) -> NTSTATUS;
   pub fn ZwFlushInstructionCache(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Length: SIZE_T,
   ) -> NTSTATUS;
   pub fn ZwFlushKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn ZwFlushProcessWriteBuffers() -> NTSTATUS;
   pub fn ZwFlushVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      IoStatus: PIO_STATUS_BLOCK,
   ) -> NTSTATUS;
   pub fn ZwFlushWriteBuffer() -> NTSTATUS;
   pub fn ZwFreeUserPhysicalPages(
      ProcessHandle: HANDLE,
      NumberOfPages: PULONG_PTR,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwFreeVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      FreeType: ULONG,
   ) -> NTSTATUS;
   pub fn ZwFreezeRegistry(TimeOutInSeconds: ULONG) -> NTSTATUS;
   pub fn ZwFreezeTransactions(
      FreezeTimeout: PLARGE_INTEGER,
      ThawTimeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwFsControlFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsControlCode: ULONG,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwGetCachedSigningLevel(
      File: HANDLE,
      Flags: PULONG,
      SigningLevel: PSE_SIGNING_LEVEL,
      Thumbprint: PUCHAR,
      ThumbprintSize: PULONG,
      ThumbprintAlgorithm: PULONG,
   ) -> NTSTATUS;
   pub fn ZwGetCompleteWnfStateSubscription(
      OldDescriptorStateName: PWNF_STATE_NAME,
      OldSubscriptionId: *mut ULONG64,
      OldDescriptorEventMask: ULONG,
      OldDescriptorStatus: ULONG,
      NewDeliveryDescriptor: PWNF_DELIVERY_DESCRIPTOR,
      DescriptorSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwGetContextThread(ThreadHandle: HANDLE, ThreadContext: PCONTEXT) -> NTSTATUS;
   pub fn ZwGetCurrentProcessorNumber() -> ULONG;
   pub fn ZwGetCurrentProcessorNumberEx(ProcessorNumber: PPROCESSOR_NUMBER) -> ULONG;
   pub fn ZwGetDevicePowerState(Device: HANDLE, State: PDEVICE_POWER_STATE) -> NTSTATUS;
   pub fn ZwGetMUIRegistryInfo(Flags: ULONG, DataSize: PULONG, Data: PVOID) -> NTSTATUS;
   pub fn ZwGetNextProcess(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Flags: ULONG,
      NewProcessHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwGetNextThread(
      ProcessHandle: HANDLE,
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      Flags: ULONG,
      NewThreadHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwGetNlsSectionPtr(
      SectionType: ULONG,
      SectionData: ULONG,
      ContextData: PVOID,
      SectionPointer: *mut PVOID,
      SectionSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwGetNotificationResourceManager(
      ResourceManagerHandle: HANDLE,
      TransactionNotification: PTRANSACTION_NOTIFICATION,
      NotificationLength: ULONG,
      Timeout: PLARGE_INTEGER,
      ReturnLength: PULONG,
      Asynchronous: ULONG,
      AsynchronousContext: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwGetPlugPlayEvent(
      EventHandle: HANDLE,
      Context: PVOID,
      EventBlock: PPLUGPLAY_EVENT_BLOCK,
      EventBufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwGetWriteWatch(
      ProcessHandle: HANDLE,
      Flags: ULONG,
      BaseAddress: PVOID,
      RegionSize: SIZE_T,
      UserAddressArray: *mut PVOID,
      EntriesInUserAddressArray: PULONG_PTR,
      Granularity: PULONG,
   ) -> NTSTATUS;
   pub fn ZwImpersonateAnonymousToken(ThreadHandle: HANDLE) -> NTSTATUS;
   pub fn ZwImpersonateClientOfPort(PortHandle: HANDLE, Message: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwImpersonateThread(
      ServerThreadHandle: HANDLE,
      ClientThreadHandle: HANDLE,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
   ) -> NTSTATUS;
   pub fn ZwInitializeEnclave(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      EnclaveInformation: PVOID,
      EnclaveInformationLength: ULONG,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn ZwInitializeNlsFiles(
      BaseAddress: *mut PVOID,
      DefaultLocaleId: PLCID,
      DefaultCasingTableSize: PLARGE_INTEGER,
      CurrentNLSVersion: PULONG,
   ) -> NTSTATUS;
   pub fn ZwInitializeRegistry(BootCondition: USHORT) -> NTSTATUS;
   pub fn ZwInitiatePowerAction(
      SystemAction: POWER_ACTION,
      LightestSystemState: SYSTEM_POWER_STATE,
      Flags: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwIsProcessInJob(ProcessHandle: HANDLE, JobHandle: HANDLE) -> NTSTATUS;
   pub fn ZwIsSystemResumeAutomatic() -> BOOLEAN;
   pub fn ZwIsUILanguageComitted() -> NTSTATUS;
   pub fn ZwListenPort(PortHandle: HANDLE, ConnectionRequest: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwLoadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwLoadEnclaveData(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      Protect: ULONG,
      PageInformation: PVOID,
      PageInformationLength: ULONG,
      NumberOfBytesWritten: PSIZE_T,
      EnclaveError: PULONG,
   ) -> NTSTATUS;
   pub fn ZwLoadKey(TargetKey: POBJECT_ATTRIBUTES, SourceFile: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn ZwLoadKey2(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwLoadKey3(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
      ExtendedParameters: PCM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
      DesiredAccess: ACCESS_MASK,
      RootHandle: PHANDLE,
      Reserved: PVOID,
   ) -> NTSTATUS;
   pub fn ZwLoadKeyEx(
      TargetKey: POBJECT_ATTRIBUTES,
      SourceFile: POBJECT_ATTRIBUTES,
      Flags: ULONG,
      TrustClassKey: HANDLE,
      Event: HANDLE,
      DesiredAccess: ACCESS_MASK,
      RootHandle: PHANDLE,
      Reserved: PVOID,
   ) -> NTSTATUS;
   pub fn ZwLockFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ByteOffset: PLARGE_INTEGER,
      Length: PLARGE_INTEGER,
      Key: ULONG,
      FailImmediately: BOOLEAN,
      ExclusiveLock: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwLockProductActivationKeys(pPrivateVer: *mut ULONG, pSafeMode: *mut ULONG) -> NTSTATUS;
   pub fn ZwLockRegistryKey(KeyHandle: HANDLE) -> NTSTATUS;
   pub fn ZwLockVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      MapType: ULONG,
   ) -> NTSTATUS;
   pub fn ZwMakePermanentObject(Handle: HANDLE) -> NTSTATUS;
   pub fn ZwMakeTemporaryObject(Handle: HANDLE) -> NTSTATUS;
   pub fn ZwManagePartition(
      TargetHandle: HANDLE,
      SourceHandle: HANDLE,
      PartitionInformationClass: PARTITION_INFORMATION_CLASS,
      PartitionInformation: PVOID,
      PartitionInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwMapCMFModule(
      What: ULONG,
      Index: ULONG,
      CacheIndexOut: PULONG,
      CacheFlagsOut: PULONG,
      ViewSizeOut: PULONG,
      BaseAddress: *mut PVOID,
   ) -> NTSTATUS;
   pub fn ZwMapUserPhysicalPages(
      VirtualAddress: PVOID,
      NumberOfPages: SIZE_T,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwMapUserPhysicalPagesScatter(
      VirtualAddresses: *mut PVOID,
      NumberOfPages: SIZE_T,
      UserPfnArray: PULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwMapViewOfSection(
      SectionHandle: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      ZeroBits: ULONG_PTR,
      CommitSize: SIZE_T,
      SectionOffset: PLARGE_INTEGER,
      ViewSize: PSIZE_T,
      InheritDisposition: SECTION_INHERIT,
      AllocationType: ULONG,
      Win32Protect: ULONG,
   ) -> NTSTATUS;
   pub fn ZwMapViewOfSectionEx(
      SectionHandle: HANDLE,
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      SectionOffset: PLARGE_INTEGER,
      ViewSize: PSIZE_T,
      AllocationType: ULONG,
      PageProtection: ULONG,
      ExtendedParameters: PMEM_EXTENDED_PARAMETER,
      ExtendedParameterCount: ULONG,
   ) -> NTSTATUS;
   pub fn ZwModifyBootEntry(BootEntry: PBOOT_ENTRY) -> NTSTATUS;
   pub fn ZwModifyDriverEntry(DriverEntry: PEFI_DRIVER_ENTRY) -> NTSTATUS;
   pub fn ZwNotifyChangeDirectoryFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwNotifyChangeDirectoryFileEx(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn ZwNotifyChangeKey(
      KeyHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      Buffer: PVOID,
      BufferSize: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwNotifyChangeMultipleKeys(
      MasterKeyHandle: HANDLE,
      Count: ULONG,
      SubordinateObjects: *mut OBJECT_ATTRIBUTES,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      CompletionFilter: ULONG,
      WatchTree: BOOLEAN,
      Buffer: PVOID,
      BufferSize: ULONG,
      Asynchronous: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwNotifyChangeSession(
      SessionHandle: HANDLE,
      ChangeSequenceNumber: ULONG,
      ChangeTimeStamp: PLARGE_INTEGER,
      Event: IO_SESSION_EVENT,
      NewState: IO_SESSION_STATE,
      PreviousState: IO_SESSION_STATE,
      Payload: PVOID,
      PayloadSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwOpenCpuPartition(
      CpuPartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenDirectoryObject(
      DirectoryHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenEnlistment(
      EnlistmentHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ResourceManagerHandle: HANDLE,
      EnlistmentGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenEvent(
      EventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenEventPair(
      EventPairHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenFile(
      FileHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ShareAccess: ULONG,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn ZwOpenIoCompletion(
      IoCompletionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenJobObject(
      JobHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenKey(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenKeyedEvent(
      KeyedEventHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenKeyEx(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn ZwOpenKeyTransacted(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      TransactionHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenKeyTransactedEx(
      KeyHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      OpenOptions: ULONG,
      TransactionHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenMutant(
      MutantHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ObjectTypeName: PUNICODE_STRING,
      ObjectName: PUNICODE_STRING,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      GrantedAccess: ACCESS_MASK,
      Privileges: PPRIVILEGE_SET,
      ObjectCreation: BOOLEAN,
      AccessGranted: BOOLEAN,
      GenerateOnClose: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwOpenPartition(
      PartitionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenPrivateNamespace(
      NamespaceHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      BoundaryDescriptor: POBJECT_BOUNDARY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn ZwOpenProcess(
      ProcessHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   pub fn ZwOpenProcessToken(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenProcessTokenEx(
      ProcessHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      HandleAttributes: ULONG,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenResourceManager(
      ResourceManagerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      TmHandle: HANDLE,
      ResourceManagerGuid: LPGUID,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenSection(
      SectionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenSemaphore(
      SemaphoreHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenSession(
      SessionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenSymbolicLinkObject(
      LinkHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenThread(
      ThreadHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      ClientId: PCLIENT_ID,
   ) -> NTSTATUS;
   pub fn ZwOpenThreadToken(
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      OpenAsSelf: BOOLEAN,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenThreadTokenEx(
      ThreadHandle: HANDLE,
      DesiredAccess: ACCESS_MASK,
      OpenAsSelf: BOOLEAN,
      HandleAttributes: ULONG,
      TokenHandle: PHANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenTimer(
      TimerHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwOpenTransaction(
      TransactionHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      Uow: LPGUID,
      TmHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwOpenTransactionManager(
      TmHandle: PHANDLE,
      DesiredAccess: ACCESS_MASK,
      ObjectAttributes: POBJECT_ATTRIBUTES,
      LogFileName: PUNICODE_STRING,
      TmIdentity: LPGUID,
      OpenOptions: ULONG,
   ) -> NTSTATUS;
   pub fn ZwPlugPlayControl(
      PnPControlClass: PLUGPLAY_CONTROL_CLASS,
      PnPControlData: PVOID,
      PnPControlDataLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwPowerInformation(
      InformationLevel: POWER_INFORMATION_LEVEL,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwPrepareComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwPrepareEnlistment(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
      -> NTSTATUS;
   pub fn ZwPrePrepareComplete(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwPrePrepareEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwPrivilegeCheck(
      ClientToken: HANDLE,
      RequiredPrivileges: PPRIVILEGE_SET,
      Result: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwPrivilegedServiceAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      ServiceName: PUNICODE_STRING,
      ClientToken: HANDLE,
      Privileges: PPRIVILEGE_SET,
      AccessGranted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwPrivilegeObjectAuditAlarm(
      SubsystemName: PUNICODE_STRING,
      HandleId: PVOID,
      ClientToken: HANDLE,
      DesiredAccess: ACCESS_MASK,
      Privileges: PPRIVILEGE_SET,
      AccessGranted: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwPropagationComplete(
      ResourceManagerHandle: HANDLE,
      RequestCookie: ULONG,
      BufferLength: ULONG,
      Buffer: PVOID,
   ) -> NTSTATUS;
   pub fn ZwPropagationFailed(
      ResourceManagerHandle: HANDLE,
      RequestCookie: ULONG,
      PropStatus: NTSTATUS,
   ) -> NTSTATUS;
   pub fn ZwProtectVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      NewProtect: ULONG,
      OldProtect: PULONG,
   ) -> NTSTATUS;
   pub fn ZwPssCaptureVaSpaceBulk(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      BulkInformation: PNTPSS_MEMORY_BULK_INFORMATION,
      BulkInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwPulseEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn ZwQueryAttributesFile(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      FileInformation: PFILE_BASIC_INFORMATION,
   ) -> NTSTATUS;
   pub fn ZwQueryAuxiliaryCounterFrequency(AuxiliaryCounterFrequency: PULONG64) -> NTSTATUS;
   pub fn ZwQueryBootEntryOrder(Ids: PULONG, Count: PULONG) -> NTSTATUS;
   pub fn ZwQueryBootOptions(BootOptions: PBOOT_OPTIONS, BootOptionsLength: PULONG) -> NTSTATUS;
   pub fn ZwQueryDebugFilterState(ComponentId: ULONG, Level: ULONG) -> NTSTATUS;
   pub fn ZwQueryDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: PLCID) -> NTSTATUS;
   pub fn ZwQueryDefaultUILanguage(DefaultUILanguageId: *mut LANGID) -> NTSTATUS;
   pub fn ZwQueryDirectoryFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
      ReturnSingleEntry: BOOLEAN,
      FileName: PUNICODE_STRING,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwQueryDirectoryFileEx(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
      QueryFlags: ULONG,
      FileName: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwQueryDirectoryObject(
      DirectoryHandle: HANDLE,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      RestartScan: BOOLEAN,
      Context: PULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryDriverEntryOrder(Ids: PULONG, Count: PULONG) -> NTSTATUS;
   pub fn ZwQueryEaFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      EaList: PVOID,
      EaListLength: ULONG,
      EaIndex: PULONG,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwQueryEvent(
      EventHandle: HANDLE,
      EventInformationClass: EVENT_INFORMATION_CLASS,
      EventInformation: PVOID,
      EventInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryFullAttributesFile(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationAtom(
      Atom: RTL_ATOM,
      AtomInformationClass: ATOM_INFORMATION_CLASS,
      AtomInformation: PVOID,
      AtomInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationByName(
      ObjectAttributes: POBJECT_ATTRIBUTES,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationEnlistment(
      EnlistmentHandle: HANDLE,
      EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
      EnlistmentInformation: PVOID,
      EnlistmentInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationJobObject(
      JobHandle: HANDLE,
      JobObjectInformationClass: JOBOBJECTINFOCLASS,
      JobObjectInformation: PVOID,
      JobObjectInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationPort(
      PortHandle: HANDLE,
      PortInformationClass: PORT_INFORMATION_CLASS,
      PortInformation: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationProcess(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationResourceManager(
      ResourceManagerHandle: HANDLE,
      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
      ResourceManagerInformation: PVOID,
      ResourceManagerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: THREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationToken(
      TokenHandle: HANDLE,
      TokenInformationClass: ULONG,
      TokenInformation: PVOID,
      TokenInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationTransaction(
      TransactionHandle: HANDLE,
      TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
      TransactionInformation: PVOID,
      TransactionInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationTransactionManager(
      TransactionManagerHandle: HANDLE,
      TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
      TransactionManagerInformation: PVOID,
      TransactionManagerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInformationWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
      WorkerFactoryInformation: PVOID,
      WorkerFactoryInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryInstallUILanguage(InstallUILanguageId: *mut LANGID) -> NTSTATUS;
   pub fn ZwQueryIntervalProfile(ProfileSource: KPROFILE_SOURCE, Interval: PULONG) -> NTSTATUS;
   pub fn ZwQueryIoCompletion(
      IoCompletionHandle: HANDLE,
      IoCompletionInformationClass: IO_COMPLETION_INFORMATION_CLASS,
      IoCompletionInformation: PVOID,
      IoCompletionInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryIoRingCapabilities(
      IoRingCapabilitiesLength: SIZE_T,
      IoRingCapabilities: PVOID,
   ) -> NTSTATUS;
   pub fn ZwQueryKey(
      KeyHandle: HANDLE,
      KeyInformationClass: KEY_INFORMATION_CLASS,
      KeyInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryLicenseValue(
      ValueName: PUNICODE_STRING,
      Type: PULONG,
      Data: PVOID,
      DataSize: ULONG,
      ResultDataSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryMultipleValueKey(
      KeyHandle: HANDLE,
      ValueEntries: PKEY_VALUE_ENTRY,
      EntryCount: ULONG,
      ValueBuffer: PVOID,
      BufferLength: PULONG,
      RequiredBufferLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryMutant(
      MutantHandle: HANDLE,
      MutantInformationClass: MUTANT_INFORMATION_CLASS,
      MutantInformation: PVOID,
      MutantInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryObject(
      Handle: HANDLE,
      ObjectInformationClass: OBJECT_INFORMATION_CLASS,
      ObjectInformation: PVOID,
      ObjectInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryOpenSubKeys(TargetKey: POBJECT_ATTRIBUTES, HandleCount: PULONG) -> NTSTATUS;
   pub fn ZwQueryOpenSubKeysEx(
      TargetKey: POBJECT_ATTRIBUTES,
      BufferLength: ULONG,
      Buffer: PVOID,
      RequiredSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryPerformanceCounter(
      PerformanceCounter: PLARGE_INTEGER,
      PerformanceFrequency: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwQueryPortInformationProcess() -> NTSTATUS;
   pub fn ZwQueryQuotaInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ReturnSingleEntry: BOOLEAN,
      SidList: PVOID,
      SidListLength: ULONG,
      StartSid: PSID,
      RestartScan: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwQuerySection(
      SectionHandle: HANDLE,
      SectionInformationClass: SECTION_INFORMATION_CLASS,
      SectionInformation: PVOID,
      SectionInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwQuerySecurityAttributesToken(
      TokenHandle: HANDLE,
      Attributes: PUNICODE_STRING,
      NumberOfAttributes: ULONG,
      Buffer: PVOID,
      Length: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySecurityObject(
      Handle: HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
      Length: ULONG,
      LengthNeeded: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySecurityPolicy(
      Policy: PCUNICODE_STRING,
      KeyName: PCUNICODE_STRING,
      ValueName: PCUNICODE_STRING,
      ValueType: SECURE_SETTING_VALUE_TYPE,
      Value: PVOID,
      ValueSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySemaphore(
      SemaphoreHandle: HANDLE,
      SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS,
      SemaphoreInformation: PVOID,
      SemaphoreInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySymbolicLinkObject(
      LinkHandle: HANDLE,
      LinkTarget: PUNICODE_STRING,
      ReturnedLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemEnvironmentValue(
      VariableName: PUNICODE_STRING,
      VariableValue: PWSTR,
      ValueLength: USHORT,
      ReturnLength: PUSHORT,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemEnvironmentValueEx(
      VariableName: PUNICODE_STRING,
      VendorGuid: PCGUID,
      Buffer: PVOID,
      BufferLength: PULONG,
      Attributes: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemInformationEx(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQuerySystemTime(SystemTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwQueryTimer(
      TimerHandle: HANDLE,
      TimerInformationClass: TIMER_INFORMATION_CLASS,
      TimerInformation: PVOID,
      TimerInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryTimerResolution(
      MaximumTime: PULONG,
      MinimumTime: PULONG,
      CurrentTime: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryValueKey(
      KeyHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
      KeyValueInformation: PVOID,
      Length: ULONG,
      ResultLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      MemoryInformationClass: MEMORY_INFORMATION_CLASS,
      MemoryInformation: PVOID,
      MemoryInformationLength: SIZE_T,
      ReturnLength: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwQueryVolumeInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsInformation: PVOID,
      Length: ULONG,
      FsInformationClass: FSINFOCLASS,
   ) -> NTSTATUS;
   pub fn ZwQueryWnfStateData(
      StateName: PCWNF_STATE_NAME,
      TypeId: PCWNF_TYPE_ID,
      ExplicitScope: *const ::core::ffi::c_void,
      ChangeStamp: PWNF_CHANGE_STAMP,
      Buffer: PVOID,
      BufferSize: PULONG,
   ) -> NTSTATUS;
   pub fn ZwQueryWnfStateNameInformation(
      StateName: PCWNF_STATE_NAME,
      NameInfoClass: WNF_STATE_NAME_INFORMATION,
      ExplicitScope: *const ::core::ffi::c_void,
      InfoBuffer: PVOID,
      InfoBufferSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwQueueApcThread(
      ThreadHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn ZwQueueApcThreadEx(
      ThreadHandle: HANDLE,
      ReserveHandle: HANDLE,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn ZwQueueApcThreadEx2(
      ThreadHandle: HANDLE,
      ReserveHandle: HANDLE,
      ApcFlags: ULONG,
      ApcRoutine: PPS_APC_ROUTINE,
      ApcArgument1: PVOID,
      ApcArgument2: PVOID,
      ApcArgument3: PVOID,
   ) -> NTSTATUS;
   pub fn ZwRaiseException(
      ExceptionRecord: PEXCEPTION_RECORD,
      ContextRecord: PCONTEXT,
      FirstChance: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwRaiseHardError(
      ErrorStatus: NTSTATUS,
      NumberOfParameters: ULONG,
      UnicodeStringParameterMask: ULONG,
      Parameters: PULONG_PTR,
      ValidResponseOptions: ULONG,
      Response: PULONG,
   ) -> NTSTATUS;
   pub fn ZwReadFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn ZwReadFileScatter(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      SegmentArray: PFILE_SEGMENT_ELEMENT,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn ZwReadOnlyEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwReadRequestData(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      DataEntryIndex: ULONG,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwReadVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwReadVirtualMemoryEx(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesRead: PSIZE_T,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwRecoverEnlistment(EnlistmentHandle: HANDLE, EnlistmentKey: PVOID) -> NTSTATUS;
   pub fn ZwRecoverResourceManager(ResourceManagerHandle: HANDLE) -> NTSTATUS;
   pub fn ZwRecoverTransactionManager(TransactionManagerHandle: HANDLE) -> NTSTATUS;
   pub fn ZwRegisterProtocolAddressInformation(
      ResourceManager: HANDLE,
      ProtocolId: PCRM_PROTOCOL_ID,
      ProtocolInformationSize: ULONG,
      ProtocolInformation: PVOID,
      CreateOptions: ULONG,
   ) -> NTSTATUS;
   pub fn ZwRegisterThreadTerminatePort(PortHandle: HANDLE) -> NTSTATUS;
   pub fn ZwReleaseCMFViewOwnership() -> NTSTATUS;
   pub fn ZwReleaseKeyedEvent(
      KeyedEventHandle: HANDLE,
      KeyValue: PVOID,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwReleaseMutant(MutantHandle: HANDLE, PreviousCount: PLONG) -> NTSTATUS;
   pub fn ZwReleaseSemaphore(
      SemaphoreHandle: HANDLE,
      ReleaseCount: LONG,
      PreviousCount: PLONG,
   ) -> NTSTATUS;
   pub fn ZwReleaseWorkerFactoryWorker(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
   pub fn ZwRemoveIoCompletion(
      IoCompletionHandle: HANDLE,
      KeyContext: *mut PVOID,
      ApcContext: *mut PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwRemoveIoCompletionEx(
      IoCompletionHandle: HANDLE,
      IoCompletionInformation: PFILE_IO_COMPLETION_INFORMATION,
      Count: ULONG,
      NumEntriesRemoved: PULONG,
      Timeout: PLARGE_INTEGER,
      Alertable: BOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwRemoveProcessDebug(ProcessHandle: HANDLE, DebugObjectHandle: HANDLE) -> NTSTATUS;
   pub fn ZwRenameKey(KeyHandle: HANDLE, NewName: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwRenameTransactionManager(
      LogFileName: PUNICODE_STRING,
      ExistingTransactionManagerGuid: LPGUID,
   ) -> NTSTATUS;
   pub fn ZwReplaceKey(
      NewFile: POBJECT_ATTRIBUTES,
      TargetHandle: HANDLE,
      OldFile: POBJECT_ATTRIBUTES,
   ) -> NTSTATUS;
   pub fn ZwReplacePartitionUnit(
      TargetInstancePath: PUNICODE_STRING,
      SpareInstancePath: PUNICODE_STRING,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwReplyPort(PortHandle: HANDLE, ReplyMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwReplyWaitReceivePort(
      PortHandle: HANDLE,
      PortContext: *mut PVOID,
      ReplyMessage: PPORT_MESSAGE,
      ReceiveMessage: PPORT_MESSAGE,
   ) -> NTSTATUS;
   pub fn ZwReplyWaitReceivePortEx(
      PortHandle: HANDLE,
      PortContext: *mut PVOID,
      ReplyMessage: PPORT_MESSAGE,
      ReceiveMessage: PPORT_MESSAGE,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwReplyWaitReplyPort(PortHandle: HANDLE, ReplyMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwRequestPort(PortHandle: HANDLE, RequestMessage: PPORT_MESSAGE) -> NTSTATUS;
   pub fn ZwRequestWaitReplyPort(
      PortHandle: HANDLE,
      RequestMessage: PPORT_MESSAGE,
      ReplyMessage: PPORT_MESSAGE,
   ) -> NTSTATUS;
   pub fn ZwRequestWakeupLatency(latency: LATENCY_TIME) -> NTSTATUS;
   pub fn ZwResetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn ZwResetWriteWatch(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      RegionSize: SIZE_T,
   ) -> NTSTATUS;
   pub fn ZwRestoreKey(KeyHandle: HANDLE, FileHandle: HANDLE, Flags: ULONG) -> NTSTATUS;
   pub fn ZwResumeProcess(ProcessHandle: HANDLE) -> NTSTATUS;
   pub fn ZwResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn ZwRevertContainerImpersonation() -> NTSTATUS;
   pub fn ZwRollbackComplete(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwRollbackEnlistment(
      EnlistmentHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwRollbackTransaction(TransactionHandle: HANDLE, Wait: BOOLEAN) -> NTSTATUS;
   pub fn ZwRollforwardTransactionManager(
      TransactionManagerHandle: HANDLE,
      TmVirtualClock: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwSaveKey(KeyHandle: HANDLE, FileHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSaveKeyEx(KeyHandle: HANDLE, FileHandle: HANDLE, Format: ULONG) -> NTSTATUS;
   pub fn ZwSaveMergedKeys(
      HighPrecedenceKeyHandle: HANDLE,
      LowPrecedenceKeyHandle: HANDLE,
      FileHandle: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwSecureConnectPort(
      PortHandle: PHANDLE,
      PortName: PUNICODE_STRING,
      SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
      ClientView: PPORT_VIEW,
      RequiredServerSid: PSID,
      ServerView: PREMOTE_PORT_VIEW,
      MaxMessageLength: PULONG,
      ConnectionInformation: PVOID,
      ConnectionInformationLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwSerializeBoot() -> NTSTATUS;
   pub fn ZwSetBootEntryOrder(Ids: PULONG, Count: ULONG) -> NTSTATUS;
   pub fn ZwSetBootOptions(BootOptions: PBOOT_OPTIONS, FieldsToChange: ULONG) -> NTSTATUS;
   pub fn ZwSetCachedSigningLevel(
      Flags: ULONG,
      InputSigningLevel: SE_SIGNING_LEVEL,
      SourceFiles: PHANDLE,
      SourceFileCount: ULONG,
      TargetFile: HANDLE,
   ) -> NTSTATUS;
   pub fn ZwSetCachedSigningLevel2(
      Flags: ULONG,
      InputSigningLevel: SE_SIGNING_LEVEL,
      SourceFiles: PHANDLE,
      SourceFileCount: ULONG,
      TargetFile: HANDLE,
      CacheInformation: *mut SE_SET_FILE_CACHE_INFORMATION,
   ) -> NTSTATUS;
   pub fn ZwSetContextThread(ThreadHandle: HANDLE, ThreadContext: PCONTEXT) -> NTSTATUS;
   pub fn ZwSetDebugFilterState(ComponentId: ULONG, Level: ULONG, State: BOOLEAN) -> NTSTATUS;
   pub fn ZwSetDefaultHardErrorPort(DefaultHardErrorPort: HANDLE) -> NTSTATUS;
   pub fn ZwSetDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: LCID) -> NTSTATUS;
   pub fn ZwSetDefaultUILanguage(DefaultUILanguageId: LANGID) -> NTSTATUS;
   pub fn ZwSetDriverEntryOrder(Ids: PULONG, Count: ULONG) -> NTSTATUS;
   pub fn ZwSetEaFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
   pub fn ZwSetEventBoostPriority(EventHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetEventEx(ThreadId: HANDLE, Lock: PRTL_SRWLOCK) -> NTSTATUS;
   pub fn ZwSetHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetHighWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetInformationCpuPartition(
      CpuPartitionHandle: HANDLE,
      CpuPartitionInformationClass: ULONG,
      CpuPartitionInformation: PVOID,
      CpuPartitionInformationLength: ULONG,
      arg1: PVOID,
      arg2: ULONG,
      arg3: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationDebugObject(
      DebugObjectHandle: HANDLE,
      DebugObjectInformationClass: DEBUGOBJECTINFOCLASS,
      DebugInformation: PVOID,
      DebugInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationEnlistment(
      EnlistmentHandle: HANDLE,
      EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
      EnlistmentInformation: PVOID,
      EnlistmentInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FileInformation: PVOID,
      Length: ULONG,
      FileInformationClass: FILE_INFORMATION_CLASS,
   ) -> NTSTATUS;
   pub fn ZwSetInformationIoRing(
      IoRingHandle: HANDLE,
      IoRingInformationClass: ULONG,
      IoRingInformationLength: ULONG,
      IoRingInformation: PVOID,
   ) -> NTSTATUS;
   pub fn ZwSetInformationJobObject(
      JobHandle: HANDLE,
      JobObjectInformationClass: JOBOBJECTINFOCLASS,
      JobObjectInformation: PVOID,
      JobObjectInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationKey(
      KeyHandle: HANDLE,
      KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
      KeySetInformation: PVOID,
      KeySetInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationObject(
      Handle: HANDLE,
      ObjectInformationClass: OBJECT_INFORMATION_CLASS,
      ObjectInformation: PVOID,
      ObjectInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationProcess(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationResourceManager(
      ResourceManagerHandle: HANDLE,
      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
      ResourceManagerInformation: PVOID,
      ResourceManagerInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationSymbolicLink(
      LinkHandle: HANDLE,
      SymbolicLinkInformationClass: SYMBOLIC_LINK_INFO_CLASS,
      SymbolicLinkInformation: PVOID,
      SymbolicLinkInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: THREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationToken(
      TokenHandle: HANDLE,
      TokenInformationClass: ULONG,
      TokenInformation: PVOID,
      TokenInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationTransaction(
      TransactionHandle: HANDLE,
      TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
      TransactionInformation: PVOID,
      TransactionInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationTransactionManager(
      TmHandle: HANDLE,
      TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
      TransactionManagerInformation: PVOID,
      TransactionManagerInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationVirtualMemory(
      ProcessHandle: HANDLE,
      VmInformationClass: VIRTUAL_MEMORY_INFORMATION_CLASS,
      NumberOfEntries: SIZE_T,
      VirtualAddresses: PMEMORY_RANGE_ENTRY,
      VmInformation: PVOID,
      VmInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetInformationWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
      WorkerFactoryInformation: PVOID,
      WorkerFactoryInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetIntervalProfile(Interval: ULONG, Source: KPROFILE_SOURCE) -> NTSTATUS;
   pub fn ZwSetIoCompletion(
      IoCompletionHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwSetIoCompletionEx(
      IoCompletionHandle: HANDLE,
      IoCompletionPacketHandle: HANDLE,
      KeyContext: PVOID,
      ApcContext: PVOID,
      IoStatus: NTSTATUS,
      IoStatusInformation: ULONG_PTR,
   ) -> NTSTATUS;
   pub fn ZwSetIRTimer(TimerHandle: HANDLE, DueTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwSetLdtEntries(
      Selector0: ULONG,
      Entry0Low: ULONG,
      Entry0Hi: ULONG,
      Selector1: ULONG,
      Entry1Low: ULONG,
      Entry1Hi: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetLowWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSetQuotaInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetSecurityObject(
      Handle: HANDLE,
      SecurityInformation: SECURITY_INFORMATION,
      SecurityDescriptor: PSECURITY_DESCRIPTOR,
   ) -> NTSTATUS;
   pub fn ZwSetSystemEnvironmentValue(
      VariableName: PUNICODE_STRING,
      VariableValue: PUNICODE_STRING,
   ) -> NTSTATUS;
   pub fn ZwSetSystemEnvironmentValueEx(
      VariableName: PUNICODE_STRING,
      VendorGuid: PCGUID,
      Buffer: PVOID,
      BufferLength: ULONG,
      Attributes: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetSystemInformation(
      SystemInformationClass: SYSTEM_INFORMATION_CLASS,
      SystemInformation: PVOID,
      SystemInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetSystemPowerState(
      SystemAction: POWER_ACTION,
      LightestSystemState: SYSTEM_POWER_STATE,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetSystemTime(SystemTime: PLARGE_INTEGER, PreviousTime: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwSetThreadExecutionState(
      NewFlags: EXECUTION_STATE,
      PreviousFlags: *mut EXECUTION_STATE,
   ) -> NTSTATUS;
   pub fn ZwSetTimer(
      TimerHandle: HANDLE,
      DueTime: PLARGE_INTEGER,
      TimerApcRoutine: PTIMER_APC_ROUTINE,
      TimerContext: PVOID,
      ResumeTimer: BOOLEAN,
      Period: LONG,
      PreviousState: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn ZwSetTimer2(
      TimerHandle: HANDLE,
      DueTime: PLARGE_INTEGER,
      Period: PLARGE_INTEGER,
      Parameters: PT2_SET_PARAMETERS,
   ) -> NTSTATUS;
   pub fn ZwSetTimerEx(
      TimerHandle: HANDLE,
      TimerSetInformationClass: TIMER_SET_INFORMATION_CLASS,
      TimerSetInformation: PVOID,
      TimerSetInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetTimerResolution(
      DesiredTime: ULONG,
      SetResolution: BOOLEAN,
      ActualTime: PULONG,
   ) -> NTSTATUS;
   pub fn ZwSetUuidSeed(Seed: PCHAR) -> NTSTATUS;
   pub fn ZwSetValueKey(
      KeyHandle: HANDLE,
      ValueName: PUNICODE_STRING,
      TitleIndex: ULONG,
      Type: ULONG,
      Data: PVOID,
      DataSize: ULONG,
   ) -> NTSTATUS;
   pub fn ZwSetVolumeInformationFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      FsInformation: PVOID,
      Length: ULONG,
      FsInformationClass: FSINFOCLASS,
   ) -> NTSTATUS;
   pub fn ZwSetWnfProcessNotificationEvent(NotificationEvent: HANDLE) -> NTSTATUS;
   pub fn ZwShutdownSystem(Action: SHUTDOWN_ACTION) -> NTSTATUS;
   pub fn ZwShutdownWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      PendingWorkerCount: *mut LONG,
   ) -> NTSTATUS;
   pub fn ZwSignalAndWaitForSingleObject(
      SignalHandle: HANDLE,
      WaitHandle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwSinglePhaseReject(EnlistmentHandle: HANDLE, TmVirtualClock: PLARGE_INTEGER)
      -> NTSTATUS;
   pub fn ZwStartProfile(ProfileHandle: HANDLE) -> NTSTATUS;
   pub fn ZwStopProfile(ProfileHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSubmitIoRing(
      IoRingHandle: HANDLE,
      Flags: ULONG,
      WaitOperations: ULONG,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwSubscribeWnfStateChange(
      StateName: PCWNF_STATE_NAME,
      ChangeStamp: WNF_CHANGE_STAMP,
      EventMask: ULONG,
      SubscriptionId: PULONG64,
   ) -> NTSTATUS;
   pub fn ZwSuspendProcess(ProcessHandle: HANDLE) -> NTSTATUS;
   pub fn ZwSuspendThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
   pub fn ZwSystemDebugControl(
      Command: SYSDBG_COMMAND,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwTerminateEnclave(BaseAddress: PVOID, Flags: ULONG) -> NTSTATUS;
   pub fn ZwTerminateJobObject(JobHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn ZwTerminateProcess(ProcessHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn ZwTerminateThread(ThreadHandle: HANDLE, ExitStatus: NTSTATUS) -> NTSTATUS;
   pub fn ZwTestAlert() -> NTSTATUS;
   pub fn ZwThawRegistry() -> NTSTATUS;
   pub fn ZwThawTransactions() -> NTSTATUS;
   pub fn ZwTraceControl(
      FunctionCode: ETWTRACECONTROLCODE,
      InputBuffer: PVOID,
      InputBufferLength: ULONG,
      OutputBuffer: PVOID,
      OutputBufferLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwTraceEvent(
      TraceHandle: HANDLE,
      Flags: ULONG,
      FieldSize: ULONG,
      Fields: PVOID,
   ) -> NTSTATUS;
   pub fn ZwTranslateFilePath(
      InputFilePath: PFILE_PATH,
      OutputType: ULONG,
      OutputFilePath: PFILE_PATH,
      OutputFilePathLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwUmsThreadYield(SchedulerParam: PVOID) -> NTSTATUS;
   pub fn ZwUnloadDriver(DriverServiceName: PUNICODE_STRING) -> NTSTATUS;
   pub fn ZwUnloadKey(TargetKey: POBJECT_ATTRIBUTES) -> NTSTATUS;
   pub fn ZwUnloadKey2(TargetKey: POBJECT_ATTRIBUTES, Flags: ULONG) -> NTSTATUS;
   pub fn ZwUnloadKeyEx(TargetKey: POBJECT_ATTRIBUTES, Event: HANDLE) -> NTSTATUS;
   pub fn ZwUnlockFile(
      FileHandle: HANDLE,
      IoStatusBlock: PIO_STATUS_BLOCK,
      ByteOffset: PLARGE_INTEGER,
      Length: PLARGE_INTEGER,
      Key: ULONG,
   ) -> NTSTATUS;
   pub fn ZwUnlockVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: *mut PVOID,
      RegionSize: PSIZE_T,
      MapType: ULONG,
   ) -> NTSTATUS;
   pub fn ZwUnmapViewOfSection(ProcessHandle: HANDLE, BaseAddress: PVOID) -> NTSTATUS;
   pub fn ZwUnmapViewOfSectionEx(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwUnsubscribeWnfStateChange(StateName: PCWNF_STATE_NAME) -> NTSTATUS;
   pub fn ZwUpdateWnfStateData(
      StateName: PCWNF_STATE_NAME,
      Buffer: *const ::core::ffi::c_void,
      Length: ULONG,
      TypeId: PCWNF_TYPE_ID,
      ExplicitScope: *const ::core::ffi::c_void,
      MatchingChangeStamp: WNF_CHANGE_STAMP,
      CheckStamp: LOGICAL,
   ) -> NTSTATUS;
   pub fn ZwVdmControl(Service: VDMSERVICECLASS, ServiceData: PVOID) -> NTSTATUS;
   pub fn ZwWaitForAlertByThreadId(Address: PVOID, Timeout: PLARGE_INTEGER) -> NTSTATUS;
   pub fn ZwWaitForDebugEvent(
      DebugObjectHandle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
      WaitStateChange: PDBGUI_WAIT_STATE_CHANGE,
   ) -> NTSTATUS;
   pub fn ZwWaitForKeyedEvent(
      KeyedEventHandle: HANDLE,
      KeyValue: PVOID,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwWaitForMultipleObjects(
      Count: ULONG,
      Handles: *mut HANDLE,
      WaitType: WAIT_TYPE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwWaitForMultipleObjects32(
      Count: ULONG,
      Handles: *mut LONG,
      WaitType: WAIT_TYPE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwWaitForSingleObject(
      Handle: HANDLE,
      Alertable: BOOLEAN,
      Timeout: PLARGE_INTEGER,
   ) -> NTSTATUS;
   pub fn ZwWaitForWorkViaWorkerFactory(
      WorkerFactoryHandle: HANDLE,
      MiniPackets: PFILE_IO_COMPLETION_INFORMATION,
      Count: ULONG,
      PacketsReturned: PULONG,
      DeferredWork: PWORKER_FACTORY_DEFERRED_WORK,
   ) -> NTSTATUS;
   pub fn ZwWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
   pub fn ZwWorkerFactoryWorkerReady(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
   pub fn ZwWow64QueryInformationProcess64(
      ProcessHandle: HANDLE,
      ProcessInformationClass: PROCESSINFOCLASS,
      ProcessInformation: PVOID,
      ProcessInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn ZwWow64QueryVirtualMemory64(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      MemoryInformationClass: MEMORY_INFORMATION_CLASS,
      MemoryInformation: PVOID,
      MemoryInformationLength: ULONGLONG,
      ReturnLength: PULONGLONG,
   ) -> NTSTATUS;
   pub fn ZwWow64ReadVirtualMemory64(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: ULONGLONG,
      NumberOfBytesRead: PULONGLONG,
      Flags: ULONG,
   ) -> NTSTATUS;
   pub fn ZwWow64WriteVirtualMemory64(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: ULONGLONG,
      NumberOfBytesWritten: PULONGLONG,
   ) -> NTSTATUS;
   pub fn ZwWriteFile(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      Buffer: PVOID,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn ZwWriteFileGather(
      FileHandle: HANDLE,
      Event: HANDLE,
      ApcRoutine: PIO_APC_ROUTINE,
      ApcContext: PVOID,
      IoStatusBlock: PIO_STATUS_BLOCK,
      SegmentArray: PFILE_SEGMENT_ELEMENT,
      Length: ULONG,
      ByteOffset: PLARGE_INTEGER,
      Key: PULONG,
   ) -> NTSTATUS;
   pub fn ZwWriteRequestData(
      PortHandle: HANDLE,
      Message: PPORT_MESSAGE,
      DataEntryIndex: ULONG,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesWritten: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwWriteVirtualMemory(
      ProcessHandle: HANDLE,
      BaseAddress: PVOID,
      Buffer: PVOID,
      BufferSize: SIZE_T,
      NumberOfBytesWritten: PSIZE_T,
   ) -> NTSTATUS;
   pub fn ZwYieldExecution() -> NTSTATUS;
   pub fn NtUserQueryWindow(WindowHandle: HWND, WindowInfo: WINDOWINFOCLASS) -> ULONG_PTR;
   pub fn NtUserTestForInteractiveUser(AuthenticationId: PLUID) -> NTSTATUS;
   pub fn NtUserCheckAccessForIntegrityLevel(
      ProcessIdFirst: ULONG,
      ProcessIdSecond: ULONG,
      GrantedAccess: PBOOLEAN,
   ) -> NTSTATUS;
   pub fn NtUserCheckProcessForClipboardAccess(ProcessId: ULONG, GrantedAccess: PULONG)
      -> NTSTATUS;
   pub fn NtUserInternalGetWindowText(
      WindowHandle: HWND,
      pString: LPWSTR,
      cchMaxCount: ULONG,
   ) -> ULONG;
   pub fn NtUserInternalGetWindowIcon(WindowHandle: HWND, IconType: ULONG) -> HICON;
   pub fn NtUserGetClassName(
      WindowHandle: HWND,
      Real: LONGLONG,
      ClassName: PUNICODE_STRING,
   ) -> ULONG;
   #[doc = "Performs special kernel operations for console host applications. (win32u.dll)\nThis includes reparenting the console window, allowing the console to pass foreground rights\non to launched console subsystem applications and terminating attached processes.\n# Arguments\n\n* `Command` - One of the CONSOLECONTROL values indicating which console control function should be executed.\n* `ConsoleInformation` - A pointer to one of the  structures specifying additional data for the requested console control function.\n* `ConsoleInformationLength` - The size of the structure pointed to by the ConsoleInformation parameter.\n# Returns\n\nSuccessful or errant status."]
   pub fn NtUserConsoleControl(
      Command: CONSOLECONTROL,
      ConsoleInformation: PVOID,
      ConsoleInformationLength: ULONG,
   ) -> NTSTATUS;
   #[doc = "Performs special kernel operations for console host applications. (user32.dll)\nThis includes reparenting the console window, allowing the console to pass foreground rights\non to launched console subsystem applications and terminating attached processes.\n# Arguments\n\n* `Command` - One of the CONSOLECONTROL values indicating which console control function should be executed.\n* `ConsoleInformation` - A pointer to one of the  structures specifying additional data for the requested console control function.\n* `ConsoleInformationLength` - The size of the structure pointed to by the ConsoleInformation parameter.\n# Returns\n\nSuccessful or errant status."]
   pub fn ConsoleControl(
      Command: CONSOLECONTROL,
      ConsoleInformation: PVOID,
      ConsoleInformationLength: ULONG,
   ) -> NTSTATUS;
   #[doc = "Opens the specified window station.\n# Arguments\n\n* `ObjectAttributes` - The name of the window station to be opened. Window station names are case-insensitive. This window station must belong to the current session.\n* `DesiredAccess` - The access to the window station.\n# Returns\n\nSuccessful or errant status."]
   pub fn NtUserOpenWindowStation(
      ObjectAttributes: OBJECT_ATTRIBUTES,
      DesiredAccess: ACCESS_MASK,
   ) -> HWINSTA;
   pub fn NtUserCreateWindowStation(
      ObjectAttributes: OBJECT_ATTRIBUTES,
      DesiredAccess: ACCESS_MASK,
      KeyboardLayoutHandle: HANDLE,
      KeyboardLayoutOffset: PVOID,
      NlsTableOffset: PVOID,
      KeyboardDescriptor: PVOID,
      LanguageIdString: UNICODE_STRING,
      KeyboardLocale: ULONG,
   ) -> HWINSTA;
   pub fn NtUserBuildHwndList(
      DesktopHandle: HANDLE,
      StartWindowHandle: HWND,
      IncludeChildren: LOGICAL,
      ExcludeImmersive: LOGICAL,
      ThreadId: ULONG,
      HwndListInformationLength: ULONG,
      HwndListInformation: PVOID,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtUserBuildNameList(
      WindowStationHandle: HWINSTA,
      NameListInformationLength: ULONG,
      NameListInformation: PVOID,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtUserBuildPropList(
      WindowStationHandle: HWINSTA,
      PropListInformationLength: ULONG,
      PropListInformation: PVOID,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtUserGetProcessWindowStation() -> HWND;
   pub fn NtUserGhostWindowFromHungWindow(WindowHandle: HWND) -> HWND;
   pub fn NtUserHungWindowFromGhostWindow(WindowHandle: HWND) -> HWND;
   pub fn GhostWindowFromHungWindow(WindowHandle: HWND) -> HWND;
   pub fn HungWindowFromGhostWindow(WindowHandle: HWND) -> HWND;
   pub fn NtUserCloseWindowStation(WindowStationHandle: HWINSTA) -> LOGICAL;
   pub fn NtUserSetProcessWindowStation(WindowStationHandle: HWINSTA) -> LOGICAL;
   pub fn SetWindowStationUser(
      WindowStationHandle: HWINSTA,
      UserLogonId: PLUID,
      UserSid: PSID,
      UserSidLength: ULONG,
   ) -> LOGICAL;
   pub fn NtUserSetChildWindowNoActivate(WindowHandle: HWND) -> LOGICAL;
   pub fn SetChildWindowNoActivate(WindowHandle: HWND) -> LOGICAL;
   pub fn NtUserSetWindowStationUser(
      WindowStationHandle: HWINSTA,
      UserLogonId: PLUID,
      UserSid: PSID,
      UserSidLength: ULONG,
   ) -> LOGICAL;
   pub fn NtUserOpenDesktop(
      ObjectAttributes: PCOBJECT_ATTRIBUTES,
      Flags: ULONG,
      DesiredAccess: ACCESS_MASK,
   ) -> HANDLE;
   pub fn NtUserSetThreadDesktop(DesktopHandle: HDESK) -> LOGICAL;
   pub fn NtUserSwitchDesktop(DesktopHandle: HDESK, Flags: ULONG, FadeTime: ULONG) -> LOGICAL;
   pub fn NtUserGetIconInfo(
      IconOrCursorHandle: HICON,
      Iconinfo: PICONINFO,
      Name: PUNICODE_STRING,
      ResourceId: PUNICODE_STRING,
      ColorBits: PULONG,
      IsCursorHandle: LOGICAL,
   ) -> LOGICAL;
   pub fn NtUserGetIconSize(
      IconOrCursorHandle: HGDIOBJ,
      IsCursorHandle: LOGICAL,
      XX: PULONG,
      YY: PULONG,
   ) -> LOGICAL;
   pub fn NtUserGetForegroundWindow() -> HWND;
   pub fn NtUserSetActiveWindow(WindowHandle: HWND) -> HWND;
   pub fn NtUserSetFocus(WindowHandle: HWND) -> HWND;
   pub fn NtUserGetThreadState(UserThreadState: ULONG) -> ULONG_PTR;
   pub fn NtUserSetWindowPlacement(WindowHandle: HWND, lpwndpl: *const WINDOWPLACEMENT) -> BOOL;
   pub fn NtUserAttachThreadInput(IdAttach: ULONG, IdAttachTo: ULONG, Attach: BOOL) -> BOOL;
   pub fn NtUserBeginPaint(WindowHandle: HWND, lpPaint: LPPAINTSTRUCT) -> HDC;
   pub fn NtUserBlockInput(BlockInput: BOOL) -> BOOL;
   pub fn tUserCalculatePopupWindowPosition(
      anchorPoint: *const POINT,
      windowSize: *const SIZE,
      flags: ULONG,
      excludeRect: *mut RECT,
      popupWindowPosition: *mut RECT,
   ) -> BOOL;
   pub fn NtUserChangeWindowMessageFilterEx(
      WindowHandle: HWND,
      message: ULONG,
      action: ULONG,
      pChangeFilterStruct: PCHANGEFILTERSTRUCT,
   ) -> BOOL;
   pub fn NtUserChildWindowFromPointEx(WindowHandle: HWND, pt: POINT, flags: ULONG) -> HWND;
   pub fn NtUserClipCursor(lpRect: *const RECT) -> BOOL;
   pub fn NtUserCloseDesktop(hDesktop: HDESK) -> BOOL;
   pub fn NtUserCopyAcceleratorTable(
      hAccelSrc: HACCEL,
      lpAccelDst: LPACCEL,
      cAccelEntries: LONG,
   ) -> LONG;
   pub fn NtUserCreateAcceleratorTable(paccel: LPACCEL, cAccel: LONG) -> HACCEL;
   pub fn NtUserDeleteMenu(hMenu: HMENU, uPosition: ULONG, uFlags: ULONG) -> BOOL;
   pub fn NtUserDestroyMenu(hMenu: HMENU) -> BOOL;
   pub fn NtUserDestroyWindow(WindowHandle: HWND) -> BOOL;
   pub fn NtUserDragDetect(WindowHandle: HWND, pt: POINT) -> BOOL;
   pub fn NtUserDragObject(
      WindowHandleParent: HWND,
      WindowHandleFrom: HWND,
      fmt: ULONG,
      data: ULONG_PTR,
      hcur: HCURSOR,
   ) -> ULONG;
   pub fn NtUserDrawAnimatedRects(
      WindowHandle: HWND,
      idAni: ::core::ffi::c_int,
      lprcFrom: *const RECT,
      lprcTo: *const RECT,
   ) -> BOOL;
   pub fn NtUserEndMenu() -> BOOL;
   pub fn NtUserEndPaint(WindowHandle: HWND, lpPaint: *const PAINTSTRUCT) -> BOOL;
   pub fn NtUserEnumDisplayMonitors(
      hdc: HDC,
      lprcClip: LPCRECT,
      lpfnEnum: MONITORENUMPROC,
      dwData: LPARAM,
   ) -> BOOL;
   pub fn NtUserExcludeUpdateRgn(hDC: HDC, WindowHandle: HWND) -> HRGN;
   pub fn NtUserFlashWindowEx(pfwi: PFLASHWINFO) -> BOOL;
   pub fn NtUserGetAncestor(WindowHandle: HWND, gaFlags: ULONG) -> HWND;
   pub fn NtUserGetCaretBlinkTime() -> ULONG;
   pub fn NtUserGetCaretPos(lpPoint: LPPOINT) -> BOOL;
   pub fn NtUserGetClipCursor(lpRect: LPRECT) -> BOOL;
   pub fn NtUserGetComboBoxInfo(WindowHandleCombo: HWND, pcbi: PCOMBOBOXINFO) -> BOOL;
   pub fn NtUserGetCurrentInputMessageSource(InputMessageSource: *mut INPUT_MESSAGE_SOURCE)
      -> BOOL;
   pub fn NtUserGetCursor() -> HCURSOR;
   pub fn NtUserGetCursorInfo(pci: PCURSORINFO) -> BOOL;
   pub fn NtUserGetDCEx(WindowHandle: HWND, hrgnClip: HRGN, flags: ULONG) -> HDC;
   pub fn NtUserGetDisplayAutoRotationPreferences(
      pOrientation: *mut ORIENTATION_PREFERENCE,
   ) -> BOOL;
   pub fn NtUserGetDoubleClickTime() -> ULONG;
   pub fn NtUserGetGUIThreadInfo(idThread: ULONG, pgui: PGUITHREADINFO) -> BOOL;
   pub fn NtUserGetGuiResources(ProcessHandle: HANDLE, uiFlags: ULONG) -> ULONG;
   pub fn NtUserGetLayeredWindowAttributes(
      WindowHandle: HWND,
      pcrKey: *mut COLORREF,
      pbAlpha: *mut BYTE,
      pdwFlags: ULONG,
   ) -> BOOL;
   pub fn NtUserGetListBoxInfo(WindowHandle: HWND) -> ULONG;
   pub fn NtUserGetMenuBarInfo(
      WindowHandle: HWND,
      idObject: LONG,
      idItem: LONG,
      pmbi: PMENUBARINFO,
   ) -> BOOL;
   pub fn NtUserGetMenuItemRect(
      WindowHandle: HWND,
      hMenu: HMENU,
      uItem: ULONG,
      lprcItem: LPRECT,
   ) -> BOOL;
   pub fn NtUserGetMouseMovePointsEx(
      cbSize: ULONG,
      lppt: LPMOUSEMOVEPOINT,
      lpptBuf: LPMOUSEMOVEPOINT,
      nBufPoints: LONG,
      resolution: ULONG,
   ) -> LONG;
   pub fn NtUserGetRawInputData(
      hRawInput: HRAWINPUT,
      uiCommand: ULONG,
      pData: LPVOID,
      pcbSize: PULONG,
      cbSizeHeader: ULONG,
   ) -> ULONG;
   pub fn NtUserGetRawInputDeviceList(
      pRawInputDeviceList: PRAWINPUTDEVICELIST,
      puiNumDevices: PULONG,
      cbSize: ULONG,
   ) -> ULONG;
   pub fn NtUserGetRegisteredRawInputDevices(
      pRawInputDevices: PRAWINPUTDEVICE,
      puiNumDevices: PULONG,
      cbSize: ULONG,
   ) -> ULONG;
   pub fn NtUserGetSystemMenu(WindowHandle: HWND, bRevert: BOOL) -> HMENU;
   pub fn NtUserGetThreadDesktop(ThreadId: ULONG) -> HDESK;
   pub fn NtUserGetTitleBarInfo(WindowHandle: HWND, pti: PTITLEBARINFO) -> BOOL;
   pub fn NtUserGetObjectInformation(
      hObj: HANDLE,
      Index: LONG,
      vInfo: PVOID,
      Length: ULONG,
      LengthNeeded: PULONG,
   ) -> BOOL;
   pub fn NtUserGetWindowDC(WindowHandle: HWND) -> HDC;
   pub fn NtUserGetWindowPlacement(WindowHandle: HWND, lpwndpl: *mut WINDOWPLACEMENT) -> BOOL;
   pub fn NtUserHiliteMenuItem(
      WindowHandle: HWND,
      Menu: HMENU,
      IDHiliteItem: ULONG,
      Hilite: ULONG,
   ) -> BOOL;
   pub fn NtUserInvalidateRect(WindowHandle: HWND, Rect: *const RECT, Erase: BOOL) -> BOOL;
   pub fn NtUserInvalidateRgn(WindowHandle: HWND, hRgn: HRGN, Erase: BOOL) -> BOOL;
   pub fn NtUserIsTouchWindow(WindowHandle: HWND, Flags: PULONG) -> BOOL;
   pub fn NtUserKillTimer(WindowHandle: HWND, IDEvent: ULONG_PTR) -> BOOL;
   pub fn NtUserLockWorkStation() -> BOOL;
   pub fn NtUserLogicalToPhysicalPoint(WindowHandle: HWND, lpPoint: LPPOINT) -> BOOL;
   pub fn NtUserMenuItemFromPoint(WindowHandle: HWND, hMenu: HMENU, ptScreen: POINT) -> LONG;
   pub fn NtUserMoveWindow(
      WindowHandle: HWND,
      X: LONG,
      Y: LONG,
      nWidth: LONG,
      nHeight: LONG,
      bRepaint: BOOL,
   ) -> BOOL;
   pub fn NtUserOpenInputDesktop(Flags: ULONG, Inherit: BOOL, DesiredAccess: ACCESS_MASK) -> HDESK;
   pub fn NtUserPhysicalToLogicalPoint(WindowHandle: HWND, lpPoint: LPPOINT) -> BOOL;
   pub fn NtUserPrintWindow(WindowHandle: HWND, hdcBlt: HDC, nFlags: ULONG) -> BOOL;
   pub fn NtUserQueryInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: USERTHREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
      ReturnLength: PULONG,
   ) -> NTSTATUS;
   pub fn NtUserSetInformationThread(
      ThreadHandle: HANDLE,
      ThreadInformationClass: USERTHREADINFOCLASS,
      ThreadInformation: PVOID,
      ThreadInformationLength: ULONG,
   ) -> NTSTATUS;
   pub fn QuerySendMessage(pMsg: *mut MSG) -> BOOL;
   pub fn NtUserRedrawWindow(
      WindowHandle: HWND,
      lprcUpdate: PRECT,
      hrgnUpdate: HRGN,
      flags: ULONG,
   ) -> BOOL;
   pub fn NtUserRealChildWindowFromPoint(
      WindowHandleParent: HWND,
      ptParentClientCoords: POINT,
   ) -> HWND;
   pub fn NtUserRegisterHotKey(WindowHandle: HWND, id: LONG, fsModifiers: ULONG, vk: ULONG)
      -> BOOL;
   pub fn NtUserRemoveMenu(hMenu: HMENU, uPosition: ULONG, uFlags: ULONG) -> BOOL;
   pub fn NtUserSendInput(cInputs: ULONG, pInputs: LPINPUT, cbSize: LONG) -> ULONG;
   pub fn NtUserSetCapture(WindowHandle: HWND) -> HWND;
   pub fn NtUserSetTimer(
      WindowHandle: HWND,
      nIDEvent: ULONG_PTR,
      uElapse: ULONG,
      lpTimerFunc: TIMERPROC,
      uToleranceDelay: ULONG,
   ) -> ULONG_PTR;
   pub fn NtUserSetClassWord(WindowHandle: HWND, nIndex: LONG, wNewWord: WORD) -> WORD;
   pub fn NtUserSetCursorPos(X: LONG, Y: LONG) -> BOOL;
   pub fn NtUserSetLayeredWindowAttributes(
      WindowHandle: HWND,
      crKey: COLORREF,
      bAlpha: BYTE,
      dwFlags: DWORD,
   ) -> BOOL;
   pub fn NtUserSetProcessRestrictionExemption(EnableExemption: BOOL) -> BOOL;
   pub fn NtUserSetWindowPos(
      WindowHandle: HWND,
      WindowHandleInsertAfter: HWND,
      X: LONG,
      Y: LONG,
      cx: LONG,
      cy: LONG,
      uFlags: ULONG,
   ) -> BOOL;
   pub fn NtUserSetWindowWord(WindowHandle: HWND, nIndex: LONG, wNewWord: WORD) -> WORD;
   pub fn NtUserShellForegroundBoostProcess(ProcessHandle: HANDLE, WindowHandle: HWND) -> HWND;
   pub fn NtUserSetAdditionalForegroundBoostProcesses(WindowHandle: HWND) -> ULONG;
   pub fn NtUserSetAdditionalPowerThrottlingProcess(WindowHandle: HWND) -> ULONG;
   pub fn NtUserShowCursor(bShow: BOOL) -> LONG;
   pub fn NtUserShowWindow(WindowHandle: HWND, nCmdShow: LONG) -> BOOL;
   pub fn NtUserShowWindowAsync(WindowHandle: HWND, nCmdShow: LONG) -> BOOL;
   pub fn NtUserShutdownBlockReasonQuery(
      WindowHandle: HWND,
      pwszBuff: LPWSTR,
      pcchBuff: PULONG,
   ) -> BOOL;
   pub fn NtUserShutdownReasonDestroy(WindowHandle: HWND) -> BOOL;
   pub fn NtUserTrackMouseEvent(lpEventTrack: LPTRACKMOUSEEVENT) -> BOOL;
   pub fn NtUserTrackPopupMenuEx(
      hMenu: HMENU,
      uFlags: ULONG,
      x: LONG,
      y: LONG,
      WindowHandle: HWND,
      lptpm: LPTPMPARAMS,
   ) -> BOOL;
   pub fn NtUserUnhookWinEvent(hWinEventHook: HWINEVENTHOOK) -> BOOL;
   pub fn NtUserUnregisterHotKey(WindowHandle: HWND, id: LONG) -> BOOL;
   pub fn NtUserUserHandleGrantAccess(UserHandle: HANDLE, Job: HANDLE, Grant: BOOL) -> BOOL;
   pub fn NtUserValidateRect(WindowHandle: HWND, Rect: *const RECT) -> BOOL;
   pub fn NtUserWindowFromDC(hDC: HDC) -> HWND;
   pub fn NtUserWindowFromPhysicalPoint(Point: POINT) -> HWND;
   pub fn NtUserWindowFromPoint(Point: POINT) -> HWND;
}
